"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ContractFactory: () => ContractFactory,
  ContractUtils: () => util_exports
});
module.exports = __toCommonJS(src_exports);

// src/contract-factory.ts
var import_abi_coder = require("@fuel-ts/abi-coder");
var import_crypto = require("@fuel-ts/crypto");
var import_errors2 = require("@fuel-ts/errors");
var import_program = require("@fuel-ts/program");
var import_providers = require("@fuel-ts/providers");
var import_ethers2 = require("ethers");

// src/util.ts
var util_exports = {};
__export(util_exports, {
  getContractId: () => getContractId,
  getContractRoot: () => getContractRoot,
  getContractStorageRoot: () => getContractStorageRoot,
  hexlifyWithPrefix: () => hexlifyWithPrefix
});
var import_errors = require("@fuel-ts/errors");
var import_merkle = require("@fuel-ts/merkle");
var import_utils = require("@fuel-ts/utils");
var import_ethers = require("ethers");
var getContractRoot = (bytecode) => {
  const chunkSize = 16 * 1024;
  const bytes = (0, import_ethers.getBytesCopy)(bytecode);
  const chunks = (0, import_utils.chunkAndPadBytes)(bytes, chunkSize);
  return (0, import_merkle.calcRoot)(chunks.map((c) => (0, import_ethers.hexlify)(c)));
};
var getContractStorageRoot = (storageSlots) => {
  const tree = new import_merkle.SparseMerkleTree();
  storageSlots.forEach(({ key, value }) => tree.update((0, import_ethers.sha256)(key), value));
  return tree.root;
};
var getContractId = (bytecode, salt, stateRoot) => {
  const root = getContractRoot((0, import_ethers.getBytesCopy)(bytecode));
  const contractId = (0, import_ethers.sha256)((0, import_ethers.concat)(["0x4655454C", salt, root, stateRoot]));
  return contractId;
};
var hexlifyWithPrefix = (value, isKnownHex = false) => {
  if (value.startsWith("0x")) {
    return (0, import_ethers.hexlify)(value);
  }
  if (isKnownHex) {
    return (0, import_ethers.hexlify)(`0x${value}`);
  }
  throw new import_errors.FuelError(import_errors.FuelError.CODES.UNEXPECTED_HEX_VALUE, `Value should be hex string ${value}.`);
};

// src/contract-factory.ts
var ContractFactory = class {
  bytecode;
  interface;
  provider;
  account;
  /**
   * Create a ContractFactory instance.
   *
   * @param bytecode - The bytecode of the contract.
   * @param abi - The contract's ABI (Application Binary Interface).
   * @param accountOrProvider - An account or provider to be associated with the factory.
   */
  constructor(bytecode, abi, accountOrProvider = null) {
    this.bytecode = (0, import_ethers2.getBytesCopy)(bytecode);
    if (abi instanceof import_abi_coder.Interface) {
      this.interface = abi;
    } else {
      this.interface = new import_abi_coder.Interface(abi);
    }
    if (accountOrProvider && "provider" in accountOrProvider) {
      this.provider = accountOrProvider.provider;
      this.account = accountOrProvider;
    } else {
      this.provider = accountOrProvider;
      this.account = null;
    }
  }
  /**
   * Connect the factory to a provider.
   *
   * @param provider - The provider to be associated with the factory.
   * @returns A new ContractFactory instance.
   */
  connect(provider) {
    return new ContractFactory(this.bytecode, this.interface, provider);
  }
  /**
   * Create a transaction request to deploy a contract with the specified options.
   *
   * @param deployContractOptions - Options for deploying the contract.
   * @returns The CreateTransactionRequest object for deploying the contract.
   */
  createTransactionRequest(deployContractOptions) {
    const storageSlots = deployContractOptions?.storageSlots?.map(({ key, value }) => ({
      key: hexlifyWithPrefix(key, true),
      value: hexlifyWithPrefix(value, true)
    })).sort(({ key: keyA }, { key: keyB }) => keyA.localeCompare(keyB));
    const options = {
      salt: (0, import_crypto.randomBytes)(32),
      ...deployContractOptions,
      storageSlots: storageSlots || []
    };
    if (!this.provider) {
      throw new import_errors2.FuelError(
        import_errors2.ErrorCode.MISSING_PROVIDER,
        "Cannot create transaction request without provider"
      );
    }
    const stateRoot = options.stateRoot || getContractStorageRoot(options.storageSlots);
    const contractId = getContractId(this.bytecode, options.salt, stateRoot);
    const transactionRequest = new import_providers.CreateTransactionRequest({
      gasPrice: 0,
      gasLimit: 0,
      bytecodeWitnessIndex: 0,
      witnesses: [this.bytecode],
      ...options
    });
    transactionRequest.addContractCreatedOutput(contractId, stateRoot);
    return {
      contractId,
      transactionRequest
    };
  }
  /**
   * Deploy a contract with the specified options.
   *
   * @param deployContractOptions - Options for deploying the contract.
   * @returns A promise that resolves to the deployed contract instance.
   */
  async deployContract(deployContractOptions = {}) {
    if (!this.account) {
      throw new import_errors2.FuelError(import_errors2.ErrorCode.ACCOUNT_REQUIRED, "Cannot deploy Contract without account.");
    }
    const { configurableConstants } = deployContractOptions;
    if (configurableConstants) {
      this.setConfigurableConstants(configurableConstants);
    }
    const { contractId, transactionRequest } = this.createTransactionRequest(deployContractOptions);
    const { requiredQuantities, maxFee, gasUsed } = await this.account.provider.getTransactionCost(transactionRequest);
    transactionRequest.gasLimit = gasUsed;
    await this.account.fund(transactionRequest, requiredQuantities, maxFee);
    const response = await this.account.sendTransaction(transactionRequest);
    await response.wait();
    return new import_program.Contract(contractId, this.interface, this.account);
  }
  /**
   * Set configurable constants of the contract with the specified values.
   *
   * @param configurableConstants - An object containing configurable names and their values.
   */
  setConfigurableConstants(configurableConstants) {
    try {
      const hasConfigurable = Object.keys(this.interface.configurables).length;
      if (!hasConfigurable) {
        throw new Error("Contract does not have configurables to be set");
      }
      Object.entries(configurableConstants).forEach(([key, value]) => {
        if (!this.interface.configurables[key]) {
          throw new Error(`Contract does not have a configurable named: '${key}'`);
        }
        const { offset } = this.interface.configurables[key];
        const encoded = this.interface.encodeConfigurable(key, value);
        const bytes = (0, import_ethers2.getBytesCopy)(this.bytecode);
        bytes.set(encoded, offset);
        this.bytecode = bytes;
      });
    } catch (err) {
      throw new import_errors2.FuelError(
        import_errors2.ErrorCode.INVALID_CONFIGURABLE_CONSTANTS,
        `Error setting configurable constants on contract: ${err.message}.`
      );
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ContractFactory,
  ContractUtils
});
//# sourceMappingURL=index.js.map