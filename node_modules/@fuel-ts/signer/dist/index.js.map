{"version":3,"sources":["../src/index.ts","../src/signer.ts"],"sourcesContent":["export { default as Signer } from './signer';\nexport * from './signer';\n","import { Address } from '@fuel-ts/address';\nimport { randomBytes } from '@fuel-ts/crypto';\nimport { hash } from '@fuel-ts/hasher';\nimport { toBytes } from '@fuel-ts/math';\nimport * as elliptic from 'elliptic';\nimport { hexlify, concat, getBytesCopy } from 'ethers';\nimport type { BytesLike } from 'ethers';\n\n/* Importing `ec` like this to avoid the 'Requested module is a CommonJS module,\n * which may not support all module.exports as named exports' error\n * @see https://github.com/FuelLabs/fuels-ts/issues/841\n */\nconst { ec: EC } = elliptic;\n\n/**\n * Return elliptic instance with curve secp256k1\n */\nexport function getCurve() {\n  return new EC('secp256k1');\n}\n\nclass Signer {\n  readonly address: Address;\n\n  readonly publicKey: string;\n\n  readonly compressedPublicKey: string;\n\n  readonly privateKey: string;\n\n  /**\n   * Create a Signer instance from a given private key\n   *\n   * @param privateKey - The private key to use for signing\n   * @returns A new Signer instance\n   */\n  constructor(privateKey: BytesLike) {\n    // A lot of common tools do not prefix private keys with a 0x\n    if (typeof privateKey === 'string') {\n      if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {\n        // eslint-disable-next-line no-param-reassign\n        privateKey = `0x${privateKey}`;\n      }\n    }\n\n    // Convert to byte array, normalize private key input allowing it to be BytesLike\n    // like remove 0x prefix and accept array of bytes\n    const privateKeyBytes = getBytesCopy(privateKey);\n    const keyPair = getCurve().keyFromPrivate(privateKeyBytes, 'hex');\n\n    // Slice(1) removes the encoding scheme from the public key\n    this.compressedPublicKey = hexlify(Uint8Array.from(keyPair.getPublic(true, 'array')));\n    this.publicKey = hexlify(Uint8Array.from(keyPair.getPublic(false, 'array').slice(1)));\n    this.privateKey = hexlify(privateKeyBytes);\n    this.address = Address.fromPublicKey(this.publicKey);\n  }\n\n  /**\n   * Sign data using the Signer instance\n   *\n   * Signature is a 64 byte array of the concatenated r and s values with the compressed recoveryParam byte. [Read more](FuelLabs/fuel-specs/specs/protocol/cryptographic_primitives.md#public-key-cryptography)\n   *\n   * @param data - The data to be sign\n   * @returns hashed signature\n   */\n  sign(data: BytesLike) {\n    const keyPair = getCurve().keyFromPrivate(getBytesCopy(this.privateKey), 'hex');\n    const signature = keyPair.sign(getBytesCopy(data), {\n      canonical: true,\n    });\n    const r = toBytes(signature.r, 32);\n    const s = toBytes(signature.s, 32);\n\n    // add recoveryParam to first s byte\n    s[0] |= (signature.recoveryParam || 0) << 7;\n\n    return concat([r, s]);\n  }\n\n  /**\n   * Add point on the current elliptic curve\n   *\n   * @param point - Point to add on the curve\n   * @returns compressed point on the curve\n   */\n  addPoint(point: BytesLike) {\n    const p0 = getCurve().keyFromPublic(getBytesCopy(this.compressedPublicKey));\n    const p1 = getCurve().keyFromPublic(getBytesCopy(point));\n    const result = p0.getPublic().add(p1.getPublic());\n\n    return hexlify(Uint8Array.from(result.encode('array', true)));\n  }\n\n  /**\n   * Recover the public key from a signature performed with [`sign`](#sign).\n   *\n   * @param data - Data\n   * @param signature - hashed signature\n   * @returns public key from signature from the\n   */\n  static recoverPublicKey(data: BytesLike, signature: BytesLike): string {\n    const signedMessageBytes = getBytesCopy(signature);\n    const r = signedMessageBytes.slice(0, 32);\n    const s = signedMessageBytes.slice(32, 64);\n    const recoveryParam = (s[0] & 0x80) >> 7;\n\n    // remove recoveryParam from s first byte\n    s[0] &= 0x7f;\n\n    const publicKey = getCurve()\n      .recoverPubKey(getBytesCopy(data), { r, s }, recoveryParam)\n      .encode('array', false)\n      .slice(1);\n\n    return hexlify(Uint8Array.from(publicKey));\n  }\n\n  /**\n   * Recover the address from a signature performed with [`sign`](#sign).\n   *\n   * @param data - Data\n   * @param signature - Signature\n   * @returns Address from signature\n   */\n  static recoverAddress(data: BytesLike, signature: BytesLike): Address {\n    return Address.fromPublicKey(Signer.recoverPublicKey(data, signature));\n  }\n\n  /**\n   * Generate a random privateKey\n   *\n   * @param entropy - Adds extra entropy to generate the privateKey\n   * @returns random 32-byte hashed\n   */\n  static generatePrivateKey(entropy?: BytesLike) {\n    return entropy ? hash(concat([randomBytes(32), getBytesCopy(entropy)])) : randomBytes(32);\n  }\n\n  /**\n   * Extended publicKey from a compact publicKey\n   *\n   * @param publicKey - Compact publicKey\n   * @returns extended publicKey\n   */\n  static extendPublicKey(publicKey: BytesLike) {\n    const keyPair = getCurve().keyFromPublic(getBytesCopy(publicKey));\n    return hexlify(Uint8Array.from(keyPair.getPublic(false, 'array').slice(1)));\n  }\n}\n\nexport default Signer;\n"],"mappings":"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","names":[]}