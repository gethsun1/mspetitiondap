#!/usr/bin/env node
"use strict";
(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __require2 = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require3() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var __accessCheck = (obj, member, msg) => {
    if (!member.has(obj))
      throw TypeError("Cannot " + msg);
  };
  var __privateGet = (obj, member, getter3) => {
    __accessCheck(obj, member, "read from private field");
    return getter3 ? getter3.call(obj) : member.get(obj);
  };
  var __privateAdd = (obj, member, value) => {
    if (member.has(obj))
      throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  };
  var __privateSet = (obj, member, value, setter) => {
    __accessCheck(obj, member, "write to private field");
    setter ? setter.call(obj, value) : member.set(obj, value);
    return value;
  };
  var __privateMethod = (obj, member, method) => {
    __accessCheck(obj, member, "access private method");
    return method;
  };

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/internal/constants.js
  var require_constants = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/internal/constants.js"(exports, module2) {
      var SEMVER_SPEC_VERSION = "2.0.0";
      var MAX_LENGTH = 256;
      var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
      9007199254740991;
      var MAX_SAFE_COMPONENT_LENGTH = 16;
      module2.exports = {
        SEMVER_SPEC_VERSION,
        MAX_LENGTH,
        MAX_SAFE_INTEGER,
        MAX_SAFE_COMPONENT_LENGTH
      };
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/internal/debug.js
  var require_debug = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/internal/debug.js"(exports, module2) {
      var debug2 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
      };
      module2.exports = debug2;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/internal/re.js
  var require_re = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/internal/re.js"(exports, module2) {
      var { MAX_SAFE_COMPONENT_LENGTH } = require_constants();
      var debug2 = require_debug();
      exports = module2.exports = {};
      var re = exports.re = [];
      var src = exports.src = [];
      var t = exports.t = {};
      var R = 0;
      var createToken2 = (name, value, isGlobal) => {
        const index = R++;
        debug2(name, index, value);
        t[name] = index;
        src[index] = value;
        re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      };
      createToken2("NUMERICIDENTIFIER", "0|[1-9]\\d*");
      createToken2("NUMERICIDENTIFIERLOOSE", "[0-9]+");
      createToken2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
      createToken2("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
      createToken2("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
      createToken2("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
      createToken2("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
      createToken2("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
      createToken2("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
      createToken2("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
      createToken2("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
      createToken2("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
      createToken2("FULL", `^${src[t.FULLPLAIN]}$`);
      createToken2("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
      createToken2("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
      createToken2("GTLT", "((?:<|>)?=?)");
      createToken2("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
      createToken2("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
      createToken2("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
      createToken2("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
      createToken2("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
      createToken2("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
      createToken2("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
      createToken2("COERCERTL", src[t.COERCE], true);
      createToken2("LONETILDE", "(?:~>?)");
      createToken2("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
      exports.tildeTrimReplace = "$1~";
      createToken2("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
      createToken2("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
      createToken2("LONECARET", "(?:\\^)");
      createToken2("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
      exports.caretTrimReplace = "$1^";
      createToken2("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
      createToken2("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
      createToken2("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
      createToken2("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
      createToken2("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
      exports.comparatorTrimReplace = "$1$2$3";
      createToken2("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
      createToken2("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
      createToken2("STAR", "(<|>)?=?\\s*\\*");
      createToken2("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
      createToken2("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/internal/parse-options.js
  var require_parse_options = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/internal/parse-options.js"(exports, module2) {
      var opts = ["includePrerelease", "loose", "rtl"];
      var parseOptions = (options) => !options ? {} : typeof options !== "object" ? { loose: true } : opts.filter((k) => options[k]).reduce((o, k) => {
        o[k] = true;
        return o;
      }, {});
      module2.exports = parseOptions;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/internal/identifiers.js
  var require_identifiers = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/internal/identifiers.js"(exports, module2) {
      var numeric = /^[0-9]+$/;
      var compareIdentifiers = (a, b) => {
        const anum = numeric.test(a);
        const bnum = numeric.test(b);
        if (anum && bnum) {
          a = +a;
          b = +b;
        }
        return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
      };
      var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
      module2.exports = {
        compareIdentifiers,
        rcompareIdentifiers
      };
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/classes/semver.js
  var require_semver = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/classes/semver.js"(exports, module2) {
      var debug2 = require_debug();
      var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
      var { re, t } = require_re();
      var parseOptions = require_parse_options();
      var { compareIdentifiers } = require_identifiers();
      var SemVer = class {
        constructor(version2, options) {
          options = parseOptions(options);
          if (version2 instanceof SemVer) {
            if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
              return version2;
            } else {
              version2 = version2.version;
            }
          } else if (typeof version2 !== "string") {
            throw new TypeError(`Invalid Version: ${version2}`);
          }
          if (version2.length > MAX_LENGTH) {
            throw new TypeError(
              `version is longer than ${MAX_LENGTH} characters`
            );
          }
          debug2("SemVer", version2, options);
          this.options = options;
          this.loose = !!options.loose;
          this.includePrerelease = !!options.includePrerelease;
          const m = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
          if (!m) {
            throw new TypeError(`Invalid Version: ${version2}`);
          }
          this.raw = version2;
          this.major = +m[1];
          this.minor = +m[2];
          this.patch = +m[3];
          if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
            throw new TypeError("Invalid major version");
          }
          if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
            throw new TypeError("Invalid minor version");
          }
          if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
            throw new TypeError("Invalid patch version");
          }
          if (!m[4]) {
            this.prerelease = [];
          } else {
            this.prerelease = m[4].split(".").map((id) => {
              if (/^[0-9]+$/.test(id)) {
                const num = +id;
                if (num >= 0 && num < MAX_SAFE_INTEGER) {
                  return num;
                }
              }
              return id;
            });
          }
          this.build = m[5] ? m[5].split(".") : [];
          this.format();
        }
        format() {
          this.version = `${this.major}.${this.minor}.${this.patch}`;
          if (this.prerelease.length) {
            this.version += `-${this.prerelease.join(".")}`;
          }
          return this.version;
        }
        toString() {
          return this.version;
        }
        compare(other) {
          debug2("SemVer.compare", this.version, this.options, other);
          if (!(other instanceof SemVer)) {
            if (typeof other === "string" && other === this.version) {
              return 0;
            }
            other = new SemVer(other, this.options);
          }
          if (other.version === this.version) {
            return 0;
          }
          return this.compareMain(other) || this.comparePre(other);
        }
        compareMain(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }
          return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
        }
        comparePre(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }
          if (this.prerelease.length && !other.prerelease.length) {
            return -1;
          } else if (!this.prerelease.length && other.prerelease.length) {
            return 1;
          } else if (!this.prerelease.length && !other.prerelease.length) {
            return 0;
          }
          let i = 0;
          do {
            const a = this.prerelease[i];
            const b = other.prerelease[i];
            debug2("prerelease compare", i, a, b);
            if (a === void 0 && b === void 0) {
              return 0;
            } else if (b === void 0) {
              return 1;
            } else if (a === void 0) {
              return -1;
            } else if (a === b) {
              continue;
            } else {
              return compareIdentifiers(a, b);
            }
          } while (++i);
        }
        compareBuild(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }
          let i = 0;
          do {
            const a = this.build[i];
            const b = other.build[i];
            debug2("prerelease compare", i, a, b);
            if (a === void 0 && b === void 0) {
              return 0;
            } else if (b === void 0) {
              return 1;
            } else if (a === void 0) {
              return -1;
            } else if (a === b) {
              continue;
            } else {
              return compareIdentifiers(a, b);
            }
          } while (++i);
        }
        // preminor will bump the version up to the next minor release, and immediately
        // down to pre-release. premajor and prepatch work the same way.
        inc(release, identifier) {
          switch (release) {
            case "premajor":
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor = 0;
              this.major++;
              this.inc("pre", identifier);
              break;
            case "preminor":
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor++;
              this.inc("pre", identifier);
              break;
            case "prepatch":
              this.prerelease.length = 0;
              this.inc("patch", identifier);
              this.inc("pre", identifier);
              break;
            case "prerelease":
              if (this.prerelease.length === 0) {
                this.inc("patch", identifier);
              }
              this.inc("pre", identifier);
              break;
            case "major":
              if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
                this.major++;
              }
              this.minor = 0;
              this.patch = 0;
              this.prerelease = [];
              break;
            case "minor":
              if (this.patch !== 0 || this.prerelease.length === 0) {
                this.minor++;
              }
              this.patch = 0;
              this.prerelease = [];
              break;
            case "patch":
              if (this.prerelease.length === 0) {
                this.patch++;
              }
              this.prerelease = [];
              break;
            case "pre":
              if (this.prerelease.length === 0) {
                this.prerelease = [0];
              } else {
                let i = this.prerelease.length;
                while (--i >= 0) {
                  if (typeof this.prerelease[i] === "number") {
                    this.prerelease[i]++;
                    i = -2;
                  }
                }
                if (i === -1) {
                  this.prerelease.push(0);
                }
              }
              if (identifier) {
                if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                  if (isNaN(this.prerelease[1])) {
                    this.prerelease = [identifier, 0];
                  }
                } else {
                  this.prerelease = [identifier, 0];
                }
              }
              break;
            default:
              throw new Error(`invalid increment argument: ${release}`);
          }
          this.format();
          this.raw = this.version;
          return this;
        }
      };
      module2.exports = SemVer;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/parse.js
  var require_parse = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/parse.js"(exports, module2) {
      var { MAX_LENGTH } = require_constants();
      var { re, t } = require_re();
      var SemVer = require_semver();
      var parseOptions = require_parse_options();
      var parse3 = (version2, options) => {
        options = parseOptions(options);
        if (version2 instanceof SemVer) {
          return version2;
        }
        if (typeof version2 !== "string") {
          return null;
        }
        if (version2.length > MAX_LENGTH) {
          return null;
        }
        const r = options.loose ? re[t.LOOSE] : re[t.FULL];
        if (!r.test(version2)) {
          return null;
        }
        try {
          return new SemVer(version2, options);
        } catch (er) {
          return null;
        }
      };
      module2.exports = parse3;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/valid.js
  var require_valid = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/valid.js"(exports, module2) {
      var parse3 = require_parse();
      var valid = (version2, options) => {
        const v = parse3(version2, options);
        return v ? v.version : null;
      };
      module2.exports = valid;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/clean.js
  var require_clean = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/clean.js"(exports, module2) {
      var parse3 = require_parse();
      var clean = (version2, options) => {
        const s = parse3(version2.trim().replace(/^[=v]+/, ""), options);
        return s ? s.version : null;
      };
      module2.exports = clean;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/inc.js
  var require_inc = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/inc.js"(exports, module2) {
      var SemVer = require_semver();
      var inc = (version2, release, options, identifier) => {
        if (typeof options === "string") {
          identifier = options;
          options = void 0;
        }
        try {
          return new SemVer(
            version2 instanceof SemVer ? version2.version : version2,
            options
          ).inc(release, identifier).version;
        } catch (er) {
          return null;
        }
      };
      module2.exports = inc;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/compare.js
  var require_compare = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/compare.js"(exports, module2) {
      var SemVer = require_semver();
      var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
      module2.exports = compare;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/eq.js
  var require_eq = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/eq.js"(exports, module2) {
      var compare = require_compare();
      var eq = (a, b, loose) => compare(a, b, loose) === 0;
      module2.exports = eq;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/diff.js
  var require_diff = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/diff.js"(exports, module2) {
      var parse3 = require_parse();
      var eq = require_eq();
      var diff = (version1, version2) => {
        if (eq(version1, version2)) {
          return null;
        } else {
          const v1 = parse3(version1);
          const v2 = parse3(version2);
          const hasPre = v1.prerelease.length || v2.prerelease.length;
          const prefix = hasPre ? "pre" : "";
          const defaultResult = hasPre ? "prerelease" : "";
          for (const key in v1) {
            if (key === "major" || key === "minor" || key === "patch") {
              if (v1[key] !== v2[key]) {
                return prefix + key;
              }
            }
          }
          return defaultResult;
        }
      };
      module2.exports = diff;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/major.js
  var require_major = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/major.js"(exports, module2) {
      var SemVer = require_semver();
      var major = (a, loose) => new SemVer(a, loose).major;
      module2.exports = major;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/minor.js
  var require_minor = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/minor.js"(exports, module2) {
      var SemVer = require_semver();
      var minor = (a, loose) => new SemVer(a, loose).minor;
      module2.exports = minor;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/patch.js
  var require_patch = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/patch.js"(exports, module2) {
      var SemVer = require_semver();
      var patch = (a, loose) => new SemVer(a, loose).patch;
      module2.exports = patch;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/prerelease.js
  var require_prerelease = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/prerelease.js"(exports, module2) {
      var parse3 = require_parse();
      var prerelease = (version2, options) => {
        const parsed = parse3(version2, options);
        return parsed && parsed.prerelease.length ? parsed.prerelease : null;
      };
      module2.exports = prerelease;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/rcompare.js
  var require_rcompare = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/rcompare.js"(exports, module2) {
      var compare = require_compare();
      var rcompare = (a, b, loose) => compare(b, a, loose);
      module2.exports = rcompare;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/compare-loose.js
  var require_compare_loose = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/compare-loose.js"(exports, module2) {
      var compare = require_compare();
      var compareLoose = (a, b) => compare(a, b, true);
      module2.exports = compareLoose;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/compare-build.js
  var require_compare_build = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/compare-build.js"(exports, module2) {
      var SemVer = require_semver();
      var compareBuild = (a, b, loose) => {
        const versionA = new SemVer(a, loose);
        const versionB = new SemVer(b, loose);
        return versionA.compare(versionB) || versionA.compareBuild(versionB);
      };
      module2.exports = compareBuild;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/sort.js
  var require_sort = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/sort.js"(exports, module2) {
      var compareBuild = require_compare_build();
      var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
      module2.exports = sort;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/rsort.js
  var require_rsort = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/rsort.js"(exports, module2) {
      var compareBuild = require_compare_build();
      var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
      module2.exports = rsort;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/gt.js
  var require_gt = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/gt.js"(exports, module2) {
      var compare = require_compare();
      var gt = (a, b, loose) => compare(a, b, loose) > 0;
      module2.exports = gt;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/lt.js
  var require_lt = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/lt.js"(exports, module2) {
      var compare = require_compare();
      var lt = (a, b, loose) => compare(a, b, loose) < 0;
      module2.exports = lt;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/neq.js
  var require_neq = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/neq.js"(exports, module2) {
      var compare = require_compare();
      var neq = (a, b, loose) => compare(a, b, loose) !== 0;
      module2.exports = neq;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/gte.js
  var require_gte = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/gte.js"(exports, module2) {
      var compare = require_compare();
      var gte = (a, b, loose) => compare(a, b, loose) >= 0;
      module2.exports = gte;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/lte.js
  var require_lte = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/lte.js"(exports, module2) {
      var compare = require_compare();
      var lte = (a, b, loose) => compare(a, b, loose) <= 0;
      module2.exports = lte;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/cmp.js
  var require_cmp = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/cmp.js"(exports, module2) {
      var eq = require_eq();
      var neq = require_neq();
      var gt = require_gt();
      var gte = require_gte();
      var lt = require_lt();
      var lte = require_lte();
      var cmp = (a, op, b, loose) => {
        switch (op) {
          case "===":
            if (typeof a === "object") {
              a = a.version;
            }
            if (typeof b === "object") {
              b = b.version;
            }
            return a === b;
          case "!==":
            if (typeof a === "object") {
              a = a.version;
            }
            if (typeof b === "object") {
              b = b.version;
            }
            return a !== b;
          case "":
          case "=":
          case "==":
            return eq(a, b, loose);
          case "!=":
            return neq(a, b, loose);
          case ">":
            return gt(a, b, loose);
          case ">=":
            return gte(a, b, loose);
          case "<":
            return lt(a, b, loose);
          case "<=":
            return lte(a, b, loose);
          default:
            throw new TypeError(`Invalid operator: ${op}`);
        }
      };
      module2.exports = cmp;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/coerce.js
  var require_coerce = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/coerce.js"(exports, module2) {
      var SemVer = require_semver();
      var parse3 = require_parse();
      var { re, t } = require_re();
      var coerce = (version2, options) => {
        if (version2 instanceof SemVer) {
          return version2;
        }
        if (typeof version2 === "number") {
          version2 = String(version2);
        }
        if (typeof version2 !== "string") {
          return null;
        }
        options = options || {};
        let match3 = null;
        if (!options.rtl) {
          match3 = version2.match(re[t.COERCE]);
        } else {
          let next;
          while ((next = re[t.COERCERTL].exec(version2)) && (!match3 || match3.index + match3[0].length !== version2.length)) {
            if (!match3 || next.index + next[0].length !== match3.index + match3[0].length) {
              match3 = next;
            }
            re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
          }
          re[t.COERCERTL].lastIndex = -1;
        }
        if (match3 === null) {
          return null;
        }
        return parse3(`${match3[2]}.${match3[3] || "0"}.${match3[4] || "0"}`, options);
      };
      module2.exports = coerce;
    }
  });

  // ../../node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/iterator.js
  var require_iterator = __commonJS({
    "../../node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/iterator.js"(exports, module2) {
      "use strict";
      module2.exports = function(Yallist) {
        Yallist.prototype[Symbol.iterator] = function* () {
          for (let walker = this.head; walker; walker = walker.next) {
            yield walker.value;
          }
        };
      };
    }
  });

  // ../../node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/yallist.js
  var require_yallist = __commonJS({
    "../../node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/yallist.js"(exports, module2) {
      "use strict";
      module2.exports = Yallist;
      Yallist.Node = Node2;
      Yallist.create = Yallist;
      function Yallist(list) {
        var self2 = this;
        if (!(self2 instanceof Yallist)) {
          self2 = new Yallist();
        }
        self2.tail = null;
        self2.head = null;
        self2.length = 0;
        if (list && typeof list.forEach === "function") {
          list.forEach(function(item) {
            self2.push(item);
          });
        } else if (arguments.length > 0) {
          for (var i = 0, l = arguments.length; i < l; i++) {
            self2.push(arguments[i]);
          }
        }
        return self2;
      }
      Yallist.prototype.removeNode = function(node) {
        if (node.list !== this) {
          throw new Error("removing node which does not belong to this list");
        }
        var next = node.next;
        var prev = node.prev;
        if (next) {
          next.prev = prev;
        }
        if (prev) {
          prev.next = next;
        }
        if (node === this.head) {
          this.head = next;
        }
        if (node === this.tail) {
          this.tail = prev;
        }
        node.list.length--;
        node.next = null;
        node.prev = null;
        node.list = null;
        return next;
      };
      Yallist.prototype.unshiftNode = function(node) {
        if (node === this.head) {
          return;
        }
        if (node.list) {
          node.list.removeNode(node);
        }
        var head = this.head;
        node.list = this;
        node.next = head;
        if (head) {
          head.prev = node;
        }
        this.head = node;
        if (!this.tail) {
          this.tail = node;
        }
        this.length++;
      };
      Yallist.prototype.pushNode = function(node) {
        if (node === this.tail) {
          return;
        }
        if (node.list) {
          node.list.removeNode(node);
        }
        var tail = this.tail;
        node.list = this;
        node.prev = tail;
        if (tail) {
          tail.next = node;
        }
        this.tail = node;
        if (!this.head) {
          this.head = node;
        }
        this.length++;
      };
      Yallist.prototype.push = function() {
        for (var i = 0, l = arguments.length; i < l; i++) {
          push(this, arguments[i]);
        }
        return this.length;
      };
      Yallist.prototype.unshift = function() {
        for (var i = 0, l = arguments.length; i < l; i++) {
          unshift(this, arguments[i]);
        }
        return this.length;
      };
      Yallist.prototype.pop = function() {
        if (!this.tail) {
          return void 0;
        }
        var res = this.tail.value;
        this.tail = this.tail.prev;
        if (this.tail) {
          this.tail.next = null;
        } else {
          this.head = null;
        }
        this.length--;
        return res;
      };
      Yallist.prototype.shift = function() {
        if (!this.head) {
          return void 0;
        }
        var res = this.head.value;
        this.head = this.head.next;
        if (this.head) {
          this.head.prev = null;
        } else {
          this.tail = null;
        }
        this.length--;
        return res;
      };
      Yallist.prototype.forEach = function(fn, thisp) {
        thisp = thisp || this;
        for (var walker = this.head, i = 0; walker !== null; i++) {
          fn.call(thisp, walker.value, i, this);
          walker = walker.next;
        }
      };
      Yallist.prototype.forEachReverse = function(fn, thisp) {
        thisp = thisp || this;
        for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
          fn.call(thisp, walker.value, i, this);
          walker = walker.prev;
        }
      };
      Yallist.prototype.get = function(n) {
        for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
          walker = walker.next;
        }
        if (i === n && walker !== null) {
          return walker.value;
        }
      };
      Yallist.prototype.getReverse = function(n) {
        for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
          walker = walker.prev;
        }
        if (i === n && walker !== null) {
          return walker.value;
        }
      };
      Yallist.prototype.map = function(fn, thisp) {
        thisp = thisp || this;
        var res = new Yallist();
        for (var walker = this.head; walker !== null; ) {
          res.push(fn.call(thisp, walker.value, this));
          walker = walker.next;
        }
        return res;
      };
      Yallist.prototype.mapReverse = function(fn, thisp) {
        thisp = thisp || this;
        var res = new Yallist();
        for (var walker = this.tail; walker !== null; ) {
          res.push(fn.call(thisp, walker.value, this));
          walker = walker.prev;
        }
        return res;
      };
      Yallist.prototype.reduce = function(fn, initial) {
        var acc;
        var walker = this.head;
        if (arguments.length > 1) {
          acc = initial;
        } else if (this.head) {
          walker = this.head.next;
          acc = this.head.value;
        } else {
          throw new TypeError("Reduce of empty list with no initial value");
        }
        for (var i = 0; walker !== null; i++) {
          acc = fn(acc, walker.value, i);
          walker = walker.next;
        }
        return acc;
      };
      Yallist.prototype.reduceReverse = function(fn, initial) {
        var acc;
        var walker = this.tail;
        if (arguments.length > 1) {
          acc = initial;
        } else if (this.tail) {
          walker = this.tail.prev;
          acc = this.tail.value;
        } else {
          throw new TypeError("Reduce of empty list with no initial value");
        }
        for (var i = this.length - 1; walker !== null; i--) {
          acc = fn(acc, walker.value, i);
          walker = walker.prev;
        }
        return acc;
      };
      Yallist.prototype.toArray = function() {
        var arr = new Array(this.length);
        for (var i = 0, walker = this.head; walker !== null; i++) {
          arr[i] = walker.value;
          walker = walker.next;
        }
        return arr;
      };
      Yallist.prototype.toArrayReverse = function() {
        var arr = new Array(this.length);
        for (var i = 0, walker = this.tail; walker !== null; i++) {
          arr[i] = walker.value;
          walker = walker.prev;
        }
        return arr;
      };
      Yallist.prototype.slice = function(from, to) {
        to = to || this.length;
        if (to < 0) {
          to += this.length;
        }
        from = from || 0;
        if (from < 0) {
          from += this.length;
        }
        var ret3 = new Yallist();
        if (to < from || to < 0) {
          return ret3;
        }
        if (from < 0) {
          from = 0;
        }
        if (to > this.length) {
          to = this.length;
        }
        for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
          walker = walker.next;
        }
        for (; walker !== null && i < to; i++, walker = walker.next) {
          ret3.push(walker.value);
        }
        return ret3;
      };
      Yallist.prototype.sliceReverse = function(from, to) {
        to = to || this.length;
        if (to < 0) {
          to += this.length;
        }
        from = from || 0;
        if (from < 0) {
          from += this.length;
        }
        var ret3 = new Yallist();
        if (to < from || to < 0) {
          return ret3;
        }
        if (from < 0) {
          from = 0;
        }
        if (to > this.length) {
          to = this.length;
        }
        for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
          walker = walker.prev;
        }
        for (; walker !== null && i > from; i--, walker = walker.prev) {
          ret3.push(walker.value);
        }
        return ret3;
      };
      Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
        if (start > this.length) {
          start = this.length - 1;
        }
        if (start < 0) {
          start = this.length + start;
        }
        for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
          walker = walker.next;
        }
        var ret3 = [];
        for (var i = 0; walker && i < deleteCount; i++) {
          ret3.push(walker.value);
          walker = this.removeNode(walker);
        }
        if (walker === null) {
          walker = this.tail;
        }
        if (walker !== this.head && walker !== this.tail) {
          walker = walker.prev;
        }
        for (var i = 0; i < nodes.length; i++) {
          walker = insert(this, walker, nodes[i]);
        }
        return ret3;
      };
      Yallist.prototype.reverse = function() {
        var head = this.head;
        var tail = this.tail;
        for (var walker = head; walker !== null; walker = walker.prev) {
          var p = walker.prev;
          walker.prev = walker.next;
          walker.next = p;
        }
        this.head = tail;
        this.tail = head;
        return this;
      };
      function insert(self2, node, value) {
        var inserted = node === self2.head ? new Node2(value, null, node, self2) : new Node2(value, node, node.next, self2);
        if (inserted.next === null) {
          self2.tail = inserted;
        }
        if (inserted.prev === null) {
          self2.head = inserted;
        }
        self2.length++;
        return inserted;
      }
      function push(self2, item) {
        self2.tail = new Node2(item, self2.tail, null, self2);
        if (!self2.head) {
          self2.head = self2.tail;
        }
        self2.length++;
      }
      function unshift(self2, item) {
        self2.head = new Node2(item, null, self2.head, self2);
        if (!self2.tail) {
          self2.tail = self2.head;
        }
        self2.length++;
      }
      function Node2(value, prev, next, list) {
        if (!(this instanceof Node2)) {
          return new Node2(value, prev, next, list);
        }
        this.list = list;
        this.value = value;
        if (prev) {
          prev.next = this;
          this.prev = prev;
        } else {
          this.prev = null;
        }
        if (next) {
          next.prev = this;
          this.next = next;
        } else {
          this.next = null;
        }
      }
      try {
        require_iterator()(Yallist);
      } catch (er) {
      }
    }
  });

  // ../../node_modules/.pnpm/lru-cache@6.0.0/node_modules/lru-cache/index.js
  var require_lru_cache = __commonJS({
    "../../node_modules/.pnpm/lru-cache@6.0.0/node_modules/lru-cache/index.js"(exports, module2) {
      "use strict";
      var Yallist = require_yallist();
      var MAX = Symbol("max");
      var LENGTH = Symbol("length");
      var LENGTH_CALCULATOR = Symbol("lengthCalculator");
      var ALLOW_STALE = Symbol("allowStale");
      var MAX_AGE = Symbol("maxAge");
      var DISPOSE = Symbol("dispose");
      var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
      var LRU_LIST = Symbol("lruList");
      var CACHE = Symbol("cache");
      var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
      var naiveLength = () => 1;
      var LRUCache2 = class {
        constructor(options) {
          if (typeof options === "number")
            options = { max: options };
          if (!options)
            options = {};
          if (options.max && (typeof options.max !== "number" || options.max < 0))
            throw new TypeError("max must be a non-negative number");
          const max2 = this[MAX] = options.max || Infinity;
          const lc = options.length || naiveLength;
          this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
          this[ALLOW_STALE] = options.stale || false;
          if (options.maxAge && typeof options.maxAge !== "number")
            throw new TypeError("maxAge must be a number");
          this[MAX_AGE] = options.maxAge || 0;
          this[DISPOSE] = options.dispose;
          this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
          this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
          this.reset();
        }
        // resize the cache when the max changes.
        set max(mL) {
          if (typeof mL !== "number" || mL < 0)
            throw new TypeError("max must be a non-negative number");
          this[MAX] = mL || Infinity;
          trim2(this);
        }
        get max() {
          return this[MAX];
        }
        set allowStale(allowStale) {
          this[ALLOW_STALE] = !!allowStale;
        }
        get allowStale() {
          return this[ALLOW_STALE];
        }
        set maxAge(mA) {
          if (typeof mA !== "number")
            throw new TypeError("maxAge must be a non-negative number");
          this[MAX_AGE] = mA;
          trim2(this);
        }
        get maxAge() {
          return this[MAX_AGE];
        }
        // resize the cache when the lengthCalculator changes.
        set lengthCalculator(lC) {
          if (typeof lC !== "function")
            lC = naiveLength;
          if (lC !== this[LENGTH_CALCULATOR]) {
            this[LENGTH_CALCULATOR] = lC;
            this[LENGTH] = 0;
            this[LRU_LIST].forEach((hit) => {
              hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
              this[LENGTH] += hit.length;
            });
          }
          trim2(this);
        }
        get lengthCalculator() {
          return this[LENGTH_CALCULATOR];
        }
        get length() {
          return this[LENGTH];
        }
        get itemCount() {
          return this[LRU_LIST].length;
        }
        rforEach(fn, thisp) {
          thisp = thisp || this;
          for (let walker = this[LRU_LIST].tail; walker !== null; ) {
            const prev = walker.prev;
            forEachStep(this, fn, walker, thisp);
            walker = prev;
          }
        }
        forEach(fn, thisp) {
          thisp = thisp || this;
          for (let walker = this[LRU_LIST].head; walker !== null; ) {
            const next = walker.next;
            forEachStep(this, fn, walker, thisp);
            walker = next;
          }
        }
        keys() {
          return this[LRU_LIST].toArray().map((k) => k.key);
        }
        values() {
          return this[LRU_LIST].toArray().map((k) => k.value);
        }
        reset() {
          if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
            this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
          }
          this[CACHE] = /* @__PURE__ */ new Map();
          this[LRU_LIST] = new Yallist();
          this[LENGTH] = 0;
        }
        dump() {
          return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
            k: hit.key,
            v: hit.value,
            e: hit.now + (hit.maxAge || 0)
          }).toArray().filter((h) => h);
        }
        dumpLru() {
          return this[LRU_LIST];
        }
        set(key, value, maxAge) {
          maxAge = maxAge || this[MAX_AGE];
          if (maxAge && typeof maxAge !== "number")
            throw new TypeError("maxAge must be a number");
          const now = maxAge ? Date.now() : 0;
          const len = this[LENGTH_CALCULATOR](value, key);
          if (this[CACHE].has(key)) {
            if (len > this[MAX]) {
              del(this, this[CACHE].get(key));
              return false;
            }
            const node = this[CACHE].get(key);
            const item = node.value;
            if (this[DISPOSE]) {
              if (!this[NO_DISPOSE_ON_SET])
                this[DISPOSE](key, item.value);
            }
            item.now = now;
            item.maxAge = maxAge;
            item.value = value;
            this[LENGTH] += len - item.length;
            item.length = len;
            this.get(key);
            trim2(this);
            return true;
          }
          const hit = new Entry(key, value, len, now, maxAge);
          if (hit.length > this[MAX]) {
            if (this[DISPOSE])
              this[DISPOSE](key, value);
            return false;
          }
          this[LENGTH] += hit.length;
          this[LRU_LIST].unshift(hit);
          this[CACHE].set(key, this[LRU_LIST].head);
          trim2(this);
          return true;
        }
        has(key) {
          if (!this[CACHE].has(key))
            return false;
          const hit = this[CACHE].get(key).value;
          return !isStale(this, hit);
        }
        get(key) {
          return get(this, key, true);
        }
        peek(key) {
          return get(this, key, false);
        }
        pop() {
          const node = this[LRU_LIST].tail;
          if (!node)
            return null;
          del(this, node);
          return node.value;
        }
        del(key) {
          del(this, this[CACHE].get(key));
        }
        load(arr) {
          this.reset();
          const now = Date.now();
          for (let l = arr.length - 1; l >= 0; l--) {
            const hit = arr[l];
            const expiresAt = hit.e || 0;
            if (expiresAt === 0)
              this.set(hit.k, hit.v);
            else {
              const maxAge = expiresAt - now;
              if (maxAge > 0) {
                this.set(hit.k, hit.v, maxAge);
              }
            }
          }
        }
        prune() {
          this[CACHE].forEach((value, key) => get(this, key, false));
        }
      };
      var get = (self2, key, doUse) => {
        const node = self2[CACHE].get(key);
        if (node) {
          const hit = node.value;
          if (isStale(self2, hit)) {
            del(self2, node);
            if (!self2[ALLOW_STALE])
              return void 0;
          } else {
            if (doUse) {
              if (self2[UPDATE_AGE_ON_GET])
                node.value.now = Date.now();
              self2[LRU_LIST].unshiftNode(node);
            }
          }
          return hit.value;
        }
      };
      var isStale = (self2, hit) => {
        if (!hit || !hit.maxAge && !self2[MAX_AGE])
          return false;
        const diff = Date.now() - hit.now;
        return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
      };
      var trim2 = (self2) => {
        if (self2[LENGTH] > self2[MAX]) {
          for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
            const prev = walker.prev;
            del(self2, walker);
            walker = prev;
          }
        }
      };
      var del = (self2, node) => {
        if (node) {
          const hit = node.value;
          if (self2[DISPOSE])
            self2[DISPOSE](hit.key, hit.value);
          self2[LENGTH] -= hit.length;
          self2[CACHE].delete(hit.key);
          self2[LRU_LIST].removeNode(node);
        }
      };
      var Entry = class {
        constructor(key, value, length, now, maxAge) {
          this.key = key;
          this.value = value;
          this.length = length;
          this.now = now;
          this.maxAge = maxAge || 0;
        }
      };
      var forEachStep = (self2, fn, node, thisp) => {
        let hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            hit = void 0;
        }
        if (hit)
          fn.call(thisp, hit.value, hit.key, self2);
      };
      module2.exports = LRUCache2;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/classes/range.js
  var require_range = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/classes/range.js"(exports, module2) {
      var Range = class {
        constructor(range, options) {
          options = parseOptions(options);
          if (range instanceof Range) {
            if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
              return range;
            } else {
              return new Range(range.raw, options);
            }
          }
          if (range instanceof Comparator) {
            this.raw = range.value;
            this.set = [[range]];
            this.format();
            return this;
          }
          this.options = options;
          this.loose = !!options.loose;
          this.includePrerelease = !!options.includePrerelease;
          this.raw = range;
          this.set = range.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
          if (!this.set.length) {
            throw new TypeError(`Invalid SemVer Range: ${range}`);
          }
          if (this.set.length > 1) {
            const first = this.set[0];
            this.set = this.set.filter((c) => !isNullSet(c[0]));
            if (this.set.length === 0) {
              this.set = [first];
            } else if (this.set.length > 1) {
              for (const c of this.set) {
                if (c.length === 1 && isAny(c[0])) {
                  this.set = [c];
                  break;
                }
              }
            }
          }
          this.format();
        }
        format() {
          this.range = this.set.map((comps) => {
            return comps.join(" ").trim();
          }).join("||").trim();
          return this.range;
        }
        toString() {
          return this.range;
        }
        parseRange(range) {
          range = range.trim();
          const memoOpts = Object.keys(this.options).join(",");
          const memoKey = `parseRange:${memoOpts}:${range}`;
          const cached = cache2.get(memoKey);
          if (cached) {
            return cached;
          }
          const loose = this.options.loose;
          const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
          range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
          debug2("hyphen replace", range);
          range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
          debug2("comparator trim", range);
          range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
          range = range.replace(re[t.CARETTRIM], caretTrimReplace);
          range = range.split(/\s+/).join(" ");
          let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
          if (loose) {
            rangeList = rangeList.filter((comp) => {
              debug2("loose invalid filter", comp, this.options);
              return !!comp.match(re[t.COMPARATORLOOSE]);
            });
          }
          debug2("range list", rangeList);
          const rangeMap = /* @__PURE__ */ new Map();
          const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
          for (const comp of comparators) {
            if (isNullSet(comp)) {
              return [comp];
            }
            rangeMap.set(comp.value, comp);
          }
          if (rangeMap.size > 1 && rangeMap.has("")) {
            rangeMap.delete("");
          }
          const result = [...rangeMap.values()];
          cache2.set(memoKey, result);
          return result;
        }
        intersects(range, options) {
          if (!(range instanceof Range)) {
            throw new TypeError("a Range is required");
          }
          return this.set.some((thisComparators) => {
            return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
              return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
                return rangeComparators.every((rangeComparator) => {
                  return thisComparator.intersects(rangeComparator, options);
                });
              });
            });
          });
        }
        // if ANY of the sets match ALL of its comparators, then pass
        test(version2) {
          if (!version2) {
            return false;
          }
          if (typeof version2 === "string") {
            try {
              version2 = new SemVer(version2, this.options);
            } catch (er) {
              return false;
            }
          }
          for (let i = 0; i < this.set.length; i++) {
            if (testSet(this.set[i], version2, this.options)) {
              return true;
            }
          }
          return false;
        }
      };
      module2.exports = Range;
      var LRU = require_lru_cache();
      var cache2 = new LRU({ max: 1e3 });
      var parseOptions = require_parse_options();
      var Comparator = require_comparator();
      var debug2 = require_debug();
      var SemVer = require_semver();
      var {
        re,
        t,
        comparatorTrimReplace,
        tildeTrimReplace,
        caretTrimReplace
      } = require_re();
      var isNullSet = (c) => c.value === "<0.0.0-0";
      var isAny = (c) => c.value === "";
      var isSatisfiable = (comparators, options) => {
        let result = true;
        const remainingComparators = comparators.slice();
        let testComparator = remainingComparators.pop();
        while (result && remainingComparators.length) {
          result = remainingComparators.every((otherComparator) => {
            return testComparator.intersects(otherComparator, options);
          });
          testComparator = remainingComparators.pop();
        }
        return result;
      };
      var parseComparator = (comp, options) => {
        debug2("comp", comp, options);
        comp = replaceCarets(comp, options);
        debug2("caret", comp);
        comp = replaceTildes(comp, options);
        debug2("tildes", comp);
        comp = replaceXRanges(comp, options);
        debug2("xrange", comp);
        comp = replaceStars(comp, options);
        debug2("stars", comp);
        return comp;
      };
      var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
      var replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((c) => {
        return replaceTilde(c, options);
      }).join(" ");
      var replaceTilde = (comp, options) => {
        const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
        return comp.replace(r, (_, M, m, p, pr) => {
          debug2("tilde", comp, _, M, m, p, pr);
          let ret3;
          if (isX(M)) {
            ret3 = "";
          } else if (isX(m)) {
            ret3 = `>=${M}.0.0 <${+M + 1}.0.0-0`;
          } else if (isX(p)) {
            ret3 = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
          } else if (pr) {
            debug2("replaceTilde pr", pr);
            ret3 = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          } else {
            ret3 = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
          }
          debug2("tilde return", ret3);
          return ret3;
        });
      };
      var replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((c) => {
        return replaceCaret(c, options);
      }).join(" ");
      var replaceCaret = (comp, options) => {
        debug2("caret", comp, options);
        const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
        const z = options.includePrerelease ? "-0" : "";
        return comp.replace(r, (_, M, m, p, pr) => {
          debug2("caret", comp, _, M, m, p, pr);
          let ret3;
          if (isX(M)) {
            ret3 = "";
          } else if (isX(m)) {
            ret3 = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
          } else if (isX(p)) {
            if (M === "0") {
              ret3 = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
            } else {
              ret3 = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
            }
          } else if (pr) {
            debug2("replaceCaret pr", pr);
            if (M === "0") {
              if (m === "0") {
                ret3 = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
              } else {
                ret3 = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
              }
            } else {
              ret3 = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
            }
          } else {
            debug2("no pr");
            if (M === "0") {
              if (m === "0") {
                ret3 = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
              } else {
                ret3 = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
              }
            } else {
              ret3 = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
            }
          }
          debug2("caret return", ret3);
          return ret3;
        });
      };
      var replaceXRanges = (comp, options) => {
        debug2("replaceXRanges", comp, options);
        return comp.split(/\s+/).map((c) => {
          return replaceXRange(c, options);
        }).join(" ");
      };
      var replaceXRange = (comp, options) => {
        comp = comp.trim();
        const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
        return comp.replace(r, (ret3, gtlt, M, m, p, pr) => {
          debug2("xRange", comp, ret3, gtlt, M, m, p, pr);
          const xM = isX(M);
          const xm = xM || isX(m);
          const xp = xm || isX(p);
          const anyX = xp;
          if (gtlt === "=" && anyX) {
            gtlt = "";
          }
          pr = options.includePrerelease ? "-0" : "";
          if (xM) {
            if (gtlt === ">" || gtlt === "<") {
              ret3 = "<0.0.0-0";
            } else {
              ret3 = "*";
            }
          } else if (gtlt && anyX) {
            if (xm) {
              m = 0;
            }
            p = 0;
            if (gtlt === ">") {
              gtlt = ">=";
              if (xm) {
                M = +M + 1;
                m = 0;
                p = 0;
              } else {
                m = +m + 1;
                p = 0;
              }
            } else if (gtlt === "<=") {
              gtlt = "<";
              if (xm) {
                M = +M + 1;
              } else {
                m = +m + 1;
              }
            }
            if (gtlt === "<") {
              pr = "-0";
            }
            ret3 = `${gtlt + M}.${m}.${p}${pr}`;
          } else if (xm) {
            ret3 = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
          } else if (xp) {
            ret3 = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
          }
          debug2("xRange return", ret3);
          return ret3;
        });
      };
      var replaceStars = (comp, options) => {
        debug2("replaceStars", comp, options);
        return comp.trim().replace(re[t.STAR], "");
      };
      var replaceGTE0 = (comp, options) => {
        debug2("replaceGTE0", comp, options);
        return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
      };
      var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
        if (isX(fM)) {
          from = "";
        } else if (isX(fm)) {
          from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
        } else if (isX(fp)) {
          from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
        } else if (fpr) {
          from = `>=${from}`;
        } else {
          from = `>=${from}${incPr ? "-0" : ""}`;
        }
        if (isX(tM)) {
          to = "";
        } else if (isX(tm)) {
          to = `<${+tM + 1}.0.0-0`;
        } else if (isX(tp)) {
          to = `<${tM}.${+tm + 1}.0-0`;
        } else if (tpr) {
          to = `<=${tM}.${tm}.${tp}-${tpr}`;
        } else if (incPr) {
          to = `<${tM}.${tm}.${+tp + 1}-0`;
        } else {
          to = `<=${to}`;
        }
        return `${from} ${to}`.trim();
      };
      var testSet = (set2, version2, options) => {
        for (let i = 0; i < set2.length; i++) {
          if (!set2[i].test(version2)) {
            return false;
          }
        }
        if (version2.prerelease.length && !options.includePrerelease) {
          for (let i = 0; i < set2.length; i++) {
            debug2(set2[i].semver);
            if (set2[i].semver === Comparator.ANY) {
              continue;
            }
            if (set2[i].semver.prerelease.length > 0) {
              const allowed = set2[i].semver;
              if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
                return true;
              }
            }
          }
          return false;
        }
        return true;
      };
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/classes/comparator.js
  var require_comparator = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/classes/comparator.js"(exports, module2) {
      var ANY = Symbol("SemVer ANY");
      var Comparator = class {
        static get ANY() {
          return ANY;
        }
        constructor(comp, options) {
          options = parseOptions(options);
          if (comp instanceof Comparator) {
            if (comp.loose === !!options.loose) {
              return comp;
            } else {
              comp = comp.value;
            }
          }
          debug2("comparator", comp, options);
          this.options = options;
          this.loose = !!options.loose;
          this.parse(comp);
          if (this.semver === ANY) {
            this.value = "";
          } else {
            this.value = this.operator + this.semver.version;
          }
          debug2("comp", this);
        }
        parse(comp) {
          const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
          const m = comp.match(r);
          if (!m) {
            throw new TypeError(`Invalid comparator: ${comp}`);
          }
          this.operator = m[1] !== void 0 ? m[1] : "";
          if (this.operator === "=") {
            this.operator = "";
          }
          if (!m[2]) {
            this.semver = ANY;
          } else {
            this.semver = new SemVer(m[2], this.options.loose);
          }
        }
        toString() {
          return this.value;
        }
        test(version2) {
          debug2("Comparator.test", version2, this.options.loose);
          if (this.semver === ANY || version2 === ANY) {
            return true;
          }
          if (typeof version2 === "string") {
            try {
              version2 = new SemVer(version2, this.options);
            } catch (er) {
              return false;
            }
          }
          return cmp(version2, this.operator, this.semver, this.options);
        }
        intersects(comp, options) {
          if (!(comp instanceof Comparator)) {
            throw new TypeError("a Comparator is required");
          }
          if (!options || typeof options !== "object") {
            options = {
              loose: !!options,
              includePrerelease: false
            };
          }
          if (this.operator === "") {
            if (this.value === "") {
              return true;
            }
            return new Range(comp.value, options).test(this.value);
          } else if (comp.operator === "") {
            if (comp.value === "") {
              return true;
            }
            return new Range(this.value, options).test(comp.semver);
          }
          const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
          const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
          const sameSemVer = this.semver.version === comp.semver.version;
          const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
          const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
          const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
          return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
        }
      };
      module2.exports = Comparator;
      var parseOptions = require_parse_options();
      var { re, t } = require_re();
      var cmp = require_cmp();
      var debug2 = require_debug();
      var SemVer = require_semver();
      var Range = require_range();
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/satisfies.js
  var require_satisfies = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/satisfies.js"(exports, module2) {
      var Range = require_range();
      var satisfies = (version2, range, options) => {
        try {
          range = new Range(range, options);
        } catch (er) {
          return false;
        }
        return range.test(version2);
      };
      module2.exports = satisfies;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/to-comparators.js
  var require_to_comparators = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/to-comparators.js"(exports, module2) {
      var Range = require_range();
      var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
      module2.exports = toComparators;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/max-satisfying.js
  var require_max_satisfying = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/max-satisfying.js"(exports, module2) {
      var SemVer = require_semver();
      var Range = require_range();
      var maxSatisfying = (versions3, range, options) => {
        let max2 = null;
        let maxSV = null;
        let rangeObj = null;
        try {
          rangeObj = new Range(range, options);
        } catch (er) {
          return null;
        }
        versions3.forEach((v) => {
          if (rangeObj.test(v)) {
            if (!max2 || maxSV.compare(v) === -1) {
              max2 = v;
              maxSV = new SemVer(max2, options);
            }
          }
        });
        return max2;
      };
      module2.exports = maxSatisfying;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/min-satisfying.js
  var require_min_satisfying = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/min-satisfying.js"(exports, module2) {
      var SemVer = require_semver();
      var Range = require_range();
      var minSatisfying = (versions3, range, options) => {
        let min = null;
        let minSV = null;
        let rangeObj = null;
        try {
          rangeObj = new Range(range, options);
        } catch (er) {
          return null;
        }
        versions3.forEach((v) => {
          if (rangeObj.test(v)) {
            if (!min || minSV.compare(v) === 1) {
              min = v;
              minSV = new SemVer(min, options);
            }
          }
        });
        return min;
      };
      module2.exports = minSatisfying;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/min-version.js
  var require_min_version = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/min-version.js"(exports, module2) {
      var SemVer = require_semver();
      var Range = require_range();
      var gt = require_gt();
      var minVersion = (range, loose) => {
        range = new Range(range, loose);
        let minver = new SemVer("0.0.0");
        if (range.test(minver)) {
          return minver;
        }
        minver = new SemVer("0.0.0-0");
        if (range.test(minver)) {
          return minver;
        }
        minver = null;
        for (let i = 0; i < range.set.length; ++i) {
          const comparators = range.set[i];
          let setMin = null;
          comparators.forEach((comparator) => {
            const compver = new SemVer(comparator.semver.version);
            switch (comparator.operator) {
              case ">":
                if (compver.prerelease.length === 0) {
                  compver.patch++;
                } else {
                  compver.prerelease.push(0);
                }
                compver.raw = compver.format();
              case "":
              case ">=":
                if (!setMin || gt(compver, setMin)) {
                  setMin = compver;
                }
                break;
              case "<":
              case "<=":
                break;
              default:
                throw new Error(`Unexpected operation: ${comparator.operator}`);
            }
          });
          if (setMin && (!minver || gt(minver, setMin))) {
            minver = setMin;
          }
        }
        if (minver && range.test(minver)) {
          return minver;
        }
        return null;
      };
      module2.exports = minVersion;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/valid.js
  var require_valid2 = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/valid.js"(exports, module2) {
      var Range = require_range();
      var validRange = (range, options) => {
        try {
          return new Range(range, options).range || "*";
        } catch (er) {
          return null;
        }
      };
      module2.exports = validRange;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/outside.js
  var require_outside = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/outside.js"(exports, module2) {
      var SemVer = require_semver();
      var Comparator = require_comparator();
      var { ANY } = Comparator;
      var Range = require_range();
      var satisfies = require_satisfies();
      var gt = require_gt();
      var lt = require_lt();
      var lte = require_lte();
      var gte = require_gte();
      var outside = (version2, range, hilo, options) => {
        version2 = new SemVer(version2, options);
        range = new Range(range, options);
        let gtfn, ltefn, ltfn, comp, ecomp;
        switch (hilo) {
          case ">":
            gtfn = gt;
            ltefn = lte;
            ltfn = lt;
            comp = ">";
            ecomp = ">=";
            break;
          case "<":
            gtfn = lt;
            ltefn = gte;
            ltfn = gt;
            comp = "<";
            ecomp = "<=";
            break;
          default:
            throw new TypeError('Must provide a hilo val of "<" or ">"');
        }
        if (satisfies(version2, range, options)) {
          return false;
        }
        for (let i = 0; i < range.set.length; ++i) {
          const comparators = range.set[i];
          let high = null;
          let low = null;
          comparators.forEach((comparator) => {
            if (comparator.semver === ANY) {
              comparator = new Comparator(">=0.0.0");
            }
            high = high || comparator;
            low = low || comparator;
            if (gtfn(comparator.semver, high.semver, options)) {
              high = comparator;
            } else if (ltfn(comparator.semver, low.semver, options)) {
              low = comparator;
            }
          });
          if (high.operator === comp || high.operator === ecomp) {
            return false;
          }
          if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
            return false;
          } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
            return false;
          }
        }
        return true;
      };
      module2.exports = outside;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/gtr.js
  var require_gtr = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/gtr.js"(exports, module2) {
      var outside = require_outside();
      var gtr = (version2, range, options) => outside(version2, range, ">", options);
      module2.exports = gtr;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/ltr.js
  var require_ltr = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/ltr.js"(exports, module2) {
      var outside = require_outside();
      var ltr = (version2, range, options) => outside(version2, range, "<", options);
      module2.exports = ltr;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/intersects.js
  var require_intersects = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/intersects.js"(exports, module2) {
      var Range = require_range();
      var intersects = (r1, r2, options) => {
        r1 = new Range(r1, options);
        r2 = new Range(r2, options);
        return r1.intersects(r2);
      };
      module2.exports = intersects;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/simplify.js
  var require_simplify = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/simplify.js"(exports, module2) {
      var satisfies = require_satisfies();
      var compare = require_compare();
      module2.exports = (versions3, range, options) => {
        const set2 = [];
        let first = null;
        let prev = null;
        const v = versions3.sort((a, b) => compare(a, b, options));
        for (const version2 of v) {
          const included = satisfies(version2, range, options);
          if (included) {
            prev = version2;
            if (!first) {
              first = version2;
            }
          } else {
            if (prev) {
              set2.push([first, prev]);
            }
            prev = null;
            first = null;
          }
        }
        if (first) {
          set2.push([first, null]);
        }
        const ranges = [];
        for (const [min, max2] of set2) {
          if (min === max2) {
            ranges.push(min);
          } else if (!max2 && min === v[0]) {
            ranges.push("*");
          } else if (!max2) {
            ranges.push(`>=${min}`);
          } else if (min === v[0]) {
            ranges.push(`<=${max2}`);
          } else {
            ranges.push(`${min} - ${max2}`);
          }
        }
        const simplified = ranges.join(" || ");
        const original = typeof range.raw === "string" ? range.raw : String(range);
        return simplified.length < original.length ? simplified : range;
      };
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/subset.js
  var require_subset = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/subset.js"(exports, module2) {
      var Range = require_range();
      var Comparator = require_comparator();
      var { ANY } = Comparator;
      var satisfies = require_satisfies();
      var compare = require_compare();
      var subset = (sub, dom, options = {}) => {
        if (sub === dom) {
          return true;
        }
        sub = new Range(sub, options);
        dom = new Range(dom, options);
        let sawNonNull = false;
        OUTER:
          for (const simpleSub of sub.set) {
            for (const simpleDom of dom.set) {
              const isSub = simpleSubset(simpleSub, simpleDom, options);
              sawNonNull = sawNonNull || isSub !== null;
              if (isSub) {
                continue OUTER;
              }
            }
            if (sawNonNull) {
              return false;
            }
          }
        return true;
      };
      var simpleSubset = (sub, dom, options) => {
        if (sub === dom) {
          return true;
        }
        if (sub.length === 1 && sub[0].semver === ANY) {
          if (dom.length === 1 && dom[0].semver === ANY) {
            return true;
          } else if (options.includePrerelease) {
            sub = [new Comparator(">=0.0.0-0")];
          } else {
            sub = [new Comparator(">=0.0.0")];
          }
        }
        if (dom.length === 1 && dom[0].semver === ANY) {
          if (options.includePrerelease) {
            return true;
          } else {
            dom = [new Comparator(">=0.0.0")];
          }
        }
        const eqSet = /* @__PURE__ */ new Set();
        let gt, lt;
        for (const c of sub) {
          if (c.operator === ">" || c.operator === ">=") {
            gt = higherGT(gt, c, options);
          } else if (c.operator === "<" || c.operator === "<=") {
            lt = lowerLT(lt, c, options);
          } else {
            eqSet.add(c.semver);
          }
        }
        if (eqSet.size > 1) {
          return null;
        }
        let gtltComp;
        if (gt && lt) {
          gtltComp = compare(gt.semver, lt.semver, options);
          if (gtltComp > 0) {
            return null;
          } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
            return null;
          }
        }
        for (const eq of eqSet) {
          if (gt && !satisfies(eq, String(gt), options)) {
            return null;
          }
          if (lt && !satisfies(eq, String(lt), options)) {
            return null;
          }
          for (const c of dom) {
            if (!satisfies(eq, String(c), options)) {
              return false;
            }
          }
          return true;
        }
        let higher, lower;
        let hasDomLT, hasDomGT;
        let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
        let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
        if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
          needDomLTPre = false;
        }
        for (const c of dom) {
          hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
          hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
          if (gt) {
            if (needDomGTPre) {
              if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
                needDomGTPre = false;
              }
            }
            if (c.operator === ">" || c.operator === ">=") {
              higher = higherGT(gt, c, options);
              if (higher === c && higher !== gt) {
                return false;
              }
            } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
              return false;
            }
          }
          if (lt) {
            if (needDomLTPre) {
              if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
                needDomLTPre = false;
              }
            }
            if (c.operator === "<" || c.operator === "<=") {
              lower = lowerLT(lt, c, options);
              if (lower === c && lower !== lt) {
                return false;
              }
            } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
              return false;
            }
          }
          if (!c.operator && (lt || gt) && gtltComp !== 0) {
            return false;
          }
        }
        if (gt && hasDomLT && !lt && gtltComp !== 0) {
          return false;
        }
        if (lt && hasDomGT && !gt && gtltComp !== 0) {
          return false;
        }
        if (needDomGTPre || needDomLTPre) {
          return false;
        }
        return true;
      };
      var higherGT = (a, b, options) => {
        if (!a) {
          return b;
        }
        const comp = compare(a.semver, b.semver, options);
        return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
      };
      var lowerLT = (a, b, options) => {
        if (!a) {
          return b;
        }
        const comp = compare(a.semver, b.semver, options);
        return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
      };
      module2.exports = subset;
    }
  });

  // ../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/index.js
  var require_semver2 = __commonJS({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/index.js"(exports, module2) {
      var internalRe = require_re();
      var constants = require_constants();
      var SemVer = require_semver();
      var identifiers = require_identifiers();
      var parse3 = require_parse();
      var valid = require_valid();
      var clean = require_clean();
      var inc = require_inc();
      var diff = require_diff();
      var major = require_major();
      var minor = require_minor();
      var patch = require_patch();
      var prerelease = require_prerelease();
      var compare = require_compare();
      var rcompare = require_rcompare();
      var compareLoose = require_compare_loose();
      var compareBuild = require_compare_build();
      var sort = require_sort();
      var rsort = require_rsort();
      var gt = require_gt();
      var lt = require_lt();
      var eq = require_eq();
      var neq = require_neq();
      var gte = require_gte();
      var lte = require_lte();
      var cmp = require_cmp();
      var coerce = require_coerce();
      var Comparator = require_comparator();
      var Range = require_range();
      var satisfies = require_satisfies();
      var toComparators = require_to_comparators();
      var maxSatisfying = require_max_satisfying();
      var minSatisfying = require_min_satisfying();
      var minVersion = require_min_version();
      var validRange = require_valid2();
      var outside = require_outside();
      var gtr = require_gtr();
      var ltr = require_ltr();
      var intersects = require_intersects();
      var simplifyRange = require_simplify();
      var subset = require_subset();
      module2.exports = {
        parse: parse3,
        valid,
        clean,
        inc,
        diff,
        major,
        minor,
        patch,
        prerelease,
        compare,
        rcompare,
        compareLoose,
        compareBuild,
        sort,
        rsort,
        gt,
        lt,
        eq,
        neq,
        gte,
        lte,
        cmp,
        coerce,
        Comparator,
        Range,
        satisfies,
        toComparators,
        maxSatisfying,
        minSatisfying,
        minVersion,
        validRange,
        outside,
        gtr,
        ltr,
        intersects,
        simplifyRange,
        subset,
        SemVer,
        re: internalRe.re,
        src: internalRe.src,
        tokens: internalRe.t,
        SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
        compareIdentifiers: identifiers.compareIdentifiers,
        rcompareIdentifiers: identifiers.rcompareIdentifiers
      };
    }
  });

  // ../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/error.js
  var require_error = __commonJS({
    "../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/error.js"(exports) {
      var CommanderError2 = class extends Error {
        /**
         * Constructs the CommanderError class
         * @param {number} exitCode suggested exit code which could be used with process.exit
         * @param {string} code an id string representing the error
         * @param {string} message human-readable description of the error
         * @constructor
         */
        constructor(exitCode, code, message) {
          super(message);
          Error.captureStackTrace(this, this.constructor);
          this.name = this.constructor.name;
          this.code = code;
          this.exitCode = exitCode;
          this.nestedError = void 0;
        }
      };
      var InvalidArgumentError2 = class extends CommanderError2 {
        /**
         * Constructs the InvalidArgumentError class
         * @param {string} [message] explanation of why argument is invalid
         * @constructor
         */
        constructor(message) {
          super(1, "commander.invalidArgument", message);
          Error.captureStackTrace(this, this.constructor);
          this.name = this.constructor.name;
        }
      };
      exports.CommanderError = CommanderError2;
      exports.InvalidArgumentError = InvalidArgumentError2;
    }
  });

  // ../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/argument.js
  var require_argument = __commonJS({
    "../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/argument.js"(exports) {
      var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
      var Argument2 = class {
        /**
         * Initialize a new command argument with the given name and description.
         * The default is that the argument is required, and you can explicitly
         * indicate this with <> around the name. Put [] around the name for an optional argument.
         *
         * @param {string} name
         * @param {string} [description]
         */
        constructor(name, description) {
          this.description = description || "";
          this.variadic = false;
          this.parseArg = void 0;
          this.defaultValue = void 0;
          this.defaultValueDescription = void 0;
          this.argChoices = void 0;
          switch (name[0]) {
            case "<":
              this.required = true;
              this._name = name.slice(1, -1);
              break;
            case "[":
              this.required = false;
              this._name = name.slice(1, -1);
              break;
            default:
              this.required = true;
              this._name = name;
              break;
          }
          if (this._name.length > 3 && this._name.slice(-3) === "...") {
            this.variadic = true;
            this._name = this._name.slice(0, -3);
          }
        }
        /**
         * Return argument name.
         *
         * @return {string}
         */
        name() {
          return this._name;
        }
        /**
         * @api private
         */
        _concatValue(value, previous) {
          if (previous === this.defaultValue || !Array.isArray(previous)) {
            return [value];
          }
          return previous.concat(value);
        }
        /**
         * Set the default value, and optionally supply the description to be displayed in the help.
         *
         * @param {any} value
         * @param {string} [description]
         * @return {Argument}
         */
        default(value, description) {
          this.defaultValue = value;
          this.defaultValueDescription = description;
          return this;
        }
        /**
         * Set the custom handler for processing CLI command arguments into argument values.
         *
         * @param {Function} [fn]
         * @return {Argument}
         */
        argParser(fn) {
          this.parseArg = fn;
          return this;
        }
        /**
         * Only allow argument value to be one of choices.
         *
         * @param {string[]} values
         * @return {Argument}
         */
        choices(values) {
          this.argChoices = values.slice();
          this.parseArg = (arg, previous) => {
            if (!this.argChoices.includes(arg)) {
              throw new InvalidArgumentError2(`Allowed choices are ${this.argChoices.join(", ")}.`);
            }
            if (this.variadic) {
              return this._concatValue(arg, previous);
            }
            return arg;
          };
          return this;
        }
        /**
         * Make argument required.
         */
        argRequired() {
          this.required = true;
          return this;
        }
        /**
         * Make argument optional.
         */
        argOptional() {
          this.required = false;
          return this;
        }
      };
      function humanReadableArgName(arg) {
        const nameOutput = arg.name() + (arg.variadic === true ? "..." : "");
        return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
      }
      exports.Argument = Argument2;
      exports.humanReadableArgName = humanReadableArgName;
    }
  });

  // ../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/help.js
  var require_help = __commonJS({
    "../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/help.js"(exports) {
      var { humanReadableArgName } = require_argument();
      var Help2 = class {
        constructor() {
          this.helpWidth = void 0;
          this.sortSubcommands = false;
          this.sortOptions = false;
        }
        /**
         * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.
         *
         * @param {Command} cmd
         * @returns {Command[]}
         */
        visibleCommands(cmd) {
          const visibleCommands = cmd.commands.filter((cmd2) => !cmd2._hidden);
          if (cmd._hasImplicitHelpCommand()) {
            const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);
            const helpCommand = cmd.createCommand(helpName).helpOption(false);
            helpCommand.description(cmd._helpCommandDescription);
            if (helpArgs)
              helpCommand.arguments(helpArgs);
            visibleCommands.push(helpCommand);
          }
          if (this.sortSubcommands) {
            visibleCommands.sort((a, b) => {
              return a.name().localeCompare(b.name());
            });
          }
          return visibleCommands;
        }
        /**
         * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.
         *
         * @param {Command} cmd
         * @returns {Option[]}
         */
        visibleOptions(cmd) {
          const visibleOptions = cmd.options.filter((option) => !option.hidden);
          const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);
          const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);
          if (showShortHelpFlag || showLongHelpFlag) {
            let helpOption;
            if (!showShortHelpFlag) {
              helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);
            } else if (!showLongHelpFlag) {
              helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);
            } else {
              helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);
            }
            visibleOptions.push(helpOption);
          }
          if (this.sortOptions) {
            const getSortKey = (option) => {
              return option.short ? option.short.replace(/^-/, "") : option.long.replace(/^--/, "");
            };
            visibleOptions.sort((a, b) => {
              return getSortKey(a).localeCompare(getSortKey(b));
            });
          }
          return visibleOptions;
        }
        /**
         * Get an array of the arguments if any have a description.
         *
         * @param {Command} cmd
         * @returns {Argument[]}
         */
        visibleArguments(cmd) {
          if (cmd._argsDescription) {
            cmd._args.forEach((argument) => {
              argument.description = argument.description || cmd._argsDescription[argument.name()] || "";
            });
          }
          if (cmd._args.find((argument) => argument.description)) {
            return cmd._args;
          }
          return [];
        }
        /**
         * Get the command term to show in the list of subcommands.
         *
         * @param {Command} cmd
         * @returns {string}
         */
        subcommandTerm(cmd) {
          const args = cmd._args.map((arg) => humanReadableArgName(arg)).join(" ");
          return cmd._name + (cmd._aliases[0] ? "|" + cmd._aliases[0] : "") + (cmd.options.length ? " [options]" : "") + // simplistic check for non-help option
          (args ? " " + args : "");
        }
        /**
         * Get the option term to show in the list of options.
         *
         * @param {Option} option
         * @returns {string}
         */
        optionTerm(option) {
          return option.flags;
        }
        /**
         * Get the argument term to show in the list of arguments.
         *
         * @param {Argument} argument
         * @returns {string}
         */
        argumentTerm(argument) {
          return argument.name();
        }
        /**
         * Get the longest command term length.
         *
         * @param {Command} cmd
         * @param {Help} helper
         * @returns {number}
         */
        longestSubcommandTermLength(cmd, helper) {
          return helper.visibleCommands(cmd).reduce((max2, command) => {
            return Math.max(max2, helper.subcommandTerm(command).length);
          }, 0);
        }
        /**
         * Get the longest option term length.
         *
         * @param {Command} cmd
         * @param {Help} helper
         * @returns {number}
         */
        longestOptionTermLength(cmd, helper) {
          return helper.visibleOptions(cmd).reduce((max2, option) => {
            return Math.max(max2, helper.optionTerm(option).length);
          }, 0);
        }
        /**
         * Get the longest argument term length.
         *
         * @param {Command} cmd
         * @param {Help} helper
         * @returns {number}
         */
        longestArgumentTermLength(cmd, helper) {
          return helper.visibleArguments(cmd).reduce((max2, argument) => {
            return Math.max(max2, helper.argumentTerm(argument).length);
          }, 0);
        }
        /**
         * Get the command usage to be displayed at the top of the built-in help.
         *
         * @param {Command} cmd
         * @returns {string}
         */
        commandUsage(cmd) {
          let cmdName = cmd._name;
          if (cmd._aliases[0]) {
            cmdName = cmdName + "|" + cmd._aliases[0];
          }
          let parentCmdNames = "";
          for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {
            parentCmdNames = parentCmd.name() + " " + parentCmdNames;
          }
          return parentCmdNames + cmdName + " " + cmd.usage();
        }
        /**
         * Get the description for the command.
         *
         * @param {Command} cmd
         * @returns {string}
         */
        commandDescription(cmd) {
          return cmd.description();
        }
        /**
         * Get the subcommand summary to show in the list of subcommands.
         * (Fallback to description for backwards compatiblity.)
         *
         * @param {Command} cmd
         * @returns {string}
         */
        subcommandDescription(cmd) {
          return cmd.summary() || cmd.description();
        }
        /**
         * Get the option description to show in the list of options.
         *
         * @param {Option} option
         * @return {string}
         */
        optionDescription(option) {
          const extraInfo = [];
          if (option.argChoices) {
            extraInfo.push(
              // use stringify to match the display of the default value
              `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
            );
          }
          if (option.defaultValue !== void 0) {
            const showDefault = option.required || option.optional || option.isBoolean() && typeof option.defaultValue === "boolean";
            if (showDefault) {
              extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);
            }
          }
          if (option.presetArg !== void 0 && option.optional) {
            extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);
          }
          if (option.envVar !== void 0) {
            extraInfo.push(`env: ${option.envVar}`);
          }
          if (extraInfo.length > 0) {
            return `${option.description} (${extraInfo.join(", ")})`;
          }
          return option.description;
        }
        /**
         * Get the argument description to show in the list of arguments.
         *
         * @param {Argument} argument
         * @return {string}
         */
        argumentDescription(argument) {
          const extraInfo = [];
          if (argument.argChoices) {
            extraInfo.push(
              // use stringify to match the display of the default value
              `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`
            );
          }
          if (argument.defaultValue !== void 0) {
            extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);
          }
          if (extraInfo.length > 0) {
            const extraDescripton = `(${extraInfo.join(", ")})`;
            if (argument.description) {
              return `${argument.description} ${extraDescripton}`;
            }
            return extraDescripton;
          }
          return argument.description;
        }
        /**
         * Generate the built-in help text.
         *
         * @param {Command} cmd
         * @param {Help} helper
         * @returns {string}
         */
        formatHelp(cmd, helper) {
          const termWidth = helper.padWidth(cmd, helper);
          const helpWidth = helper.helpWidth || 80;
          const itemIndentWidth = 2;
          const itemSeparatorWidth = 2;
          function formatItem(term, description) {
            if (description) {
              const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
              return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);
            }
            return term;
          }
          function formatList(textArray) {
            return textArray.join("\n").replace(/^/gm, " ".repeat(itemIndentWidth));
          }
          let output3 = [`Usage: ${helper.commandUsage(cmd)}`, ""];
          const commandDescription = helper.commandDescription(cmd);
          if (commandDescription.length > 0) {
            output3 = output3.concat([commandDescription, ""]);
          }
          const argumentList = helper.visibleArguments(cmd).map((argument) => {
            return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));
          });
          if (argumentList.length > 0) {
            output3 = output3.concat(["Arguments:", formatList(argumentList), ""]);
          }
          const optionList = helper.visibleOptions(cmd).map((option) => {
            return formatItem(helper.optionTerm(option), helper.optionDescription(option));
          });
          if (optionList.length > 0) {
            output3 = output3.concat(["Options:", formatList(optionList), ""]);
          }
          const commandList = helper.visibleCommands(cmd).map((cmd2) => {
            return formatItem(helper.subcommandTerm(cmd2), helper.subcommandDescription(cmd2));
          });
          if (commandList.length > 0) {
            output3 = output3.concat(["Commands:", formatList(commandList), ""]);
          }
          return output3.join("\n");
        }
        /**
         * Calculate the pad width from the maximum term length.
         *
         * @param {Command} cmd
         * @param {Help} helper
         * @returns {number}
         */
        padWidth(cmd, helper) {
          return Math.max(
            helper.longestOptionTermLength(cmd, helper),
            helper.longestSubcommandTermLength(cmd, helper),
            helper.longestArgumentTermLength(cmd, helper)
          );
        }
        /**
         * Wrap the given string to width characters per line, with lines after the first indented.
         * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.
         *
         * @param {string} str
         * @param {number} width
         * @param {number} indent
         * @param {number} [minColumnWidth=40]
         * @return {string}
         *
         */
        wrap(str, width, indent, minColumnWidth = 40) {
          if (str.match(/[\n]\s+/))
            return str;
          const columnWidth = width - indent;
          if (columnWidth < minColumnWidth)
            return str;
          const leadingStr = str.slice(0, indent);
          const columnText = str.slice(indent);
          const indentString = " ".repeat(indent);
          const regex = new RegExp(".{1," + (columnWidth - 1) + "}([\\s\u200B]|$)|[^\\s\u200B]+?([\\s\u200B]|$)", "g");
          const lines = columnText.match(regex) || [];
          return leadingStr + lines.map((line, i) => {
            if (line.slice(-1) === "\n") {
              line = line.slice(0, line.length - 1);
            }
            return (i > 0 ? indentString : "") + line.trimRight();
          }).join("\n");
        }
      };
      exports.Help = Help2;
    }
  });

  // ../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/option.js
  var require_option = __commonJS({
    "../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/option.js"(exports) {
      var { InvalidArgumentError: InvalidArgumentError2 } = require_error();
      var Option2 = class {
        /**
         * Initialize a new `Option` with the given `flags` and `description`.
         *
         * @param {string} flags
         * @param {string} [description]
         */
        constructor(flags, description) {
          this.flags = flags;
          this.description = description || "";
          this.required = flags.includes("<");
          this.optional = flags.includes("[");
          this.variadic = /\w\.\.\.[>\]]$/.test(flags);
          this.mandatory = false;
          const optionFlags = splitOptionFlags(flags);
          this.short = optionFlags.shortFlag;
          this.long = optionFlags.longFlag;
          this.negate = false;
          if (this.long) {
            this.negate = this.long.startsWith("--no-");
          }
          this.defaultValue = void 0;
          this.defaultValueDescription = void 0;
          this.presetArg = void 0;
          this.envVar = void 0;
          this.parseArg = void 0;
          this.hidden = false;
          this.argChoices = void 0;
          this.conflictsWith = [];
          this.implied = void 0;
        }
        /**
         * Set the default value, and optionally supply the description to be displayed in the help.
         *
         * @param {any} value
         * @param {string} [description]
         * @return {Option}
         */
        default(value, description) {
          this.defaultValue = value;
          this.defaultValueDescription = description;
          return this;
        }
        /**
         * Preset to use when option used without option-argument, especially optional but also boolean and negated.
         * The custom processing (parseArg) is called.
         *
         * @example
         * new Option('--color').default('GREYSCALE').preset('RGB');
         * new Option('--donate [amount]').preset('20').argParser(parseFloat);
         *
         * @param {any} arg
         * @return {Option}
         */
        preset(arg) {
          this.presetArg = arg;
          return this;
        }
        /**
         * Add option name(s) that conflict with this option.
         * An error will be displayed if conflicting options are found during parsing.
         *
         * @example
         * new Option('--rgb').conflicts('cmyk');
         * new Option('--js').conflicts(['ts', 'jsx']);
         *
         * @param {string | string[]} names
         * @return {Option}
         */
        conflicts(names) {
          this.conflictsWith = this.conflictsWith.concat(names);
          return this;
        }
        /**
         * Specify implied option values for when this option is set and the implied options are not.
         *
         * The custom processing (parseArg) is not called on the implied values.
         *
         * @example
         * program
         *   .addOption(new Option('--log', 'write logging information to file'))
         *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));
         *
         * @param {Object} impliedOptionValues
         * @return {Option}
         */
        implies(impliedOptionValues) {
          this.implied = Object.assign(this.implied || {}, impliedOptionValues);
          return this;
        }
        /**
         * Set environment variable to check for option value.
         *
         * An environment variable is only used if when processed the current option value is
         * undefined, or the source of the current value is 'default' or 'config' or 'env'.
         *
         * @param {string} name
         * @return {Option}
         */
        env(name) {
          this.envVar = name;
          return this;
        }
        /**
         * Set the custom handler for processing CLI option arguments into option values.
         *
         * @param {Function} [fn]
         * @return {Option}
         */
        argParser(fn) {
          this.parseArg = fn;
          return this;
        }
        /**
         * Whether the option is mandatory and must have a value after parsing.
         *
         * @param {boolean} [mandatory=true]
         * @return {Option}
         */
        makeOptionMandatory(mandatory = true) {
          this.mandatory = !!mandatory;
          return this;
        }
        /**
         * Hide option in help.
         *
         * @param {boolean} [hide=true]
         * @return {Option}
         */
        hideHelp(hide = true) {
          this.hidden = !!hide;
          return this;
        }
        /**
         * @api private
         */
        _concatValue(value, previous) {
          if (previous === this.defaultValue || !Array.isArray(previous)) {
            return [value];
          }
          return previous.concat(value);
        }
        /**
         * Only allow option value to be one of choices.
         *
         * @param {string[]} values
         * @return {Option}
         */
        choices(values) {
          this.argChoices = values.slice();
          this.parseArg = (arg, previous) => {
            if (!this.argChoices.includes(arg)) {
              throw new InvalidArgumentError2(`Allowed choices are ${this.argChoices.join(", ")}.`);
            }
            if (this.variadic) {
              return this._concatValue(arg, previous);
            }
            return arg;
          };
          return this;
        }
        /**
         * Return option name.
         *
         * @return {string}
         */
        name() {
          if (this.long) {
            return this.long.replace(/^--/, "");
          }
          return this.short.replace(/^-/, "");
        }
        /**
         * Return option name, in a camelcase format that can be used
         * as a object attribute key.
         *
         * @return {string}
         * @api private
         */
        attributeName() {
          return camelcase(this.name().replace(/^no-/, ""));
        }
        /**
         * Check if `arg` matches the short or long flag.
         *
         * @param {string} arg
         * @return {boolean}
         * @api private
         */
        is(arg) {
          return this.short === arg || this.long === arg;
        }
        /**
         * Return whether a boolean option.
         *
         * Options are one of boolean, negated, required argument, or optional argument.
         *
         * @return {boolean}
         * @api private
         */
        isBoolean() {
          return !this.required && !this.optional && !this.negate;
        }
      };
      var DualOptions = class {
        /**
         * @param {Option[]} options
         */
        constructor(options) {
          this.positiveOptions = /* @__PURE__ */ new Map();
          this.negativeOptions = /* @__PURE__ */ new Map();
          this.dualOptions = /* @__PURE__ */ new Set();
          options.forEach((option) => {
            if (option.negate) {
              this.negativeOptions.set(option.attributeName(), option);
            } else {
              this.positiveOptions.set(option.attributeName(), option);
            }
          });
          this.negativeOptions.forEach((value, key) => {
            if (this.positiveOptions.has(key)) {
              this.dualOptions.add(key);
            }
          });
        }
        /**
         * Did the value come from the option, and not from possible matching dual option?
         *
         * @param {any} value
         * @param {Option} option
         * @returns {boolean}
         */
        valueFromOption(value, option) {
          const optionKey = option.attributeName();
          if (!this.dualOptions.has(optionKey))
            return true;
          const preset = this.negativeOptions.get(optionKey).presetArg;
          const negativeValue = preset !== void 0 ? preset : false;
          return option.negate === (negativeValue === value);
        }
      };
      function camelcase(str) {
        return str.split("-").reduce((str2, word) => {
          return str2 + word[0].toUpperCase() + word.slice(1);
        });
      }
      function splitOptionFlags(flags) {
        let shortFlag;
        let longFlag;
        const flagParts = flags.split(/[ |,]+/);
        if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1]))
          shortFlag = flagParts.shift();
        longFlag = flagParts.shift();
        if (!shortFlag && /^-[^-]$/.test(longFlag)) {
          shortFlag = longFlag;
          longFlag = void 0;
        }
        return { shortFlag, longFlag };
      }
      exports.Option = Option2;
      exports.splitOptionFlags = splitOptionFlags;
      exports.DualOptions = DualOptions;
    }
  });

  // ../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/suggestSimilar.js
  var require_suggestSimilar = __commonJS({
    "../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/suggestSimilar.js"(exports) {
      var maxDistance = 3;
      function editDistance(a, b) {
        if (Math.abs(a.length - b.length) > maxDistance)
          return Math.max(a.length, b.length);
        const d = [];
        for (let i = 0; i <= a.length; i++) {
          d[i] = [i];
        }
        for (let j = 0; j <= b.length; j++) {
          d[0][j] = j;
        }
        for (let j = 1; j <= b.length; j++) {
          for (let i = 1; i <= a.length; i++) {
            let cost = 1;
            if (a[i - 1] === b[j - 1]) {
              cost = 0;
            } else {
              cost = 1;
            }
            d[i][j] = Math.min(
              d[i - 1][j] + 1,
              // deletion
              d[i][j - 1] + 1,
              // insertion
              d[i - 1][j - 1] + cost
              // substitution
            );
            if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
              d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
            }
          }
        }
        return d[a.length][b.length];
      }
      function suggestSimilar(word, candidates) {
        if (!candidates || candidates.length === 0)
          return "";
        candidates = Array.from(new Set(candidates));
        const searchingOptions = word.startsWith("--");
        if (searchingOptions) {
          word = word.slice(2);
          candidates = candidates.map((candidate) => candidate.slice(2));
        }
        let similar = [];
        let bestDistance = maxDistance;
        const minSimilarity = 0.4;
        candidates.forEach((candidate) => {
          if (candidate.length <= 1)
            return;
          const distance = editDistance(word, candidate);
          const length = Math.max(word.length, candidate.length);
          const similarity = (length - distance) / length;
          if (similarity > minSimilarity) {
            if (distance < bestDistance) {
              bestDistance = distance;
              similar = [candidate];
            } else if (distance === bestDistance) {
              similar.push(candidate);
            }
          }
        });
        similar.sort((a, b) => a.localeCompare(b));
        if (searchingOptions) {
          similar = similar.map((candidate) => `--${candidate}`);
        }
        if (similar.length > 1) {
          return `
(Did you mean one of ${similar.join(", ")}?)`;
        }
        if (similar.length === 1) {
          return `
(Did you mean ${similar[0]}?)`;
        }
        return "";
      }
      exports.suggestSimilar = suggestSimilar;
    }
  });

  // ../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/command.js
  var require_command = __commonJS({
    "../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/lib/command.js"(exports) {
      var EventEmitter = __require2("events").EventEmitter;
      var childProcess = __require2("child_process");
      var path4 = __require2("path");
      var fs4 = __require2("fs");
      var process2 = __require2("process");
      var { Argument: Argument2, humanReadableArgName } = require_argument();
      var { CommanderError: CommanderError2 } = require_error();
      var { Help: Help2 } = require_help();
      var { Option: Option2, splitOptionFlags, DualOptions } = require_option();
      var { suggestSimilar } = require_suggestSimilar();
      var Command2 = class extends EventEmitter {
        /**
         * Initialize a new `Command`.
         *
         * @param {string} [name]
         */
        constructor(name) {
          super();
          this.commands = [];
          this.options = [];
          this.parent = null;
          this._allowUnknownOption = false;
          this._allowExcessArguments = true;
          this._args = [];
          this.args = [];
          this.rawArgs = [];
          this.processedArgs = [];
          this._scriptPath = null;
          this._name = name || "";
          this._optionValues = {};
          this._optionValueSources = {};
          this._storeOptionsAsProperties = false;
          this._actionHandler = null;
          this._executableHandler = false;
          this._executableFile = null;
          this._executableDir = null;
          this._defaultCommandName = null;
          this._exitCallback = null;
          this._aliases = [];
          this._combineFlagAndOptionalValue = true;
          this._description = "";
          this._summary = "";
          this._argsDescription = void 0;
          this._enablePositionalOptions = false;
          this._passThroughOptions = false;
          this._lifeCycleHooks = {};
          this._showHelpAfterError = false;
          this._showSuggestionAfterError = true;
          this._outputConfiguration = {
            writeOut: (str) => process2.stdout.write(str),
            writeErr: (str) => process2.stderr.write(str),
            getOutHelpWidth: () => process2.stdout.isTTY ? process2.stdout.columns : void 0,
            getErrHelpWidth: () => process2.stderr.isTTY ? process2.stderr.columns : void 0,
            outputError: (str, write) => write(str)
          };
          this._hidden = false;
          this._hasHelpOption = true;
          this._helpFlags = "-h, --help";
          this._helpDescription = "display help for command";
          this._helpShortFlag = "-h";
          this._helpLongFlag = "--help";
          this._addImplicitHelpCommand = void 0;
          this._helpCommandName = "help";
          this._helpCommandnameAndArgs = "help [command]";
          this._helpCommandDescription = "display help for command";
          this._helpConfiguration = {};
        }
        /**
         * Copy settings that are useful to have in common across root command and subcommands.
         *
         * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)
         *
         * @param {Command} sourceCommand
         * @return {Command} `this` command for chaining
         */
        copyInheritedSettings(sourceCommand) {
          this._outputConfiguration = sourceCommand._outputConfiguration;
          this._hasHelpOption = sourceCommand._hasHelpOption;
          this._helpFlags = sourceCommand._helpFlags;
          this._helpDescription = sourceCommand._helpDescription;
          this._helpShortFlag = sourceCommand._helpShortFlag;
          this._helpLongFlag = sourceCommand._helpLongFlag;
          this._helpCommandName = sourceCommand._helpCommandName;
          this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;
          this._helpCommandDescription = sourceCommand._helpCommandDescription;
          this._helpConfiguration = sourceCommand._helpConfiguration;
          this._exitCallback = sourceCommand._exitCallback;
          this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
          this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
          this._allowExcessArguments = sourceCommand._allowExcessArguments;
          this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
          this._showHelpAfterError = sourceCommand._showHelpAfterError;
          this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
          return this;
        }
        /**
         * Define a command.
         *
         * There are two styles of command: pay attention to where to put the description.
         *
         * @example
         * // Command implemented using action handler (description is supplied separately to `.command`)
         * program
         *   .command('clone <source> [destination]')
         *   .description('clone a repository into a newly created directory')
         *   .action((source, destination) => {
         *     console.log('clone command called');
         *   });
         *
         * // Command implemented using separate executable file (description is second parameter to `.command`)
         * program
         *   .command('start <service>', 'start named service')
         *   .command('stop [service]', 'stop named service, or all if no name supplied');
         *
         * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`
         * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)
         * @param {Object} [execOpts] - configuration options (for executable)
         * @return {Command} returns new command for action handler, or `this` for executable command
         */
        command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
          let desc = actionOptsOrExecDesc;
          let opts = execOpts;
          if (typeof desc === "object" && desc !== null) {
            opts = desc;
            desc = null;
          }
          opts = opts || {};
          const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
          const cmd = this.createCommand(name);
          if (desc) {
            cmd.description(desc);
            cmd._executableHandler = true;
          }
          if (opts.isDefault)
            this._defaultCommandName = cmd._name;
          cmd._hidden = !!(opts.noHelp || opts.hidden);
          cmd._executableFile = opts.executableFile || null;
          if (args)
            cmd.arguments(args);
          this.commands.push(cmd);
          cmd.parent = this;
          cmd.copyInheritedSettings(this);
          if (desc)
            return this;
          return cmd;
        }
        /**
         * Factory routine to create a new unattached command.
         *
         * See .command() for creating an attached subcommand, which uses this routine to
         * create the command. You can override createCommand to customise subcommands.
         *
         * @param {string} [name]
         * @return {Command} new command
         */
        createCommand(name) {
          return new Command2(name);
        }
        /**
         * You can customise the help with a subclass of Help by overriding createHelp,
         * or by overriding Help properties using configureHelp().
         *
         * @return {Help}
         */
        createHelp() {
          return Object.assign(new Help2(), this.configureHelp());
        }
        /**
         * You can customise the help by overriding Help properties using configureHelp(),
         * or with a subclass of Help by overriding createHelp().
         *
         * @param {Object} [configuration] - configuration options
         * @return {Command|Object} `this` command for chaining, or stored configuration
         */
        configureHelp(configuration) {
          if (configuration === void 0)
            return this._helpConfiguration;
          this._helpConfiguration = configuration;
          return this;
        }
        /**
         * The default output goes to stdout and stderr. You can customise this for special
         * applications. You can also customise the display of errors by overriding outputError.
         *
         * The configuration properties are all functions:
         *
         *     // functions to change where being written, stdout and stderr
         *     writeOut(str)
         *     writeErr(str)
         *     // matching functions to specify width for wrapping help
         *     getOutHelpWidth()
         *     getErrHelpWidth()
         *     // functions based on what is being written out
         *     outputError(str, write) // used for displaying errors, and not used for displaying help
         *
         * @param {Object} [configuration] - configuration options
         * @return {Command|Object} `this` command for chaining, or stored configuration
         */
        configureOutput(configuration) {
          if (configuration === void 0)
            return this._outputConfiguration;
          Object.assign(this._outputConfiguration, configuration);
          return this;
        }
        /**
         * Display the help or a custom message after an error occurs.
         *
         * @param {boolean|string} [displayHelp]
         * @return {Command} `this` command for chaining
         */
        showHelpAfterError(displayHelp = true) {
          if (typeof displayHelp !== "string")
            displayHelp = !!displayHelp;
          this._showHelpAfterError = displayHelp;
          return this;
        }
        /**
         * Display suggestion of similar commands for unknown commands, or options for unknown options.
         *
         * @param {boolean} [displaySuggestion]
         * @return {Command} `this` command for chaining
         */
        showSuggestionAfterError(displaySuggestion = true) {
          this._showSuggestionAfterError = !!displaySuggestion;
          return this;
        }
        /**
         * Add a prepared subcommand.
         *
         * See .command() for creating an attached subcommand which inherits settings from its parent.
         *
         * @param {Command} cmd - new subcommand
         * @param {Object} [opts] - configuration options
         * @return {Command} `this` command for chaining
         */
        addCommand(cmd, opts) {
          if (!cmd._name) {
            throw new Error(`Command passed to .addCommand() must have a name
- specify the name in Command constructor or using .name()`);
          }
          opts = opts || {};
          if (opts.isDefault)
            this._defaultCommandName = cmd._name;
          if (opts.noHelp || opts.hidden)
            cmd._hidden = true;
          this.commands.push(cmd);
          cmd.parent = this;
          return this;
        }
        /**
         * Factory routine to create a new unattached argument.
         *
         * See .argument() for creating an attached argument, which uses this routine to
         * create the argument. You can override createArgument to return a custom argument.
         *
         * @param {string} name
         * @param {string} [description]
         * @return {Argument} new argument
         */
        createArgument(name, description) {
          return new Argument2(name, description);
        }
        /**
         * Define argument syntax for command.
         *
         * The default is that the argument is required, and you can explicitly
         * indicate this with <> around the name. Put [] around the name for an optional argument.
         *
         * @example
         * program.argument('<input-file>');
         * program.argument('[output-file]');
         *
         * @param {string} name
         * @param {string} [description]
         * @param {Function|*} [fn] - custom argument processing function
         * @param {*} [defaultValue]
         * @return {Command} `this` command for chaining
         */
        argument(name, description, fn, defaultValue) {
          const argument = this.createArgument(name, description);
          if (typeof fn === "function") {
            argument.default(defaultValue).argParser(fn);
          } else {
            argument.default(fn);
          }
          this.addArgument(argument);
          return this;
        }
        /**
         * Define argument syntax for command, adding multiple at once (without descriptions).
         *
         * See also .argument().
         *
         * @example
         * program.arguments('<cmd> [env]');
         *
         * @param {string} names
         * @return {Command} `this` command for chaining
         */
        arguments(names) {
          names.split(/ +/).forEach((detail) => {
            this.argument(detail);
          });
          return this;
        }
        /**
         * Define argument syntax for command, adding a prepared argument.
         *
         * @param {Argument} argument
         * @return {Command} `this` command for chaining
         */
        addArgument(argument) {
          const previousArgument = this._args.slice(-1)[0];
          if (previousArgument && previousArgument.variadic) {
            throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
          }
          if (argument.required && argument.defaultValue !== void 0 && argument.parseArg === void 0) {
            throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);
          }
          this._args.push(argument);
          return this;
        }
        /**
         * Override default decision whether to add implicit help command.
         *
         *    addHelpCommand() // force on
         *    addHelpCommand(false); // force off
         *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details
         *
         * @return {Command} `this` command for chaining
         */
        addHelpCommand(enableOrNameAndArgs, description) {
          if (enableOrNameAndArgs === false) {
            this._addImplicitHelpCommand = false;
          } else {
            this._addImplicitHelpCommand = true;
            if (typeof enableOrNameAndArgs === "string") {
              this._helpCommandName = enableOrNameAndArgs.split(" ")[0];
              this._helpCommandnameAndArgs = enableOrNameAndArgs;
            }
            this._helpCommandDescription = description || this._helpCommandDescription;
          }
          return this;
        }
        /**
         * @return {boolean}
         * @api private
         */
        _hasImplicitHelpCommand() {
          if (this._addImplicitHelpCommand === void 0) {
            return this.commands.length && !this._actionHandler && !this._findCommand("help");
          }
          return this._addImplicitHelpCommand;
        }
        /**
         * Add hook for life cycle event.
         *
         * @param {string} event
         * @param {Function} listener
         * @return {Command} `this` command for chaining
         */
        hook(event, listener) {
          const allowedValues = ["preSubcommand", "preAction", "postAction"];
          if (!allowedValues.includes(event)) {
            throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
          }
          if (this._lifeCycleHooks[event]) {
            this._lifeCycleHooks[event].push(listener);
          } else {
            this._lifeCycleHooks[event] = [listener];
          }
          return this;
        }
        /**
         * Register callback to use as replacement for calling process.exit.
         *
         * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing
         * @return {Command} `this` command for chaining
         */
        exitOverride(fn) {
          if (fn) {
            this._exitCallback = fn;
          } else {
            this._exitCallback = (err) => {
              if (err.code !== "commander.executeSubCommandAsync") {
                throw err;
              } else {
              }
            };
          }
          return this;
        }
        /**
         * Call process.exit, and _exitCallback if defined.
         *
         * @param {number} exitCode exit code for using with process.exit
         * @param {string} code an id string representing the error
         * @param {string} message human-readable description of the error
         * @return never
         * @api private
         */
        _exit(exitCode, code, message) {
          if (this._exitCallback) {
            this._exitCallback(new CommanderError2(exitCode, code, message));
          }
          process2.exit(exitCode);
        }
        /**
         * Register callback `fn` for the command.
         *
         * @example
         * program
         *   .command('serve')
         *   .description('start service')
         *   .action(function() {
         *      // do work here
         *   });
         *
         * @param {Function} fn
         * @return {Command} `this` command for chaining
         */
        action(fn) {
          const listener = (args) => {
            const expectedArgsCount = this._args.length;
            const actionArgs = args.slice(0, expectedArgsCount);
            if (this._storeOptionsAsProperties) {
              actionArgs[expectedArgsCount] = this;
            } else {
              actionArgs[expectedArgsCount] = this.opts();
            }
            actionArgs.push(this);
            return fn.apply(this, actionArgs);
          };
          this._actionHandler = listener;
          return this;
        }
        /**
         * Factory routine to create a new unattached option.
         *
         * See .option() for creating an attached option, which uses this routine to
         * create the option. You can override createOption to return a custom option.
         *
         * @param {string} flags
         * @param {string} [description]
         * @return {Option} new option
         */
        createOption(flags, description) {
          return new Option2(flags, description);
        }
        /**
         * Add an option.
         *
         * @param {Option} option
         * @return {Command} `this` command for chaining
         */
        addOption(option) {
          const oname = option.name();
          const name = option.attributeName();
          if (option.negate) {
            const positiveLongFlag = option.long.replace(/^--no-/, "--");
            if (!this._findOption(positiveLongFlag)) {
              this.setOptionValueWithSource(name, option.defaultValue === void 0 ? true : option.defaultValue, "default");
            }
          } else if (option.defaultValue !== void 0) {
            this.setOptionValueWithSource(name, option.defaultValue, "default");
          }
          this.options.push(option);
          const handleOptionValue = (val, invalidValueMessage, valueSource) => {
            if (val == null && option.presetArg !== void 0) {
              val = option.presetArg;
            }
            const oldValue = this.getOptionValue(name);
            if (val !== null && option.parseArg) {
              try {
                val = option.parseArg(val, oldValue);
              } catch (err) {
                if (err.code === "commander.invalidArgument") {
                  const message = `${invalidValueMessage} ${err.message}`;
                  this.error(message, { exitCode: err.exitCode, code: err.code });
                }
                throw err;
              }
            } else if (val !== null && option.variadic) {
              val = option._concatValue(val, oldValue);
            }
            if (val == null) {
              if (option.negate) {
                val = false;
              } else if (option.isBoolean() || option.optional) {
                val = true;
              } else {
                val = "";
              }
            }
            this.setOptionValueWithSource(name, val, valueSource);
          };
          this.on("option:" + oname, (val) => {
            const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
            handleOptionValue(val, invalidValueMessage, "cli");
          });
          if (option.envVar) {
            this.on("optionEnv:" + oname, (val) => {
              const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
              handleOptionValue(val, invalidValueMessage, "env");
            });
          }
          return this;
        }
        /**
         * Internal implementation shared by .option() and .requiredOption()
         *
         * @api private
         */
        _optionEx(config, flags, description, fn, defaultValue) {
          if (typeof flags === "object" && flags instanceof Option2) {
            throw new Error("To add an Option object use addOption() instead of option() or requiredOption()");
          }
          const option = this.createOption(flags, description);
          option.makeOptionMandatory(!!config.mandatory);
          if (typeof fn === "function") {
            option.default(defaultValue).argParser(fn);
          } else if (fn instanceof RegExp) {
            const regex = fn;
            fn = (val, def) => {
              const m = regex.exec(val);
              return m ? m[0] : def;
            };
            option.default(defaultValue).argParser(fn);
          } else {
            option.default(fn);
          }
          return this.addOption(option);
        }
        /**
         * Define option with `flags`, `description` and optional
         * coercion `fn`.
         *
         * The `flags` string contains the short and/or long flags,
         * separated by comma, a pipe or space. The following are all valid
         * all will output this way when `--help` is used.
         *
         *     "-p, --pepper"
         *     "-p|--pepper"
         *     "-p --pepper"
         *
         * @example
         * // simple boolean defaulting to undefined
         * program.option('-p, --pepper', 'add pepper');
         *
         * program.pepper
         * // => undefined
         *
         * --pepper
         * program.pepper
         * // => true
         *
         * // simple boolean defaulting to true (unless non-negated option is also defined)
         * program.option('-C, --no-cheese', 'remove cheese');
         *
         * program.cheese
         * // => true
         *
         * --no-cheese
         * program.cheese
         * // => false
         *
         * // required argument
         * program.option('-C, --chdir <path>', 'change the working directory');
         *
         * --chdir /tmp
         * program.chdir
         * // => "/tmp"
         *
         * // optional argument
         * program.option('-c, --cheese [type]', 'add cheese [marble]');
         *
         * @param {string} flags
         * @param {string} [description]
         * @param {Function|*} [fn] - custom option processing function or default value
         * @param {*} [defaultValue]
         * @return {Command} `this` command for chaining
         */
        option(flags, description, fn, defaultValue) {
          return this._optionEx({}, flags, description, fn, defaultValue);
        }
        /**
        * Add a required option which must have a value after parsing. This usually means
        * the option must be specified on the command line. (Otherwise the same as .option().)
        *
        * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.
        *
        * @param {string} flags
        * @param {string} [description]
        * @param {Function|*} [fn] - custom option processing function or default value
        * @param {*} [defaultValue]
        * @return {Command} `this` command for chaining
        */
        requiredOption(flags, description, fn, defaultValue) {
          return this._optionEx({ mandatory: true }, flags, description, fn, defaultValue);
        }
        /**
         * Alter parsing of short flags with optional values.
         *
         * @example
         * // for `.option('-f,--flag [value]'):
         * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour
         * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`
         *
         * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.
         */
        combineFlagAndOptionalValue(combine = true) {
          this._combineFlagAndOptionalValue = !!combine;
          return this;
        }
        /**
         * Allow unknown options on the command line.
         *
         * @param {Boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown
         * for unknown options.
         */
        allowUnknownOption(allowUnknown = true) {
          this._allowUnknownOption = !!allowUnknown;
          return this;
        }
        /**
         * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.
         *
         * @param {Boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown
         * for excess arguments.
         */
        allowExcessArguments(allowExcess = true) {
          this._allowExcessArguments = !!allowExcess;
          return this;
        }
        /**
         * Enable positional options. Positional means global options are specified before subcommands which lets
         * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.
         * The default behaviour is non-positional and global options may appear anywhere on the command line.
         *
         * @param {Boolean} [positional=true]
         */
        enablePositionalOptions(positional = true) {
          this._enablePositionalOptions = !!positional;
          return this;
        }
        /**
         * Pass through options that come after command-arguments rather than treat them as command-options,
         * so actual command-options come before command-arguments. Turning this on for a subcommand requires
         * positional options to have been enabled on the program (parent commands).
         * The default behaviour is non-positional and options may appear before or after command-arguments.
         *
         * @param {Boolean} [passThrough=true]
         * for unknown options.
         */
        passThroughOptions(passThrough = true) {
          this._passThroughOptions = !!passThrough;
          if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {
            throw new Error("passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)");
          }
          return this;
        }
        /**
          * Whether to store option values as properties on command object,
          * or store separately (specify false). In both cases the option values can be accessed using .opts().
          *
          * @param {boolean} [storeAsProperties=true]
          * @return {Command} `this` command for chaining
          */
        storeOptionsAsProperties(storeAsProperties = true) {
          this._storeOptionsAsProperties = !!storeAsProperties;
          if (this.options.length) {
            throw new Error("call .storeOptionsAsProperties() before adding options");
          }
          return this;
        }
        /**
         * Retrieve option value.
         *
         * @param {string} key
         * @return {Object} value
         */
        getOptionValue(key) {
          if (this._storeOptionsAsProperties) {
            return this[key];
          }
          return this._optionValues[key];
        }
        /**
         * Store option value.
         *
         * @param {string} key
         * @param {Object} value
         * @return {Command} `this` command for chaining
         */
        setOptionValue(key, value) {
          return this.setOptionValueWithSource(key, value, void 0);
        }
        /**
          * Store option value and where the value came from.
          *
          * @param {string} key
          * @param {Object} value
          * @param {string} source - expected values are default/config/env/cli/implied
          * @return {Command} `this` command for chaining
          */
        setOptionValueWithSource(key, value, source) {
          if (this._storeOptionsAsProperties) {
            this[key] = value;
          } else {
            this._optionValues[key] = value;
          }
          this._optionValueSources[key] = source;
          return this;
        }
        /**
          * Get source of option value.
          * Expected values are default | config | env | cli | implied
          *
          * @param {string} key
          * @return {string}
          */
        getOptionValueSource(key) {
          return this._optionValueSources[key];
        }
        /**
         * Get user arguments from implied or explicit arguments.
         * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.
         *
         * @api private
         */
        _prepareUserArgs(argv, parseOptions) {
          if (argv !== void 0 && !Array.isArray(argv)) {
            throw new Error("first parameter to parse must be array or undefined");
          }
          parseOptions = parseOptions || {};
          if (argv === void 0) {
            argv = process2.argv;
            if (process2.versions && process2.versions.electron) {
              parseOptions.from = "electron";
            }
          }
          this.rawArgs = argv.slice();
          let userArgs;
          switch (parseOptions.from) {
            case void 0:
            case "node":
              this._scriptPath = argv[1];
              userArgs = argv.slice(2);
              break;
            case "electron":
              if (process2.defaultApp) {
                this._scriptPath = argv[1];
                userArgs = argv.slice(2);
              } else {
                userArgs = argv.slice(1);
              }
              break;
            case "user":
              userArgs = argv.slice(0);
              break;
            default:
              throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
          }
          if (!this._name && this._scriptPath)
            this.nameFromFilename(this._scriptPath);
          this._name = this._name || "program";
          return userArgs;
        }
        /**
         * Parse `argv`, setting options and invoking commands when defined.
         *
         * The default expectation is that the arguments are from node and have the application as argv[0]
         * and the script being run in argv[1], with user parameters after that.
         *
         * @example
         * program.parse(process.argv);
         * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions
         * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
         *
         * @param {string[]} [argv] - optional, defaults to process.argv
         * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron
         * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'
         * @return {Command} `this` command for chaining
         */
        parse(argv, parseOptions) {
          const userArgs = this._prepareUserArgs(argv, parseOptions);
          this._parseCommand([], userArgs);
          return this;
        }
        /**
         * Parse `argv`, setting options and invoking commands when defined.
         *
         * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.
         *
         * The default expectation is that the arguments are from node and have the application as argv[0]
         * and the script being run in argv[1], with user parameters after that.
         *
         * @example
         * await program.parseAsync(process.argv);
         * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions
         * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]
         *
         * @param {string[]} [argv]
         * @param {Object} [parseOptions]
         * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'
         * @return {Promise}
         */
        async parseAsync(argv, parseOptions) {
          const userArgs = this._prepareUserArgs(argv, parseOptions);
          await this._parseCommand([], userArgs);
          return this;
        }
        /**
         * Execute a sub-command executable.
         *
         * @api private
         */
        _executeSubCommand(subcommand, args) {
          args = args.slice();
          let launchWithNode = false;
          const sourceExt = [".js", ".ts", ".tsx", ".mjs", ".cjs"];
          function findFile(baseDir, baseName) {
            const localBin = path4.resolve(baseDir, baseName);
            if (fs4.existsSync(localBin))
              return localBin;
            if (sourceExt.includes(path4.extname(baseName)))
              return void 0;
            const foundExt = sourceExt.find((ext2) => fs4.existsSync(`${localBin}${ext2}`));
            if (foundExt)
              return `${localBin}${foundExt}`;
            return void 0;
          }
          this._checkForMissingMandatoryOptions();
          this._checkForConflictingOptions();
          let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;
          let executableDir = this._executableDir || "";
          if (this._scriptPath) {
            let resolvedScriptPath;
            try {
              resolvedScriptPath = fs4.realpathSync(this._scriptPath);
            } catch (err) {
              resolvedScriptPath = this._scriptPath;
            }
            executableDir = path4.resolve(path4.dirname(resolvedScriptPath), executableDir);
          }
          if (executableDir) {
            let localFile = findFile(executableDir, executableFile);
            if (!localFile && !subcommand._executableFile && this._scriptPath) {
              const legacyName = path4.basename(this._scriptPath, path4.extname(this._scriptPath));
              if (legacyName !== this._name) {
                localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);
              }
            }
            executableFile = localFile || executableFile;
          }
          launchWithNode = sourceExt.includes(path4.extname(executableFile));
          let proc2;
          if (process2.platform !== "win32") {
            if (launchWithNode) {
              args.unshift(executableFile);
              args = incrementNodeInspectorPort(process2.execArgv).concat(args);
              proc2 = childProcess.spawn(process2.argv[0], args, { stdio: "inherit" });
            } else {
              proc2 = childProcess.spawn(executableFile, args, { stdio: "inherit" });
            }
          } else {
            args.unshift(executableFile);
            args = incrementNodeInspectorPort(process2.execArgv).concat(args);
            proc2 = childProcess.spawn(process2.execPath, args, { stdio: "inherit" });
          }
          if (!proc2.killed) {
            const signals = ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"];
            signals.forEach((signal) => {
              process2.on(signal, () => {
                if (proc2.killed === false && proc2.exitCode === null) {
                  proc2.kill(signal);
                }
              });
            });
          }
          const exitCallback = this._exitCallback;
          if (!exitCallback) {
            proc2.on("close", process2.exit.bind(process2));
          } else {
            proc2.on("close", () => {
              exitCallback(new CommanderError2(process2.exitCode || 0, "commander.executeSubCommandAsync", "(close)"));
            });
          }
          proc2.on("error", (err) => {
            if (err.code === "ENOENT") {
              const executableDirMessage = executableDir ? `searched for local subcommand relative to directory '${executableDir}'` : "no directory for search for local subcommand, use .executableDir() to supply a custom directory";
              const executableMissing = `'${executableFile}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name or path
 - ${executableDirMessage}`;
              throw new Error(executableMissing);
            } else if (err.code === "EACCES") {
              throw new Error(`'${executableFile}' not executable`);
            }
            if (!exitCallback) {
              process2.exit(1);
            } else {
              const wrappedError = new CommanderError2(1, "commander.executeSubCommandAsync", "(error)");
              wrappedError.nestedError = err;
              exitCallback(wrappedError);
            }
          });
          this.runningCommand = proc2;
        }
        /**
         * @api private
         */
        _dispatchSubcommand(commandName, operands, unknown2) {
          const subCommand = this._findCommand(commandName);
          if (!subCommand)
            this.help({ error: true });
          let hookResult;
          hookResult = this._chainOrCallSubCommandHook(hookResult, subCommand, "preSubcommand");
          hookResult = this._chainOrCall(hookResult, () => {
            if (subCommand._executableHandler) {
              this._executeSubCommand(subCommand, operands.concat(unknown2));
            } else {
              return subCommand._parseCommand(operands, unknown2);
            }
          });
          return hookResult;
        }
        /**
         * Check this.args against expected this._args.
         *
         * @api private
         */
        _checkNumberOfArguments() {
          this._args.forEach((arg, i) => {
            if (arg.required && this.args[i] == null) {
              this.missingArgument(arg.name());
            }
          });
          if (this._args.length > 0 && this._args[this._args.length - 1].variadic) {
            return;
          }
          if (this.args.length > this._args.length) {
            this._excessArguments(this.args);
          }
        }
        /**
         * Process this.args using this._args and save as this.processedArgs!
         *
         * @api private
         */
        _processArguments() {
          const myParseArg = (argument, value, previous) => {
            let parsedValue = value;
            if (value !== null && argument.parseArg) {
              try {
                parsedValue = argument.parseArg(value, previous);
              } catch (err) {
                if (err.code === "commander.invalidArgument") {
                  const message = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'. ${err.message}`;
                  this.error(message, { exitCode: err.exitCode, code: err.code });
                }
                throw err;
              }
            }
            return parsedValue;
          };
          this._checkNumberOfArguments();
          const processedArgs = [];
          this._args.forEach((declaredArg, index) => {
            let value = declaredArg.defaultValue;
            if (declaredArg.variadic) {
              if (index < this.args.length) {
                value = this.args.slice(index);
                if (declaredArg.parseArg) {
                  value = value.reduce((processed, v) => {
                    return myParseArg(declaredArg, v, processed);
                  }, declaredArg.defaultValue);
                }
              } else if (value === void 0) {
                value = [];
              }
            } else if (index < this.args.length) {
              value = this.args[index];
              if (declaredArg.parseArg) {
                value = myParseArg(declaredArg, value, declaredArg.defaultValue);
              }
            }
            processedArgs[index] = value;
          });
          this.processedArgs = processedArgs;
        }
        /**
         * Once we have a promise we chain, but call synchronously until then.
         *
         * @param {Promise|undefined} promise
         * @param {Function} fn
         * @return {Promise|undefined}
         * @api private
         */
        _chainOrCall(promise, fn) {
          if (promise && promise.then && typeof promise.then === "function") {
            return promise.then(() => fn());
          }
          return fn();
        }
        /**
         *
         * @param {Promise|undefined} promise
         * @param {string} event
         * @return {Promise|undefined}
         * @api private
         */
        _chainOrCallHooks(promise, event) {
          let result = promise;
          const hooks = [];
          getCommandAndParents(this).reverse().filter((cmd) => cmd._lifeCycleHooks[event] !== void 0).forEach((hookedCommand) => {
            hookedCommand._lifeCycleHooks[event].forEach((callback) => {
              hooks.push({ hookedCommand, callback });
            });
          });
          if (event === "postAction") {
            hooks.reverse();
          }
          hooks.forEach((hookDetail) => {
            result = this._chainOrCall(result, () => {
              return hookDetail.callback(hookDetail.hookedCommand, this);
            });
          });
          return result;
        }
        /**
         *
         * @param {Promise|undefined} promise
         * @param {Command} subCommand
         * @param {string} event
         * @return {Promise|undefined}
         * @api private
         */
        _chainOrCallSubCommandHook(promise, subCommand, event) {
          let result = promise;
          if (this._lifeCycleHooks[event] !== void 0) {
            this._lifeCycleHooks[event].forEach((hook) => {
              result = this._chainOrCall(result, () => {
                return hook(this, subCommand);
              });
            });
          }
          return result;
        }
        /**
         * Process arguments in context of this command.
         * Returns action result, in case it is a promise.
         *
         * @api private
         */
        _parseCommand(operands, unknown2) {
          const parsed = this.parseOptions(unknown2);
          this._parseOptionsEnv();
          this._parseOptionsImplied();
          operands = operands.concat(parsed.operands);
          unknown2 = parsed.unknown;
          this.args = operands.concat(unknown2);
          if (operands && this._findCommand(operands[0])) {
            return this._dispatchSubcommand(operands[0], operands.slice(1), unknown2);
          }
          if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {
            if (operands.length === 1) {
              this.help();
            }
            return this._dispatchSubcommand(operands[1], [], [this._helpLongFlag]);
          }
          if (this._defaultCommandName) {
            outputHelpIfRequested(this, unknown2);
            return this._dispatchSubcommand(this._defaultCommandName, operands, unknown2);
          }
          if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
            this.help({ error: true });
          }
          outputHelpIfRequested(this, parsed.unknown);
          this._checkForMissingMandatoryOptions();
          this._checkForConflictingOptions();
          const checkForUnknownOptions = () => {
            if (parsed.unknown.length > 0) {
              this.unknownOption(parsed.unknown[0]);
            }
          };
          const commandEvent = `command:${this.name()}`;
          if (this._actionHandler) {
            checkForUnknownOptions();
            this._processArguments();
            let actionResult;
            actionResult = this._chainOrCallHooks(actionResult, "preAction");
            actionResult = this._chainOrCall(actionResult, () => this._actionHandler(this.processedArgs));
            if (this.parent) {
              actionResult = this._chainOrCall(actionResult, () => {
                this.parent.emit(commandEvent, operands, unknown2);
              });
            }
            actionResult = this._chainOrCallHooks(actionResult, "postAction");
            return actionResult;
          }
          if (this.parent && this.parent.listenerCount(commandEvent)) {
            checkForUnknownOptions();
            this._processArguments();
            this.parent.emit(commandEvent, operands, unknown2);
          } else if (operands.length) {
            if (this._findCommand("*")) {
              return this._dispatchSubcommand("*", operands, unknown2);
            }
            if (this.listenerCount("command:*")) {
              this.emit("command:*", operands, unknown2);
            } else if (this.commands.length) {
              this.unknownCommand();
            } else {
              checkForUnknownOptions();
              this._processArguments();
            }
          } else if (this.commands.length) {
            checkForUnknownOptions();
            this.help({ error: true });
          } else {
            checkForUnknownOptions();
            this._processArguments();
          }
        }
        /**
         * Find matching command.
         *
         * @api private
         */
        _findCommand(name) {
          if (!name)
            return void 0;
          return this.commands.find((cmd) => cmd._name === name || cmd._aliases.includes(name));
        }
        /**
         * Return an option matching `arg` if any.
         *
         * @param {string} arg
         * @return {Option}
         * @api private
         */
        _findOption(arg) {
          return this.options.find((option) => option.is(arg));
        }
        /**
         * Display an error message if a mandatory option does not have a value.
         * Called after checking for help flags in leaf subcommand.
         *
         * @api private
         */
        _checkForMissingMandatoryOptions() {
          for (let cmd = this; cmd; cmd = cmd.parent) {
            cmd.options.forEach((anOption) => {
              if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === void 0) {
                cmd.missingMandatoryOptionValue(anOption);
              }
            });
          }
        }
        /**
         * Display an error message if conflicting options are used together in this.
         *
         * @api private
         */
        _checkForConflictingLocalOptions() {
          const definedNonDefaultOptions = this.options.filter(
            (option) => {
              const optionKey = option.attributeName();
              if (this.getOptionValue(optionKey) === void 0) {
                return false;
              }
              return this.getOptionValueSource(optionKey) !== "default";
            }
          );
          const optionsWithConflicting = definedNonDefaultOptions.filter(
            (option) => option.conflictsWith.length > 0
          );
          optionsWithConflicting.forEach((option) => {
            const conflictingAndDefined = definedNonDefaultOptions.find(
              (defined) => option.conflictsWith.includes(defined.attributeName())
            );
            if (conflictingAndDefined) {
              this._conflictingOption(option, conflictingAndDefined);
            }
          });
        }
        /**
         * Display an error message if conflicting options are used together.
         * Called after checking for help flags in leaf subcommand.
         *
         * @api private
         */
        _checkForConflictingOptions() {
          for (let cmd = this; cmd; cmd = cmd.parent) {
            cmd._checkForConflictingLocalOptions();
          }
        }
        /**
         * Parse options from `argv` removing known options,
         * and return argv split into operands and unknown arguments.
         *
         * Examples:
         *
         *     argv => operands, unknown
         *     --known kkk op => [op], []
         *     op --known kkk => [op], []
         *     sub --unknown uuu op => [sub], [--unknown uuu op]
         *     sub -- --unknown uuu op => [sub --unknown uuu op], []
         *
         * @param {String[]} argv
         * @return {{operands: String[], unknown: String[]}}
         */
        parseOptions(argv) {
          const operands = [];
          const unknown2 = [];
          let dest = operands;
          const args = argv.slice();
          function maybeOption(arg) {
            return arg.length > 1 && arg[0] === "-";
          }
          let activeVariadicOption = null;
          while (args.length) {
            const arg = args.shift();
            if (arg === "--") {
              if (dest === unknown2)
                dest.push(arg);
              dest.push(...args);
              break;
            }
            if (activeVariadicOption && !maybeOption(arg)) {
              this.emit(`option:${activeVariadicOption.name()}`, arg);
              continue;
            }
            activeVariadicOption = null;
            if (maybeOption(arg)) {
              const option = this._findOption(arg);
              if (option) {
                if (option.required) {
                  const value = args.shift();
                  if (value === void 0)
                    this.optionMissingArgument(option);
                  this.emit(`option:${option.name()}`, value);
                } else if (option.optional) {
                  let value = null;
                  if (args.length > 0 && !maybeOption(args[0])) {
                    value = args.shift();
                  }
                  this.emit(`option:${option.name()}`, value);
                } else {
                  this.emit(`option:${option.name()}`);
                }
                activeVariadicOption = option.variadic ? option : null;
                continue;
              }
            }
            if (arg.length > 2 && arg[0] === "-" && arg[1] !== "-") {
              const option = this._findOption(`-${arg[1]}`);
              if (option) {
                if (option.required || option.optional && this._combineFlagAndOptionalValue) {
                  this.emit(`option:${option.name()}`, arg.slice(2));
                } else {
                  this.emit(`option:${option.name()}`);
                  args.unshift(`-${arg.slice(2)}`);
                }
                continue;
              }
            }
            if (/^--[^=]+=/.test(arg)) {
              const index = arg.indexOf("=");
              const option = this._findOption(arg.slice(0, index));
              if (option && (option.required || option.optional)) {
                this.emit(`option:${option.name()}`, arg.slice(index + 1));
                continue;
              }
            }
            if (maybeOption(arg)) {
              dest = unknown2;
            }
            if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown2.length === 0) {
              if (this._findCommand(arg)) {
                operands.push(arg);
                if (args.length > 0)
                  unknown2.push(...args);
                break;
              } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {
                operands.push(arg);
                if (args.length > 0)
                  operands.push(...args);
                break;
              } else if (this._defaultCommandName) {
                unknown2.push(arg);
                if (args.length > 0)
                  unknown2.push(...args);
                break;
              }
            }
            if (this._passThroughOptions) {
              dest.push(arg);
              if (args.length > 0)
                dest.push(...args);
              break;
            }
            dest.push(arg);
          }
          return { operands, unknown: unknown2 };
        }
        /**
         * Return an object containing local option values as key-value pairs.
         *
         * @return {Object}
         */
        opts() {
          if (this._storeOptionsAsProperties) {
            const result = {};
            const len = this.options.length;
            for (let i = 0; i < len; i++) {
              const key = this.options[i].attributeName();
              result[key] = key === this._versionOptionName ? this._version : this[key];
            }
            return result;
          }
          return this._optionValues;
        }
        /**
         * Return an object containing merged local and global option values as key-value pairs.
         *
         * @return {Object}
         */
        optsWithGlobals() {
          return getCommandAndParents(this).reduce(
            (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),
            {}
          );
        }
        /**
         * Display error message and exit (or call exitOverride).
         *
         * @param {string} message
         * @param {Object} [errorOptions]
         * @param {string} [errorOptions.code] - an id string representing the error
         * @param {number} [errorOptions.exitCode] - used with process.exit
         */
        error(message, errorOptions) {
          this._outputConfiguration.outputError(`${message}
`, this._outputConfiguration.writeErr);
          if (typeof this._showHelpAfterError === "string") {
            this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);
          } else if (this._showHelpAfterError) {
            this._outputConfiguration.writeErr("\n");
            this.outputHelp({ error: true });
          }
          const config = errorOptions || {};
          const exitCode = config.exitCode || 1;
          const code = config.code || "commander.error";
          this._exit(exitCode, code, message);
        }
        /**
         * Apply any option related environment variables, if option does
         * not have a value from cli or client code.
         *
         * @api private
         */
        _parseOptionsEnv() {
          this.options.forEach((option) => {
            if (option.envVar && option.envVar in process2.env) {
              const optionKey = option.attributeName();
              if (this.getOptionValue(optionKey) === void 0 || ["default", "config", "env"].includes(this.getOptionValueSource(optionKey))) {
                if (option.required || option.optional) {
                  this.emit(`optionEnv:${option.name()}`, process2.env[option.envVar]);
                } else {
                  this.emit(`optionEnv:${option.name()}`);
                }
              }
            }
          });
        }
        /**
         * Apply any implied option values, if option is undefined or default value.
         *
         * @api private
         */
        _parseOptionsImplied() {
          const dualHelper = new DualOptions(this.options);
          const hasCustomOptionValue = (optionKey) => {
            return this.getOptionValue(optionKey) !== void 0 && !["default", "implied"].includes(this.getOptionValueSource(optionKey));
          };
          this.options.filter((option) => option.implied !== void 0 && hasCustomOptionValue(option.attributeName()) && dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option)).forEach((option) => {
            Object.keys(option.implied).filter((impliedKey) => !hasCustomOptionValue(impliedKey)).forEach((impliedKey) => {
              this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], "implied");
            });
          });
        }
        /**
         * Argument `name` is missing.
         *
         * @param {string} name
         * @api private
         */
        missingArgument(name) {
          const message = `error: missing required argument '${name}'`;
          this.error(message, { code: "commander.missingArgument" });
        }
        /**
         * `Option` is missing an argument.
         *
         * @param {Option} option
         * @api private
         */
        optionMissingArgument(option) {
          const message = `error: option '${option.flags}' argument missing`;
          this.error(message, { code: "commander.optionMissingArgument" });
        }
        /**
         * `Option` does not have a value, and is a mandatory option.
         *
         * @param {Option} option
         * @api private
         */
        missingMandatoryOptionValue(option) {
          const message = `error: required option '${option.flags}' not specified`;
          this.error(message, { code: "commander.missingMandatoryOptionValue" });
        }
        /**
         * `Option` conflicts with another option.
         *
         * @param {Option} option
         * @param {Option} conflictingOption
         * @api private
         */
        _conflictingOption(option, conflictingOption) {
          const findBestOptionFromValue = (option2) => {
            const optionKey = option2.attributeName();
            const optionValue = this.getOptionValue(optionKey);
            const negativeOption = this.options.find((target) => target.negate && optionKey === target.attributeName());
            const positiveOption = this.options.find((target) => !target.negate && optionKey === target.attributeName());
            if (negativeOption && (negativeOption.presetArg === void 0 && optionValue === false || negativeOption.presetArg !== void 0 && optionValue === negativeOption.presetArg)) {
              return negativeOption;
            }
            return positiveOption || option2;
          };
          const getErrorMessage = (option2) => {
            const bestOption = findBestOptionFromValue(option2);
            const optionKey = bestOption.attributeName();
            const source = this.getOptionValueSource(optionKey);
            if (source === "env") {
              return `environment variable '${bestOption.envVar}'`;
            }
            return `option '${bestOption.flags}'`;
          };
          const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;
          this.error(message, { code: "commander.conflictingOption" });
        }
        /**
         * Unknown option `flag`.
         *
         * @param {string} flag
         * @api private
         */
        unknownOption(flag) {
          if (this._allowUnknownOption)
            return;
          let suggestion = "";
          if (flag.startsWith("--") && this._showSuggestionAfterError) {
            let candidateFlags = [];
            let command = this;
            do {
              const moreFlags = command.createHelp().visibleOptions(command).filter((option) => option.long).map((option) => option.long);
              candidateFlags = candidateFlags.concat(moreFlags);
              command = command.parent;
            } while (command && !command._enablePositionalOptions);
            suggestion = suggestSimilar(flag, candidateFlags);
          }
          const message = `error: unknown option '${flag}'${suggestion}`;
          this.error(message, { code: "commander.unknownOption" });
        }
        /**
         * Excess arguments, more than expected.
         *
         * @param {string[]} receivedArgs
         * @api private
         */
        _excessArguments(receivedArgs) {
          if (this._allowExcessArguments)
            return;
          const expected = this._args.length;
          const s = expected === 1 ? "" : "s";
          const forSubcommand = this.parent ? ` for '${this.name()}'` : "";
          const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
          this.error(message, { code: "commander.excessArguments" });
        }
        /**
         * Unknown command.
         *
         * @api private
         */
        unknownCommand() {
          const unknownName = this.args[0];
          let suggestion = "";
          if (this._showSuggestionAfterError) {
            const candidateNames = [];
            this.createHelp().visibleCommands(this).forEach((command) => {
              candidateNames.push(command.name());
              if (command.alias())
                candidateNames.push(command.alias());
            });
            suggestion = suggestSimilar(unknownName, candidateNames);
          }
          const message = `error: unknown command '${unknownName}'${suggestion}`;
          this.error(message, { code: "commander.unknownCommand" });
        }
        /**
         * Set the program version to `str`.
         *
         * This method auto-registers the "-V, --version" flag
         * which will print the version number when passed.
         *
         * You can optionally supply the  flags and description to override the defaults.
         *
         * @param {string} str
         * @param {string} [flags]
         * @param {string} [description]
         * @return {this | string} `this` command for chaining, or version string if no arguments
         */
        version(str, flags, description) {
          if (str === void 0)
            return this._version;
          this._version = str;
          flags = flags || "-V, --version";
          description = description || "output the version number";
          const versionOption = this.createOption(flags, description);
          this._versionOptionName = versionOption.attributeName();
          this.options.push(versionOption);
          this.on("option:" + versionOption.name(), () => {
            this._outputConfiguration.writeOut(`${str}
`);
            this._exit(0, "commander.version", str);
          });
          return this;
        }
        /**
         * Set the description.
         *
         * @param {string} [str]
         * @param {Object} [argsDescription]
         * @return {string|Command}
         */
        description(str, argsDescription) {
          if (str === void 0 && argsDescription === void 0)
            return this._description;
          this._description = str;
          if (argsDescription) {
            this._argsDescription = argsDescription;
          }
          return this;
        }
        /**
         * Set the summary. Used when listed as subcommand of parent.
         *
         * @param {string} [str]
         * @return {string|Command}
         */
        summary(str) {
          if (str === void 0)
            return this._summary;
          this._summary = str;
          return this;
        }
        /**
         * Set an alias for the command.
         *
         * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.
         *
         * @param {string} [alias]
         * @return {string|Command}
         */
        alias(alias) {
          if (alias === void 0)
            return this._aliases[0];
          let command = this;
          if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
            command = this.commands[this.commands.length - 1];
          }
          if (alias === command._name)
            throw new Error("Command alias can't be the same as its name");
          command._aliases.push(alias);
          return this;
        }
        /**
         * Set aliases for the command.
         *
         * Only the first alias is shown in the auto-generated help.
         *
         * @param {string[]} [aliases]
         * @return {string[]|Command}
         */
        aliases(aliases) {
          if (aliases === void 0)
            return this._aliases;
          aliases.forEach((alias) => this.alias(alias));
          return this;
        }
        /**
         * Set / get the command usage `str`.
         *
         * @param {string} [str]
         * @return {String|Command}
         */
        usage(str) {
          if (str === void 0) {
            if (this._usage)
              return this._usage;
            const args = this._args.map((arg) => {
              return humanReadableArgName(arg);
            });
            return [].concat(
              this.options.length || this._hasHelpOption ? "[options]" : [],
              this.commands.length ? "[command]" : [],
              this._args.length ? args : []
            ).join(" ");
          }
          this._usage = str;
          return this;
        }
        /**
         * Get or set the name of the command.
         *
         * @param {string} [str]
         * @return {string|Command}
         */
        name(str) {
          if (str === void 0)
            return this._name;
          this._name = str;
          return this;
        }
        /**
         * Set the name of the command from script filename, such as process.argv[1],
         * or require.main.filename, or __filename.
         *
         * (Used internally and public although not documented in README.)
         *
         * @example
         * program.nameFromFilename(require.main.filename);
         *
         * @param {string} filename
         * @return {Command}
         */
        nameFromFilename(filename) {
          this._name = path4.basename(filename, path4.extname(filename));
          return this;
        }
        /**
         * Get or set the directory for searching for executable subcommands of this command.
         *
         * @example
         * program.executableDir(__dirname);
         * // or
         * program.executableDir('subcommands');
         *
         * @param {string} [path]
         * @return {string|Command}
         */
        executableDir(path5) {
          if (path5 === void 0)
            return this._executableDir;
          this._executableDir = path5;
          return this;
        }
        /**
         * Return program help documentation.
         *
         * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout
         * @return {string}
         */
        helpInformation(contextOptions) {
          const helper = this.createHelp();
          if (helper.helpWidth === void 0) {
            helper.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
          }
          return helper.formatHelp(this, helper);
        }
        /**
         * @api private
         */
        _getHelpContext(contextOptions) {
          contextOptions = contextOptions || {};
          const context2 = { error: !!contextOptions.error };
          let write;
          if (context2.error) {
            write = (arg) => this._outputConfiguration.writeErr(arg);
          } else {
            write = (arg) => this._outputConfiguration.writeOut(arg);
          }
          context2.write = contextOptions.write || write;
          context2.command = this;
          return context2;
        }
        /**
         * Output help information for this command.
         *
         * Outputs built-in help, and custom text added using `.addHelpText()`.
         *
         * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout
         */
        outputHelp(contextOptions) {
          let deprecatedCallback;
          if (typeof contextOptions === "function") {
            deprecatedCallback = contextOptions;
            contextOptions = void 0;
          }
          const context2 = this._getHelpContext(contextOptions);
          getCommandAndParents(this).reverse().forEach((command) => command.emit("beforeAllHelp", context2));
          this.emit("beforeHelp", context2);
          let helpInformation = this.helpInformation(context2);
          if (deprecatedCallback) {
            helpInformation = deprecatedCallback(helpInformation);
            if (typeof helpInformation !== "string" && !Buffer.isBuffer(helpInformation)) {
              throw new Error("outputHelp callback must return a string or a Buffer");
            }
          }
          context2.write(helpInformation);
          this.emit(this._helpLongFlag);
          this.emit("afterHelp", context2);
          getCommandAndParents(this).forEach((command) => command.emit("afterAllHelp", context2));
        }
        /**
         * You can pass in flags and a description to override the help
         * flags and help description for your command. Pass in false to
         * disable the built-in help option.
         *
         * @param {string | boolean} [flags]
         * @param {string} [description]
         * @return {Command} `this` command for chaining
         */
        helpOption(flags, description) {
          if (typeof flags === "boolean") {
            this._hasHelpOption = flags;
            return this;
          }
          this._helpFlags = flags || this._helpFlags;
          this._helpDescription = description || this._helpDescription;
          const helpFlags = splitOptionFlags(this._helpFlags);
          this._helpShortFlag = helpFlags.shortFlag;
          this._helpLongFlag = helpFlags.longFlag;
          return this;
        }
        /**
         * Output help information and exit.
         *
         * Outputs built-in help, and custom text added using `.addHelpText()`.
         *
         * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout
         */
        help(contextOptions) {
          this.outputHelp(contextOptions);
          let exitCode = process2.exitCode || 0;
          if (exitCode === 0 && contextOptions && typeof contextOptions !== "function" && contextOptions.error) {
            exitCode = 1;
          }
          this._exit(exitCode, "commander.help", "(outputHelp)");
        }
        /**
         * Add additional text to be displayed with the built-in help.
         *
         * Position is 'before' or 'after' to affect just this command,
         * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.
         *
         * @param {string} position - before or after built-in help
         * @param {string | Function} text - string to add, or a function returning a string
         * @return {Command} `this` command for chaining
         */
        addHelpText(position, text) {
          const allowedValues = ["beforeAll", "before", "after", "afterAll"];
          if (!allowedValues.includes(position)) {
            throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
          }
          const helpEvent = `${position}Help`;
          this.on(helpEvent, (context2) => {
            let helpStr;
            if (typeof text === "function") {
              helpStr = text({ error: context2.error, command: context2.command });
            } else {
              helpStr = text;
            }
            if (helpStr) {
              context2.write(`${helpStr}
`);
            }
          });
          return this;
        }
      };
      function outputHelpIfRequested(cmd, args) {
        const helpOption = cmd._hasHelpOption && args.find((arg) => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);
        if (helpOption) {
          cmd.outputHelp();
          cmd._exit(0, "commander.helpDisplayed", "(outputHelp)");
        }
      }
      function incrementNodeInspectorPort(args) {
        return args.map((arg) => {
          if (!arg.startsWith("--inspect")) {
            return arg;
          }
          let debugOption;
          let debugHost = "127.0.0.1";
          let debugPort = "9229";
          let match3;
          if ((match3 = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
            debugOption = match3[1];
          } else if ((match3 = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
            debugOption = match3[1];
            if (/^\d+$/.test(match3[3])) {
              debugPort = match3[3];
            } else {
              debugHost = match3[3];
            }
          } else if ((match3 = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
            debugOption = match3[1];
            debugHost = match3[3];
            debugPort = match3[4];
          }
          if (debugOption && debugPort !== "0") {
            return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
          }
          return arg;
        });
      }
      function getCommandAndParents(startCommand) {
        const result = [];
        for (let command = startCommand; command; command = command.parent) {
          result.push(command);
        }
        return result;
      }
      exports.Command = Command2;
    }
  });

  // ../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/index.js
  var require_commander = __commonJS({
    "../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/index.js"(exports, module2) {
      var { Argument: Argument2 } = require_argument();
      var { Command: Command2 } = require_command();
      var { CommanderError: CommanderError2, InvalidArgumentError: InvalidArgumentError2 } = require_error();
      var { Help: Help2 } = require_help();
      var { Option: Option2 } = require_option();
      exports = module2.exports = new Command2();
      exports.program = exports;
      exports.Argument = Argument2;
      exports.Command = Command2;
      exports.CommanderError = CommanderError2;
      exports.Help = Help2;
      exports.InvalidArgumentError = InvalidArgumentError2;
      exports.InvalidOptionArgumentError = InvalidArgumentError2;
      exports.Option = Option2;
    }
  });

  // ../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js
  var require_balanced_match = __commonJS({
    "../../node_modules/.pnpm/balanced-match@1.0.2/node_modules/balanced-match/index.js"(exports, module2) {
      "use strict";
      module2.exports = balanced;
      function balanced(a, b, str) {
        if (a instanceof RegExp)
          a = maybeMatch(a, str);
        if (b instanceof RegExp)
          b = maybeMatch(b, str);
        var r = range(a, b, str);
        return r && {
          start: r[0],
          end: r[1],
          pre: str.slice(0, r[0]),
          body: str.slice(r[0] + a.length, r[1]),
          post: str.slice(r[1] + b.length)
        };
      }
      function maybeMatch(reg, str) {
        var m = str.match(reg);
        return m ? m[0] : null;
      }
      balanced.range = range;
      function range(a, b, str) {
        var begs, beg, left, right, result;
        var ai = str.indexOf(a);
        var bi = str.indexOf(b, ai + 1);
        var i = ai;
        if (ai >= 0 && bi > 0) {
          if (a === b) {
            return [ai, bi];
          }
          begs = [];
          left = str.length;
          while (i >= 0 && !result) {
            if (i == ai) {
              begs.push(i);
              ai = str.indexOf(a, i + 1);
            } else if (begs.length == 1) {
              result = [begs.pop(), bi];
            } else {
              beg = begs.pop();
              if (beg < left) {
                left = beg;
                right = bi;
              }
              bi = str.indexOf(b, i + 1);
            }
            i = ai < bi && ai >= 0 ? ai : bi;
          }
          if (begs.length) {
            result = [left, right];
          }
        }
        return result;
      }
    }
  });

  // ../../node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js
  var require_brace_expansion = __commonJS({
    "../../node_modules/.pnpm/brace-expansion@2.0.1/node_modules/brace-expansion/index.js"(exports, module2) {
      var balanced = require_balanced_match();
      module2.exports = expandTop;
      var escSlash = "\0SLASH" + Math.random() + "\0";
      var escOpen = "\0OPEN" + Math.random() + "\0";
      var escClose = "\0CLOSE" + Math.random() + "\0";
      var escComma = "\0COMMA" + Math.random() + "\0";
      var escPeriod = "\0PERIOD" + Math.random() + "\0";
      function numeric(str) {
        return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
      }
      function escapeBraces(str) {
        return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
      }
      function unescapeBraces(str) {
        return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
      }
      function parseCommaParts(str) {
        if (!str)
          return [""];
        var parts = [];
        var m = balanced("{", "}", str);
        if (!m)
          return str.split(",");
        var pre = m.pre;
        var body = m.body;
        var post = m.post;
        var p = pre.split(",");
        p[p.length - 1] += "{" + body + "}";
        var postParts = parseCommaParts(post);
        if (post.length) {
          p[p.length - 1] += postParts.shift();
          p.push.apply(p, postParts);
        }
        parts.push.apply(parts, p);
        return parts;
      }
      function expandTop(str) {
        if (!str)
          return [];
        if (str.substr(0, 2) === "{}") {
          str = "\\{\\}" + str.substr(2);
        }
        return expand2(escapeBraces(str), true).map(unescapeBraces);
      }
      function embrace(str) {
        return "{" + str + "}";
      }
      function isPadded(el) {
        return /^-?0\d/.test(el);
      }
      function lte(i, y) {
        return i <= y;
      }
      function gte(i, y) {
        return i >= y;
      }
      function expand2(str, isTop) {
        var expansions = [];
        var m = balanced("{", "}", str);
        if (!m)
          return [str];
        var pre = m.pre;
        var post = m.post.length ? expand2(m.post, false) : [""];
        if (/\$$/.test(m.pre)) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + "{" + m.body + "}" + post[k];
            expansions.push(expansion);
          }
        } else {
          var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
          var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
          var isSequence = isNumericSequence || isAlphaSequence;
          var isOptions = m.body.indexOf(",") >= 0;
          if (!isSequence && !isOptions) {
            if (m.post.match(/,.*\}/)) {
              str = m.pre + "{" + m.body + escClose + m.post;
              return expand2(str);
            }
            return [str];
          }
          var n;
          if (isSequence) {
            n = m.body.split(/\.\./);
          } else {
            n = parseCommaParts(m.body);
            if (n.length === 1) {
              n = expand2(n[0], false).map(embrace);
              if (n.length === 1) {
                return post.map(function(p) {
                  return m.pre + n[0] + p;
                });
              }
            }
          }
          var N;
          if (isSequence) {
            var x = numeric(n[0]);
            var y = numeric(n[1]);
            var width = Math.max(n[0].length, n[1].length);
            var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
            var test = lte;
            var reverse = y < x;
            if (reverse) {
              incr *= -1;
              test = gte;
            }
            var pad3 = n.some(isPadded);
            N = [];
            for (var i = x; test(i, y); i += incr) {
              var c;
              if (isAlphaSequence) {
                c = String.fromCharCode(i);
                if (c === "\\")
                  c = "";
              } else {
                c = String(i);
                if (pad3) {
                  var need = width - c.length;
                  if (need > 0) {
                    var z = new Array(need + 1).join("0");
                    if (i < 0)
                      c = "-" + z + c.slice(1);
                    else
                      c = z + c;
                  }
                }
              }
              N.push(c);
            }
          } else {
            N = [];
            for (var j = 0; j < n.length; j++) {
              N.push.apply(N, expand2(n[j], false));
            }
          }
          for (var j = 0; j < N.length; j++) {
            for (var k = 0; k < post.length; k++) {
              var expansion = pre + N[j] + post[k];
              if (!isTop || isSequence || expansion)
                expansions.push(expansion);
            }
          }
        }
        return expansions;
      }
    }
  });

  // ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/opts-arg.js
  var require_opts_arg = __commonJS({
    "../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/opts-arg.js"(exports, module2) {
      var { promisify } = __require2("util");
      var fs4 = __require2("fs");
      var optsArg = (opts) => {
        if (!opts)
          opts = { mode: 511, fs: fs4 };
        else if (typeof opts === "object")
          opts = { mode: 511, fs: fs4, ...opts };
        else if (typeof opts === "number")
          opts = { mode: opts, fs: fs4 };
        else if (typeof opts === "string")
          opts = { mode: parseInt(opts, 8), fs: fs4 };
        else
          throw new TypeError("invalid options argument");
        opts.mkdir = opts.mkdir || opts.fs.mkdir || fs4.mkdir;
        opts.mkdirAsync = promisify(opts.mkdir);
        opts.stat = opts.stat || opts.fs.stat || fs4.stat;
        opts.statAsync = promisify(opts.stat);
        opts.statSync = opts.statSync || opts.fs.statSync || fs4.statSync;
        opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs4.mkdirSync;
        return opts;
      };
      module2.exports = optsArg;
    }
  });

  // ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/path-arg.js
  var require_path_arg = __commonJS({
    "../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/path-arg.js"(exports, module2) {
      var platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;
      var { resolve: resolve4, parse: parse3 } = __require2("path");
      var pathArg = (path4) => {
        if (/\0/.test(path4)) {
          throw Object.assign(
            new TypeError("path must be a string without null bytes"),
            {
              path: path4,
              code: "ERR_INVALID_ARG_VALUE"
            }
          );
        }
        path4 = resolve4(path4);
        if (platform === "win32") {
          const badWinChars = /[*|"<>?:]/;
          const { root } = parse3(path4);
          if (badWinChars.test(path4.substr(root.length))) {
            throw Object.assign(new Error("Illegal characters in path."), {
              path: path4,
              code: "EINVAL"
            });
          }
        }
        return path4;
      };
      module2.exports = pathArg;
    }
  });

  // ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/find-made.js
  var require_find_made = __commonJS({
    "../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/find-made.js"(exports, module2) {
      var { dirname: dirname2 } = __require2("path");
      var findMade = (opts, parent, path4 = void 0) => {
        if (path4 === parent)
          return Promise.resolve();
        return opts.statAsync(parent).then(
          (st) => st.isDirectory() ? path4 : void 0,
          // will fail later
          (er) => er.code === "ENOENT" ? findMade(opts, dirname2(parent), parent) : void 0
        );
      };
      var findMadeSync = (opts, parent, path4 = void 0) => {
        if (path4 === parent)
          return void 0;
        try {
          return opts.statSync(parent).isDirectory() ? path4 : void 0;
        } catch (er) {
          return er.code === "ENOENT" ? findMadeSync(opts, dirname2(parent), parent) : void 0;
        }
      };
      module2.exports = { findMade, findMadeSync };
    }
  });

  // ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/mkdirp-manual.js
  var require_mkdirp_manual = __commonJS({
    "../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/mkdirp-manual.js"(exports, module2) {
      var { dirname: dirname2 } = __require2("path");
      var mkdirpManual = (path4, opts, made) => {
        opts.recursive = false;
        const parent = dirname2(path4);
        if (parent === path4) {
          return opts.mkdirAsync(path4, opts).catch((er) => {
            if (er.code !== "EISDIR")
              throw er;
          });
        }
        return opts.mkdirAsync(path4, opts).then(() => made || path4, (er) => {
          if (er.code === "ENOENT")
            return mkdirpManual(parent, opts).then((made2) => mkdirpManual(path4, opts, made2));
          if (er.code !== "EEXIST" && er.code !== "EROFS")
            throw er;
          return opts.statAsync(path4).then((st) => {
            if (st.isDirectory())
              return made;
            else
              throw er;
          }, () => {
            throw er;
          });
        });
      };
      var mkdirpManualSync = (path4, opts, made) => {
        const parent = dirname2(path4);
        opts.recursive = false;
        if (parent === path4) {
          try {
            return opts.mkdirSync(path4, opts);
          } catch (er) {
            if (er.code !== "EISDIR")
              throw er;
            else
              return;
          }
        }
        try {
          opts.mkdirSync(path4, opts);
          return made || path4;
        } catch (er) {
          if (er.code === "ENOENT")
            return mkdirpManualSync(path4, opts, mkdirpManualSync(parent, opts, made));
          if (er.code !== "EEXIST" && er.code !== "EROFS")
            throw er;
          try {
            if (!opts.statSync(path4).isDirectory())
              throw er;
          } catch (_) {
            throw er;
          }
        }
      };
      module2.exports = { mkdirpManual, mkdirpManualSync };
    }
  });

  // ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/mkdirp-native.js
  var require_mkdirp_native = __commonJS({
    "../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/mkdirp-native.js"(exports, module2) {
      var { dirname: dirname2 } = __require2("path");
      var { findMade, findMadeSync } = require_find_made();
      var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
      var mkdirpNative = (path4, opts) => {
        opts.recursive = true;
        const parent = dirname2(path4);
        if (parent === path4)
          return opts.mkdirAsync(path4, opts);
        return findMade(opts, path4).then((made) => opts.mkdirAsync(path4, opts).then(() => made).catch((er) => {
          if (er.code === "ENOENT")
            return mkdirpManual(path4, opts);
          else
            throw er;
        }));
      };
      var mkdirpNativeSync = (path4, opts) => {
        opts.recursive = true;
        const parent = dirname2(path4);
        if (parent === path4)
          return opts.mkdirSync(path4, opts);
        const made = findMadeSync(opts, path4);
        try {
          opts.mkdirSync(path4, opts);
          return made;
        } catch (er) {
          if (er.code === "ENOENT")
            return mkdirpManualSync(path4, opts);
          else
            throw er;
        }
      };
      module2.exports = { mkdirpNative, mkdirpNativeSync };
    }
  });

  // ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/use-native.js
  var require_use_native = __commonJS({
    "../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/lib/use-native.js"(exports, module2) {
      var fs4 = __require2("fs");
      var version2 = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;
      var versArr = version2.replace(/^v/, "").split(".");
      var hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12;
      var useNative = !hasNative ? () => false : (opts) => opts.mkdir === fs4.mkdir;
      var useNativeSync = !hasNative ? () => false : (opts) => opts.mkdirSync === fs4.mkdirSync;
      module2.exports = { useNative, useNativeSync };
    }
  });

  // ../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/index.js
  var require_mkdirp = __commonJS({
    "../../node_modules/.pnpm/mkdirp@1.0.4/node_modules/mkdirp/index.js"(exports, module2) {
      var optsArg = require_opts_arg();
      var pathArg = require_path_arg();
      var { mkdirpNative, mkdirpNativeSync } = require_mkdirp_native();
      var { mkdirpManual, mkdirpManualSync } = require_mkdirp_manual();
      var { useNative, useNativeSync } = require_use_native();
      var mkdirp3 = (path4, opts) => {
        path4 = pathArg(path4);
        opts = optsArg(opts);
        return useNative(opts) ? mkdirpNative(path4, opts) : mkdirpManual(path4, opts);
      };
      var mkdirpSync = (path4, opts) => {
        path4 = pathArg(path4);
        opts = optsArg(opts);
        return useNativeSync(opts) ? mkdirpNativeSync(path4, opts) : mkdirpManualSync(path4, opts);
      };
      mkdirp3.sync = mkdirpSync;
      mkdirp3.native = (path4, opts) => mkdirpNative(pathArg(path4), optsArg(opts));
      mkdirp3.manual = (path4, opts) => mkdirpManual(pathArg(path4), optsArg(opts));
      mkdirp3.nativeSync = (path4, opts) => mkdirpNativeSync(pathArg(path4), optsArg(opts));
      mkdirp3.manualSync = (path4, opts) => mkdirpManualSync(pathArg(path4), optsArg(opts));
      module2.exports = mkdirp3;
    }
  });

  // ../../node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/old.js
  var require_old = __commonJS({
    "../../node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/old.js"(exports) {
      var pathModule = __require2("path");
      var isWindows = process.platform === "win32";
      var fs4 = __require2("fs");
      var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
      function rethrow() {
        var callback;
        if (DEBUG) {
          var backtrace = new Error();
          callback = debugCallback;
        } else
          callback = missingCallback;
        return callback;
        function debugCallback(err) {
          if (err) {
            backtrace.message = err.message;
            err = backtrace;
            missingCallback(err);
          }
        }
        function missingCallback(err) {
          if (err) {
            if (process.throwDeprecation)
              throw err;
            else if (!process.noDeprecation) {
              var msg = "fs: missing callback " + (err.stack || err.message);
              if (process.traceDeprecation)
                console.trace(msg);
              else
                console.error(msg);
            }
          }
        }
      }
      function maybeCallback(cb) {
        return typeof cb === "function" ? cb : rethrow();
      }
      var normalize4 = pathModule.normalize;
      if (isWindows) {
        nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
      } else {
        nextPartRe = /(.*?)(?:[\/]+|$)/g;
      }
      var nextPartRe;
      if (isWindows) {
        splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
      } else {
        splitRootRe = /^[\/]*/;
      }
      var splitRootRe;
      exports.realpathSync = function realpathSync2(p, cache2) {
        p = pathModule.resolve(p);
        if (cache2 && Object.prototype.hasOwnProperty.call(cache2, p)) {
          return cache2[p];
        }
        var original = p, seenLinks = {}, knownHard = {};
        var pos;
        var current;
        var base;
        var previous;
        start();
        function start() {
          var m = splitRootRe.exec(p);
          pos = m[0].length;
          current = m[0];
          base = m[0];
          previous = "";
          if (isWindows && !knownHard[base]) {
            fs4.lstatSync(base);
            knownHard[base] = true;
          }
        }
        while (pos < p.length) {
          nextPartRe.lastIndex = pos;
          var result = nextPartRe.exec(p);
          previous = current;
          current += result[0];
          base = previous + result[1];
          pos = nextPartRe.lastIndex;
          if (knownHard[base] || cache2 && cache2[base] === base) {
            continue;
          }
          var resolvedLink;
          if (cache2 && Object.prototype.hasOwnProperty.call(cache2, base)) {
            resolvedLink = cache2[base];
          } else {
            var stat = fs4.lstatSync(base);
            if (!stat.isSymbolicLink()) {
              knownHard[base] = true;
              if (cache2)
                cache2[base] = base;
              continue;
            }
            var linkTarget = null;
            if (!isWindows) {
              var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
              if (seenLinks.hasOwnProperty(id)) {
                linkTarget = seenLinks[id];
              }
            }
            if (linkTarget === null) {
              fs4.statSync(base);
              linkTarget = fs4.readlinkSync(base);
            }
            resolvedLink = pathModule.resolve(previous, linkTarget);
            if (cache2)
              cache2[base] = resolvedLink;
            if (!isWindows)
              seenLinks[id] = linkTarget;
          }
          p = pathModule.resolve(resolvedLink, p.slice(pos));
          start();
        }
        if (cache2)
          cache2[original] = p;
        return p;
      };
      exports.realpath = function realpath2(p, cache2, cb) {
        if (typeof cb !== "function") {
          cb = maybeCallback(cache2);
          cache2 = null;
        }
        p = pathModule.resolve(p);
        if (cache2 && Object.prototype.hasOwnProperty.call(cache2, p)) {
          return process.nextTick(cb.bind(null, null, cache2[p]));
        }
        var original = p, seenLinks = {}, knownHard = {};
        var pos;
        var current;
        var base;
        var previous;
        start();
        function start() {
          var m = splitRootRe.exec(p);
          pos = m[0].length;
          current = m[0];
          base = m[0];
          previous = "";
          if (isWindows && !knownHard[base]) {
            fs4.lstat(base, function(err) {
              if (err)
                return cb(err);
              knownHard[base] = true;
              LOOP();
            });
          } else {
            process.nextTick(LOOP);
          }
        }
        function LOOP() {
          if (pos >= p.length) {
            if (cache2)
              cache2[original] = p;
            return cb(null, p);
          }
          nextPartRe.lastIndex = pos;
          var result = nextPartRe.exec(p);
          previous = current;
          current += result[0];
          base = previous + result[1];
          pos = nextPartRe.lastIndex;
          if (knownHard[base] || cache2 && cache2[base] === base) {
            return process.nextTick(LOOP);
          }
          if (cache2 && Object.prototype.hasOwnProperty.call(cache2, base)) {
            return gotResolvedLink(cache2[base]);
          }
          return fs4.lstat(base, gotStat);
        }
        function gotStat(err, stat) {
          if (err)
            return cb(err);
          if (!stat.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache2)
              cache2[base] = base;
            return process.nextTick(LOOP);
          }
          if (!isWindows) {
            var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              return gotTarget(null, seenLinks[id], base);
            }
          }
          fs4.stat(base, function(err2) {
            if (err2)
              return cb(err2);
            fs4.readlink(base, function(err3, target) {
              if (!isWindows)
                seenLinks[id] = target;
              gotTarget(err3, target);
            });
          });
        }
        function gotTarget(err, target, base2) {
          if (err)
            return cb(err);
          var resolvedLink = pathModule.resolve(previous, target);
          if (cache2)
            cache2[base2] = resolvedLink;
          gotResolvedLink(resolvedLink);
        }
        function gotResolvedLink(resolvedLink) {
          p = pathModule.resolve(resolvedLink, p.slice(pos));
          start();
        }
      };
    }
  });

  // ../../node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/index.js
  var require_fs = __commonJS({
    "../../node_modules/.pnpm/fs.realpath@1.0.0/node_modules/fs.realpath/index.js"(exports, module2) {
      module2.exports = realpath2;
      realpath2.realpath = realpath2;
      realpath2.sync = realpathSync2;
      realpath2.realpathSync = realpathSync2;
      realpath2.monkeypatch = monkeypatch;
      realpath2.unmonkeypatch = unmonkeypatch;
      var fs4 = __require2("fs");
      var origRealpath = fs4.realpath;
      var origRealpathSync = fs4.realpathSync;
      var version2 = process.version;
      var ok = /^v[0-5]\./.test(version2);
      var old = require_old();
      function newError(er) {
        return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
      }
      function realpath2(p, cache2, cb) {
        if (ok) {
          return origRealpath(p, cache2, cb);
        }
        if (typeof cache2 === "function") {
          cb = cache2;
          cache2 = null;
        }
        origRealpath(p, cache2, function(er, result) {
          if (newError(er)) {
            old.realpath(p, cache2, cb);
          } else {
            cb(er, result);
          }
        });
      }
      function realpathSync2(p, cache2) {
        if (ok) {
          return origRealpathSync(p, cache2);
        }
        try {
          return origRealpathSync(p, cache2);
        } catch (er) {
          if (newError(er)) {
            return old.realpathSync(p, cache2);
          } else {
            throw er;
          }
        }
      }
      function monkeypatch() {
        fs4.realpath = realpath2;
        fs4.realpathSync = realpathSync2;
      }
      function unmonkeypatch() {
        fs4.realpath = origRealpath;
        fs4.realpathSync = origRealpathSync;
      }
    }
  });

  // ../../node_modules/.pnpm/concat-map@0.0.1/node_modules/concat-map/index.js
  var require_concat_map = __commonJS({
    "../../node_modules/.pnpm/concat-map@0.0.1/node_modules/concat-map/index.js"(exports, module2) {
      module2.exports = function(xs, fn) {
        var res = [];
        for (var i = 0; i < xs.length; i++) {
          var x = fn(xs[i], i);
          if (isArray(x))
            res.push.apply(res, x);
          else
            res.push(x);
        }
        return res;
      };
      var isArray = Array.isArray || function(xs) {
        return Object.prototype.toString.call(xs) === "[object Array]";
      };
    }
  });

  // ../../node_modules/.pnpm/brace-expansion@1.1.11/node_modules/brace-expansion/index.js
  var require_brace_expansion2 = __commonJS({
    "../../node_modules/.pnpm/brace-expansion@1.1.11/node_modules/brace-expansion/index.js"(exports, module2) {
      var concatMap = require_concat_map();
      var balanced = require_balanced_match();
      module2.exports = expandTop;
      var escSlash = "\0SLASH" + Math.random() + "\0";
      var escOpen = "\0OPEN" + Math.random() + "\0";
      var escClose = "\0CLOSE" + Math.random() + "\0";
      var escComma = "\0COMMA" + Math.random() + "\0";
      var escPeriod = "\0PERIOD" + Math.random() + "\0";
      function numeric(str) {
        return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
      }
      function escapeBraces(str) {
        return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
      }
      function unescapeBraces(str) {
        return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
      }
      function parseCommaParts(str) {
        if (!str)
          return [""];
        var parts = [];
        var m = balanced("{", "}", str);
        if (!m)
          return str.split(",");
        var pre = m.pre;
        var body = m.body;
        var post = m.post;
        var p = pre.split(",");
        p[p.length - 1] += "{" + body + "}";
        var postParts = parseCommaParts(post);
        if (post.length) {
          p[p.length - 1] += postParts.shift();
          p.push.apply(p, postParts);
        }
        parts.push.apply(parts, p);
        return parts;
      }
      function expandTop(str) {
        if (!str)
          return [];
        if (str.substr(0, 2) === "{}") {
          str = "\\{\\}" + str.substr(2);
        }
        return expand2(escapeBraces(str), true).map(unescapeBraces);
      }
      function embrace(str) {
        return "{" + str + "}";
      }
      function isPadded(el) {
        return /^-?0\d/.test(el);
      }
      function lte(i, y) {
        return i <= y;
      }
      function gte(i, y) {
        return i >= y;
      }
      function expand2(str, isTop) {
        var expansions = [];
        var m = balanced("{", "}", str);
        if (!m || /\$$/.test(m.pre))
          return [str];
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand2(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand2(n[0], false).map(embrace);
            if (n.length === 1) {
              var post = m.post.length ? expand2(m.post, false) : [""];
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var pre = m.pre;
        var post = m.post.length ? expand2(m.post, false) : [""];
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad3 = n.some(isPadded);
          N = [];
          for (var i = x; test(i, y); i += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i);
              if (c === "\\")
                c = "";
            } else {
              c = String(i);
              if (pad3) {
                var need = width - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = concatMap(n, function(el) {
            return expand2(el, false);
          });
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
        return expansions;
      }
    }
  });

  // ../../node_modules/.pnpm/minimatch@3.1.2/node_modules/minimatch/minimatch.js
  var require_minimatch = __commonJS({
    "../../node_modules/.pnpm/minimatch@3.1.2/node_modules/minimatch/minimatch.js"(exports, module2) {
      module2.exports = minimatch2;
      minimatch2.Minimatch = Minimatch2;
      var path4 = function() {
        try {
          return __require2("path");
        } catch (e) {
        }
      }() || {
        sep: "/"
      };
      minimatch2.sep = path4.sep;
      var GLOBSTAR2 = minimatch2.GLOBSTAR = Minimatch2.GLOBSTAR = {};
      var expand2 = require_brace_expansion2();
      var plTypes = {
        "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
        "?": { open: "(?:", close: ")?" },
        "+": { open: "(?:", close: ")+" },
        "*": { open: "(?:", close: ")*" },
        "@": { open: "(?:", close: ")" }
      };
      var qmark3 = "[^/]";
      var star3 = qmark3 + "*?";
      var twoStarDot2 = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
      var twoStarNoDot2 = "(?:(?!(?:\\/|^)\\.).)*?";
      var reSpecials2 = charSet("().*{}+?[]^$\\!");
      function charSet(s) {
        return s.split("").reduce(function(set2, c) {
          set2[c] = true;
          return set2;
        }, {});
      }
      var slashSplit = /\/+/;
      minimatch2.filter = filter2;
      function filter2(pattern, options) {
        options = options || {};
        return function(p, i, list) {
          return minimatch2(p, pattern, options);
        };
      }
      function ext2(a, b) {
        b = b || {};
        var t = {};
        Object.keys(a).forEach(function(k) {
          t[k] = a[k];
        });
        Object.keys(b).forEach(function(k) {
          t[k] = b[k];
        });
        return t;
      }
      minimatch2.defaults = function(def) {
        if (!def || typeof def !== "object" || !Object.keys(def).length) {
          return minimatch2;
        }
        var orig = minimatch2;
        var m = function minimatch3(p, pattern, options) {
          return orig(p, pattern, ext2(def, options));
        };
        m.Minimatch = function Minimatch3(pattern, options) {
          return new orig.Minimatch(pattern, ext2(def, options));
        };
        m.Minimatch.defaults = function defaults2(options) {
          return orig.defaults(ext2(def, options)).Minimatch;
        };
        m.filter = function filter3(pattern, options) {
          return orig.filter(pattern, ext2(def, options));
        };
        m.defaults = function defaults2(options) {
          return orig.defaults(ext2(def, options));
        };
        m.makeRe = function makeRe3(pattern, options) {
          return orig.makeRe(pattern, ext2(def, options));
        };
        m.braceExpand = function braceExpand3(pattern, options) {
          return orig.braceExpand(pattern, ext2(def, options));
        };
        m.match = function(list, pattern, options) {
          return orig.match(list, pattern, ext2(def, options));
        };
        return m;
      };
      Minimatch2.defaults = function(def) {
        return minimatch2.defaults(def).Minimatch;
      };
      function minimatch2(p, pattern, options) {
        assertValidPattern2(pattern);
        if (!options)
          options = {};
        if (!options.nocomment && pattern.charAt(0) === "#") {
          return false;
        }
        return new Minimatch2(pattern, options).match(p);
      }
      function Minimatch2(pattern, options) {
        if (!(this instanceof Minimatch2)) {
          return new Minimatch2(pattern, options);
        }
        assertValidPattern2(pattern);
        if (!options)
          options = {};
        pattern = pattern.trim();
        if (!options.allowWindowsEscape && path4.sep !== "/") {
          pattern = pattern.split(path4.sep).join("/");
        }
        this.options = options;
        this.set = [];
        this.pattern = pattern;
        this.regexp = null;
        this.negate = false;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.make();
      }
      Minimatch2.prototype.debug = function() {
      };
      Minimatch2.prototype.make = make;
      function make() {
        var pattern = this.pattern;
        var options = this.options;
        if (!options.nocomment && pattern.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        var set2 = this.globSet = this.braceExpand();
        if (options.debug)
          this.debug = function debug2() {
            console.error.apply(console, arguments);
          };
        this.debug(this.pattern, set2);
        set2 = this.globParts = set2.map(function(s) {
          return s.split(slashSplit);
        });
        this.debug(this.pattern, set2);
        set2 = set2.map(function(s, si, set3) {
          return s.map(this.parse, this);
        }, this);
        this.debug(this.pattern, set2);
        set2 = set2.filter(function(s) {
          return s.indexOf(false) === -1;
        });
        this.debug(this.pattern, set2);
        this.set = set2;
      }
      Minimatch2.prototype.parseNegate = parseNegate;
      function parseNegate() {
        var pattern = this.pattern;
        var negate = false;
        var options = this.options;
        var negateOffset = 0;
        if (options.nonegate)
          return;
        for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset)
          this.pattern = pattern.substr(negateOffset);
        this.negate = negate;
      }
      minimatch2.braceExpand = function(pattern, options) {
        return braceExpand2(pattern, options);
      };
      Minimatch2.prototype.braceExpand = braceExpand2;
      function braceExpand2(pattern, options) {
        if (!options) {
          if (this instanceof Minimatch2) {
            options = this.options;
          } else {
            options = {};
          }
        }
        pattern = typeof pattern === "undefined" ? this.pattern : pattern;
        assertValidPattern2(pattern);
        if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
          return [pattern];
        }
        return expand2(pattern);
      }
      var MAX_PATTERN_LENGTH2 = 1024 * 64;
      var assertValidPattern2 = function(pattern) {
        if (typeof pattern !== "string") {
          throw new TypeError("invalid pattern");
        }
        if (pattern.length > MAX_PATTERN_LENGTH2) {
          throw new TypeError("pattern is too long");
        }
      };
      Minimatch2.prototype.parse = parse3;
      var SUBPARSE = {};
      function parse3(pattern, isSub) {
        assertValidPattern2(pattern);
        var options = this.options;
        if (pattern === "**") {
          if (!options.noglobstar)
            return GLOBSTAR2;
          else
            pattern = "*";
        }
        if (pattern === "")
          return "";
        var re = "";
        var hasMagic2 = !!options.nocase;
        var escaping = false;
        var patternListStack = [];
        var negativeLists = [];
        var stateChar;
        var inClass = false;
        var reClassStart = -1;
        var classStart = -1;
        var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        var self2 = this;
        function clearStateChar() {
          if (stateChar) {
            switch (stateChar) {
              case "*":
                re += star3;
                hasMagic2 = true;
                break;
              case "?":
                re += qmark3;
                hasMagic2 = true;
                break;
              default:
                re += "\\" + stateChar;
                break;
            }
            self2.debug("clearStateChar %j %j", stateChar, re);
            stateChar = false;
          }
        }
        for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
          this.debug("%s	%s %s %j", pattern, i, re, c);
          if (escaping && reSpecials2[c]) {
            re += "\\" + c;
            escaping = false;
            continue;
          }
          switch (c) {
            case "/": {
              return false;
            }
            case "\\":
              clearStateChar();
              escaping = true;
              continue;
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
              if (inClass) {
                this.debug("  in class");
                if (c === "!" && i === classStart + 1)
                  c = "^";
                re += c;
                continue;
              }
              self2.debug("call clearStateChar %j", stateChar);
              clearStateChar();
              stateChar = c;
              if (options.noext)
                clearStateChar();
              continue;
            case "(":
              if (inClass) {
                re += "(";
                continue;
              }
              if (!stateChar) {
                re += "\\(";
                continue;
              }
              patternListStack.push({
                type: stateChar,
                start: i - 1,
                reStart: re.length,
                open: plTypes[stateChar].open,
                close: plTypes[stateChar].close
              });
              re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
              this.debug("plType %j %j", stateChar, re);
              stateChar = false;
              continue;
            case ")":
              if (inClass || !patternListStack.length) {
                re += "\\)";
                continue;
              }
              clearStateChar();
              hasMagic2 = true;
              var pl = patternListStack.pop();
              re += pl.close;
              if (pl.type === "!") {
                negativeLists.push(pl);
              }
              pl.reEnd = re.length;
              continue;
            case "|":
              if (inClass || !patternListStack.length || escaping) {
                re += "\\|";
                escaping = false;
                continue;
              }
              clearStateChar();
              re += "|";
              continue;
            case "[":
              clearStateChar();
              if (inClass) {
                re += "\\" + c;
                continue;
              }
              inClass = true;
              classStart = i;
              reClassStart = re.length;
              re += c;
              continue;
            case "]":
              if (i === classStart + 1 || !inClass) {
                re += "\\" + c;
                escaping = false;
                continue;
              }
              var cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                var sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic2 = hasMagic2 || sp[1];
                inClass = false;
                continue;
              }
              hasMagic2 = true;
              inClass = false;
              re += c;
              continue;
            default:
              clearStateChar();
              if (escaping) {
                escaping = false;
              } else if (reSpecials2[c] && !(c === "^" && inClass)) {
                re += "\\";
              }
              re += c;
          }
        }
        if (inClass) {
          cs = pattern.substr(classStart + 1);
          sp = this.parse(cs, SUBPARSE);
          re = re.substr(0, reClassStart) + "\\[" + sp[0];
          hasMagic2 = hasMagic2 || sp[1];
        }
        for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
          var tail = re.slice(pl.reStart + pl.open.length);
          this.debug("setting tail", re, pl);
          tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
            if (!$2) {
              $2 = "\\";
            }
            return $1 + $1 + $2 + "|";
          });
          this.debug("tail=%j\n   %s", tail, tail, pl, re);
          var t = pl.type === "*" ? star3 : pl.type === "?" ? qmark3 : "\\" + pl.type;
          hasMagic2 = true;
          re = re.slice(0, pl.reStart) + t + "\\(" + tail;
        }
        clearStateChar();
        if (escaping) {
          re += "\\\\";
        }
        var addPatternStart2 = false;
        switch (re.charAt(0)) {
          case "[":
          case ".":
          case "(":
            addPatternStart2 = true;
        }
        for (var n = negativeLists.length - 1; n > -1; n--) {
          var nl = negativeLists[n];
          var nlBefore = re.slice(0, nl.reStart);
          var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
          var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
          var nlAfter = re.slice(nl.reEnd);
          nlLast += nlAfter;
          var openParensBefore = nlBefore.split("(").length - 1;
          var cleanAfter = nlAfter;
          for (i = 0; i < openParensBefore; i++) {
            cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
          }
          nlAfter = cleanAfter;
          var dollar = "";
          if (nlAfter === "" && isSub !== SUBPARSE) {
            dollar = "$";
          }
          var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
          re = newRe;
        }
        if (re !== "" && hasMagic2) {
          re = "(?=.)" + re;
        }
        if (addPatternStart2) {
          re = patternStart + re;
        }
        if (isSub === SUBPARSE) {
          return [re, hasMagic2];
        }
        if (!hasMagic2) {
          return globUnescape(pattern);
        }
        var flags = options.nocase ? "i" : "";
        try {
          var regExp = new RegExp("^" + re + "$", flags);
        } catch (er) {
          return new RegExp("$.");
        }
        regExp._glob = pattern;
        regExp._src = re;
        return regExp;
      }
      minimatch2.makeRe = function(pattern, options) {
        return new Minimatch2(pattern, options || {}).makeRe();
      };
      Minimatch2.prototype.makeRe = makeRe2;
      function makeRe2() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        var set2 = this.set;
        if (!set2.length) {
          this.regexp = false;
          return this.regexp;
        }
        var options = this.options;
        var twoStar = options.noglobstar ? star3 : options.dot ? twoStarDot2 : twoStarNoDot2;
        var flags = options.nocase ? "i" : "";
        var re = set2.map(function(pattern) {
          return pattern.map(function(p) {
            return p === GLOBSTAR2 ? twoStar : typeof p === "string" ? regExpEscape3(p) : p._src;
          }).join("\\/");
        }).join("|");
        re = "^(?:" + re + ")$";
        if (this.negate)
          re = "^(?!" + re + ").*$";
        try {
          this.regexp = new RegExp(re, flags);
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      minimatch2.match = function(list, pattern, options) {
        options = options || {};
        var mm = new Minimatch2(pattern, options);
        list = list.filter(function(f2) {
          return mm.match(f2);
        });
        if (mm.options.nonull && !list.length) {
          list.push(pattern);
        }
        return list;
      };
      Minimatch2.prototype.match = function match3(f2, partial) {
        if (typeof partial === "undefined")
          partial = this.partial;
        this.debug("match", f2, this.pattern);
        if (this.comment)
          return false;
        if (this.empty)
          return f2 === "";
        if (f2 === "/" && partial)
          return true;
        var options = this.options;
        if (path4.sep !== "/") {
          f2 = f2.split(path4.sep).join("/");
        }
        f2 = f2.split(slashSplit);
        this.debug(this.pattern, "split", f2);
        var set2 = this.set;
        this.debug(this.pattern, "set", set2);
        var filename;
        var i;
        for (i = f2.length - 1; i >= 0; i--) {
          filename = f2[i];
          if (filename)
            break;
        }
        for (i = 0; i < set2.length; i++) {
          var pattern = set2[i];
          var file = f2;
          if (options.matchBase && pattern.length === 1) {
            file = [filename];
          }
          var hit = this.matchOne(file, pattern, partial);
          if (hit) {
            if (options.flipNegate)
              return true;
            return !this.negate;
          }
        }
        if (options.flipNegate)
          return false;
        return this.negate;
      };
      Minimatch2.prototype.matchOne = function(file, pattern, partial) {
        var options = this.options;
        this.debug(
          "matchOne",
          { "this": this, file, pattern }
        );
        this.debug("matchOne", file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
          this.debug("matchOne loop");
          var p = pattern[pi];
          var f2 = file[fi];
          this.debug(pattern, p, f2);
          if (p === false)
            return false;
          if (p === GLOBSTAR2) {
            this.debug("GLOBSTAR", [pattern, p, f2]);
            var fr = fi;
            var pr = pi + 1;
            if (pr === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                  return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
              if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern, pr);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
              if (fr === fl)
                return true;
            }
            return false;
          }
          var hit;
          if (typeof p === "string") {
            hit = f2 === p;
            this.debug("string match", p, f2, hit);
          } else {
            hit = f2.match(p);
            this.debug("pattern match", p, f2, hit);
          }
          if (!hit)
            return false;
        }
        if (fi === fl && pi === pl) {
          return true;
        } else if (fi === fl) {
          return partial;
        } else if (pi === pl) {
          return fi === fl - 1 && file[fi] === "";
        }
        throw new Error("wtf?");
      };
      function globUnescape(s) {
        return s.replace(/\\(.)/g, "$1");
      }
      function regExpEscape3(s) {
        return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      }
    }
  });

  // ../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits_browser.js"(exports, module2) {
      if (typeof Object.create === "function") {
        module2.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        module2.exports = function inherits(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js
  var require_inherits = __commonJS({
    "../../node_modules/.pnpm/inherits@2.0.4/node_modules/inherits/inherits.js"(exports, module2) {
      try {
        util = __require2("util");
        if (typeof util.inherits !== "function")
          throw "";
        module2.exports = util.inherits;
      } catch (e) {
        module2.exports = require_inherits_browser();
      }
      var util;
    }
  });

  // ../../node_modules/.pnpm/path-is-absolute@1.0.1/node_modules/path-is-absolute/index.js
  var require_path_is_absolute = __commonJS({
    "../../node_modules/.pnpm/path-is-absolute@1.0.1/node_modules/path-is-absolute/index.js"(exports, module2) {
      "use strict";
      function posix2(path4) {
        return path4.charAt(0) === "/";
      }
      function win322(path4) {
        var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
        var result = splitDeviceRe.exec(path4);
        var device = result[1] || "";
        var isUnc = Boolean(device && device.charAt(1) !== ":");
        return Boolean(result[2] || isUnc);
      }
      module2.exports = process.platform === "win32" ? win322 : posix2;
      module2.exports.posix = posix2;
      module2.exports.win32 = win322;
    }
  });

  // ../../node_modules/.pnpm/glob@7.2.3/node_modules/glob/common.js
  var require_common = __commonJS({
    "../../node_modules/.pnpm/glob@7.2.3/node_modules/glob/common.js"(exports) {
      exports.setopts = setopts;
      exports.ownProp = ownProp;
      exports.makeAbs = makeAbs;
      exports.finish = finish;
      exports.mark = mark;
      exports.isIgnored = isIgnored;
      exports.childrenIgnored = childrenIgnored;
      function ownProp(obj, field) {
        return Object.prototype.hasOwnProperty.call(obj, field);
      }
      var fs4 = __require2("fs");
      var path4 = __require2("path");
      var minimatch2 = require_minimatch();
      var isAbsolute = require_path_is_absolute();
      var Minimatch2 = minimatch2.Minimatch;
      function alphasort(a, b) {
        return a.localeCompare(b, "en");
      }
      function setupIgnores(self2, options) {
        self2.ignore = options.ignore || [];
        if (!Array.isArray(self2.ignore))
          self2.ignore = [self2.ignore];
        if (self2.ignore.length) {
          self2.ignore = self2.ignore.map(ignoreMap);
        }
      }
      function ignoreMap(pattern) {
        var gmatcher = null;
        if (pattern.slice(-3) === "/**") {
          var gpattern = pattern.replace(/(\/\*\*)+$/, "");
          gmatcher = new Minimatch2(gpattern, { dot: true });
        }
        return {
          matcher: new Minimatch2(pattern, { dot: true }),
          gmatcher
        };
      }
      function setopts(self2, pattern, options) {
        if (!options)
          options = {};
        if (options.matchBase && -1 === pattern.indexOf("/")) {
          if (options.noglobstar) {
            throw new Error("base matching requires globstar");
          }
          pattern = "**/" + pattern;
        }
        self2.silent = !!options.silent;
        self2.pattern = pattern;
        self2.strict = options.strict !== false;
        self2.realpath = !!options.realpath;
        self2.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
        self2.follow = !!options.follow;
        self2.dot = !!options.dot;
        self2.mark = !!options.mark;
        self2.nodir = !!options.nodir;
        if (self2.nodir)
          self2.mark = true;
        self2.sync = !!options.sync;
        self2.nounique = !!options.nounique;
        self2.nonull = !!options.nonull;
        self2.nosort = !!options.nosort;
        self2.nocase = !!options.nocase;
        self2.stat = !!options.stat;
        self2.noprocess = !!options.noprocess;
        self2.absolute = !!options.absolute;
        self2.fs = options.fs || fs4;
        self2.maxLength = options.maxLength || Infinity;
        self2.cache = options.cache || /* @__PURE__ */ Object.create(null);
        self2.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
        self2.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
        setupIgnores(self2, options);
        self2.changedCwd = false;
        var cwd = process.cwd();
        if (!ownProp(options, "cwd"))
          self2.cwd = cwd;
        else {
          self2.cwd = path4.resolve(options.cwd);
          self2.changedCwd = self2.cwd !== cwd;
        }
        self2.root = options.root || path4.resolve(self2.cwd, "/");
        self2.root = path4.resolve(self2.root);
        if (process.platform === "win32")
          self2.root = self2.root.replace(/\\/g, "/");
        self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
        if (process.platform === "win32")
          self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
        self2.nomount = !!options.nomount;
        options.nonegate = true;
        options.nocomment = true;
        options.allowWindowsEscape = false;
        self2.minimatch = new Minimatch2(pattern, options);
        self2.options = self2.minimatch.options;
      }
      function finish(self2) {
        var nou = self2.nounique;
        var all = nou ? [] : /* @__PURE__ */ Object.create(null);
        for (var i = 0, l = self2.matches.length; i < l; i++) {
          var matches = self2.matches[i];
          if (!matches || Object.keys(matches).length === 0) {
            if (self2.nonull) {
              var literal = self2.minimatch.globSet[i];
              if (nou)
                all.push(literal);
              else
                all[literal] = true;
            }
          } else {
            var m = Object.keys(matches);
            if (nou)
              all.push.apply(all, m);
            else
              m.forEach(function(m2) {
                all[m2] = true;
              });
          }
        }
        if (!nou)
          all = Object.keys(all);
        if (!self2.nosort)
          all = all.sort(alphasort);
        if (self2.mark) {
          for (var i = 0; i < all.length; i++) {
            all[i] = self2._mark(all[i]);
          }
          if (self2.nodir) {
            all = all.filter(function(e) {
              var notDir = !/\/$/.test(e);
              var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
              if (notDir && c)
                notDir = c !== "DIR" && !Array.isArray(c);
              return notDir;
            });
          }
        }
        if (self2.ignore.length)
          all = all.filter(function(m2) {
            return !isIgnored(self2, m2);
          });
        self2.found = all;
      }
      function mark(self2, p) {
        var abs = makeAbs(self2, p);
        var c = self2.cache[abs];
        var m = p;
        if (c) {
          var isDir = c === "DIR" || Array.isArray(c);
          var slash = p.slice(-1) === "/";
          if (isDir && !slash)
            m += "/";
          else if (!isDir && slash)
            m = m.slice(0, -1);
          if (m !== p) {
            var mabs = makeAbs(self2, m);
            self2.statCache[mabs] = self2.statCache[abs];
            self2.cache[mabs] = self2.cache[abs];
          }
        }
        return m;
      }
      function makeAbs(self2, f2) {
        var abs = f2;
        if (f2.charAt(0) === "/") {
          abs = path4.join(self2.root, f2);
        } else if (isAbsolute(f2) || f2 === "") {
          abs = f2;
        } else if (self2.changedCwd) {
          abs = path4.resolve(self2.cwd, f2);
        } else {
          abs = path4.resolve(f2);
        }
        if (process.platform === "win32")
          abs = abs.replace(/\\/g, "/");
        return abs;
      }
      function isIgnored(self2, path5) {
        if (!self2.ignore.length)
          return false;
        return self2.ignore.some(function(item) {
          return item.matcher.match(path5) || !!(item.gmatcher && item.gmatcher.match(path5));
        });
      }
      function childrenIgnored(self2, path5) {
        if (!self2.ignore.length)
          return false;
        return self2.ignore.some(function(item) {
          return !!(item.gmatcher && item.gmatcher.match(path5));
        });
      }
    }
  });

  // ../../node_modules/.pnpm/glob@7.2.3/node_modules/glob/sync.js
  var require_sync = __commonJS({
    "../../node_modules/.pnpm/glob@7.2.3/node_modules/glob/sync.js"(exports, module2) {
      module2.exports = globSync2;
      globSync2.GlobSync = GlobSync;
      var rp = require_fs();
      var minimatch2 = require_minimatch();
      var Minimatch2 = minimatch2.Minimatch;
      var Glob2 = require_glob().Glob;
      var util = __require2("util");
      var path4 = __require2("path");
      var assert5 = __require2("assert");
      var isAbsolute = require_path_is_absolute();
      var common = require_common();
      var setopts = common.setopts;
      var ownProp = common.ownProp;
      var childrenIgnored = common.childrenIgnored;
      var isIgnored = common.isIgnored;
      function globSync2(pattern, options) {
        if (typeof options === "function" || arguments.length === 3)
          throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
        return new GlobSync(pattern, options).found;
      }
      function GlobSync(pattern, options) {
        if (!pattern)
          throw new Error("must provide pattern");
        if (typeof options === "function" || arguments.length === 3)
          throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
        if (!(this instanceof GlobSync))
          return new GlobSync(pattern, options);
        setopts(this, pattern, options);
        if (this.noprocess)
          return this;
        var n = this.minimatch.set.length;
        this.matches = new Array(n);
        for (var i = 0; i < n; i++) {
          this._process(this.minimatch.set[i], i, false);
        }
        this._finish();
      }
      GlobSync.prototype._finish = function() {
        assert5.ok(this instanceof GlobSync);
        if (this.realpath) {
          var self2 = this;
          this.matches.forEach(function(matchset, index) {
            var set2 = self2.matches[index] = /* @__PURE__ */ Object.create(null);
            for (var p in matchset) {
              try {
                p = self2._makeAbs(p);
                var real = rp.realpathSync(p, self2.realpathCache);
                set2[real] = true;
              } catch (er) {
                if (er.syscall === "stat")
                  set2[self2._makeAbs(p)] = true;
                else
                  throw er;
              }
            }
          });
        }
        common.finish(this);
      };
      GlobSync.prototype._process = function(pattern, index, inGlobStar) {
        assert5.ok(this instanceof GlobSync);
        var n = 0;
        while (typeof pattern[n] === "string") {
          n++;
        }
        var prefix;
        switch (n) {
          case pattern.length:
            this._processSimple(pattern.join("/"), index);
            return;
          case 0:
            prefix = null;
            break;
          default:
            prefix = pattern.slice(0, n).join("/");
            break;
        }
        var remain = pattern.slice(n);
        var read;
        if (prefix === null)
          read = ".";
        else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
          return typeof p === "string" ? p : "[*]";
        }).join("/"))) {
          if (!prefix || !isAbsolute(prefix))
            prefix = "/" + prefix;
          read = prefix;
        } else
          read = prefix;
        var abs = this._makeAbs(read);
        if (childrenIgnored(this, read))
          return;
        var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
        if (isGlobStar)
          this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
        else
          this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
      };
      GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
        var entries = this._readdir(abs, inGlobStar);
        if (!entries)
          return;
        var pn = remain[0];
        var negate = !!this.minimatch.negate;
        var rawGlob = pn._glob;
        var dotOk = this.dot || rawGlob.charAt(0) === ".";
        var matchedEntries = [];
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (e.charAt(0) !== "." || dotOk) {
            var m;
            if (negate && !prefix) {
              m = !e.match(pn);
            } else {
              m = e.match(pn);
            }
            if (m)
              matchedEntries.push(e);
          }
        }
        var len = matchedEntries.length;
        if (len === 0)
          return;
        if (remain.length === 1 && !this.mark && !this.stat) {
          if (!this.matches[index])
            this.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var i = 0; i < len; i++) {
            var e = matchedEntries[i];
            if (prefix) {
              if (prefix.slice(-1) !== "/")
                e = prefix + "/" + e;
              else
                e = prefix + e;
            }
            if (e.charAt(0) === "/" && !this.nomount) {
              e = path4.join(this.root, e);
            }
            this._emitMatch(index, e);
          }
          return;
        }
        remain.shift();
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          var newPattern;
          if (prefix)
            newPattern = [prefix, e];
          else
            newPattern = [e];
          this._process(newPattern.concat(remain), index, inGlobStar);
        }
      };
      GlobSync.prototype._emitMatch = function(index, e) {
        if (isIgnored(this, e))
          return;
        var abs = this._makeAbs(e);
        if (this.mark)
          e = this._mark(e);
        if (this.absolute) {
          e = abs;
        }
        if (this.matches[index][e])
          return;
        if (this.nodir) {
          var c = this.cache[abs];
          if (c === "DIR" || Array.isArray(c))
            return;
        }
        this.matches[index][e] = true;
        if (this.stat)
          this._stat(e);
      };
      GlobSync.prototype._readdirInGlobStar = function(abs) {
        if (this.follow)
          return this._readdir(abs, false);
        var entries;
        var lstat2;
        var stat;
        try {
          lstat2 = this.fs.lstatSync(abs);
        } catch (er) {
          if (er.code === "ENOENT") {
            return null;
          }
        }
        var isSym = lstat2 && lstat2.isSymbolicLink();
        this.symlinks[abs] = isSym;
        if (!isSym && lstat2 && !lstat2.isDirectory())
          this.cache[abs] = "FILE";
        else
          entries = this._readdir(abs, false);
        return entries;
      };
      GlobSync.prototype._readdir = function(abs, inGlobStar) {
        var entries;
        if (inGlobStar && !ownProp(this.symlinks, abs))
          return this._readdirInGlobStar(abs);
        if (ownProp(this.cache, abs)) {
          var c = this.cache[abs];
          if (!c || c === "FILE")
            return null;
          if (Array.isArray(c))
            return c;
        }
        try {
          return this._readdirEntries(abs, this.fs.readdirSync(abs));
        } catch (er) {
          this._readdirError(abs, er);
          return null;
        }
      };
      GlobSync.prototype._readdirEntries = function(abs, entries) {
        if (!this.mark && !this.stat) {
          for (var i = 0; i < entries.length; i++) {
            var e = entries[i];
            if (abs === "/")
              e = abs + e;
            else
              e = abs + "/" + e;
            this.cache[e] = true;
          }
        }
        this.cache[abs] = entries;
        return entries;
      };
      GlobSync.prototype._readdirError = function(f2, er) {
        switch (er.code) {
          case "ENOTSUP":
          case "ENOTDIR":
            var abs = this._makeAbs(f2);
            this.cache[abs] = "FILE";
            if (abs === this.cwdAbs) {
              var error2 = new Error(er.code + " invalid cwd " + this.cwd);
              error2.path = this.cwd;
              error2.code = er.code;
              throw error2;
            }
            break;
          case "ENOENT":
          case "ELOOP":
          case "ENAMETOOLONG":
          case "UNKNOWN":
            this.cache[this._makeAbs(f2)] = false;
            break;
          default:
            this.cache[this._makeAbs(f2)] = false;
            if (this.strict)
              throw er;
            if (!this.silent)
              console.error("glob error", er);
            break;
        }
      };
      GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
        var entries = this._readdir(abs, inGlobStar);
        if (!entries)
          return;
        var remainWithoutGlobStar = remain.slice(1);
        var gspref = prefix ? [prefix] : [];
        var noGlobStar = gspref.concat(remainWithoutGlobStar);
        this._process(noGlobStar, index, false);
        var len = entries.length;
        var isSym = this.symlinks[abs];
        if (isSym && inGlobStar)
          return;
        for (var i = 0; i < len; i++) {
          var e = entries[i];
          if (e.charAt(0) === "." && !this.dot)
            continue;
          var instead = gspref.concat(entries[i], remainWithoutGlobStar);
          this._process(instead, index, true);
          var below = gspref.concat(entries[i], remain);
          this._process(below, index, true);
        }
      };
      GlobSync.prototype._processSimple = function(prefix, index) {
        var exists3 = this._stat(prefix);
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        if (!exists3)
          return;
        if (prefix && isAbsolute(prefix) && !this.nomount) {
          var trail = /[\/\\]$/.test(prefix);
          if (prefix.charAt(0) === "/") {
            prefix = path4.join(this.root, prefix);
          } else {
            prefix = path4.resolve(this.root, prefix);
            if (trail)
              prefix += "/";
          }
        }
        if (process.platform === "win32")
          prefix = prefix.replace(/\\/g, "/");
        this._emitMatch(index, prefix);
      };
      GlobSync.prototype._stat = function(f2) {
        var abs = this._makeAbs(f2);
        var needDir = f2.slice(-1) === "/";
        if (f2.length > this.maxLength)
          return false;
        if (!this.stat && ownProp(this.cache, abs)) {
          var c = this.cache[abs];
          if (Array.isArray(c))
            c = "DIR";
          if (!needDir || c === "DIR")
            return c;
          if (needDir && c === "FILE")
            return false;
        }
        var exists3;
        var stat = this.statCache[abs];
        if (!stat) {
          var lstat2;
          try {
            lstat2 = this.fs.lstatSync(abs);
          } catch (er) {
            if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
              this.statCache[abs] = false;
              return false;
            }
          }
          if (lstat2 && lstat2.isSymbolicLink()) {
            try {
              stat = this.fs.statSync(abs);
            } catch (er) {
              stat = lstat2;
            }
          } else {
            stat = lstat2;
          }
        }
        this.statCache[abs] = stat;
        var c = true;
        if (stat)
          c = stat.isDirectory() ? "DIR" : "FILE";
        this.cache[abs] = this.cache[abs] || c;
        if (needDir && c === "FILE")
          return false;
        return c;
      };
      GlobSync.prototype._mark = function(p) {
        return common.mark(this, p);
      };
      GlobSync.prototype._makeAbs = function(f2) {
        return common.makeAbs(this, f2);
      };
    }
  });

  // ../../node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js
  var require_wrappy = __commonJS({
    "../../node_modules/.pnpm/wrappy@1.0.2/node_modules/wrappy/wrappy.js"(exports, module2) {
      module2.exports = wrappy;
      function wrappy(fn, cb) {
        if (fn && cb)
          return wrappy(fn)(cb);
        if (typeof fn !== "function")
          throw new TypeError("need wrapper function");
        Object.keys(fn).forEach(function(k) {
          wrapper[k] = fn[k];
        });
        return wrapper;
        function wrapper() {
          var args = new Array(arguments.length);
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i];
          }
          var ret3 = fn.apply(this, args);
          var cb2 = args[args.length - 1];
          if (typeof ret3 === "function" && ret3 !== cb2) {
            Object.keys(cb2).forEach(function(k) {
              ret3[k] = cb2[k];
            });
          }
          return ret3;
        }
      }
    }
  });

  // ../../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js
  var require_once = __commonJS({
    "../../node_modules/.pnpm/once@1.4.0/node_modules/once/once.js"(exports, module2) {
      var wrappy = require_wrappy();
      module2.exports = wrappy(once2);
      module2.exports.strict = wrappy(onceStrict);
      once2.proto = once2(function() {
        Object.defineProperty(Function.prototype, "once", {
          value: function() {
            return once2(this);
          },
          configurable: true
        });
        Object.defineProperty(Function.prototype, "onceStrict", {
          value: function() {
            return onceStrict(this);
          },
          configurable: true
        });
      });
      function once2(fn) {
        var f2 = function() {
          if (f2.called)
            return f2.value;
          f2.called = true;
          return f2.value = fn.apply(this, arguments);
        };
        f2.called = false;
        return f2;
      }
      function onceStrict(fn) {
        var f2 = function() {
          if (f2.called)
            throw new Error(f2.onceError);
          f2.called = true;
          return f2.value = fn.apply(this, arguments);
        };
        var name = fn.name || "Function wrapped with `once`";
        f2.onceError = name + " shouldn't be called more than once";
        f2.called = false;
        return f2;
      }
    }
  });

  // ../../node_modules/.pnpm/inflight@1.0.6/node_modules/inflight/inflight.js
  var require_inflight = __commonJS({
    "../../node_modules/.pnpm/inflight@1.0.6/node_modules/inflight/inflight.js"(exports, module2) {
      var wrappy = require_wrappy();
      var reqs = /* @__PURE__ */ Object.create(null);
      var once2 = require_once();
      module2.exports = wrappy(inflight);
      function inflight(key, cb) {
        if (reqs[key]) {
          reqs[key].push(cb);
          return null;
        } else {
          reqs[key] = [cb];
          return makeres(key);
        }
      }
      function makeres(key) {
        return once2(function RES() {
          var cbs = reqs[key];
          var len = cbs.length;
          var args = slice(arguments);
          try {
            for (var i = 0; i < len; i++) {
              cbs[i].apply(null, args);
            }
          } finally {
            if (cbs.length > len) {
              cbs.splice(0, len);
              process.nextTick(function() {
                RES.apply(null, args);
              });
            } else {
              delete reqs[key];
            }
          }
        });
      }
      function slice(args) {
        var length = args.length;
        var array2 = [];
        for (var i = 0; i < length; i++)
          array2[i] = args[i];
        return array2;
      }
    }
  });

  // ../../node_modules/.pnpm/glob@7.2.3/node_modules/glob/glob.js
  var require_glob = __commonJS({
    "../../node_modules/.pnpm/glob@7.2.3/node_modules/glob/glob.js"(exports, module2) {
      module2.exports = glob2;
      var rp = require_fs();
      var minimatch2 = require_minimatch();
      var Minimatch2 = minimatch2.Minimatch;
      var inherits = require_inherits();
      var EE2 = __require2("events").EventEmitter;
      var path4 = __require2("path");
      var assert5 = __require2("assert");
      var isAbsolute = require_path_is_absolute();
      var globSync2 = require_sync();
      var common = require_common();
      var setopts = common.setopts;
      var ownProp = common.ownProp;
      var inflight = require_inflight();
      var util = __require2("util");
      var childrenIgnored = common.childrenIgnored;
      var isIgnored = common.isIgnored;
      var once2 = require_once();
      function glob2(pattern, options, cb) {
        if (typeof options === "function")
          cb = options, options = {};
        if (!options)
          options = {};
        if (options.sync) {
          if (cb)
            throw new TypeError("callback provided to sync glob");
          return globSync2(pattern, options);
        }
        return new Glob2(pattern, options, cb);
      }
      glob2.sync = globSync2;
      var GlobSync = glob2.GlobSync = globSync2.GlobSync;
      glob2.glob = glob2;
      function extend(origin, add3) {
        if (add3 === null || typeof add3 !== "object") {
          return origin;
        }
        var keys4 = Object.keys(add3);
        var i = keys4.length;
        while (i--) {
          origin[keys4[i]] = add3[keys4[i]];
        }
        return origin;
      }
      glob2.hasMagic = function(pattern, options_) {
        var options = extend({}, options_);
        options.noprocess = true;
        var g = new Glob2(pattern, options);
        var set2 = g.minimatch.set;
        if (!pattern)
          return false;
        if (set2.length > 1)
          return true;
        for (var j = 0; j < set2[0].length; j++) {
          if (typeof set2[0][j] !== "string")
            return true;
        }
        return false;
      };
      glob2.Glob = Glob2;
      inherits(Glob2, EE2);
      function Glob2(pattern, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = null;
        }
        if (options && options.sync) {
          if (cb)
            throw new TypeError("callback provided to sync glob");
          return new GlobSync(pattern, options);
        }
        if (!(this instanceof Glob2))
          return new Glob2(pattern, options, cb);
        setopts(this, pattern, options);
        this._didRealPath = false;
        var n = this.minimatch.set.length;
        this.matches = new Array(n);
        if (typeof cb === "function") {
          cb = once2(cb);
          this.on("error", cb);
          this.on("end", function(matches) {
            cb(null, matches);
          });
        }
        var self2 = this;
        this._processing = 0;
        this._emitQueue = [];
        this._processQueue = [];
        this.paused = false;
        if (this.noprocess)
          return this;
        if (n === 0)
          return done();
        var sync2 = true;
        for (var i = 0; i < n; i++) {
          this._process(this.minimatch.set[i], i, false, done);
        }
        sync2 = false;
        function done() {
          --self2._processing;
          if (self2._processing <= 0) {
            if (sync2) {
              process.nextTick(function() {
                self2._finish();
              });
            } else {
              self2._finish();
            }
          }
        }
      }
      Glob2.prototype._finish = function() {
        assert5(this instanceof Glob2);
        if (this.aborted)
          return;
        if (this.realpath && !this._didRealpath)
          return this._realpath();
        common.finish(this);
        this.emit("end", this.found);
      };
      Glob2.prototype._realpath = function() {
        if (this._didRealpath)
          return;
        this._didRealpath = true;
        var n = this.matches.length;
        if (n === 0)
          return this._finish();
        var self2 = this;
        for (var i = 0; i < this.matches.length; i++)
          this._realpathSet(i, next);
        function next() {
          if (--n === 0)
            self2._finish();
        }
      };
      Glob2.prototype._realpathSet = function(index, cb) {
        var matchset = this.matches[index];
        if (!matchset)
          return cb();
        var found = Object.keys(matchset);
        var self2 = this;
        var n = found.length;
        if (n === 0)
          return cb();
        var set2 = this.matches[index] = /* @__PURE__ */ Object.create(null);
        found.forEach(function(p, i) {
          p = self2._makeAbs(p);
          rp.realpath(p, self2.realpathCache, function(er, real) {
            if (!er)
              set2[real] = true;
            else if (er.syscall === "stat")
              set2[p] = true;
            else
              self2.emit("error", er);
            if (--n === 0) {
              self2.matches[index] = set2;
              cb();
            }
          });
        });
      };
      Glob2.prototype._mark = function(p) {
        return common.mark(this, p);
      };
      Glob2.prototype._makeAbs = function(f2) {
        return common.makeAbs(this, f2);
      };
      Glob2.prototype.abort = function() {
        this.aborted = true;
        this.emit("abort");
      };
      Glob2.prototype.pause = function() {
        if (!this.paused) {
          this.paused = true;
          this.emit("pause");
        }
      };
      Glob2.prototype.resume = function() {
        if (this.paused) {
          this.emit("resume");
          this.paused = false;
          if (this._emitQueue.length) {
            var eq = this._emitQueue.slice(0);
            this._emitQueue.length = 0;
            for (var i = 0; i < eq.length; i++) {
              var e = eq[i];
              this._emitMatch(e[0], e[1]);
            }
          }
          if (this._processQueue.length) {
            var pq = this._processQueue.slice(0);
            this._processQueue.length = 0;
            for (var i = 0; i < pq.length; i++) {
              var p = pq[i];
              this._processing--;
              this._process(p[0], p[1], p[2], p[3]);
            }
          }
        }
      };
      Glob2.prototype._process = function(pattern, index, inGlobStar, cb) {
        assert5(this instanceof Glob2);
        assert5(typeof cb === "function");
        if (this.aborted)
          return;
        this._processing++;
        if (this.paused) {
          this._processQueue.push([pattern, index, inGlobStar, cb]);
          return;
        }
        var n = 0;
        while (typeof pattern[n] === "string") {
          n++;
        }
        var prefix;
        switch (n) {
          case pattern.length:
            this._processSimple(pattern.join("/"), index, cb);
            return;
          case 0:
            prefix = null;
            break;
          default:
            prefix = pattern.slice(0, n).join("/");
            break;
        }
        var remain = pattern.slice(n);
        var read;
        if (prefix === null)
          read = ".";
        else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
          return typeof p === "string" ? p : "[*]";
        }).join("/"))) {
          if (!prefix || !isAbsolute(prefix))
            prefix = "/" + prefix;
          read = prefix;
        } else
          read = prefix;
        var abs = this._makeAbs(read);
        if (childrenIgnored(this, read))
          return cb();
        var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
        if (isGlobStar)
          this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
        else
          this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
      };
      Glob2.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
        var self2 = this;
        this._readdir(abs, inGlobStar, function(er, entries) {
          return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
        });
      };
      Glob2.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
        if (!entries)
          return cb();
        var pn = remain[0];
        var negate = !!this.minimatch.negate;
        var rawGlob = pn._glob;
        var dotOk = this.dot || rawGlob.charAt(0) === ".";
        var matchedEntries = [];
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (e.charAt(0) !== "." || dotOk) {
            var m;
            if (negate && !prefix) {
              m = !e.match(pn);
            } else {
              m = e.match(pn);
            }
            if (m)
              matchedEntries.push(e);
          }
        }
        var len = matchedEntries.length;
        if (len === 0)
          return cb();
        if (remain.length === 1 && !this.mark && !this.stat) {
          if (!this.matches[index])
            this.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var i = 0; i < len; i++) {
            var e = matchedEntries[i];
            if (prefix) {
              if (prefix !== "/")
                e = prefix + "/" + e;
              else
                e = prefix + e;
            }
            if (e.charAt(0) === "/" && !this.nomount) {
              e = path4.join(this.root, e);
            }
            this._emitMatch(index, e);
          }
          return cb();
        }
        remain.shift();
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          var newPattern;
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          this._process([e].concat(remain), index, inGlobStar, cb);
        }
        cb();
      };
      Glob2.prototype._emitMatch = function(index, e) {
        if (this.aborted)
          return;
        if (isIgnored(this, e))
          return;
        if (this.paused) {
          this._emitQueue.push([index, e]);
          return;
        }
        var abs = isAbsolute(e) ? e : this._makeAbs(e);
        if (this.mark)
          e = this._mark(e);
        if (this.absolute)
          e = abs;
        if (this.matches[index][e])
          return;
        if (this.nodir) {
          var c = this.cache[abs];
          if (c === "DIR" || Array.isArray(c))
            return;
        }
        this.matches[index][e] = true;
        var st = this.statCache[abs];
        if (st)
          this.emit("stat", e, st);
        this.emit("match", e);
      };
      Glob2.prototype._readdirInGlobStar = function(abs, cb) {
        if (this.aborted)
          return;
        if (this.follow)
          return this._readdir(abs, false, cb);
        var lstatkey = "lstat\0" + abs;
        var self2 = this;
        var lstatcb = inflight(lstatkey, lstatcb_);
        if (lstatcb)
          self2.fs.lstat(abs, lstatcb);
        function lstatcb_(er, lstat2) {
          if (er && er.code === "ENOENT")
            return cb();
          var isSym = lstat2 && lstat2.isSymbolicLink();
          self2.symlinks[abs] = isSym;
          if (!isSym && lstat2 && !lstat2.isDirectory()) {
            self2.cache[abs] = "FILE";
            cb();
          } else
            self2._readdir(abs, false, cb);
        }
      };
      Glob2.prototype._readdir = function(abs, inGlobStar, cb) {
        if (this.aborted)
          return;
        cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
        if (!cb)
          return;
        if (inGlobStar && !ownProp(this.symlinks, abs))
          return this._readdirInGlobStar(abs, cb);
        if (ownProp(this.cache, abs)) {
          var c = this.cache[abs];
          if (!c || c === "FILE")
            return cb();
          if (Array.isArray(c))
            return cb(null, c);
        }
        var self2 = this;
        self2.fs.readdir(abs, readdirCb(this, abs, cb));
      };
      function readdirCb(self2, abs, cb) {
        return function(er, entries) {
          if (er)
            self2._readdirError(abs, er, cb);
          else
            self2._readdirEntries(abs, entries, cb);
        };
      }
      Glob2.prototype._readdirEntries = function(abs, entries, cb) {
        if (this.aborted)
          return;
        if (!this.mark && !this.stat) {
          for (var i = 0; i < entries.length; i++) {
            var e = entries[i];
            if (abs === "/")
              e = abs + e;
            else
              e = abs + "/" + e;
            this.cache[e] = true;
          }
        }
        this.cache[abs] = entries;
        return cb(null, entries);
      };
      Glob2.prototype._readdirError = function(f2, er, cb) {
        if (this.aborted)
          return;
        switch (er.code) {
          case "ENOTSUP":
          case "ENOTDIR":
            var abs = this._makeAbs(f2);
            this.cache[abs] = "FILE";
            if (abs === this.cwdAbs) {
              var error2 = new Error(er.code + " invalid cwd " + this.cwd);
              error2.path = this.cwd;
              error2.code = er.code;
              this.emit("error", error2);
              this.abort();
            }
            break;
          case "ENOENT":
          case "ELOOP":
          case "ENAMETOOLONG":
          case "UNKNOWN":
            this.cache[this._makeAbs(f2)] = false;
            break;
          default:
            this.cache[this._makeAbs(f2)] = false;
            if (this.strict) {
              this.emit("error", er);
              this.abort();
            }
            if (!this.silent)
              console.error("glob error", er);
            break;
        }
        return cb();
      };
      Glob2.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
        var self2 = this;
        this._readdir(abs, inGlobStar, function(er, entries) {
          self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
        });
      };
      Glob2.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
        if (!entries)
          return cb();
        var remainWithoutGlobStar = remain.slice(1);
        var gspref = prefix ? [prefix] : [];
        var noGlobStar = gspref.concat(remainWithoutGlobStar);
        this._process(noGlobStar, index, false, cb);
        var isSym = this.symlinks[abs];
        var len = entries.length;
        if (isSym && inGlobStar)
          return cb();
        for (var i = 0; i < len; i++) {
          var e = entries[i];
          if (e.charAt(0) === "." && !this.dot)
            continue;
          var instead = gspref.concat(entries[i], remainWithoutGlobStar);
          this._process(instead, index, true, cb);
          var below = gspref.concat(entries[i], remain);
          this._process(below, index, true, cb);
        }
        cb();
      };
      Glob2.prototype._processSimple = function(prefix, index, cb) {
        var self2 = this;
        this._stat(prefix, function(er, exists3) {
          self2._processSimple2(prefix, index, er, exists3, cb);
        });
      };
      Glob2.prototype._processSimple2 = function(prefix, index, er, exists3, cb) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        if (!exists3)
          return cb();
        if (prefix && isAbsolute(prefix) && !this.nomount) {
          var trail = /[\/\\]$/.test(prefix);
          if (prefix.charAt(0) === "/") {
            prefix = path4.join(this.root, prefix);
          } else {
            prefix = path4.resolve(this.root, prefix);
            if (trail)
              prefix += "/";
          }
        }
        if (process.platform === "win32")
          prefix = prefix.replace(/\\/g, "/");
        this._emitMatch(index, prefix);
        cb();
      };
      Glob2.prototype._stat = function(f2, cb) {
        var abs = this._makeAbs(f2);
        var needDir = f2.slice(-1) === "/";
        if (f2.length > this.maxLength)
          return cb();
        if (!this.stat && ownProp(this.cache, abs)) {
          var c = this.cache[abs];
          if (Array.isArray(c))
            c = "DIR";
          if (!needDir || c === "DIR")
            return cb(null, c);
          if (needDir && c === "FILE")
            return cb();
        }
        var exists3;
        var stat = this.statCache[abs];
        if (stat !== void 0) {
          if (stat === false)
            return cb(null, stat);
          else {
            var type3 = stat.isDirectory() ? "DIR" : "FILE";
            if (needDir && type3 === "FILE")
              return cb();
            else
              return cb(null, type3, stat);
          }
        }
        var self2 = this;
        var statcb = inflight("stat\0" + abs, lstatcb_);
        if (statcb)
          self2.fs.lstat(abs, statcb);
        function lstatcb_(er, lstat2) {
          if (lstat2 && lstat2.isSymbolicLink()) {
            return self2.fs.stat(abs, function(er2, stat2) {
              if (er2)
                self2._stat2(f2, abs, null, lstat2, cb);
              else
                self2._stat2(f2, abs, er2, stat2, cb);
            });
          } else {
            self2._stat2(f2, abs, er, lstat2, cb);
          }
        }
      };
      Glob2.prototype._stat2 = function(f2, abs, er, stat, cb) {
        if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
          this.statCache[abs] = false;
          return cb();
        }
        var needDir = f2.slice(-1) === "/";
        this.statCache[abs] = stat;
        if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
          return cb(null, false, stat);
        var c = true;
        if (stat)
          c = stat.isDirectory() ? "DIR" : "FILE";
        this.cache[abs] = this.cache[abs] || c;
        if (needDir && c === "FILE")
          return cb();
        return cb(null, c, stat);
      };
    }
  });

  // ../../node_modules/.pnpm/rimraf@3.0.2/node_modules/rimraf/rimraf.js
  var require_rimraf = __commonJS({
    "../../node_modules/.pnpm/rimraf@3.0.2/node_modules/rimraf/rimraf.js"(exports, module2) {
      var assert5 = __require2("assert");
      var path4 = __require2("path");
      var fs4 = __require2("fs");
      var glob2 = void 0;
      try {
        glob2 = require_glob();
      } catch (_err) {
      }
      var defaultGlobOpts = {
        nosort: true,
        silent: true
      };
      var timeout = 0;
      var isWindows = process.platform === "win32";
      var defaults2 = (options) => {
        const methods = [
          "unlink",
          "chmod",
          "stat",
          "lstat",
          "rmdir",
          "readdir"
        ];
        methods.forEach((m) => {
          options[m] = options[m] || fs4[m];
          m = m + "Sync";
          options[m] = options[m] || fs4[m];
        });
        options.maxBusyTries = options.maxBusyTries || 3;
        options.emfileWait = options.emfileWait || 1e3;
        if (options.glob === false) {
          options.disableGlob = true;
        }
        if (options.disableGlob !== true && glob2 === void 0) {
          throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
        }
        options.disableGlob = options.disableGlob || false;
        options.glob = options.glob || defaultGlobOpts;
      };
      var rimraf3 = (p, options, cb) => {
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        assert5(p, "rimraf: missing path");
        assert5.equal(typeof p, "string", "rimraf: path should be a string");
        assert5.equal(typeof cb, "function", "rimraf: callback function required");
        assert5(options, "rimraf: invalid options argument provided");
        assert5.equal(typeof options, "object", "rimraf: options should be object");
        defaults2(options);
        let busyTries = 0;
        let errState = null;
        let n = 0;
        const next = (er) => {
          errState = errState || er;
          if (--n === 0)
            cb(errState);
        };
        const afterGlob = (er, results) => {
          if (er)
            return cb(er);
          n = results.length;
          if (n === 0)
            return cb();
          results.forEach((p2) => {
            const CB = (er2) => {
              if (er2) {
                if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
                  busyTries++;
                  return setTimeout(() => rimraf_(p2, options, CB), busyTries * 100);
                }
                if (er2.code === "EMFILE" && timeout < options.emfileWait) {
                  return setTimeout(() => rimraf_(p2, options, CB), timeout++);
                }
                if (er2.code === "ENOENT")
                  er2 = null;
              }
              timeout = 0;
              next(er2);
            };
            rimraf_(p2, options, CB);
          });
        };
        if (options.disableGlob || !glob2.hasMagic(p))
          return afterGlob(null, [p]);
        options.lstat(p, (er, stat) => {
          if (!er)
            return afterGlob(null, [p]);
          glob2(p, options.glob, afterGlob);
        });
      };
      var rimraf_ = (p, options, cb) => {
        assert5(p);
        assert5(options);
        assert5(typeof cb === "function");
        options.lstat(p, (er, st) => {
          if (er && er.code === "ENOENT")
            return cb(null);
          if (er && er.code === "EPERM" && isWindows)
            fixWinEPERM(p, options, er, cb);
          if (st && st.isDirectory())
            return rmdir(p, options, er, cb);
          options.unlink(p, (er2) => {
            if (er2) {
              if (er2.code === "ENOENT")
                return cb(null);
              if (er2.code === "EPERM")
                return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
              if (er2.code === "EISDIR")
                return rmdir(p, options, er2, cb);
            }
            return cb(er2);
          });
        });
      };
      var fixWinEPERM = (p, options, er, cb) => {
        assert5(p);
        assert5(options);
        assert5(typeof cb === "function");
        options.chmod(p, 438, (er2) => {
          if (er2)
            cb(er2.code === "ENOENT" ? null : er);
          else
            options.stat(p, (er3, stats) => {
              if (er3)
                cb(er3.code === "ENOENT" ? null : er);
              else if (stats.isDirectory())
                rmdir(p, options, er, cb);
              else
                options.unlink(p, cb);
            });
        });
      };
      var fixWinEPERMSync = (p, options, er) => {
        assert5(p);
        assert5(options);
        try {
          options.chmodSync(p, 438);
        } catch (er2) {
          if (er2.code === "ENOENT")
            return;
          else
            throw er;
        }
        let stats;
        try {
          stats = options.statSync(p);
        } catch (er3) {
          if (er3.code === "ENOENT")
            return;
          else
            throw er;
        }
        if (stats.isDirectory())
          rmdirSync(p, options, er);
        else
          options.unlinkSync(p);
      };
      var rmdir = (p, options, originalEr, cb) => {
        assert5(p);
        assert5(options);
        assert5(typeof cb === "function");
        options.rmdir(p, (er) => {
          if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
            rmkids(p, options, cb);
          else if (er && er.code === "ENOTDIR")
            cb(originalEr);
          else
            cb(er);
        });
      };
      var rmkids = (p, options, cb) => {
        assert5(p);
        assert5(options);
        assert5(typeof cb === "function");
        options.readdir(p, (er, files) => {
          if (er)
            return cb(er);
          let n = files.length;
          if (n === 0)
            return options.rmdir(p, cb);
          let errState;
          files.forEach((f2) => {
            rimraf3(path4.join(p, f2), options, (er2) => {
              if (errState)
                return;
              if (er2)
                return cb(errState = er2);
              if (--n === 0)
                options.rmdir(p, cb);
            });
          });
        });
      };
      var rimrafSync = (p, options) => {
        options = options || {};
        defaults2(options);
        assert5(p, "rimraf: missing path");
        assert5.equal(typeof p, "string", "rimraf: path should be a string");
        assert5(options, "rimraf: missing options");
        assert5.equal(typeof options, "object", "rimraf: options should be object");
        let results;
        if (options.disableGlob || !glob2.hasMagic(p)) {
          results = [p];
        } else {
          try {
            options.lstatSync(p);
            results = [p];
          } catch (er) {
            results = glob2.sync(p, options.glob);
          }
        }
        if (!results.length)
          return;
        for (let i = 0; i < results.length; i++) {
          const p2 = results[i];
          let st;
          try {
            st = options.lstatSync(p2);
          } catch (er) {
            if (er.code === "ENOENT")
              return;
            if (er.code === "EPERM" && isWindows)
              fixWinEPERMSync(p2, options, er);
          }
          try {
            if (st && st.isDirectory())
              rmdirSync(p2, options, null);
            else
              options.unlinkSync(p2);
          } catch (er) {
            if (er.code === "ENOENT")
              return;
            if (er.code === "EPERM")
              return isWindows ? fixWinEPERMSync(p2, options, er) : rmdirSync(p2, options, er);
            if (er.code !== "EISDIR")
              throw er;
            rmdirSync(p2, options, er);
          }
        }
      };
      var rmdirSync = (p, options, originalEr) => {
        assert5(p);
        assert5(options);
        try {
          options.rmdirSync(p);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "ENOTDIR")
            throw originalEr;
          if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
            rmkidsSync(p, options);
        }
      };
      var rmkidsSync = (p, options) => {
        assert5(p);
        assert5(options);
        options.readdirSync(p).forEach((f2) => rimrafSync(path4.join(p, f2), options));
        const retries = isWindows ? 100 : 1;
        let i = 0;
        do {
          let threw = true;
          try {
            const ret3 = options.rmdirSync(p, options);
            threw = false;
            return ret3;
          } finally {
            if (++i < retries && threw)
              continue;
          }
        } while (true);
      };
      module2.exports = rimraf3;
      rimraf3.sync = rimrafSync;
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/utils.js
  var require_utils = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/utils.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.extend = extend;
      exports.indexOf = indexOf;
      exports.escapeExpression = escapeExpression;
      exports.isEmpty = isEmpty;
      exports.createFrame = createFrame;
      exports.blockParams = blockParams;
      exports.appendContextPath = appendContextPath;
      var escape2 = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;",
        "=": "&#x3D;"
      };
      var badChars = /[&<>"'`=]/g;
      var possible = /[&<>"'`=]/;
      function escapeChar(chr) {
        return escape2[chr];
      }
      function extend(obj) {
        for (var i = 1; i < arguments.length; i++) {
          for (var key in arguments[i]) {
            if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
              obj[key] = arguments[i][key];
            }
          }
        }
        return obj;
      }
      var toString3 = Object.prototype.toString;
      exports.toString = toString3;
      var isFunction = function isFunction2(value) {
        return typeof value === "function";
      };
      if (isFunction(/x/)) {
        exports.isFunction = isFunction = function(value) {
          return typeof value === "function" && toString3.call(value) === "[object Function]";
        };
      }
      exports.isFunction = isFunction;
      var isArray = Array.isArray || function(value) {
        return value && typeof value === "object" ? toString3.call(value) === "[object Array]" : false;
      };
      exports.isArray = isArray;
      function indexOf(array2, value) {
        for (var i = 0, len = array2.length; i < len; i++) {
          if (array2[i] === value) {
            return i;
          }
        }
        return -1;
      }
      function escapeExpression(string2) {
        if (typeof string2 !== "string") {
          if (string2 && string2.toHTML) {
            return string2.toHTML();
          } else if (string2 == null) {
            return "";
          } else if (!string2) {
            return string2 + "";
          }
          string2 = "" + string2;
        }
        if (!possible.test(string2)) {
          return string2;
        }
        return string2.replace(badChars, escapeChar);
      }
      function isEmpty(value) {
        if (!value && value !== 0) {
          return true;
        } else if (isArray(value) && value.length === 0) {
          return true;
        } else {
          return false;
        }
      }
      function createFrame(object2) {
        var frame = extend({}, object2);
        frame._parent = object2;
        return frame;
      }
      function blockParams(params, ids) {
        params.path = ids;
        return params;
      }
      function appendContextPath(contextPath, id) {
        return (contextPath ? contextPath + "." : "") + id;
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/exception.js
  var require_exception = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/exception.js"(exports, module2) {
      "use strict";
      exports.__esModule = true;
      var errorProps = ["description", "fileName", "lineNumber", "endLineNumber", "message", "name", "number", "stack"];
      function Exception(message, node) {
        var loc = node && node.loc, line = void 0, endLineNumber = void 0, column = void 0, endColumn = void 0;
        if (loc) {
          line = loc.start.line;
          endLineNumber = loc.end.line;
          column = loc.start.column;
          endColumn = loc.end.column;
          message += " - " + line + ":" + column;
        }
        var tmp = Error.prototype.constructor.call(this, message);
        for (var idx = 0; idx < errorProps.length; idx++) {
          this[errorProps[idx]] = tmp[errorProps[idx]];
        }
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, Exception);
        }
        try {
          if (loc) {
            this.lineNumber = line;
            this.endLineNumber = endLineNumber;
            if (Object.defineProperty) {
              Object.defineProperty(this, "column", {
                value: column,
                enumerable: true
              });
              Object.defineProperty(this, "endColumn", {
                value: endColumn,
                enumerable: true
              });
            } else {
              this.column = column;
              this.endColumn = endColumn;
            }
          }
        } catch (nop) {
        }
      }
      Exception.prototype = new Error();
      exports["default"] = Exception;
      module2.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js
  var require_block_helper_missing = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/block-helper-missing.js"(exports, module2) {
      "use strict";
      exports.__esModule = true;
      var _utils = require_utils();
      exports["default"] = function(instance) {
        instance.registerHelper("blockHelperMissing", function(context2, options) {
          var inverse = options.inverse, fn = options.fn;
          if (context2 === true) {
            return fn(this);
          } else if (context2 === false || context2 == null) {
            return inverse(this);
          } else if (_utils.isArray(context2)) {
            if (context2.length > 0) {
              if (options.ids) {
                options.ids = [options.name];
              }
              return instance.helpers.each(context2, options);
            } else {
              return inverse(this);
            }
          } else {
            if (options.data && options.ids) {
              var data = _utils.createFrame(options.data);
              data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
              options = { data };
            }
            return fn(context2, options);
          }
        });
      };
      module2.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/each.js
  var require_each = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/each.js"(exports, module2) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _utils = require_utils();
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      exports["default"] = function(instance) {
        instance.registerHelper("each", function(context2, options) {
          if (!options) {
            throw new _exception2["default"]("Must pass iterator to #each");
          }
          var fn = options.fn, inverse = options.inverse, i = 0, ret3 = "", data = void 0, contextPath = void 0;
          if (options.data && options.ids) {
            contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + ".";
          }
          if (_utils.isFunction(context2)) {
            context2 = context2.call(this);
          }
          if (options.data) {
            data = _utils.createFrame(options.data);
          }
          function execIteration(field, index, last) {
            if (data) {
              data.key = field;
              data.index = index;
              data.first = index === 0;
              data.last = !!last;
              if (contextPath) {
                data.contextPath = contextPath + field;
              }
            }
            ret3 = ret3 + fn(context2[field], {
              data,
              blockParams: _utils.blockParams([context2[field], field], [contextPath + field, null])
            });
          }
          if (context2 && typeof context2 === "object") {
            if (_utils.isArray(context2)) {
              for (var j = context2.length; i < j; i++) {
                if (i in context2) {
                  execIteration(i, i, i === context2.length - 1);
                }
              }
            } else if (global.Symbol && context2[global.Symbol.iterator]) {
              var newContext = [];
              var iterator = context2[global.Symbol.iterator]();
              for (var it = iterator.next(); !it.done; it = iterator.next()) {
                newContext.push(it.value);
              }
              context2 = newContext;
              for (var j = context2.length; i < j; i++) {
                execIteration(i, i, i === context2.length - 1);
              }
            } else {
              (function() {
                var priorKey = void 0;
                Object.keys(context2).forEach(function(key) {
                  if (priorKey !== void 0) {
                    execIteration(priorKey, i - 1);
                  }
                  priorKey = key;
                  i++;
                });
                if (priorKey !== void 0) {
                  execIteration(priorKey, i - 1, true);
                }
              })();
            }
          }
          if (i === 0) {
            ret3 = inverse(this);
          }
          return ret3;
        });
      };
      module2.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/helper-missing.js
  var require_helper_missing = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/helper-missing.js"(exports, module2) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      exports["default"] = function(instance) {
        instance.registerHelper("helperMissing", function() {
          if (arguments.length === 1) {
            return void 0;
          } else {
            throw new _exception2["default"]('Missing helper: "' + arguments[arguments.length - 1].name + '"');
          }
        });
      };
      module2.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/if.js
  var require_if = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/if.js"(exports, module2) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _utils = require_utils();
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      exports["default"] = function(instance) {
        instance.registerHelper("if", function(conditional, options) {
          if (arguments.length != 2) {
            throw new _exception2["default"]("#if requires exactly one argument");
          }
          if (_utils.isFunction(conditional)) {
            conditional = conditional.call(this);
          }
          if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
            return options.inverse(this);
          } else {
            return options.fn(this);
          }
        });
        instance.registerHelper("unless", function(conditional, options) {
          if (arguments.length != 2) {
            throw new _exception2["default"]("#unless requires exactly one argument");
          }
          return instance.helpers["if"].call(this, conditional, {
            fn: options.inverse,
            inverse: options.fn,
            hash: options.hash
          });
        });
      };
      module2.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/log.js
  var require_log = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/log.js"(exports, module2) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = function(instance) {
        instance.registerHelper("log", function() {
          var args = [void 0], options = arguments[arguments.length - 1];
          for (var i = 0; i < arguments.length - 1; i++) {
            args.push(arguments[i]);
          }
          var level = 1;
          if (options.hash.level != null) {
            level = options.hash.level;
          } else if (options.data && options.data.level != null) {
            level = options.data.level;
          }
          args[0] = level;
          instance.log.apply(instance, args);
        });
      };
      module2.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/lookup.js
  var require_lookup = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/lookup.js"(exports, module2) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = function(instance) {
        instance.registerHelper("lookup", function(obj, field, options) {
          if (!obj) {
            return obj;
          }
          return options.lookupProperty(obj, field);
        });
      };
      module2.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/with.js
  var require_with = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers/with.js"(exports, module2) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _utils = require_utils();
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      exports["default"] = function(instance) {
        instance.registerHelper("with", function(context2, options) {
          if (arguments.length != 2) {
            throw new _exception2["default"]("#with requires exactly one argument");
          }
          if (_utils.isFunction(context2)) {
            context2 = context2.call(this);
          }
          var fn = options.fn;
          if (!_utils.isEmpty(context2)) {
            var data = options.data;
            if (options.data && options.ids) {
              data = _utils.createFrame(options.data);
              data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
            }
            return fn(context2, {
              data,
              blockParams: _utils.blockParams([context2], [data && data.contextPath])
            });
          } else {
            return options.inverse(this);
          }
        });
      };
      module2.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers.js
  var require_helpers = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/helpers.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.registerDefaultHelpers = registerDefaultHelpers;
      exports.moveHelperToHooks = moveHelperToHooks;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _helpersBlockHelperMissing = require_block_helper_missing();
      var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);
      var _helpersEach = require_each();
      var _helpersEach2 = _interopRequireDefault(_helpersEach);
      var _helpersHelperMissing = require_helper_missing();
      var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);
      var _helpersIf = require_if();
      var _helpersIf2 = _interopRequireDefault(_helpersIf);
      var _helpersLog = require_log();
      var _helpersLog2 = _interopRequireDefault(_helpersLog);
      var _helpersLookup = require_lookup();
      var _helpersLookup2 = _interopRequireDefault(_helpersLookup);
      var _helpersWith = require_with();
      var _helpersWith2 = _interopRequireDefault(_helpersWith);
      function registerDefaultHelpers(instance) {
        _helpersBlockHelperMissing2["default"](instance);
        _helpersEach2["default"](instance);
        _helpersHelperMissing2["default"](instance);
        _helpersIf2["default"](instance);
        _helpersLog2["default"](instance);
        _helpersLookup2["default"](instance);
        _helpersWith2["default"](instance);
      }
      function moveHelperToHooks(instance, helperName, keepHelper) {
        if (instance.helpers[helperName]) {
          instance.hooks[helperName] = instance.helpers[helperName];
          if (!keepHelper) {
            delete instance.helpers[helperName];
          }
        }
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/decorators/inline.js
  var require_inline = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/decorators/inline.js"(exports, module2) {
      "use strict";
      exports.__esModule = true;
      var _utils = require_utils();
      exports["default"] = function(instance) {
        instance.registerDecorator("inline", function(fn, props, container, options) {
          var ret3 = fn;
          if (!props.partials) {
            props.partials = {};
            ret3 = function(context2, options2) {
              var original = container.partials;
              container.partials = _utils.extend({}, original, props.partials);
              var ret4 = fn(context2, options2);
              container.partials = original;
              return ret4;
            };
          }
          props.partials[options.args[0]] = options.fn;
          return ret3;
        });
      };
      module2.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/decorators.js
  var require_decorators = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/decorators.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.registerDefaultDecorators = registerDefaultDecorators;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _decoratorsInline = require_inline();
      var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);
      function registerDefaultDecorators(instance) {
        _decoratorsInline2["default"](instance);
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/logger.js
  var require_logger = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/logger.js"(exports, module2) {
      "use strict";
      exports.__esModule = true;
      var _utils = require_utils();
      var logger = {
        methodMap: ["debug", "info", "warn", "error"],
        level: "info",
        // Maps a given level value to the `methodMap` indexes above.
        lookupLevel: function lookupLevel(level) {
          if (typeof level === "string") {
            var levelMap = _utils.indexOf(logger.methodMap, level.toLowerCase());
            if (levelMap >= 0) {
              level = levelMap;
            } else {
              level = parseInt(level, 10);
            }
          }
          return level;
        },
        // Can be overridden in the host environment
        log: function log2(level) {
          level = logger.lookupLevel(level);
          if (typeof console !== "undefined" && logger.lookupLevel(logger.level) <= level) {
            var method = logger.methodMap[level];
            if (!console[method]) {
              method = "log";
            }
            for (var _len = arguments.length, message = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              message[_key - 1] = arguments[_key];
            }
            console[method].apply(console, message);
          }
        }
      };
      exports["default"] = logger;
      module2.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/internal/create-new-lookup-object.js
  var require_create_new_lookup_object = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/internal/create-new-lookup-object.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.createNewLookupObject = createNewLookupObject;
      var _utils = require_utils();
      function createNewLookupObject() {
        for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
          sources[_key] = arguments[_key];
        }
        return _utils.extend.apply(void 0, [/* @__PURE__ */ Object.create(null)].concat(sources));
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/internal/proto-access.js
  var require_proto_access = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/internal/proto-access.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.createProtoAccessControl = createProtoAccessControl;
      exports.resultIsAllowed = resultIsAllowed;
      exports.resetLoggedProperties = resetLoggedProperties;
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key))
                newObj[key] = obj[key];
            }
          }
          newObj["default"] = obj;
          return newObj;
        }
      }
      var _createNewLookupObject = require_create_new_lookup_object();
      var _logger = require_logger();
      var logger = _interopRequireWildcard(_logger);
      var loggedProperties = /* @__PURE__ */ Object.create(null);
      function createProtoAccessControl(runtimeOptions) {
        var defaultMethodWhiteList = /* @__PURE__ */ Object.create(null);
        defaultMethodWhiteList["constructor"] = false;
        defaultMethodWhiteList["__defineGetter__"] = false;
        defaultMethodWhiteList["__defineSetter__"] = false;
        defaultMethodWhiteList["__lookupGetter__"] = false;
        var defaultPropertyWhiteList = /* @__PURE__ */ Object.create(null);
        defaultPropertyWhiteList["__proto__"] = false;
        return {
          properties: {
            whitelist: _createNewLookupObject.createNewLookupObject(defaultPropertyWhiteList, runtimeOptions.allowedProtoProperties),
            defaultValue: runtimeOptions.allowProtoPropertiesByDefault
          },
          methods: {
            whitelist: _createNewLookupObject.createNewLookupObject(defaultMethodWhiteList, runtimeOptions.allowedProtoMethods),
            defaultValue: runtimeOptions.allowProtoMethodsByDefault
          }
        };
      }
      function resultIsAllowed(result, protoAccessControl, propertyName) {
        if (typeof result === "function") {
          return checkWhiteList(protoAccessControl.methods, propertyName);
        } else {
          return checkWhiteList(protoAccessControl.properties, propertyName);
        }
      }
      function checkWhiteList(protoAccessControlForType, propertyName) {
        if (protoAccessControlForType.whitelist[propertyName] !== void 0) {
          return protoAccessControlForType.whitelist[propertyName] === true;
        }
        if (protoAccessControlForType.defaultValue !== void 0) {
          return protoAccessControlForType.defaultValue;
        }
        logUnexpecedPropertyAccessOnce(propertyName);
        return false;
      }
      function logUnexpecedPropertyAccessOnce(propertyName) {
        if (loggedProperties[propertyName] !== true) {
          loggedProperties[propertyName] = true;
          logger.log("error", 'Handlebars: Access has been denied to resolve the property "' + propertyName + '" because it is not an "own property" of its parent.\nYou can add a runtime option to disable the check or this warning:\nSee https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details');
        }
      }
      function resetLoggedProperties() {
        Object.keys(loggedProperties).forEach(function(propertyName) {
          delete loggedProperties[propertyName];
        });
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/base.js
  var require_base = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/base.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.HandlebarsEnvironment = HandlebarsEnvironment;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _utils = require_utils();
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      var _helpers = require_helpers();
      var _decorators = require_decorators();
      var _logger = require_logger();
      var _logger2 = _interopRequireDefault(_logger);
      var _internalProtoAccess = require_proto_access();
      var VERSION = "4.7.7";
      exports.VERSION = VERSION;
      var COMPILER_REVISION = 8;
      exports.COMPILER_REVISION = COMPILER_REVISION;
      var LAST_COMPATIBLE_COMPILER_REVISION = 7;
      exports.LAST_COMPATIBLE_COMPILER_REVISION = LAST_COMPATIBLE_COMPILER_REVISION;
      var REVISION_CHANGES = {
        1: "<= 1.0.rc.2",
        // 1.0.rc.2 is actually rev2 but doesn't report it
        2: "== 1.0.0-rc.3",
        3: "== 1.0.0-rc.4",
        4: "== 1.x.x",
        5: "== 2.0.0-alpha.x",
        6: ">= 2.0.0-beta.1",
        7: ">= 4.0.0 <4.3.0",
        8: ">= 4.3.0"
      };
      exports.REVISION_CHANGES = REVISION_CHANGES;
      var objectType = "[object Object]";
      function HandlebarsEnvironment(helpers, partials, decorators) {
        this.helpers = helpers || {};
        this.partials = partials || {};
        this.decorators = decorators || {};
        _helpers.registerDefaultHelpers(this);
        _decorators.registerDefaultDecorators(this);
      }
      HandlebarsEnvironment.prototype = {
        constructor: HandlebarsEnvironment,
        logger: _logger2["default"],
        log: _logger2["default"].log,
        registerHelper: function registerHelper(name, fn) {
          if (_utils.toString.call(name) === objectType) {
            if (fn) {
              throw new _exception2["default"]("Arg not supported with multiple helpers");
            }
            _utils.extend(this.helpers, name);
          } else {
            this.helpers[name] = fn;
          }
        },
        unregisterHelper: function unregisterHelper(name) {
          delete this.helpers[name];
        },
        registerPartial: function registerPartial(name, partial) {
          if (_utils.toString.call(name) === objectType) {
            _utils.extend(this.partials, name);
          } else {
            if (typeof partial === "undefined") {
              throw new _exception2["default"]('Attempting to register a partial called "' + name + '" as undefined');
            }
            this.partials[name] = partial;
          }
        },
        unregisterPartial: function unregisterPartial(name) {
          delete this.partials[name];
        },
        registerDecorator: function registerDecorator(name, fn) {
          if (_utils.toString.call(name) === objectType) {
            if (fn) {
              throw new _exception2["default"]("Arg not supported with multiple decorators");
            }
            _utils.extend(this.decorators, name);
          } else {
            this.decorators[name] = fn;
          }
        },
        unregisterDecorator: function unregisterDecorator(name) {
          delete this.decorators[name];
        },
        /**
         * Reset the memory of illegal property accesses that have already been logged.
         * @deprecated should only be used in handlebars test-cases
         */
        resetLoggedPropertyAccesses: function resetLoggedPropertyAccesses() {
          _internalProtoAccess.resetLoggedProperties();
        }
      };
      var log2 = _logger2["default"].log;
      exports.log = log2;
      exports.createFrame = _utils.createFrame;
      exports.logger = _logger2["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/safe-string.js
  var require_safe_string = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/safe-string.js"(exports, module2) {
      "use strict";
      exports.__esModule = true;
      function SafeString(string2) {
        this.string = string2;
      }
      SafeString.prototype.toString = SafeString.prototype.toHTML = function() {
        return "" + this.string;
      };
      exports["default"] = SafeString;
      module2.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/internal/wrapHelper.js
  var require_wrapHelper = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/internal/wrapHelper.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.wrapHelper = wrapHelper;
      function wrapHelper(helper, transformOptionsFn) {
        if (typeof helper !== "function") {
          return helper;
        }
        var wrapper = function wrapper2() {
          var options = arguments[arguments.length - 1];
          arguments[arguments.length - 1] = transformOptionsFn(options);
          return helper.apply(this, arguments);
        };
        return wrapper;
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/runtime.js
  var require_runtime = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/runtime.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.checkRevision = checkRevision;
      exports.template = template;
      exports.wrapProgram = wrapProgram;
      exports.resolvePartial = resolvePartial;
      exports.invokePartial = invokePartial;
      exports.noop = noop;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key))
                newObj[key] = obj[key];
            }
          }
          newObj["default"] = obj;
          return newObj;
        }
      }
      var _utils = require_utils();
      var Utils = _interopRequireWildcard(_utils);
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      var _base = require_base();
      var _helpers = require_helpers();
      var _internalWrapHelper = require_wrapHelper();
      var _internalProtoAccess = require_proto_access();
      function checkRevision(compilerInfo) {
        var compilerRevision = compilerInfo && compilerInfo[0] || 1, currentRevision = _base.COMPILER_REVISION;
        if (compilerRevision >= _base.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= _base.COMPILER_REVISION) {
          return;
        }
        if (compilerRevision < _base.LAST_COMPATIBLE_COMPILER_REVISION) {
          var runtimeVersions = _base.REVISION_CHANGES[currentRevision], compilerVersions = _base.REVISION_CHANGES[compilerRevision];
          throw new _exception2["default"]("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" + runtimeVersions + ") or downgrade your runtime to an older version (" + compilerVersions + ").");
        } else {
          throw new _exception2["default"]("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" + compilerInfo[1] + ").");
        }
      }
      function template(templateSpec, env) {
        if (!env) {
          throw new _exception2["default"]("No environment passed to template");
        }
        if (!templateSpec || !templateSpec.main) {
          throw new _exception2["default"]("Unknown template object: " + typeof templateSpec);
        }
        templateSpec.main.decorator = templateSpec.main_d;
        env.VM.checkRevision(templateSpec.compiler);
        var templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;
        function invokePartialWrapper(partial, context2, options) {
          if (options.hash) {
            context2 = Utils.extend({}, context2, options.hash);
            if (options.ids) {
              options.ids[0] = true;
            }
          }
          partial = env.VM.resolvePartial.call(this, partial, context2, options);
          var extendedOptions = Utils.extend({}, options, {
            hooks: this.hooks,
            protoAccessControl: this.protoAccessControl
          });
          var result = env.VM.invokePartial.call(this, partial, context2, extendedOptions);
          if (result == null && env.compile) {
            options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
            result = options.partials[options.name](context2, extendedOptions);
          }
          if (result != null) {
            if (options.indent) {
              var lines = result.split("\n");
              for (var i = 0, l = lines.length; i < l; i++) {
                if (!lines[i] && i + 1 === l) {
                  break;
                }
                lines[i] = options.indent + lines[i];
              }
              result = lines.join("\n");
            }
            return result;
          } else {
            throw new _exception2["default"]("The partial " + options.name + " could not be compiled when running in runtime-only mode");
          }
        }
        var container = {
          strict: function strict(obj, name, loc) {
            if (!obj || !(name in obj)) {
              throw new _exception2["default"]('"' + name + '" not defined in ' + obj, {
                loc
              });
            }
            return container.lookupProperty(obj, name);
          },
          lookupProperty: function lookupProperty(parent, propertyName) {
            var result = parent[propertyName];
            if (result == null) {
              return result;
            }
            if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
              return result;
            }
            if (_internalProtoAccess.resultIsAllowed(result, container.protoAccessControl, propertyName)) {
              return result;
            }
            return void 0;
          },
          lookup: function lookup(depths, name) {
            var len = depths.length;
            for (var i = 0; i < len; i++) {
              var result = depths[i] && container.lookupProperty(depths[i], name);
              if (result != null) {
                return depths[i][name];
              }
            }
          },
          lambda: function lambda(current, context2) {
            return typeof current === "function" ? current.call(context2) : current;
          },
          escapeExpression: Utils.escapeExpression,
          invokePartial: invokePartialWrapper,
          fn: function fn(i) {
            var ret4 = templateSpec[i];
            ret4.decorator = templateSpec[i + "_d"];
            return ret4;
          },
          programs: [],
          program: function program2(i, data, declaredBlockParams, blockParams, depths) {
            var programWrapper = this.programs[i], fn = this.fn(i);
            if (data || depths || blockParams || declaredBlockParams) {
              programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
            } else if (!programWrapper) {
              programWrapper = this.programs[i] = wrapProgram(this, i, fn);
            }
            return programWrapper;
          },
          data: function data(value, depth) {
            while (value && depth--) {
              value = value._parent;
            }
            return value;
          },
          mergeIfNeeded: function mergeIfNeeded(param, common) {
            var obj = param || common;
            if (param && common && param !== common) {
              obj = Utils.extend({}, common, param);
            }
            return obj;
          },
          // An empty object to use as replacement for null-contexts
          nullContext: Object.seal({}),
          noop: env.VM.noop,
          compilerInfo: templateSpec.compiler
        };
        function ret3(context2) {
          var options = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
          var data = options.data;
          ret3._setup(options);
          if (!options.partial && templateSpec.useData) {
            data = initData(context2, data);
          }
          var depths = void 0, blockParams = templateSpec.useBlockParams ? [] : void 0;
          if (templateSpec.useDepths) {
            if (options.depths) {
              depths = context2 != options.depths[0] ? [context2].concat(options.depths) : options.depths;
            } else {
              depths = [context2];
            }
          }
          function main(context3) {
            return "" + templateSpec.main(container, context3, container.helpers, container.partials, data, blockParams, depths);
          }
          main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
          return main(context2, options);
        }
        ret3.isTop = true;
        ret3._setup = function(options) {
          if (!options.partial) {
            var mergedHelpers = Utils.extend({}, env.helpers, options.helpers);
            wrapHelpersToPassLookupProperty(mergedHelpers, container);
            container.helpers = mergedHelpers;
            if (templateSpec.usePartial) {
              container.partials = container.mergeIfNeeded(options.partials, env.partials);
            }
            if (templateSpec.usePartial || templateSpec.useDecorators) {
              container.decorators = Utils.extend({}, env.decorators, options.decorators);
            }
            container.hooks = {};
            container.protoAccessControl = _internalProtoAccess.createProtoAccessControl(options);
            var keepHelperInHelpers = options.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;
            _helpers.moveHelperToHooks(container, "helperMissing", keepHelperInHelpers);
            _helpers.moveHelperToHooks(container, "blockHelperMissing", keepHelperInHelpers);
          } else {
            container.protoAccessControl = options.protoAccessControl;
            container.helpers = options.helpers;
            container.partials = options.partials;
            container.decorators = options.decorators;
            container.hooks = options.hooks;
          }
        };
        ret3._child = function(i, data, blockParams, depths) {
          if (templateSpec.useBlockParams && !blockParams) {
            throw new _exception2["default"]("must pass block params");
          }
          if (templateSpec.useDepths && !depths) {
            throw new _exception2["default"]("must pass parent depths");
          }
          return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
        };
        return ret3;
      }
      function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
        function prog(context2) {
          var options = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
          var currentDepths = depths;
          if (depths && context2 != depths[0] && !(context2 === container.nullContext && depths[0] === null)) {
            currentDepths = [context2].concat(depths);
          }
          return fn(container, context2, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
        }
        prog = executeDecorators(fn, prog, container, depths, data, blockParams);
        prog.program = i;
        prog.depth = depths ? depths.length : 0;
        prog.blockParams = declaredBlockParams || 0;
        return prog;
      }
      function resolvePartial(partial, context2, options) {
        if (!partial) {
          if (options.name === "@partial-block") {
            partial = options.data["partial-block"];
          } else {
            partial = options.partials[options.name];
          }
        } else if (!partial.call && !options.name) {
          options.name = partial;
          partial = options.partials[partial];
        }
        return partial;
      }
      function invokePartial(partial, context2, options) {
        var currentPartialBlock = options.data && options.data["partial-block"];
        options.partial = true;
        if (options.ids) {
          options.data.contextPath = options.ids[0] || options.data.contextPath;
        }
        var partialBlock = void 0;
        if (options.fn && options.fn !== noop) {
          (function() {
            options.data = _base.createFrame(options.data);
            var fn = options.fn;
            partialBlock = options.data["partial-block"] = function partialBlockWrapper(context3) {
              var options2 = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
              options2.data = _base.createFrame(options2.data);
              options2.data["partial-block"] = currentPartialBlock;
              return fn(context3, options2);
            };
            if (fn.partials) {
              options.partials = Utils.extend({}, options.partials, fn.partials);
            }
          })();
        }
        if (partial === void 0 && partialBlock) {
          partial = partialBlock;
        }
        if (partial === void 0) {
          throw new _exception2["default"]("The partial " + options.name + " could not be found");
        } else if (partial instanceof Function) {
          return partial(context2, options);
        }
      }
      function noop() {
        return "";
      }
      function initData(context2, data) {
        if (!data || !("root" in data)) {
          data = data ? _base.createFrame(data) : {};
          data.root = context2;
        }
        return data;
      }
      function executeDecorators(fn, prog, container, depths, data, blockParams) {
        if (fn.decorator) {
          var props = {};
          prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
          Utils.extend(prog, props);
        }
        return prog;
      }
      function wrapHelpersToPassLookupProperty(mergedHelpers, container) {
        Object.keys(mergedHelpers).forEach(function(helperName) {
          var helper = mergedHelpers[helperName];
          mergedHelpers[helperName] = passLookupPropertyOption(helper, container);
        });
      }
      function passLookupPropertyOption(helper, container) {
        var lookupProperty = container.lookupProperty;
        return _internalWrapHelper.wrapHelper(helper, function(options) {
          return Utils.extend({ lookupProperty }, options);
        });
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/no-conflict.js
  var require_no_conflict = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/no-conflict.js"(exports, module2) {
      "use strict";
      exports.__esModule = true;
      exports["default"] = function(Handlebars2) {
        var root = typeof global !== "undefined" ? global : window, $Handlebars = root.Handlebars;
        Handlebars2.noConflict = function() {
          if (root.Handlebars === Handlebars2) {
            root.Handlebars = $Handlebars;
          }
          return Handlebars2;
        };
      };
      module2.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars.runtime.js
  var require_handlebars_runtime = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars.runtime.js"(exports, module2) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key))
                newObj[key] = obj[key];
            }
          }
          newObj["default"] = obj;
          return newObj;
        }
      }
      var _handlebarsBase = require_base();
      var base = _interopRequireWildcard(_handlebarsBase);
      var _handlebarsSafeString = require_safe_string();
      var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);
      var _handlebarsException = require_exception();
      var _handlebarsException2 = _interopRequireDefault(_handlebarsException);
      var _handlebarsUtils = require_utils();
      var Utils = _interopRequireWildcard(_handlebarsUtils);
      var _handlebarsRuntime = require_runtime();
      var runtime = _interopRequireWildcard(_handlebarsRuntime);
      var _handlebarsNoConflict = require_no_conflict();
      var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
      function create10() {
        var hb = new base.HandlebarsEnvironment();
        Utils.extend(hb, base);
        hb.SafeString = _handlebarsSafeString2["default"];
        hb.Exception = _handlebarsException2["default"];
        hb.Utils = Utils;
        hb.escapeExpression = Utils.escapeExpression;
        hb.VM = runtime;
        hb.template = function(spec) {
          return runtime.template(spec, hb);
        };
        return hb;
      }
      var inst = create10();
      inst.create = create10;
      _handlebarsNoConflict2["default"](inst);
      inst["default"] = inst;
      exports["default"] = inst;
      module2.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/ast.js
  var require_ast = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/ast.js"(exports, module2) {
      "use strict";
      exports.__esModule = true;
      var AST2 = {
        // Public API used to evaluate derived attributes regarding AST nodes
        helpers: {
          // a mustache is definitely a helper if:
          // * it is an eligible helper, and
          // * it has at least one parameter or hash segment
          helperExpression: function helperExpression(node) {
            return node.type === "SubExpression" || (node.type === "MustacheStatement" || node.type === "BlockStatement") && !!(node.params && node.params.length || node.hash);
          },
          scopedId: function scopedId(path4) {
            return /^\.|this\b/.test(path4.original);
          },
          // an ID is simple if it only has one part, and that part is not
          // `..` or `this`.
          simpleId: function simpleId(path4) {
            return path4.parts.length === 1 && !AST2.helpers.scopedId(path4) && !path4.depth;
          }
        }
      };
      exports["default"] = AST2;
      module2.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js
  var require_parser = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/parser.js"(exports, module2) {
      "use strict";
      exports.__esModule = true;
      var handlebars = function() {
        var parser = {
          trace: function trace() {
          },
          yy: {},
          symbols_: { "error": 2, "root": 3, "program": 4, "EOF": 5, "program_repetition0": 6, "statement": 7, "mustache": 8, "block": 9, "rawBlock": 10, "partial": 11, "partialBlock": 12, "content": 13, "COMMENT": 14, "CONTENT": 15, "openRawBlock": 16, "rawBlock_repetition0": 17, "END_RAW_BLOCK": 18, "OPEN_RAW_BLOCK": 19, "helperName": 20, "openRawBlock_repetition0": 21, "openRawBlock_option0": 22, "CLOSE_RAW_BLOCK": 23, "openBlock": 24, "block_option0": 25, "closeBlock": 26, "openInverse": 27, "block_option1": 28, "OPEN_BLOCK": 29, "openBlock_repetition0": 30, "openBlock_option0": 31, "openBlock_option1": 32, "CLOSE": 33, "OPEN_INVERSE": 34, "openInverse_repetition0": 35, "openInverse_option0": 36, "openInverse_option1": 37, "openInverseChain": 38, "OPEN_INVERSE_CHAIN": 39, "openInverseChain_repetition0": 40, "openInverseChain_option0": 41, "openInverseChain_option1": 42, "inverseAndProgram": 43, "INVERSE": 44, "inverseChain": 45, "inverseChain_option0": 46, "OPEN_ENDBLOCK": 47, "OPEN": 48, "mustache_repetition0": 49, "mustache_option0": 50, "OPEN_UNESCAPED": 51, "mustache_repetition1": 52, "mustache_option1": 53, "CLOSE_UNESCAPED": 54, "OPEN_PARTIAL": 55, "partialName": 56, "partial_repetition0": 57, "partial_option0": 58, "openPartialBlock": 59, "OPEN_PARTIAL_BLOCK": 60, "openPartialBlock_repetition0": 61, "openPartialBlock_option0": 62, "param": 63, "sexpr": 64, "OPEN_SEXPR": 65, "sexpr_repetition0": 66, "sexpr_option0": 67, "CLOSE_SEXPR": 68, "hash": 69, "hash_repetition_plus0": 70, "hashSegment": 71, "ID": 72, "EQUALS": 73, "blockParams": 74, "OPEN_BLOCK_PARAMS": 75, "blockParams_repetition_plus0": 76, "CLOSE_BLOCK_PARAMS": 77, "path": 78, "dataName": 79, "STRING": 80, "NUMBER": 81, "BOOLEAN": 82, "UNDEFINED": 83, "NULL": 84, "DATA": 85, "pathSegments": 86, "SEP": 87, "$accept": 0, "$end": 1 },
          terminals_: { 2: "error", 5: "EOF", 14: "COMMENT", 15: "CONTENT", 18: "END_RAW_BLOCK", 19: "OPEN_RAW_BLOCK", 23: "CLOSE_RAW_BLOCK", 29: "OPEN_BLOCK", 33: "CLOSE", 34: "OPEN_INVERSE", 39: "OPEN_INVERSE_CHAIN", 44: "INVERSE", 47: "OPEN_ENDBLOCK", 48: "OPEN", 51: "OPEN_UNESCAPED", 54: "CLOSE_UNESCAPED", 55: "OPEN_PARTIAL", 60: "OPEN_PARTIAL_BLOCK", 65: "OPEN_SEXPR", 68: "CLOSE_SEXPR", 72: "ID", 73: "EQUALS", 75: "OPEN_BLOCK_PARAMS", 77: "CLOSE_BLOCK_PARAMS", 80: "STRING", 81: "NUMBER", 82: "BOOLEAN", 83: "UNDEFINED", 84: "NULL", 85: "DATA", 87: "SEP" },
          productions_: [0, [3, 2], [4, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [7, 1], [13, 1], [10, 3], [16, 5], [9, 4], [9, 4], [24, 6], [27, 6], [38, 6], [43, 2], [45, 3], [45, 1], [26, 3], [8, 5], [8, 5], [11, 5], [12, 3], [59, 5], [63, 1], [63, 1], [64, 5], [69, 1], [71, 3], [74, 3], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [20, 1], [56, 1], [56, 1], [79, 2], [78, 1], [86, 3], [86, 1], [6, 0], [6, 2], [17, 0], [17, 2], [21, 0], [21, 2], [22, 0], [22, 1], [25, 0], [25, 1], [28, 0], [28, 1], [30, 0], [30, 2], [31, 0], [31, 1], [32, 0], [32, 1], [35, 0], [35, 2], [36, 0], [36, 1], [37, 0], [37, 1], [40, 0], [40, 2], [41, 0], [41, 1], [42, 0], [42, 1], [46, 0], [46, 1], [49, 0], [49, 2], [50, 0], [50, 1], [52, 0], [52, 2], [53, 0], [53, 1], [57, 0], [57, 2], [58, 0], [58, 1], [61, 0], [61, 2], [62, 0], [62, 1], [66, 0], [66, 2], [67, 0], [67, 1], [70, 1], [70, 2], [76, 1], [76, 2]],
          performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
            var $0 = $$.length - 1;
            switch (yystate) {
              case 1:
                return $$[$0 - 1];
                break;
              case 2:
                this.$ = yy.prepareProgram($$[$0]);
                break;
              case 3:
                this.$ = $$[$0];
                break;
              case 4:
                this.$ = $$[$0];
                break;
              case 5:
                this.$ = $$[$0];
                break;
              case 6:
                this.$ = $$[$0];
                break;
              case 7:
                this.$ = $$[$0];
                break;
              case 8:
                this.$ = $$[$0];
                break;
              case 9:
                this.$ = {
                  type: "CommentStatement",
                  value: yy.stripComment($$[$0]),
                  strip: yy.stripFlags($$[$0], $$[$0]),
                  loc: yy.locInfo(this._$)
                };
                break;
              case 10:
                this.$ = {
                  type: "ContentStatement",
                  original: $$[$0],
                  value: $$[$0],
                  loc: yy.locInfo(this._$)
                };
                break;
              case 11:
                this.$ = yy.prepareRawBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                break;
              case 12:
                this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1] };
                break;
              case 13:
                this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], false, this._$);
                break;
              case 14:
                this.$ = yy.prepareBlock($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0], true, this._$);
                break;
              case 15:
                this.$ = { open: $$[$0 - 5], path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                break;
              case 16:
                this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                break;
              case 17:
                this.$ = { path: $$[$0 - 4], params: $$[$0 - 3], hash: $$[$0 - 2], blockParams: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 5], $$[$0]) };
                break;
              case 18:
                this.$ = { strip: yy.stripFlags($$[$0 - 1], $$[$0 - 1]), program: $$[$0] };
                break;
              case 19:
                var inverse = yy.prepareBlock($$[$0 - 2], $$[$0 - 1], $$[$0], $$[$0], false, this._$), program2 = yy.prepareProgram([inverse], $$[$0 - 1].loc);
                program2.chained = true;
                this.$ = { strip: $$[$0 - 2].strip, program: program2, chain: true };
                break;
              case 20:
                this.$ = $$[$0];
                break;
              case 21:
                this.$ = { path: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 2], $$[$0]) };
                break;
              case 22:
                this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                break;
              case 23:
                this.$ = yy.prepareMustache($$[$0 - 3], $$[$0 - 2], $$[$0 - 1], $$[$0 - 4], yy.stripFlags($$[$0 - 4], $$[$0]), this._$);
                break;
              case 24:
                this.$ = {
                  type: "PartialStatement",
                  name: $$[$0 - 3],
                  params: $$[$0 - 2],
                  hash: $$[$0 - 1],
                  indent: "",
                  strip: yy.stripFlags($$[$0 - 4], $$[$0]),
                  loc: yy.locInfo(this._$)
                };
                break;
              case 25:
                this.$ = yy.preparePartialBlock($$[$0 - 2], $$[$0 - 1], $$[$0], this._$);
                break;
              case 26:
                this.$ = { path: $$[$0 - 3], params: $$[$0 - 2], hash: $$[$0 - 1], strip: yy.stripFlags($$[$0 - 4], $$[$0]) };
                break;
              case 27:
                this.$ = $$[$0];
                break;
              case 28:
                this.$ = $$[$0];
                break;
              case 29:
                this.$ = {
                  type: "SubExpression",
                  path: $$[$0 - 3],
                  params: $$[$0 - 2],
                  hash: $$[$0 - 1],
                  loc: yy.locInfo(this._$)
                };
                break;
              case 30:
                this.$ = { type: "Hash", pairs: $$[$0], loc: yy.locInfo(this._$) };
                break;
              case 31:
                this.$ = { type: "HashPair", key: yy.id($$[$0 - 2]), value: $$[$0], loc: yy.locInfo(this._$) };
                break;
              case 32:
                this.$ = yy.id($$[$0 - 1]);
                break;
              case 33:
                this.$ = $$[$0];
                break;
              case 34:
                this.$ = $$[$0];
                break;
              case 35:
                this.$ = { type: "StringLiteral", value: $$[$0], original: $$[$0], loc: yy.locInfo(this._$) };
                break;
              case 36:
                this.$ = { type: "NumberLiteral", value: Number($$[$0]), original: Number($$[$0]), loc: yy.locInfo(this._$) };
                break;
              case 37:
                this.$ = { type: "BooleanLiteral", value: $$[$0] === "true", original: $$[$0] === "true", loc: yy.locInfo(this._$) };
                break;
              case 38:
                this.$ = { type: "UndefinedLiteral", original: void 0, value: void 0, loc: yy.locInfo(this._$) };
                break;
              case 39:
                this.$ = { type: "NullLiteral", original: null, value: null, loc: yy.locInfo(this._$) };
                break;
              case 40:
                this.$ = $$[$0];
                break;
              case 41:
                this.$ = $$[$0];
                break;
              case 42:
                this.$ = yy.preparePath(true, $$[$0], this._$);
                break;
              case 43:
                this.$ = yy.preparePath(false, $$[$0], this._$);
                break;
              case 44:
                $$[$0 - 2].push({ part: yy.id($$[$0]), original: $$[$0], separator: $$[$0 - 1] });
                this.$ = $$[$0 - 2];
                break;
              case 45:
                this.$ = [{ part: yy.id($$[$0]), original: $$[$0] }];
                break;
              case 46:
                this.$ = [];
                break;
              case 47:
                $$[$0 - 1].push($$[$0]);
                break;
              case 48:
                this.$ = [];
                break;
              case 49:
                $$[$0 - 1].push($$[$0]);
                break;
              case 50:
                this.$ = [];
                break;
              case 51:
                $$[$0 - 1].push($$[$0]);
                break;
              case 58:
                this.$ = [];
                break;
              case 59:
                $$[$0 - 1].push($$[$0]);
                break;
              case 64:
                this.$ = [];
                break;
              case 65:
                $$[$0 - 1].push($$[$0]);
                break;
              case 70:
                this.$ = [];
                break;
              case 71:
                $$[$0 - 1].push($$[$0]);
                break;
              case 78:
                this.$ = [];
                break;
              case 79:
                $$[$0 - 1].push($$[$0]);
                break;
              case 82:
                this.$ = [];
                break;
              case 83:
                $$[$0 - 1].push($$[$0]);
                break;
              case 86:
                this.$ = [];
                break;
              case 87:
                $$[$0 - 1].push($$[$0]);
                break;
              case 90:
                this.$ = [];
                break;
              case 91:
                $$[$0 - 1].push($$[$0]);
                break;
              case 94:
                this.$ = [];
                break;
              case 95:
                $$[$0 - 1].push($$[$0]);
                break;
              case 98:
                this.$ = [$$[$0]];
                break;
              case 99:
                $$[$0 - 1].push($$[$0]);
                break;
              case 100:
                this.$ = [$$[$0]];
                break;
              case 101:
                $$[$0 - 1].push($$[$0]);
                break;
            }
          },
          table: [{ 3: 1, 4: 2, 5: [2, 46], 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 1: [3] }, { 5: [1, 4] }, { 5: [2, 2], 7: 5, 8: 6, 9: 7, 10: 8, 11: 9, 12: 10, 13: 11, 14: [1, 12], 15: [1, 20], 16: 17, 19: [1, 23], 24: 15, 27: 16, 29: [1, 21], 34: [1, 22], 39: [2, 2], 44: [2, 2], 47: [2, 2], 48: [1, 13], 51: [1, 14], 55: [1, 18], 59: 19, 60: [1, 24] }, { 1: [2, 1] }, { 5: [2, 47], 14: [2, 47], 15: [2, 47], 19: [2, 47], 29: [2, 47], 34: [2, 47], 39: [2, 47], 44: [2, 47], 47: [2, 47], 48: [2, 47], 51: [2, 47], 55: [2, 47], 60: [2, 47] }, { 5: [2, 3], 14: [2, 3], 15: [2, 3], 19: [2, 3], 29: [2, 3], 34: [2, 3], 39: [2, 3], 44: [2, 3], 47: [2, 3], 48: [2, 3], 51: [2, 3], 55: [2, 3], 60: [2, 3] }, { 5: [2, 4], 14: [2, 4], 15: [2, 4], 19: [2, 4], 29: [2, 4], 34: [2, 4], 39: [2, 4], 44: [2, 4], 47: [2, 4], 48: [2, 4], 51: [2, 4], 55: [2, 4], 60: [2, 4] }, { 5: [2, 5], 14: [2, 5], 15: [2, 5], 19: [2, 5], 29: [2, 5], 34: [2, 5], 39: [2, 5], 44: [2, 5], 47: [2, 5], 48: [2, 5], 51: [2, 5], 55: [2, 5], 60: [2, 5] }, { 5: [2, 6], 14: [2, 6], 15: [2, 6], 19: [2, 6], 29: [2, 6], 34: [2, 6], 39: [2, 6], 44: [2, 6], 47: [2, 6], 48: [2, 6], 51: [2, 6], 55: [2, 6], 60: [2, 6] }, { 5: [2, 7], 14: [2, 7], 15: [2, 7], 19: [2, 7], 29: [2, 7], 34: [2, 7], 39: [2, 7], 44: [2, 7], 47: [2, 7], 48: [2, 7], 51: [2, 7], 55: [2, 7], 60: [2, 7] }, { 5: [2, 8], 14: [2, 8], 15: [2, 8], 19: [2, 8], 29: [2, 8], 34: [2, 8], 39: [2, 8], 44: [2, 8], 47: [2, 8], 48: [2, 8], 51: [2, 8], 55: [2, 8], 60: [2, 8] }, { 5: [2, 9], 14: [2, 9], 15: [2, 9], 19: [2, 9], 29: [2, 9], 34: [2, 9], 39: [2, 9], 44: [2, 9], 47: [2, 9], 48: [2, 9], 51: [2, 9], 55: [2, 9], 60: [2, 9] }, { 20: 25, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 36, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 37, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 4: 38, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 15: [2, 48], 17: 39, 18: [2, 48] }, { 20: 41, 56: 40, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 44, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 5: [2, 10], 14: [2, 10], 15: [2, 10], 18: [2, 10], 19: [2, 10], 29: [2, 10], 34: [2, 10], 39: [2, 10], 44: [2, 10], 47: [2, 10], 48: [2, 10], 51: [2, 10], 55: [2, 10], 60: [2, 10] }, { 20: 45, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 46, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 47, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 41, 56: 48, 64: 42, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [2, 78], 49: 49, 65: [2, 78], 72: [2, 78], 80: [2, 78], 81: [2, 78], 82: [2, 78], 83: [2, 78], 84: [2, 78], 85: [2, 78] }, { 23: [2, 33], 33: [2, 33], 54: [2, 33], 65: [2, 33], 68: [2, 33], 72: [2, 33], 75: [2, 33], 80: [2, 33], 81: [2, 33], 82: [2, 33], 83: [2, 33], 84: [2, 33], 85: [2, 33] }, { 23: [2, 34], 33: [2, 34], 54: [2, 34], 65: [2, 34], 68: [2, 34], 72: [2, 34], 75: [2, 34], 80: [2, 34], 81: [2, 34], 82: [2, 34], 83: [2, 34], 84: [2, 34], 85: [2, 34] }, { 23: [2, 35], 33: [2, 35], 54: [2, 35], 65: [2, 35], 68: [2, 35], 72: [2, 35], 75: [2, 35], 80: [2, 35], 81: [2, 35], 82: [2, 35], 83: [2, 35], 84: [2, 35], 85: [2, 35] }, { 23: [2, 36], 33: [2, 36], 54: [2, 36], 65: [2, 36], 68: [2, 36], 72: [2, 36], 75: [2, 36], 80: [2, 36], 81: [2, 36], 82: [2, 36], 83: [2, 36], 84: [2, 36], 85: [2, 36] }, { 23: [2, 37], 33: [2, 37], 54: [2, 37], 65: [2, 37], 68: [2, 37], 72: [2, 37], 75: [2, 37], 80: [2, 37], 81: [2, 37], 82: [2, 37], 83: [2, 37], 84: [2, 37], 85: [2, 37] }, { 23: [2, 38], 33: [2, 38], 54: [2, 38], 65: [2, 38], 68: [2, 38], 72: [2, 38], 75: [2, 38], 80: [2, 38], 81: [2, 38], 82: [2, 38], 83: [2, 38], 84: [2, 38], 85: [2, 38] }, { 23: [2, 39], 33: [2, 39], 54: [2, 39], 65: [2, 39], 68: [2, 39], 72: [2, 39], 75: [2, 39], 80: [2, 39], 81: [2, 39], 82: [2, 39], 83: [2, 39], 84: [2, 39], 85: [2, 39] }, { 23: [2, 43], 33: [2, 43], 54: [2, 43], 65: [2, 43], 68: [2, 43], 72: [2, 43], 75: [2, 43], 80: [2, 43], 81: [2, 43], 82: [2, 43], 83: [2, 43], 84: [2, 43], 85: [2, 43], 87: [1, 50] }, { 72: [1, 35], 86: 51 }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 52: 52, 54: [2, 82], 65: [2, 82], 72: [2, 82], 80: [2, 82], 81: [2, 82], 82: [2, 82], 83: [2, 82], 84: [2, 82], 85: [2, 82] }, { 25: 53, 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 54, 47: [2, 54] }, { 28: 59, 43: 60, 44: [1, 58], 47: [2, 56] }, { 13: 62, 15: [1, 20], 18: [1, 61] }, { 33: [2, 86], 57: 63, 65: [2, 86], 72: [2, 86], 80: [2, 86], 81: [2, 86], 82: [2, 86], 83: [2, 86], 84: [2, 86], 85: [2, 86] }, { 33: [2, 40], 65: [2, 40], 72: [2, 40], 80: [2, 40], 81: [2, 40], 82: [2, 40], 83: [2, 40], 84: [2, 40], 85: [2, 40] }, { 33: [2, 41], 65: [2, 41], 72: [2, 41], 80: [2, 41], 81: [2, 41], 82: [2, 41], 83: [2, 41], 84: [2, 41], 85: [2, 41] }, { 20: 64, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 65, 47: [1, 66] }, { 30: 67, 33: [2, 58], 65: [2, 58], 72: [2, 58], 75: [2, 58], 80: [2, 58], 81: [2, 58], 82: [2, 58], 83: [2, 58], 84: [2, 58], 85: [2, 58] }, { 33: [2, 64], 35: 68, 65: [2, 64], 72: [2, 64], 75: [2, 64], 80: [2, 64], 81: [2, 64], 82: [2, 64], 83: [2, 64], 84: [2, 64], 85: [2, 64] }, { 21: 69, 23: [2, 50], 65: [2, 50], 72: [2, 50], 80: [2, 50], 81: [2, 50], 82: [2, 50], 83: [2, 50], 84: [2, 50], 85: [2, 50] }, { 33: [2, 90], 61: 70, 65: [2, 90], 72: [2, 90], 80: [2, 90], 81: [2, 90], 82: [2, 90], 83: [2, 90], 84: [2, 90], 85: [2, 90] }, { 20: 74, 33: [2, 80], 50: 71, 63: 72, 64: 75, 65: [1, 43], 69: 73, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 72: [1, 79] }, { 23: [2, 42], 33: [2, 42], 54: [2, 42], 65: [2, 42], 68: [2, 42], 72: [2, 42], 75: [2, 42], 80: [2, 42], 81: [2, 42], 82: [2, 42], 83: [2, 42], 84: [2, 42], 85: [2, 42], 87: [1, 50] }, { 20: 74, 53: 80, 54: [2, 84], 63: 81, 64: 75, 65: [1, 43], 69: 82, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 26: 83, 47: [1, 66] }, { 47: [2, 55] }, { 4: 84, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 39: [2, 46], 44: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 47: [2, 20] }, { 20: 85, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 4: 86, 6: 3, 14: [2, 46], 15: [2, 46], 19: [2, 46], 29: [2, 46], 34: [2, 46], 47: [2, 46], 48: [2, 46], 51: [2, 46], 55: [2, 46], 60: [2, 46] }, { 26: 87, 47: [1, 66] }, { 47: [2, 57] }, { 5: [2, 11], 14: [2, 11], 15: [2, 11], 19: [2, 11], 29: [2, 11], 34: [2, 11], 39: [2, 11], 44: [2, 11], 47: [2, 11], 48: [2, 11], 51: [2, 11], 55: [2, 11], 60: [2, 11] }, { 15: [2, 49], 18: [2, 49] }, { 20: 74, 33: [2, 88], 58: 88, 63: 89, 64: 75, 65: [1, 43], 69: 90, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 65: [2, 94], 66: 91, 68: [2, 94], 72: [2, 94], 80: [2, 94], 81: [2, 94], 82: [2, 94], 83: [2, 94], 84: [2, 94], 85: [2, 94] }, { 5: [2, 25], 14: [2, 25], 15: [2, 25], 19: [2, 25], 29: [2, 25], 34: [2, 25], 39: [2, 25], 44: [2, 25], 47: [2, 25], 48: [2, 25], 51: [2, 25], 55: [2, 25], 60: [2, 25] }, { 20: 92, 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 31: 93, 33: [2, 60], 63: 94, 64: 75, 65: [1, 43], 69: 95, 70: 76, 71: 77, 72: [1, 78], 75: [2, 60], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 66], 36: 96, 63: 97, 64: 75, 65: [1, 43], 69: 98, 70: 76, 71: 77, 72: [1, 78], 75: [2, 66], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 22: 99, 23: [2, 52], 63: 100, 64: 75, 65: [1, 43], 69: 101, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 20: 74, 33: [2, 92], 62: 102, 63: 103, 64: 75, 65: [1, 43], 69: 104, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 105] }, { 33: [2, 79], 65: [2, 79], 72: [2, 79], 80: [2, 79], 81: [2, 79], 82: [2, 79], 83: [2, 79], 84: [2, 79], 85: [2, 79] }, { 33: [2, 81] }, { 23: [2, 27], 33: [2, 27], 54: [2, 27], 65: [2, 27], 68: [2, 27], 72: [2, 27], 75: [2, 27], 80: [2, 27], 81: [2, 27], 82: [2, 27], 83: [2, 27], 84: [2, 27], 85: [2, 27] }, { 23: [2, 28], 33: [2, 28], 54: [2, 28], 65: [2, 28], 68: [2, 28], 72: [2, 28], 75: [2, 28], 80: [2, 28], 81: [2, 28], 82: [2, 28], 83: [2, 28], 84: [2, 28], 85: [2, 28] }, { 23: [2, 30], 33: [2, 30], 54: [2, 30], 68: [2, 30], 71: 106, 72: [1, 107], 75: [2, 30] }, { 23: [2, 98], 33: [2, 98], 54: [2, 98], 68: [2, 98], 72: [2, 98], 75: [2, 98] }, { 23: [2, 45], 33: [2, 45], 54: [2, 45], 65: [2, 45], 68: [2, 45], 72: [2, 45], 73: [1, 108], 75: [2, 45], 80: [2, 45], 81: [2, 45], 82: [2, 45], 83: [2, 45], 84: [2, 45], 85: [2, 45], 87: [2, 45] }, { 23: [2, 44], 33: [2, 44], 54: [2, 44], 65: [2, 44], 68: [2, 44], 72: [2, 44], 75: [2, 44], 80: [2, 44], 81: [2, 44], 82: [2, 44], 83: [2, 44], 84: [2, 44], 85: [2, 44], 87: [2, 44] }, { 54: [1, 109] }, { 54: [2, 83], 65: [2, 83], 72: [2, 83], 80: [2, 83], 81: [2, 83], 82: [2, 83], 83: [2, 83], 84: [2, 83], 85: [2, 83] }, { 54: [2, 85] }, { 5: [2, 13], 14: [2, 13], 15: [2, 13], 19: [2, 13], 29: [2, 13], 34: [2, 13], 39: [2, 13], 44: [2, 13], 47: [2, 13], 48: [2, 13], 51: [2, 13], 55: [2, 13], 60: [2, 13] }, { 38: 55, 39: [1, 57], 43: 56, 44: [1, 58], 45: 111, 46: 110, 47: [2, 76] }, { 33: [2, 70], 40: 112, 65: [2, 70], 72: [2, 70], 75: [2, 70], 80: [2, 70], 81: [2, 70], 82: [2, 70], 83: [2, 70], 84: [2, 70], 85: [2, 70] }, { 47: [2, 18] }, { 5: [2, 14], 14: [2, 14], 15: [2, 14], 19: [2, 14], 29: [2, 14], 34: [2, 14], 39: [2, 14], 44: [2, 14], 47: [2, 14], 48: [2, 14], 51: [2, 14], 55: [2, 14], 60: [2, 14] }, { 33: [1, 113] }, { 33: [2, 87], 65: [2, 87], 72: [2, 87], 80: [2, 87], 81: [2, 87], 82: [2, 87], 83: [2, 87], 84: [2, 87], 85: [2, 87] }, { 33: [2, 89] }, { 20: 74, 63: 115, 64: 75, 65: [1, 43], 67: 114, 68: [2, 96], 69: 116, 70: 76, 71: 77, 72: [1, 78], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 33: [1, 117] }, { 32: 118, 33: [2, 62], 74: 119, 75: [1, 120] }, { 33: [2, 59], 65: [2, 59], 72: [2, 59], 75: [2, 59], 80: [2, 59], 81: [2, 59], 82: [2, 59], 83: [2, 59], 84: [2, 59], 85: [2, 59] }, { 33: [2, 61], 75: [2, 61] }, { 33: [2, 68], 37: 121, 74: 122, 75: [1, 120] }, { 33: [2, 65], 65: [2, 65], 72: [2, 65], 75: [2, 65], 80: [2, 65], 81: [2, 65], 82: [2, 65], 83: [2, 65], 84: [2, 65], 85: [2, 65] }, { 33: [2, 67], 75: [2, 67] }, { 23: [1, 123] }, { 23: [2, 51], 65: [2, 51], 72: [2, 51], 80: [2, 51], 81: [2, 51], 82: [2, 51], 83: [2, 51], 84: [2, 51], 85: [2, 51] }, { 23: [2, 53] }, { 33: [1, 124] }, { 33: [2, 91], 65: [2, 91], 72: [2, 91], 80: [2, 91], 81: [2, 91], 82: [2, 91], 83: [2, 91], 84: [2, 91], 85: [2, 91] }, { 33: [2, 93] }, { 5: [2, 22], 14: [2, 22], 15: [2, 22], 19: [2, 22], 29: [2, 22], 34: [2, 22], 39: [2, 22], 44: [2, 22], 47: [2, 22], 48: [2, 22], 51: [2, 22], 55: [2, 22], 60: [2, 22] }, { 23: [2, 99], 33: [2, 99], 54: [2, 99], 68: [2, 99], 72: [2, 99], 75: [2, 99] }, { 73: [1, 108] }, { 20: 74, 63: 125, 64: 75, 65: [1, 43], 72: [1, 35], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 23], 14: [2, 23], 15: [2, 23], 19: [2, 23], 29: [2, 23], 34: [2, 23], 39: [2, 23], 44: [2, 23], 47: [2, 23], 48: [2, 23], 51: [2, 23], 55: [2, 23], 60: [2, 23] }, { 47: [2, 19] }, { 47: [2, 77] }, { 20: 74, 33: [2, 72], 41: 126, 63: 127, 64: 75, 65: [1, 43], 69: 128, 70: 76, 71: 77, 72: [1, 78], 75: [2, 72], 78: 26, 79: 27, 80: [1, 28], 81: [1, 29], 82: [1, 30], 83: [1, 31], 84: [1, 32], 85: [1, 34], 86: 33 }, { 5: [2, 24], 14: [2, 24], 15: [2, 24], 19: [2, 24], 29: [2, 24], 34: [2, 24], 39: [2, 24], 44: [2, 24], 47: [2, 24], 48: [2, 24], 51: [2, 24], 55: [2, 24], 60: [2, 24] }, { 68: [1, 129] }, { 65: [2, 95], 68: [2, 95], 72: [2, 95], 80: [2, 95], 81: [2, 95], 82: [2, 95], 83: [2, 95], 84: [2, 95], 85: [2, 95] }, { 68: [2, 97] }, { 5: [2, 21], 14: [2, 21], 15: [2, 21], 19: [2, 21], 29: [2, 21], 34: [2, 21], 39: [2, 21], 44: [2, 21], 47: [2, 21], 48: [2, 21], 51: [2, 21], 55: [2, 21], 60: [2, 21] }, { 33: [1, 130] }, { 33: [2, 63] }, { 72: [1, 132], 76: 131 }, { 33: [1, 133] }, { 33: [2, 69] }, { 15: [2, 12], 18: [2, 12] }, { 14: [2, 26], 15: [2, 26], 19: [2, 26], 29: [2, 26], 34: [2, 26], 47: [2, 26], 48: [2, 26], 51: [2, 26], 55: [2, 26], 60: [2, 26] }, { 23: [2, 31], 33: [2, 31], 54: [2, 31], 68: [2, 31], 72: [2, 31], 75: [2, 31] }, { 33: [2, 74], 42: 134, 74: 135, 75: [1, 120] }, { 33: [2, 71], 65: [2, 71], 72: [2, 71], 75: [2, 71], 80: [2, 71], 81: [2, 71], 82: [2, 71], 83: [2, 71], 84: [2, 71], 85: [2, 71] }, { 33: [2, 73], 75: [2, 73] }, { 23: [2, 29], 33: [2, 29], 54: [2, 29], 65: [2, 29], 68: [2, 29], 72: [2, 29], 75: [2, 29], 80: [2, 29], 81: [2, 29], 82: [2, 29], 83: [2, 29], 84: [2, 29], 85: [2, 29] }, { 14: [2, 15], 15: [2, 15], 19: [2, 15], 29: [2, 15], 34: [2, 15], 39: [2, 15], 44: [2, 15], 47: [2, 15], 48: [2, 15], 51: [2, 15], 55: [2, 15], 60: [2, 15] }, { 72: [1, 137], 77: [1, 136] }, { 72: [2, 100], 77: [2, 100] }, { 14: [2, 16], 15: [2, 16], 19: [2, 16], 29: [2, 16], 34: [2, 16], 44: [2, 16], 47: [2, 16], 48: [2, 16], 51: [2, 16], 55: [2, 16], 60: [2, 16] }, { 33: [1, 138] }, { 33: [2, 75] }, { 33: [2, 32] }, { 72: [2, 101], 77: [2, 101] }, { 14: [2, 17], 15: [2, 17], 19: [2, 17], 29: [2, 17], 34: [2, 17], 39: [2, 17], 44: [2, 17], 47: [2, 17], 48: [2, 17], 51: [2, 17], 55: [2, 17], 60: [2, 17] }],
          defaultActions: { 4: [2, 1], 54: [2, 55], 56: [2, 20], 60: [2, 57], 73: [2, 81], 82: [2, 85], 86: [2, 18], 90: [2, 89], 101: [2, 53], 104: [2, 93], 110: [2, 19], 111: [2, 77], 116: [2, 97], 119: [2, 63], 122: [2, 69], 135: [2, 75], 136: [2, 32] },
          parseError: function parseError(str, hash5) {
            throw new Error(str);
          },
          parse: function parse3(input) {
            var self2 = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF2 = 1;
            this.lexer.setInput(input);
            this.lexer.yy = this.yy;
            this.yy.lexer = this.lexer;
            this.yy.parser = this;
            if (typeof this.lexer.yylloc == "undefined")
              this.lexer.yylloc = {};
            var yyloc = this.lexer.yylloc;
            lstack.push(yyloc);
            var ranges = this.lexer.options && this.lexer.options.ranges;
            if (typeof this.yy.parseError === "function")
              this.parseError = this.yy.parseError;
            function popStack(n) {
              stack.length = stack.length - 2 * n;
              vstack.length = vstack.length - n;
              lstack.length = lstack.length - n;
            }
            function lex() {
              var token;
              token = self2.lexer.lex() || 1;
              if (typeof token !== "number") {
                token = self2.symbols_[token] || token;
              }
              return token;
            }
            var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
            while (true) {
              state = stack[stack.length - 1];
              if (this.defaultActions[state]) {
                action = this.defaultActions[state];
              } else {
                if (symbol === null || typeof symbol == "undefined") {
                  symbol = lex();
                }
                action = table[state] && table[state][symbol];
              }
              if (typeof action === "undefined" || !action.length || !action[0]) {
                var errStr = "";
                if (!recovering) {
                  expected = [];
                  for (p in table[state])
                    if (this.terminals_[p] && p > 2) {
                      expected.push("'" + this.terminals_[p] + "'");
                    }
                  if (this.lexer.showPosition) {
                    errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                  } else {
                    errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1 ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'");
                  }
                  this.parseError(errStr, { text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected });
                }
              }
              if (action[0] instanceof Array && action.length > 1) {
                throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
              }
              switch (action[0]) {
                case 1:
                  stack.push(symbol);
                  vstack.push(this.lexer.yytext);
                  lstack.push(this.lexer.yylloc);
                  stack.push(action[1]);
                  symbol = null;
                  if (!preErrorSymbol) {
                    yyleng = this.lexer.yyleng;
                    yytext = this.lexer.yytext;
                    yylineno = this.lexer.yylineno;
                    yyloc = this.lexer.yylloc;
                    if (recovering > 0)
                      recovering--;
                  } else {
                    symbol = preErrorSymbol;
                    preErrorSymbol = null;
                  }
                  break;
                case 2:
                  len = this.productions_[action[1]][1];
                  yyval.$ = vstack[vstack.length - len];
                  yyval._$ = { first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column };
                  if (ranges) {
                    yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
                  }
                  r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
                  if (typeof r !== "undefined") {
                    return r;
                  }
                  if (len) {
                    stack = stack.slice(0, -1 * len * 2);
                    vstack = vstack.slice(0, -1 * len);
                    lstack = lstack.slice(0, -1 * len);
                  }
                  stack.push(this.productions_[action[1]][0]);
                  vstack.push(yyval.$);
                  lstack.push(yyval._$);
                  newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                  stack.push(newState);
                  break;
                case 3:
                  return true;
              }
            }
            return true;
          }
        };
        var lexer = function() {
          var lexer2 = {
            EOF: 1,
            parseError: function parseError(str, hash5) {
              if (this.yy.parser) {
                this.yy.parser.parseError(str, hash5);
              } else {
                throw new Error(str);
              }
            },
            setInput: function setInput(input) {
              this._input = input;
              this._more = this._less = this.done = false;
              this.yylineno = this.yyleng = 0;
              this.yytext = this.matched = this.match = "";
              this.conditionStack = ["INITIAL"];
              this.yylloc = { first_line: 1, first_column: 0, last_line: 1, last_column: 0 };
              if (this.options.ranges)
                this.yylloc.range = [0, 0];
              this.offset = 0;
              return this;
            },
            input: function input() {
              var ch = this._input[0];
              this.yytext += ch;
              this.yyleng++;
              this.offset++;
              this.match += ch;
              this.matched += ch;
              var lines = ch.match(/(?:\r\n?|\n).*/g);
              if (lines) {
                this.yylineno++;
                this.yylloc.last_line++;
              } else {
                this.yylloc.last_column++;
              }
              if (this.options.ranges)
                this.yylloc.range[1]++;
              this._input = this._input.slice(1);
              return ch;
            },
            unput: function unput(ch) {
              var len = ch.length;
              var lines = ch.split(/(?:\r\n?|\n)/g);
              this._input = ch + this._input;
              this.yytext = this.yytext.substr(0, this.yytext.length - len - 1);
              this.offset -= len;
              var oldLines = this.match.split(/(?:\r\n?|\n)/g);
              this.match = this.match.substr(0, this.match.length - 1);
              this.matched = this.matched.substr(0, this.matched.length - 1);
              if (lines.length - 1)
                this.yylineno -= lines.length - 1;
              var r = this.yylloc.range;
              this.yylloc = {
                first_line: this.yylloc.first_line,
                last_line: this.yylineno + 1,
                first_column: this.yylloc.first_column,
                last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
              };
              if (this.options.ranges) {
                this.yylloc.range = [r[0], r[0] + this.yyleng - len];
              }
              return this;
            },
            more: function more() {
              this._more = true;
              return this;
            },
            less: function less(n) {
              this.unput(this.match.slice(n));
            },
            pastInput: function pastInput() {
              var past = this.matched.substr(0, this.matched.length - this.match.length);
              return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
            },
            upcomingInput: function upcomingInput() {
              var next = this.match;
              if (next.length < 20) {
                next += this._input.substr(0, 20 - next.length);
              }
              return (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
            },
            showPosition: function showPosition() {
              var pre = this.pastInput();
              var c = new Array(pre.length + 1).join("-");
              return pre + this.upcomingInput() + "\n" + c + "^";
            },
            next: function next() {
              if (this.done) {
                return this.EOF;
              }
              if (!this._input)
                this.done = true;
              var token, match3, tempMatch, index, col, lines;
              if (!this._more) {
                this.yytext = "";
                this.match = "";
              }
              var rules = this._currentRules();
              for (var i = 0; i < rules.length; i++) {
                tempMatch = this._input.match(this.rules[rules[i]]);
                if (tempMatch && (!match3 || tempMatch[0].length > match3[0].length)) {
                  match3 = tempMatch;
                  index = i;
                  if (!this.options.flex)
                    break;
                }
              }
              if (match3) {
                lines = match3[0].match(/(?:\r\n?|\n).*/g);
                if (lines)
                  this.yylineno += lines.length;
                this.yylloc = {
                  first_line: this.yylloc.last_line,
                  last_line: this.yylineno + 1,
                  first_column: this.yylloc.last_column,
                  last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match3[0].length
                };
                this.yytext += match3[0];
                this.match += match3[0];
                this.matches = match3;
                this.yyleng = this.yytext.length;
                if (this.options.ranges) {
                  this.yylloc.range = [this.offset, this.offset += this.yyleng];
                }
                this._more = false;
                this._input = this._input.slice(match3[0].length);
                this.matched += match3[0];
                token = this.performAction.call(this, this.yy, this, rules[index], this.conditionStack[this.conditionStack.length - 1]);
                if (this.done && this._input)
                  this.done = false;
                if (token)
                  return token;
                else
                  return;
              }
              if (this._input === "") {
                return this.EOF;
              } else {
                return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), { text: "", token: null, line: this.yylineno });
              }
            },
            lex: function lex() {
              var r = this.next();
              if (typeof r !== "undefined") {
                return r;
              } else {
                return this.lex();
              }
            },
            begin: function begin(condition) {
              this.conditionStack.push(condition);
            },
            popState: function popState() {
              return this.conditionStack.pop();
            },
            _currentRules: function _currentRules() {
              return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
            },
            topState: function topState() {
              return this.conditionStack[this.conditionStack.length - 2];
            },
            pushState: function begin(condition) {
              this.begin(condition);
            }
          };
          lexer2.options = {};
          lexer2.performAction = function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
            function strip(start, end) {
              return yy_.yytext = yy_.yytext.substring(start, yy_.yyleng - end + start);
            }
            var YYSTATE = YY_START;
            switch ($avoiding_name_collisions) {
              case 0:
                if (yy_.yytext.slice(-2) === "\\\\") {
                  strip(0, 1);
                  this.begin("mu");
                } else if (yy_.yytext.slice(-1) === "\\") {
                  strip(0, 1);
                  this.begin("emu");
                } else {
                  this.begin("mu");
                }
                if (yy_.yytext)
                  return 15;
                break;
              case 1:
                return 15;
                break;
              case 2:
                this.popState();
                return 15;
                break;
              case 3:
                this.begin("raw");
                return 15;
                break;
              case 4:
                this.popState();
                if (this.conditionStack[this.conditionStack.length - 1] === "raw") {
                  return 15;
                } else {
                  strip(5, 9);
                  return "END_RAW_BLOCK";
                }
                break;
              case 5:
                return 15;
                break;
              case 6:
                this.popState();
                return 14;
                break;
              case 7:
                return 65;
                break;
              case 8:
                return 68;
                break;
              case 9:
                return 19;
                break;
              case 10:
                this.popState();
                this.begin("raw");
                return 23;
                break;
              case 11:
                return 55;
                break;
              case 12:
                return 60;
                break;
              case 13:
                return 29;
                break;
              case 14:
                return 47;
                break;
              case 15:
                this.popState();
                return 44;
                break;
              case 16:
                this.popState();
                return 44;
                break;
              case 17:
                return 34;
                break;
              case 18:
                return 39;
                break;
              case 19:
                return 51;
                break;
              case 20:
                return 48;
                break;
              case 21:
                this.unput(yy_.yytext);
                this.popState();
                this.begin("com");
                break;
              case 22:
                this.popState();
                return 14;
                break;
              case 23:
                return 48;
                break;
              case 24:
                return 73;
                break;
              case 25:
                return 72;
                break;
              case 26:
                return 72;
                break;
              case 27:
                return 87;
                break;
              case 28:
                break;
              case 29:
                this.popState();
                return 54;
                break;
              case 30:
                this.popState();
                return 33;
                break;
              case 31:
                yy_.yytext = strip(1, 2).replace(/\\"/g, '"');
                return 80;
                break;
              case 32:
                yy_.yytext = strip(1, 2).replace(/\\'/g, "'");
                return 80;
                break;
              case 33:
                return 85;
                break;
              case 34:
                return 82;
                break;
              case 35:
                return 82;
                break;
              case 36:
                return 83;
                break;
              case 37:
                return 84;
                break;
              case 38:
                return 81;
                break;
              case 39:
                return 75;
                break;
              case 40:
                return 77;
                break;
              case 41:
                return 72;
                break;
              case 42:
                yy_.yytext = yy_.yytext.replace(/\\([\\\]])/g, "$1");
                return 72;
                break;
              case 43:
                return "INVALID";
                break;
              case 44:
                return 5;
                break;
            }
          };
          lexer2.rules = [/^(?:[^\x00]*?(?=(\{\{)))/, /^(?:[^\x00]+)/, /^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/, /^(?:\{\{\{\{(?=[^\/]))/, /^(?:\{\{\{\{\/[^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=[=}\s\/.])\}\}\}\})/, /^(?:[^\x00]+?(?=(\{\{\{\{)))/, /^(?:[\s\S]*?--(~)?\}\})/, /^(?:\()/, /^(?:\))/, /^(?:\{\{\{\{)/, /^(?:\}\}\}\})/, /^(?:\{\{(~)?>)/, /^(?:\{\{(~)?#>)/, /^(?:\{\{(~)?#\*?)/, /^(?:\{\{(~)?\/)/, /^(?:\{\{(~)?\^\s*(~)?\}\})/, /^(?:\{\{(~)?\s*else\s*(~)?\}\})/, /^(?:\{\{(~)?\^)/, /^(?:\{\{(~)?\s*else\b)/, /^(?:\{\{(~)?\{)/, /^(?:\{\{(~)?&)/, /^(?:\{\{(~)?!--)/, /^(?:\{\{(~)?![\s\S]*?\}\})/, /^(?:\{\{(~)?\*?)/, /^(?:=)/, /^(?:\.\.)/, /^(?:\.(?=([=~}\s\/.)|])))/, /^(?:[\/.])/, /^(?:\s+)/, /^(?:\}(~)?\}\})/, /^(?:(~)?\}\})/, /^(?:"(\\["]|[^"])*")/, /^(?:'(\\[']|[^'])*')/, /^(?:@)/, /^(?:true(?=([~}\s)])))/, /^(?:false(?=([~}\s)])))/, /^(?:undefined(?=([~}\s)])))/, /^(?:null(?=([~}\s)])))/, /^(?:-?[0-9]+(?:\.[0-9]+)?(?=([~}\s)])))/, /^(?:as\s+\|)/, /^(?:\|)/, /^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)|]))))/, /^(?:\[(\\\]|[^\]])*\])/, /^(?:.)/, /^(?:$)/];
          lexer2.conditions = { "mu": { "rules": [7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44], "inclusive": false }, "emu": { "rules": [2], "inclusive": false }, "com": { "rules": [6], "inclusive": false }, "raw": { "rules": [3, 4, 5], "inclusive": false }, "INITIAL": { "rules": [0, 1, 44], "inclusive": true } };
          return lexer2;
        }();
        parser.lexer = lexer;
        function Parser2() {
          this.yy = {};
        }
        Parser2.prototype = parser;
        parser.Parser = Parser2;
        return new Parser2();
      }();
      exports["default"] = handlebars;
      module2.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/visitor.js
  var require_visitor = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/visitor.js"(exports, module2) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      function Visitor() {
        this.parents = [];
      }
      Visitor.prototype = {
        constructor: Visitor,
        mutating: false,
        // Visits a given value. If mutating, will replace the value if necessary.
        acceptKey: function acceptKey(node, name) {
          var value = this.accept(node[name]);
          if (this.mutating) {
            if (value && !Visitor.prototype[value.type]) {
              throw new _exception2["default"]('Unexpected node type "' + value.type + '" found when accepting ' + name + " on " + node.type);
            }
            node[name] = value;
          }
        },
        // Performs an accept operation with added sanity check to ensure
        // required keys are not removed.
        acceptRequired: function acceptRequired(node, name) {
          this.acceptKey(node, name);
          if (!node[name]) {
            throw new _exception2["default"](node.type + " requires " + name);
          }
        },
        // Traverses a given array. If mutating, empty respnses will be removed
        // for child elements.
        acceptArray: function acceptArray(array2) {
          for (var i = 0, l = array2.length; i < l; i++) {
            this.acceptKey(array2, i);
            if (!array2[i]) {
              array2.splice(i, 1);
              i--;
              l--;
            }
          }
        },
        accept: function accept(object2) {
          if (!object2) {
            return;
          }
          if (!this[object2.type]) {
            throw new _exception2["default"]("Unknown type: " + object2.type, object2);
          }
          if (this.current) {
            this.parents.unshift(this.current);
          }
          this.current = object2;
          var ret3 = this[object2.type](object2);
          this.current = this.parents.shift();
          if (!this.mutating || ret3) {
            return ret3;
          } else if (ret3 !== false) {
            return object2;
          }
        },
        Program: function Program(program2) {
          this.acceptArray(program2.body);
        },
        MustacheStatement: visitSubExpression,
        Decorator: visitSubExpression,
        BlockStatement: visitBlock,
        DecoratorBlock: visitBlock,
        PartialStatement: visitPartial,
        PartialBlockStatement: function PartialBlockStatement(partial) {
          visitPartial.call(this, partial);
          this.acceptKey(partial, "program");
        },
        ContentStatement: function ContentStatement() {
        },
        CommentStatement: function CommentStatement() {
        },
        SubExpression: visitSubExpression,
        PathExpression: function PathExpression() {
        },
        StringLiteral: function StringLiteral() {
        },
        NumberLiteral: function NumberLiteral() {
        },
        BooleanLiteral: function BooleanLiteral() {
        },
        UndefinedLiteral: function UndefinedLiteral() {
        },
        NullLiteral: function NullLiteral() {
        },
        Hash: function Hash3(hash5) {
          this.acceptArray(hash5.pairs);
        },
        HashPair: function HashPair(pair) {
          this.acceptRequired(pair, "value");
        }
      };
      function visitSubExpression(mustache) {
        this.acceptRequired(mustache, "path");
        this.acceptArray(mustache.params);
        this.acceptKey(mustache, "hash");
      }
      function visitBlock(block) {
        visitSubExpression.call(this, block);
        this.acceptKey(block, "program");
        this.acceptKey(block, "inverse");
      }
      function visitPartial(partial) {
        this.acceptRequired(partial, "name");
        this.acceptArray(partial.params);
        this.acceptKey(partial, "hash");
      }
      exports["default"] = Visitor;
      module2.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/whitespace-control.js
  var require_whitespace_control = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/whitespace-control.js"(exports, module2) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _visitor = require_visitor();
      var _visitor2 = _interopRequireDefault(_visitor);
      function WhitespaceControl() {
        var options = arguments.length <= 0 || arguments[0] === void 0 ? {} : arguments[0];
        this.options = options;
      }
      WhitespaceControl.prototype = new _visitor2["default"]();
      WhitespaceControl.prototype.Program = function(program2) {
        var doStandalone = !this.options.ignoreStandalone;
        var isRoot = !this.isRootSeen;
        this.isRootSeen = true;
        var body = program2.body;
        for (var i = 0, l = body.length; i < l; i++) {
          var current = body[i], strip = this.accept(current);
          if (!strip) {
            continue;
          }
          var _isPrevWhitespace = isPrevWhitespace(body, i, isRoot), _isNextWhitespace = isNextWhitespace(body, i, isRoot), openStandalone = strip.openStandalone && _isPrevWhitespace, closeStandalone = strip.closeStandalone && _isNextWhitespace, inlineStandalone = strip.inlineStandalone && _isPrevWhitespace && _isNextWhitespace;
          if (strip.close) {
            omitRight(body, i, true);
          }
          if (strip.open) {
            omitLeft(body, i, true);
          }
          if (doStandalone && inlineStandalone) {
            omitRight(body, i);
            if (omitLeft(body, i)) {
              if (current.type === "PartialStatement") {
                current.indent = /([ \t]+$)/.exec(body[i - 1].original)[1];
              }
            }
          }
          if (doStandalone && openStandalone) {
            omitRight((current.program || current.inverse).body);
            omitLeft(body, i);
          }
          if (doStandalone && closeStandalone) {
            omitRight(body, i);
            omitLeft((current.inverse || current.program).body);
          }
        }
        return program2;
      };
      WhitespaceControl.prototype.BlockStatement = WhitespaceControl.prototype.DecoratorBlock = WhitespaceControl.prototype.PartialBlockStatement = function(block) {
        this.accept(block.program);
        this.accept(block.inverse);
        var program2 = block.program || block.inverse, inverse = block.program && block.inverse, firstInverse = inverse, lastInverse = inverse;
        if (inverse && inverse.chained) {
          firstInverse = inverse.body[0].program;
          while (lastInverse.chained) {
            lastInverse = lastInverse.body[lastInverse.body.length - 1].program;
          }
        }
        var strip = {
          open: block.openStrip.open,
          close: block.closeStrip.close,
          // Determine the standalone candiacy. Basically flag our content as being possibly standalone
          // so our parent can determine if we actually are standalone
          openStandalone: isNextWhitespace(program2.body),
          closeStandalone: isPrevWhitespace((firstInverse || program2).body)
        };
        if (block.openStrip.close) {
          omitRight(program2.body, null, true);
        }
        if (inverse) {
          var inverseStrip = block.inverseStrip;
          if (inverseStrip.open) {
            omitLeft(program2.body, null, true);
          }
          if (inverseStrip.close) {
            omitRight(firstInverse.body, null, true);
          }
          if (block.closeStrip.open) {
            omitLeft(lastInverse.body, null, true);
          }
          if (!this.options.ignoreStandalone && isPrevWhitespace(program2.body) && isNextWhitespace(firstInverse.body)) {
            omitLeft(program2.body);
            omitRight(firstInverse.body);
          }
        } else if (block.closeStrip.open) {
          omitLeft(program2.body, null, true);
        }
        return strip;
      };
      WhitespaceControl.prototype.Decorator = WhitespaceControl.prototype.MustacheStatement = function(mustache) {
        return mustache.strip;
      };
      WhitespaceControl.prototype.PartialStatement = WhitespaceControl.prototype.CommentStatement = function(node) {
        var strip = node.strip || {};
        return {
          inlineStandalone: true,
          open: strip.open,
          close: strip.close
        };
      };
      function isPrevWhitespace(body, i, isRoot) {
        if (i === void 0) {
          i = body.length;
        }
        var prev = body[i - 1], sibling = body[i - 2];
        if (!prev) {
          return isRoot;
        }
        if (prev.type === "ContentStatement") {
          return (sibling || !isRoot ? /\r?\n\s*?$/ : /(^|\r?\n)\s*?$/).test(prev.original);
        }
      }
      function isNextWhitespace(body, i, isRoot) {
        if (i === void 0) {
          i = -1;
        }
        var next = body[i + 1], sibling = body[i + 2];
        if (!next) {
          return isRoot;
        }
        if (next.type === "ContentStatement") {
          return (sibling || !isRoot ? /^\s*?\r?\n/ : /^\s*?(\r?\n|$)/).test(next.original);
        }
      }
      function omitRight(body, i, multiple) {
        var current = body[i == null ? 0 : i + 1];
        if (!current || current.type !== "ContentStatement" || !multiple && current.rightStripped) {
          return;
        }
        var original = current.value;
        current.value = current.value.replace(multiple ? /^\s+/ : /^[ \t]*\r?\n?/, "");
        current.rightStripped = current.value !== original;
      }
      function omitLeft(body, i, multiple) {
        var current = body[i == null ? body.length - 1 : i - 1];
        if (!current || current.type !== "ContentStatement" || !multiple && current.leftStripped) {
          return;
        }
        var original = current.value;
        current.value = current.value.replace(multiple ? /\s+$/ : /[ \t]+$/, "");
        current.leftStripped = current.value !== original;
        return current.leftStripped;
      }
      exports["default"] = WhitespaceControl;
      module2.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/helpers.js
  var require_helpers2 = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/helpers.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.SourceLocation = SourceLocation;
      exports.id = id;
      exports.stripFlags = stripFlags;
      exports.stripComment = stripComment;
      exports.preparePath = preparePath;
      exports.prepareMustache = prepareMustache;
      exports.prepareRawBlock = prepareRawBlock;
      exports.prepareBlock = prepareBlock;
      exports.prepareProgram = prepareProgram;
      exports.preparePartialBlock = preparePartialBlock;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      function validateClose(open, close) {
        close = close.path ? close.path.original : close;
        if (open.path.original !== close) {
          var errorNode = { loc: open.path.loc };
          throw new _exception2["default"](open.path.original + " doesn't match " + close, errorNode);
        }
      }
      function SourceLocation(source, locInfo) {
        this.source = source;
        this.start = {
          line: locInfo.first_line,
          column: locInfo.first_column
        };
        this.end = {
          line: locInfo.last_line,
          column: locInfo.last_column
        };
      }
      function id(token) {
        if (/^\[.*\]$/.test(token)) {
          return token.substring(1, token.length - 1);
        } else {
          return token;
        }
      }
      function stripFlags(open, close) {
        return {
          open: open.charAt(2) === "~",
          close: close.charAt(close.length - 3) === "~"
        };
      }
      function stripComment(comment) {
        return comment.replace(/^\{\{~?!-?-?/, "").replace(/-?-?~?\}\}$/, "");
      }
      function preparePath(data, parts, loc) {
        loc = this.locInfo(loc);
        var original = data ? "@" : "", dig = [], depth = 0;
        for (var i = 0, l = parts.length; i < l; i++) {
          var part = parts[i].part, isLiteral = parts[i].original !== part;
          original += (parts[i].separator || "") + part;
          if (!isLiteral && (part === ".." || part === "." || part === "this")) {
            if (dig.length > 0) {
              throw new _exception2["default"]("Invalid path: " + original, { loc });
            } else if (part === "..") {
              depth++;
            }
          } else {
            dig.push(part);
          }
        }
        return {
          type: "PathExpression",
          data,
          depth,
          parts: dig,
          original,
          loc
        };
      }
      function prepareMustache(path4, params, hash5, open, strip, locInfo) {
        var escapeFlag = open.charAt(3) || open.charAt(2), escaped = escapeFlag !== "{" && escapeFlag !== "&";
        var decorator = /\*/.test(open);
        return {
          type: decorator ? "Decorator" : "MustacheStatement",
          path: path4,
          params,
          hash: hash5,
          escaped,
          strip,
          loc: this.locInfo(locInfo)
        };
      }
      function prepareRawBlock(openRawBlock, contents, close, locInfo) {
        validateClose(openRawBlock, close);
        locInfo = this.locInfo(locInfo);
        var program2 = {
          type: "Program",
          body: contents,
          strip: {},
          loc: locInfo
        };
        return {
          type: "BlockStatement",
          path: openRawBlock.path,
          params: openRawBlock.params,
          hash: openRawBlock.hash,
          program: program2,
          openStrip: {},
          inverseStrip: {},
          closeStrip: {},
          loc: locInfo
        };
      }
      function prepareBlock(openBlock, program2, inverseAndProgram, close, inverted, locInfo) {
        if (close && close.path) {
          validateClose(openBlock, close);
        }
        var decorator = /\*/.test(openBlock.open);
        program2.blockParams = openBlock.blockParams;
        var inverse = void 0, inverseStrip = void 0;
        if (inverseAndProgram) {
          if (decorator) {
            throw new _exception2["default"]("Unexpected inverse block on decorator", inverseAndProgram);
          }
          if (inverseAndProgram.chain) {
            inverseAndProgram.program.body[0].closeStrip = close.strip;
          }
          inverseStrip = inverseAndProgram.strip;
          inverse = inverseAndProgram.program;
        }
        if (inverted) {
          inverted = inverse;
          inverse = program2;
          program2 = inverted;
        }
        return {
          type: decorator ? "DecoratorBlock" : "BlockStatement",
          path: openBlock.path,
          params: openBlock.params,
          hash: openBlock.hash,
          program: program2,
          inverse,
          openStrip: openBlock.strip,
          inverseStrip,
          closeStrip: close && close.strip,
          loc: this.locInfo(locInfo)
        };
      }
      function prepareProgram(statements, loc) {
        if (!loc && statements.length) {
          var firstLoc = statements[0].loc, lastLoc = statements[statements.length - 1].loc;
          if (firstLoc && lastLoc) {
            loc = {
              source: firstLoc.source,
              start: {
                line: firstLoc.start.line,
                column: firstLoc.start.column
              },
              end: {
                line: lastLoc.end.line,
                column: lastLoc.end.column
              }
            };
          }
        }
        return {
          type: "Program",
          body: statements,
          strip: {},
          loc
        };
      }
      function preparePartialBlock(open, program2, close, locInfo) {
        validateClose(open, close);
        return {
          type: "PartialBlockStatement",
          name: open.path,
          params: open.params,
          hash: open.hash,
          program: program2,
          openStrip: open.strip,
          closeStrip: close && close.strip,
          loc: this.locInfo(locInfo)
        };
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/base.js
  var require_base2 = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/base.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.parseWithoutProcessing = parseWithoutProcessing;
      exports.parse = parse3;
      function _interopRequireWildcard(obj) {
        if (obj && obj.__esModule) {
          return obj;
        } else {
          var newObj = {};
          if (obj != null) {
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key))
                newObj[key] = obj[key];
            }
          }
          newObj["default"] = obj;
          return newObj;
        }
      }
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _parser = require_parser();
      var _parser2 = _interopRequireDefault(_parser);
      var _whitespaceControl = require_whitespace_control();
      var _whitespaceControl2 = _interopRequireDefault(_whitespaceControl);
      var _helpers = require_helpers2();
      var Helpers = _interopRequireWildcard(_helpers);
      var _utils = require_utils();
      exports.parser = _parser2["default"];
      var yy = {};
      _utils.extend(yy, Helpers);
      function parseWithoutProcessing(input, options) {
        if (input.type === "Program") {
          return input;
        }
        _parser2["default"].yy = yy;
        yy.locInfo = function(locInfo) {
          return new yy.SourceLocation(options && options.srcName, locInfo);
        };
        var ast = _parser2["default"].parse(input);
        return ast;
      }
      function parse3(input, options) {
        var ast = parseWithoutProcessing(input, options);
        var strip = new _whitespaceControl2["default"](options);
        return strip.accept(ast);
      }
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js
  var require_compiler = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/compiler.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.Compiler = Compiler;
      exports.precompile = precompile;
      exports.compile = compile6;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      var _utils = require_utils();
      var _ast = require_ast();
      var _ast2 = _interopRequireDefault(_ast);
      var slice = [].slice;
      function Compiler() {
      }
      Compiler.prototype = {
        compiler: Compiler,
        equals: function equals3(other) {
          var len = this.opcodes.length;
          if (other.opcodes.length !== len) {
            return false;
          }
          for (var i = 0; i < len; i++) {
            var opcode = this.opcodes[i], otherOpcode = other.opcodes[i];
            if (opcode.opcode !== otherOpcode.opcode || !argEquals(opcode.args, otherOpcode.args)) {
              return false;
            }
          }
          len = this.children.length;
          for (var i = 0; i < len; i++) {
            if (!this.children[i].equals(other.children[i])) {
              return false;
            }
          }
          return true;
        },
        guid: 0,
        compile: function compile7(program2, options) {
          this.sourceNode = [];
          this.opcodes = [];
          this.children = [];
          this.options = options;
          this.stringParams = options.stringParams;
          this.trackIds = options.trackIds;
          options.blockParams = options.blockParams || [];
          options.knownHelpers = _utils.extend(/* @__PURE__ */ Object.create(null), {
            helperMissing: true,
            blockHelperMissing: true,
            each: true,
            "if": true,
            unless: true,
            "with": true,
            log: true,
            lookup: true
          }, options.knownHelpers);
          return this.accept(program2);
        },
        compileProgram: function compileProgram(program2) {
          var childCompiler = new this.compiler(), result = childCompiler.compile(program2, this.options), guid = this.guid++;
          this.usePartial = this.usePartial || result.usePartial;
          this.children[guid] = result;
          this.useDepths = this.useDepths || result.useDepths;
          return guid;
        },
        accept: function accept(node) {
          if (!this[node.type]) {
            throw new _exception2["default"]("Unknown type: " + node.type, node);
          }
          this.sourceNode.unshift(node);
          var ret3 = this[node.type](node);
          this.sourceNode.shift();
          return ret3;
        },
        Program: function Program(program2) {
          this.options.blockParams.unshift(program2.blockParams);
          var body = program2.body, bodyLength = body.length;
          for (var i = 0; i < bodyLength; i++) {
            this.accept(body[i]);
          }
          this.options.blockParams.shift();
          this.isSimple = bodyLength === 1;
          this.blockParams = program2.blockParams ? program2.blockParams.length : 0;
          return this;
        },
        BlockStatement: function BlockStatement(block) {
          transformLiteralToPath(block);
          var program2 = block.program, inverse = block.inverse;
          program2 = program2 && this.compileProgram(program2);
          inverse = inverse && this.compileProgram(inverse);
          var type3 = this.classifySexpr(block);
          if (type3 === "helper") {
            this.helperSexpr(block, program2, inverse);
          } else if (type3 === "simple") {
            this.simpleSexpr(block);
            this.opcode("pushProgram", program2);
            this.opcode("pushProgram", inverse);
            this.opcode("emptyHash");
            this.opcode("blockValue", block.path.original);
          } else {
            this.ambiguousSexpr(block, program2, inverse);
            this.opcode("pushProgram", program2);
            this.opcode("pushProgram", inverse);
            this.opcode("emptyHash");
            this.opcode("ambiguousBlockValue");
          }
          this.opcode("append");
        },
        DecoratorBlock: function DecoratorBlock(decorator) {
          var program2 = decorator.program && this.compileProgram(decorator.program);
          var params = this.setupFullMustacheParams(decorator, program2, void 0), path4 = decorator.path;
          this.useDecorators = true;
          this.opcode("registerDecorator", params.length, path4.original);
        },
        PartialStatement: function PartialStatement(partial) {
          this.usePartial = true;
          var program2 = partial.program;
          if (program2) {
            program2 = this.compileProgram(partial.program);
          }
          var params = partial.params;
          if (params.length > 1) {
            throw new _exception2["default"]("Unsupported number of partial arguments: " + params.length, partial);
          } else if (!params.length) {
            if (this.options.explicitPartialContext) {
              this.opcode("pushLiteral", "undefined");
            } else {
              params.push({ type: "PathExpression", parts: [], depth: 0 });
            }
          }
          var partialName = partial.name.original, isDynamic = partial.name.type === "SubExpression";
          if (isDynamic) {
            this.accept(partial.name);
          }
          this.setupFullMustacheParams(partial, program2, void 0, true);
          var indent = partial.indent || "";
          if (this.options.preventIndent && indent) {
            this.opcode("appendContent", indent);
            indent = "";
          }
          this.opcode("invokePartial", isDynamic, partialName, indent);
          this.opcode("append");
        },
        PartialBlockStatement: function PartialBlockStatement(partialBlock) {
          this.PartialStatement(partialBlock);
        },
        MustacheStatement: function MustacheStatement(mustache) {
          this.SubExpression(mustache);
          if (mustache.escaped && !this.options.noEscape) {
            this.opcode("appendEscaped");
          } else {
            this.opcode("append");
          }
        },
        Decorator: function Decorator(decorator) {
          this.DecoratorBlock(decorator);
        },
        ContentStatement: function ContentStatement(content) {
          if (content.value) {
            this.opcode("appendContent", content.value);
          }
        },
        CommentStatement: function CommentStatement() {
        },
        SubExpression: function SubExpression(sexpr) {
          transformLiteralToPath(sexpr);
          var type3 = this.classifySexpr(sexpr);
          if (type3 === "simple") {
            this.simpleSexpr(sexpr);
          } else if (type3 === "helper") {
            this.helperSexpr(sexpr);
          } else {
            this.ambiguousSexpr(sexpr);
          }
        },
        ambiguousSexpr: function ambiguousSexpr(sexpr, program2, inverse) {
          var path4 = sexpr.path, name = path4.parts[0], isBlock = program2 != null || inverse != null;
          this.opcode("getContext", path4.depth);
          this.opcode("pushProgram", program2);
          this.opcode("pushProgram", inverse);
          path4.strict = true;
          this.accept(path4);
          this.opcode("invokeAmbiguous", name, isBlock);
        },
        simpleSexpr: function simpleSexpr(sexpr) {
          var path4 = sexpr.path;
          path4.strict = true;
          this.accept(path4);
          this.opcode("resolvePossibleLambda");
        },
        helperSexpr: function helperSexpr(sexpr, program2, inverse) {
          var params = this.setupFullMustacheParams(sexpr, program2, inverse), path4 = sexpr.path, name = path4.parts[0];
          if (this.options.knownHelpers[name]) {
            this.opcode("invokeKnownHelper", params.length, name);
          } else if (this.options.knownHelpersOnly) {
            throw new _exception2["default"]("You specified knownHelpersOnly, but used the unknown helper " + name, sexpr);
          } else {
            path4.strict = true;
            path4.falsy = true;
            this.accept(path4);
            this.opcode("invokeHelper", params.length, path4.original, _ast2["default"].helpers.simpleId(path4));
          }
        },
        PathExpression: function PathExpression(path4) {
          this.addDepth(path4.depth);
          this.opcode("getContext", path4.depth);
          var name = path4.parts[0], scoped = _ast2["default"].helpers.scopedId(path4), blockParamId = !path4.depth && !scoped && this.blockParamIndex(name);
          if (blockParamId) {
            this.opcode("lookupBlockParam", blockParamId, path4.parts);
          } else if (!name) {
            this.opcode("pushContext");
          } else if (path4.data) {
            this.options.data = true;
            this.opcode("lookupData", path4.depth, path4.parts, path4.strict);
          } else {
            this.opcode("lookupOnContext", path4.parts, path4.falsy, path4.strict, scoped);
          }
        },
        StringLiteral: function StringLiteral(string2) {
          this.opcode("pushString", string2.value);
        },
        NumberLiteral: function NumberLiteral(number4) {
          this.opcode("pushLiteral", number4.value);
        },
        BooleanLiteral: function BooleanLiteral(bool3) {
          this.opcode("pushLiteral", bool3.value);
        },
        UndefinedLiteral: function UndefinedLiteral() {
          this.opcode("pushLiteral", "undefined");
        },
        NullLiteral: function NullLiteral() {
          this.opcode("pushLiteral", "null");
        },
        Hash: function Hash3(hash5) {
          var pairs = hash5.pairs, i = 0, l = pairs.length;
          this.opcode("pushHash");
          for (; i < l; i++) {
            this.pushParam(pairs[i].value);
          }
          while (i--) {
            this.opcode("assignToHash", pairs[i].key);
          }
          this.opcode("popHash");
        },
        // HELPERS
        opcode: function opcode(name) {
          this.opcodes.push({
            opcode: name,
            args: slice.call(arguments, 1),
            loc: this.sourceNode[0].loc
          });
        },
        addDepth: function addDepth(depth) {
          if (!depth) {
            return;
          }
          this.useDepths = true;
        },
        classifySexpr: function classifySexpr(sexpr) {
          var isSimple = _ast2["default"].helpers.simpleId(sexpr.path);
          var isBlockParam = isSimple && !!this.blockParamIndex(sexpr.path.parts[0]);
          var isHelper = !isBlockParam && _ast2["default"].helpers.helperExpression(sexpr);
          var isEligible = !isBlockParam && (isHelper || isSimple);
          if (isEligible && !isHelper) {
            var _name = sexpr.path.parts[0], options = this.options;
            if (options.knownHelpers[_name]) {
              isHelper = true;
            } else if (options.knownHelpersOnly) {
              isEligible = false;
            }
          }
          if (isHelper) {
            return "helper";
          } else if (isEligible) {
            return "ambiguous";
          } else {
            return "simple";
          }
        },
        pushParams: function pushParams(params) {
          for (var i = 0, l = params.length; i < l; i++) {
            this.pushParam(params[i]);
          }
        },
        pushParam: function pushParam(val) {
          var value = val.value != null ? val.value : val.original || "";
          if (this.stringParams) {
            if (value.replace) {
              value = value.replace(/^(\.?\.\/)*/g, "").replace(/\//g, ".");
            }
            if (val.depth) {
              this.addDepth(val.depth);
            }
            this.opcode("getContext", val.depth || 0);
            this.opcode("pushStringParam", value, val.type);
            if (val.type === "SubExpression") {
              this.accept(val);
            }
          } else {
            if (this.trackIds) {
              var blockParamIndex = void 0;
              if (val.parts && !_ast2["default"].helpers.scopedId(val) && !val.depth) {
                blockParamIndex = this.blockParamIndex(val.parts[0]);
              }
              if (blockParamIndex) {
                var blockParamChild = val.parts.slice(1).join(".");
                this.opcode("pushId", "BlockParam", blockParamIndex, blockParamChild);
              } else {
                value = val.original || value;
                if (value.replace) {
                  value = value.replace(/^this(?:\.|$)/, "").replace(/^\.\//, "").replace(/^\.$/, "");
                }
                this.opcode("pushId", val.type, value);
              }
            }
            this.accept(val);
          }
        },
        setupFullMustacheParams: function setupFullMustacheParams(sexpr, program2, inverse, omitEmpty) {
          var params = sexpr.params;
          this.pushParams(params);
          this.opcode("pushProgram", program2);
          this.opcode("pushProgram", inverse);
          if (sexpr.hash) {
            this.accept(sexpr.hash);
          } else {
            this.opcode("emptyHash", omitEmpty);
          }
          return params;
        },
        blockParamIndex: function blockParamIndex(name) {
          for (var depth = 0, len = this.options.blockParams.length; depth < len; depth++) {
            var blockParams = this.options.blockParams[depth], param = blockParams && _utils.indexOf(blockParams, name);
            if (blockParams && param >= 0) {
              return [depth, param];
            }
          }
        }
      };
      function precompile(input, options, env) {
        if (input == null || typeof input !== "string" && input.type !== "Program") {
          throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + input);
        }
        options = options || {};
        if (!("data" in options)) {
          options.data = true;
        }
        if (options.compat) {
          options.useDepths = true;
        }
        var ast = env.parse(input, options), environment = new env.Compiler().compile(ast, options);
        return new env.JavaScriptCompiler().compile(environment, options);
      }
      function compile6(input, options, env) {
        if (options === void 0)
          options = {};
        if (input == null || typeof input !== "string" && input.type !== "Program") {
          throw new _exception2["default"]("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + input);
        }
        options = _utils.extend({}, options);
        if (!("data" in options)) {
          options.data = true;
        }
        if (options.compat) {
          options.useDepths = true;
        }
        var compiled = void 0;
        function compileInput() {
          var ast = env.parse(input, options), environment = new env.Compiler().compile(ast, options), templateSpec = new env.JavaScriptCompiler().compile(environment, options, void 0, true);
          return env.template(templateSpec);
        }
        function ret3(context2, execOptions) {
          if (!compiled) {
            compiled = compileInput();
          }
          return compiled.call(this, context2, execOptions);
        }
        ret3._setup = function(setupOptions) {
          if (!compiled) {
            compiled = compileInput();
          }
          return compiled._setup(setupOptions);
        };
        ret3._child = function(i, data, blockParams, depths) {
          if (!compiled) {
            compiled = compileInput();
          }
          return compiled._child(i, data, blockParams, depths);
        };
        return ret3;
      }
      function argEquals(a, b) {
        if (a === b) {
          return true;
        }
        if (_utils.isArray(a) && _utils.isArray(b) && a.length === b.length) {
          for (var i = 0; i < a.length; i++) {
            if (!argEquals(a[i], b[i])) {
              return false;
            }
          }
          return true;
        }
      }
      function transformLiteralToPath(sexpr) {
        if (!sexpr.path.parts) {
          var literal = sexpr.path;
          sexpr.path = {
            type: "PathExpression",
            data: false,
            depth: 0,
            parts: [literal.original + ""],
            original: literal.original + "",
            loc: literal.loc
          };
        }
      }
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64.js
  var require_base64 = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64.js"(exports) {
      var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
      exports.encode = function(number4) {
        if (0 <= number4 && number4 < intToCharMap.length) {
          return intToCharMap[number4];
        }
        throw new TypeError("Must be between 0 and 63: " + number4);
      };
      exports.decode = function(charCode) {
        var bigA = 65;
        var bigZ = 90;
        var littleA = 97;
        var littleZ = 122;
        var zero = 48;
        var nine = 57;
        var plus = 43;
        var slash = 47;
        var littleOffset = 26;
        var numberOffset = 52;
        if (bigA <= charCode && charCode <= bigZ) {
          return charCode - bigA;
        }
        if (littleA <= charCode && charCode <= littleZ) {
          return charCode - littleA + littleOffset;
        }
        if (zero <= charCode && charCode <= nine) {
          return charCode - zero + numberOffset;
        }
        if (charCode == plus) {
          return 62;
        }
        if (charCode == slash) {
          return 63;
        }
        return -1;
      };
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64-vlq.js
  var require_base64_vlq = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/base64-vlq.js"(exports) {
      var base64 = require_base64();
      var VLQ_BASE_SHIFT = 5;
      var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
      var VLQ_BASE_MASK = VLQ_BASE - 1;
      var VLQ_CONTINUATION_BIT = VLQ_BASE;
      function toVLQSigned(aValue) {
        return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
      }
      function fromVLQSigned(aValue) {
        var isNegative = (aValue & 1) === 1;
        var shifted = aValue >> 1;
        return isNegative ? -shifted : shifted;
      }
      exports.encode = function base64VLQ_encode(aValue) {
        var encoded = "";
        var digit;
        var vlq = toVLQSigned(aValue);
        do {
          digit = vlq & VLQ_BASE_MASK;
          vlq >>>= VLQ_BASE_SHIFT;
          if (vlq > 0) {
            digit |= VLQ_CONTINUATION_BIT;
          }
          encoded += base64.encode(digit);
        } while (vlq > 0);
        return encoded;
      };
      exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
        var strLen = aStr.length;
        var result = 0;
        var shift = 0;
        var continuation, digit;
        do {
          if (aIndex >= strLen) {
            throw new Error("Expected more digits in base 64 VLQ value.");
          }
          digit = base64.decode(aStr.charCodeAt(aIndex++));
          if (digit === -1) {
            throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
          }
          continuation = !!(digit & VLQ_CONTINUATION_BIT);
          digit &= VLQ_BASE_MASK;
          result = result + (digit << shift);
          shift += VLQ_BASE_SHIFT;
        } while (continuation);
        aOutParam.value = fromVLQSigned(result);
        aOutParam.rest = aIndex;
      };
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/util.js
  var require_util = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/util.js"(exports) {
      function getArg(aArgs, aName, aDefaultValue) {
        if (aName in aArgs) {
          return aArgs[aName];
        } else if (arguments.length === 3) {
          return aDefaultValue;
        } else {
          throw new Error('"' + aName + '" is a required argument.');
        }
      }
      exports.getArg = getArg;
      var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
      var dataUrlRegexp = /^data:.+\,.+$/;
      function urlParse(aUrl) {
        var match3 = aUrl.match(urlRegexp);
        if (!match3) {
          return null;
        }
        return {
          scheme: match3[1],
          auth: match3[2],
          host: match3[3],
          port: match3[4],
          path: match3[5]
        };
      }
      exports.urlParse = urlParse;
      function urlGenerate(aParsedUrl) {
        var url = "";
        if (aParsedUrl.scheme) {
          url += aParsedUrl.scheme + ":";
        }
        url += "//";
        if (aParsedUrl.auth) {
          url += aParsedUrl.auth + "@";
        }
        if (aParsedUrl.host) {
          url += aParsedUrl.host;
        }
        if (aParsedUrl.port) {
          url += ":" + aParsedUrl.port;
        }
        if (aParsedUrl.path) {
          url += aParsedUrl.path;
        }
        return url;
      }
      exports.urlGenerate = urlGenerate;
      function normalize4(aPath) {
        var path4 = aPath;
        var url = urlParse(aPath);
        if (url) {
          if (!url.path) {
            return aPath;
          }
          path4 = url.path;
        }
        var isAbsolute = exports.isAbsolute(path4);
        var parts = path4.split(/\/+/);
        for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
          part = parts[i];
          if (part === ".") {
            parts.splice(i, 1);
          } else if (part === "..") {
            up++;
          } else if (up > 0) {
            if (part === "") {
              parts.splice(i + 1, up);
              up = 0;
            } else {
              parts.splice(i, 2);
              up--;
            }
          }
        }
        path4 = parts.join("/");
        if (path4 === "") {
          path4 = isAbsolute ? "/" : ".";
        }
        if (url) {
          url.path = path4;
          return urlGenerate(url);
        }
        return path4;
      }
      exports.normalize = normalize4;
      function join10(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        if (aPath === "") {
          aPath = ".";
        }
        var aPathUrl = urlParse(aPath);
        var aRootUrl = urlParse(aRoot);
        if (aRootUrl) {
          aRoot = aRootUrl.path || "/";
        }
        if (aPathUrl && !aPathUrl.scheme) {
          if (aRootUrl) {
            aPathUrl.scheme = aRootUrl.scheme;
          }
          return urlGenerate(aPathUrl);
        }
        if (aPathUrl || aPath.match(dataUrlRegexp)) {
          return aPath;
        }
        if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
          aRootUrl.host = aPath;
          return urlGenerate(aRootUrl);
        }
        var joined = aPath.charAt(0) === "/" ? aPath : normalize4(aRoot.replace(/\/+$/, "") + "/" + aPath);
        if (aRootUrl) {
          aRootUrl.path = joined;
          return urlGenerate(aRootUrl);
        }
        return joined;
      }
      exports.join = join10;
      exports.isAbsolute = function(aPath) {
        return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
      };
      function relative2(aRoot, aPath) {
        if (aRoot === "") {
          aRoot = ".";
        }
        aRoot = aRoot.replace(/\/$/, "");
        var level = 0;
        while (aPath.indexOf(aRoot + "/") !== 0) {
          var index = aRoot.lastIndexOf("/");
          if (index < 0) {
            return aPath;
          }
          aRoot = aRoot.slice(0, index);
          if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
            return aPath;
          }
          ++level;
        }
        return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
      }
      exports.relative = relative2;
      var supportsNullProto = function() {
        var obj = /* @__PURE__ */ Object.create(null);
        return !("__proto__" in obj);
      }();
      function identity2(s) {
        return s;
      }
      function toSetString(aStr) {
        if (isProtoString(aStr)) {
          return "$" + aStr;
        }
        return aStr;
      }
      exports.toSetString = supportsNullProto ? identity2 : toSetString;
      function fromSetString(aStr) {
        if (isProtoString(aStr)) {
          return aStr.slice(1);
        }
        return aStr;
      }
      exports.fromSetString = supportsNullProto ? identity2 : fromSetString;
      function isProtoString(s) {
        if (!s) {
          return false;
        }
        var length = s.length;
        if (length < 9) {
          return false;
        }
        if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
          return false;
        }
        for (var i = length - 10; i >= 0; i--) {
          if (s.charCodeAt(i) !== 36) {
            return false;
          }
        }
        return true;
      }
      function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
        var cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0 || onlyCompareOriginal) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByOriginalPositions = compareByOriginalPositions;
      function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0 || onlyCompareGenerated) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
      function strcmp(aStr1, aStr2) {
        if (aStr1 === aStr2) {
          return 0;
        }
        if (aStr1 === null) {
          return 1;
        }
        if (aStr2 === null) {
          return -1;
        }
        if (aStr1 > aStr2) {
          return 1;
        }
        return -1;
      }
      function compareByGeneratedPositionsInflated(mappingA, mappingB) {
        var cmp = mappingA.generatedLine - mappingB.generatedLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.generatedColumn - mappingB.generatedColumn;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = strcmp(mappingA.source, mappingB.source);
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalLine - mappingB.originalLine;
        if (cmp !== 0) {
          return cmp;
        }
        cmp = mappingA.originalColumn - mappingB.originalColumn;
        if (cmp !== 0) {
          return cmp;
        }
        return strcmp(mappingA.name, mappingB.name);
      }
      exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
      function parseSourceMapInput(str) {
        return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
      }
      exports.parseSourceMapInput = parseSourceMapInput;
      function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
        sourceURL = sourceURL || "";
        if (sourceRoot) {
          if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
            sourceRoot += "/";
          }
          sourceURL = sourceRoot + sourceURL;
        }
        if (sourceMapURL) {
          var parsed = urlParse(sourceMapURL);
          if (!parsed) {
            throw new Error("sourceMapURL could not be parsed");
          }
          if (parsed.path) {
            var index = parsed.path.lastIndexOf("/");
            if (index >= 0) {
              parsed.path = parsed.path.substring(0, index + 1);
            }
          }
          sourceURL = join10(urlGenerate(parsed), sourceURL);
        }
        return normalize4(sourceURL);
      }
      exports.computeSourceURL = computeSourceURL;
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/array-set.js
  var require_array_set = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/array-set.js"(exports) {
      var util = require_util();
      var has4 = Object.prototype.hasOwnProperty;
      var hasNativeMap = typeof Map !== "undefined";
      function ArraySet() {
        this._array = [];
        this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
      }
      ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
        var set2 = new ArraySet();
        for (var i = 0, len = aArray.length; i < len; i++) {
          set2.add(aArray[i], aAllowDuplicates);
        }
        return set2;
      };
      ArraySet.prototype.size = function ArraySet_size() {
        return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
      };
      ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
        var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
        var isDuplicate = hasNativeMap ? this.has(aStr) : has4.call(this._set, sStr);
        var idx = this._array.length;
        if (!isDuplicate || aAllowDuplicates) {
          this._array.push(aStr);
        }
        if (!isDuplicate) {
          if (hasNativeMap) {
            this._set.set(aStr, idx);
          } else {
            this._set[sStr] = idx;
          }
        }
      };
      ArraySet.prototype.has = function ArraySet_has(aStr) {
        if (hasNativeMap) {
          return this._set.has(aStr);
        } else {
          var sStr = util.toSetString(aStr);
          return has4.call(this._set, sStr);
        }
      };
      ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
        if (hasNativeMap) {
          var idx = this._set.get(aStr);
          if (idx >= 0) {
            return idx;
          }
        } else {
          var sStr = util.toSetString(aStr);
          if (has4.call(this._set, sStr)) {
            return this._set[sStr];
          }
        }
        throw new Error('"' + aStr + '" is not in the set.');
      };
      ArraySet.prototype.at = function ArraySet_at(aIdx) {
        if (aIdx >= 0 && aIdx < this._array.length) {
          return this._array[aIdx];
        }
        throw new Error("No element indexed by " + aIdx);
      };
      ArraySet.prototype.toArray = function ArraySet_toArray() {
        return this._array.slice();
      };
      exports.ArraySet = ArraySet;
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/mapping-list.js
  var require_mapping_list = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/mapping-list.js"(exports) {
      var util = require_util();
      function generatedPositionAfter(mappingA, mappingB) {
        var lineA = mappingA.generatedLine;
        var lineB = mappingB.generatedLine;
        var columnA = mappingA.generatedColumn;
        var columnB = mappingB.generatedColumn;
        return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
      }
      function MappingList() {
        this._array = [];
        this._sorted = true;
        this._last = { generatedLine: -1, generatedColumn: 0 };
      }
      MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
        this._array.forEach(aCallback, aThisArg);
      };
      MappingList.prototype.add = function MappingList_add(aMapping) {
        if (generatedPositionAfter(this._last, aMapping)) {
          this._last = aMapping;
          this._array.push(aMapping);
        } else {
          this._sorted = false;
          this._array.push(aMapping);
        }
      };
      MappingList.prototype.toArray = function MappingList_toArray() {
        if (!this._sorted) {
          this._array.sort(util.compareByGeneratedPositionsInflated);
          this._sorted = true;
        }
        return this._array;
      };
      exports.MappingList = MappingList;
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-generator.js
  var require_source_map_generator = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-generator.js"(exports) {
      var base64VLQ = require_base64_vlq();
      var util = require_util();
      var ArraySet = require_array_set().ArraySet;
      var MappingList = require_mapping_list().MappingList;
      function SourceMapGenerator(aArgs) {
        if (!aArgs) {
          aArgs = {};
        }
        this._file = util.getArg(aArgs, "file", null);
        this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
        this._skipValidation = util.getArg(aArgs, "skipValidation", false);
        this._sources = new ArraySet();
        this._names = new ArraySet();
        this._mappings = new MappingList();
        this._sourcesContents = null;
      }
      SourceMapGenerator.prototype._version = 3;
      SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
        var sourceRoot = aSourceMapConsumer.sourceRoot;
        var generator = new SourceMapGenerator({
          file: aSourceMapConsumer.file,
          sourceRoot
        });
        aSourceMapConsumer.eachMapping(function(mapping) {
          var newMapping = {
            generated: {
              line: mapping.generatedLine,
              column: mapping.generatedColumn
            }
          };
          if (mapping.source != null) {
            newMapping.source = mapping.source;
            if (sourceRoot != null) {
              newMapping.source = util.relative(sourceRoot, newMapping.source);
            }
            newMapping.original = {
              line: mapping.originalLine,
              column: mapping.originalColumn
            };
            if (mapping.name != null) {
              newMapping.name = mapping.name;
            }
          }
          generator.addMapping(newMapping);
        });
        aSourceMapConsumer.sources.forEach(function(sourceFile) {
          var sourceRelative = sourceFile;
          if (sourceRoot !== null) {
            sourceRelative = util.relative(sourceRoot, sourceFile);
          }
          if (!generator._sources.has(sourceRelative)) {
            generator._sources.add(sourceRelative);
          }
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            generator.setSourceContent(sourceFile, content);
          }
        });
        return generator;
      };
      SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
        var generated = util.getArg(aArgs, "generated");
        var original = util.getArg(aArgs, "original", null);
        var source = util.getArg(aArgs, "source", null);
        var name = util.getArg(aArgs, "name", null);
        if (!this._skipValidation) {
          this._validateMapping(generated, original, source, name);
        }
        if (source != null) {
          source = String(source);
          if (!this._sources.has(source)) {
            this._sources.add(source);
          }
        }
        if (name != null) {
          name = String(name);
          if (!this._names.has(name)) {
            this._names.add(name);
          }
        }
        this._mappings.add({
          generatedLine: generated.line,
          generatedColumn: generated.column,
          originalLine: original != null && original.line,
          originalColumn: original != null && original.column,
          source,
          name
        });
      };
      SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
        var source = aSourceFile;
        if (this._sourceRoot != null) {
          source = util.relative(this._sourceRoot, source);
        }
        if (aSourceContent != null) {
          if (!this._sourcesContents) {
            this._sourcesContents = /* @__PURE__ */ Object.create(null);
          }
          this._sourcesContents[util.toSetString(source)] = aSourceContent;
        } else if (this._sourcesContents) {
          delete this._sourcesContents[util.toSetString(source)];
          if (Object.keys(this._sourcesContents).length === 0) {
            this._sourcesContents = null;
          }
        }
      };
      SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
        var sourceFile = aSourceFile;
        if (aSourceFile == null) {
          if (aSourceMapConsumer.file == null) {
            throw new Error(
              `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
            );
          }
          sourceFile = aSourceMapConsumer.file;
        }
        var sourceRoot = this._sourceRoot;
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        var newSources = new ArraySet();
        var newNames = new ArraySet();
        this._mappings.unsortedForEach(function(mapping) {
          if (mapping.source === sourceFile && mapping.originalLine != null) {
            var original = aSourceMapConsumer.originalPositionFor({
              line: mapping.originalLine,
              column: mapping.originalColumn
            });
            if (original.source != null) {
              mapping.source = original.source;
              if (aSourceMapPath != null) {
                mapping.source = util.join(aSourceMapPath, mapping.source);
              }
              if (sourceRoot != null) {
                mapping.source = util.relative(sourceRoot, mapping.source);
              }
              mapping.originalLine = original.line;
              mapping.originalColumn = original.column;
              if (original.name != null) {
                mapping.name = original.name;
              }
            }
          }
          var source = mapping.source;
          if (source != null && !newSources.has(source)) {
            newSources.add(source);
          }
          var name = mapping.name;
          if (name != null && !newNames.has(name)) {
            newNames.add(name);
          }
        }, this);
        this._sources = newSources;
        this._names = newNames;
        aSourceMapConsumer.sources.forEach(function(sourceFile2) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
          if (content != null) {
            if (aSourceMapPath != null) {
              sourceFile2 = util.join(aSourceMapPath, sourceFile2);
            }
            if (sourceRoot != null) {
              sourceFile2 = util.relative(sourceRoot, sourceFile2);
            }
            this.setSourceContent(sourceFile2, content);
          }
        }, this);
      };
      SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
        if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
          throw new Error(
            "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
          );
        }
        if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
          return;
        } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
          return;
        } else {
          throw new Error("Invalid mapping: " + JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName
          }));
        }
      };
      SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
        var previousGeneratedColumn = 0;
        var previousGeneratedLine = 1;
        var previousOriginalColumn = 0;
        var previousOriginalLine = 0;
        var previousName = 0;
        var previousSource = 0;
        var result = "";
        var next;
        var mapping;
        var nameIdx;
        var sourceIdx;
        var mappings = this._mappings.toArray();
        for (var i = 0, len = mappings.length; i < len; i++) {
          mapping = mappings[i];
          next = "";
          if (mapping.generatedLine !== previousGeneratedLine) {
            previousGeneratedColumn = 0;
            while (mapping.generatedLine !== previousGeneratedLine) {
              next += ";";
              previousGeneratedLine++;
            }
          } else {
            if (i > 0) {
              if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
                continue;
              }
              next += ",";
            }
          }
          next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
          previousGeneratedColumn = mapping.generatedColumn;
          if (mapping.source != null) {
            sourceIdx = this._sources.indexOf(mapping.source);
            next += base64VLQ.encode(sourceIdx - previousSource);
            previousSource = sourceIdx;
            next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
            previousOriginalLine = mapping.originalLine - 1;
            next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
            previousOriginalColumn = mapping.originalColumn;
            if (mapping.name != null) {
              nameIdx = this._names.indexOf(mapping.name);
              next += base64VLQ.encode(nameIdx - previousName);
              previousName = nameIdx;
            }
          }
          result += next;
        }
        return result;
      };
      SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
        return aSources.map(function(source) {
          if (!this._sourcesContents) {
            return null;
          }
          if (aSourceRoot != null) {
            source = util.relative(aSourceRoot, source);
          }
          var key = util.toSetString(source);
          return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
        }, this);
      };
      SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
        var map2 = {
          version: this._version,
          sources: this._sources.toArray(),
          names: this._names.toArray(),
          mappings: this._serializeMappings()
        };
        if (this._file != null) {
          map2.file = this._file;
        }
        if (this._sourceRoot != null) {
          map2.sourceRoot = this._sourceRoot;
        }
        if (this._sourcesContents) {
          map2.sourcesContent = this._generateSourcesContent(map2.sources, map2.sourceRoot);
        }
        return map2;
      };
      SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
        return JSON.stringify(this.toJSON());
      };
      exports.SourceMapGenerator = SourceMapGenerator;
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/binary-search.js
  var require_binary_search = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/binary-search.js"(exports) {
      exports.GREATEST_LOWER_BOUND = 1;
      exports.LEAST_UPPER_BOUND = 2;
      function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
        var mid = Math.floor((aHigh - aLow) / 2) + aLow;
        var cmp = aCompare(aNeedle, aHaystack[mid], true);
        if (cmp === 0) {
          return mid;
        } else if (cmp > 0) {
          if (aHigh - mid > 1) {
            return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
          }
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return aHigh < aHaystack.length ? aHigh : -1;
          } else {
            return mid;
          }
        } else {
          if (mid - aLow > 1) {
            return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
          }
          if (aBias == exports.LEAST_UPPER_BOUND) {
            return mid;
          } else {
            return aLow < 0 ? -1 : aLow;
          }
        }
      }
      exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
        if (aHaystack.length === 0) {
          return -1;
        }
        var index = recursiveSearch(
          -1,
          aHaystack.length,
          aNeedle,
          aHaystack,
          aCompare,
          aBias || exports.GREATEST_LOWER_BOUND
        );
        if (index < 0) {
          return -1;
        }
        while (index - 1 >= 0) {
          if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
            break;
          }
          --index;
        }
        return index;
      };
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/quick-sort.js
  var require_quick_sort = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/quick-sort.js"(exports) {
      function swap(ary, x, y) {
        var temp = ary[x];
        ary[x] = ary[y];
        ary[y] = temp;
      }
      function randomIntInRange(low, high) {
        return Math.round(low + Math.random() * (high - low));
      }
      function doQuickSort(ary, comparator, p, r) {
        if (p < r) {
          var pivotIndex = randomIntInRange(p, r);
          var i = p - 1;
          swap(ary, pivotIndex, r);
          var pivot = ary[r];
          for (var j = p; j < r; j++) {
            if (comparator(ary[j], pivot) <= 0) {
              i += 1;
              swap(ary, i, j);
            }
          }
          swap(ary, i + 1, j);
          var q = i + 1;
          doQuickSort(ary, comparator, p, q - 1);
          doQuickSort(ary, comparator, q + 1, r);
        }
      }
      exports.quickSort = function(ary, comparator) {
        doQuickSort(ary, comparator, 0, ary.length - 1);
      };
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-consumer.js
  var require_source_map_consumer = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-map-consumer.js"(exports) {
      var util = require_util();
      var binarySearch = require_binary_search();
      var ArraySet = require_array_set().ArraySet;
      var base64VLQ = require_base64_vlq();
      var quickSort = require_quick_sort().quickSort;
      function SourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }
        return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
      }
      SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
        return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
      };
      SourceMapConsumer.prototype._version = 3;
      SourceMapConsumer.prototype.__generatedMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
        configurable: true,
        enumerable: true,
        get: function() {
          if (!this.__generatedMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__generatedMappings;
        }
      });
      SourceMapConsumer.prototype.__originalMappings = null;
      Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
        configurable: true,
        enumerable: true,
        get: function() {
          if (!this.__originalMappings) {
            this._parseMappings(this._mappings, this.sourceRoot);
          }
          return this.__originalMappings;
        }
      });
      SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
        var c = aStr.charAt(index);
        return c === ";" || c === ",";
      };
      SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        throw new Error("Subclasses must implement _parseMappings");
      };
      SourceMapConsumer.GENERATED_ORDER = 1;
      SourceMapConsumer.ORIGINAL_ORDER = 2;
      SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
      SourceMapConsumer.LEAST_UPPER_BOUND = 2;
      SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
        var context2 = aContext || null;
        var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
        var mappings;
        switch (order) {
          case SourceMapConsumer.GENERATED_ORDER:
            mappings = this._generatedMappings;
            break;
          case SourceMapConsumer.ORIGINAL_ORDER:
            mappings = this._originalMappings;
            break;
          default:
            throw new Error("Unknown order of iteration.");
        }
        var sourceRoot = this.sourceRoot;
        mappings.map(function(mapping) {
          var source = mapping.source === null ? null : this._sources.at(mapping.source);
          source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
          return {
            source,
            generatedLine: mapping.generatedLine,
            generatedColumn: mapping.generatedColumn,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: mapping.name === null ? null : this._names.at(mapping.name)
          };
        }, this).forEach(aCallback, context2);
      };
      SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
        var line = util.getArg(aArgs, "line");
        var needle = {
          source: util.getArg(aArgs, "source"),
          originalLine: line,
          originalColumn: util.getArg(aArgs, "column", 0)
        };
        needle.source = this._findSourceIndex(needle.source);
        if (needle.source < 0) {
          return [];
        }
        var mappings = [];
        var index = this._findMapping(
          needle,
          this._originalMappings,
          "originalLine",
          "originalColumn",
          util.compareByOriginalPositions,
          binarySearch.LEAST_UPPER_BOUND
        );
        if (index >= 0) {
          var mapping = this._originalMappings[index];
          if (aArgs.column === void 0) {
            var originalLine = mapping.originalLine;
            while (mapping && mapping.originalLine === originalLine) {
              mappings.push({
                line: util.getArg(mapping, "generatedLine", null),
                column: util.getArg(mapping, "generatedColumn", null),
                lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
              });
              mapping = this._originalMappings[++index];
            }
          } else {
            var originalColumn = mapping.originalColumn;
            while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
              mappings.push({
                line: util.getArg(mapping, "generatedLine", null),
                column: util.getArg(mapping, "generatedColumn", null),
                lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
              });
              mapping = this._originalMappings[++index];
            }
          }
        }
        return mappings;
      };
      exports.SourceMapConsumer = SourceMapConsumer;
      function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }
        var version2 = util.getArg(sourceMap, "version");
        var sources = util.getArg(sourceMap, "sources");
        var names = util.getArg(sourceMap, "names", []);
        var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
        var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
        var mappings = util.getArg(sourceMap, "mappings");
        var file = util.getArg(sourceMap, "file", null);
        if (version2 != this._version) {
          throw new Error("Unsupported version: " + version2);
        }
        if (sourceRoot) {
          sourceRoot = util.normalize(sourceRoot);
        }
        sources = sources.map(String).map(util.normalize).map(function(source) {
          return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
        });
        this._names = ArraySet.fromArray(names.map(String), true);
        this._sources = ArraySet.fromArray(sources, true);
        this._absoluteSources = this._sources.toArray().map(function(s) {
          return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
        });
        this.sourceRoot = sourceRoot;
        this.sourcesContent = sourcesContent;
        this._mappings = mappings;
        this._sourceMapURL = aSourceMapURL;
        this.file = file;
      }
      BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
      BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
      BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
        var relativeSource = aSource;
        if (this.sourceRoot != null) {
          relativeSource = util.relative(this.sourceRoot, relativeSource);
        }
        if (this._sources.has(relativeSource)) {
          return this._sources.indexOf(relativeSource);
        }
        var i;
        for (i = 0; i < this._absoluteSources.length; ++i) {
          if (this._absoluteSources[i] == aSource) {
            return i;
          }
        }
        return -1;
      };
      BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
        var smc = Object.create(BasicSourceMapConsumer.prototype);
        var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
        var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
        smc.sourceRoot = aSourceMap._sourceRoot;
        smc.sourcesContent = aSourceMap._generateSourcesContent(
          smc._sources.toArray(),
          smc.sourceRoot
        );
        smc.file = aSourceMap._file;
        smc._sourceMapURL = aSourceMapURL;
        smc._absoluteSources = smc._sources.toArray().map(function(s) {
          return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
        });
        var generatedMappings = aSourceMap._mappings.toArray().slice();
        var destGeneratedMappings = smc.__generatedMappings = [];
        var destOriginalMappings = smc.__originalMappings = [];
        for (var i = 0, length = generatedMappings.length; i < length; i++) {
          var srcMapping = generatedMappings[i];
          var destMapping = new Mapping();
          destMapping.generatedLine = srcMapping.generatedLine;
          destMapping.generatedColumn = srcMapping.generatedColumn;
          if (srcMapping.source) {
            destMapping.source = sources.indexOf(srcMapping.source);
            destMapping.originalLine = srcMapping.originalLine;
            destMapping.originalColumn = srcMapping.originalColumn;
            if (srcMapping.name) {
              destMapping.name = names.indexOf(srcMapping.name);
            }
            destOriginalMappings.push(destMapping);
          }
          destGeneratedMappings.push(destMapping);
        }
        quickSort(smc.__originalMappings, util.compareByOriginalPositions);
        return smc;
      };
      BasicSourceMapConsumer.prototype._version = 3;
      Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
        get: function() {
          return this._absoluteSources.slice();
        }
      });
      function Mapping() {
        this.generatedLine = 0;
        this.generatedColumn = 0;
        this.source = null;
        this.originalLine = null;
        this.originalColumn = null;
        this.name = null;
      }
      BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        var generatedLine = 1;
        var previousGeneratedColumn = 0;
        var previousOriginalLine = 0;
        var previousOriginalColumn = 0;
        var previousSource = 0;
        var previousName = 0;
        var length = aStr.length;
        var index = 0;
        var cachedSegments = {};
        var temp = {};
        var originalMappings = [];
        var generatedMappings = [];
        var mapping, str, segment, end, value;
        while (index < length) {
          if (aStr.charAt(index) === ";") {
            generatedLine++;
            index++;
            previousGeneratedColumn = 0;
          } else if (aStr.charAt(index) === ",") {
            index++;
          } else {
            mapping = new Mapping();
            mapping.generatedLine = generatedLine;
            for (end = index; end < length; end++) {
              if (this._charIsMappingSeparator(aStr, end)) {
                break;
              }
            }
            str = aStr.slice(index, end);
            segment = cachedSegments[str];
            if (segment) {
              index += str.length;
            } else {
              segment = [];
              while (index < end) {
                base64VLQ.decode(aStr, index, temp);
                value = temp.value;
                index = temp.rest;
                segment.push(value);
              }
              if (segment.length === 2) {
                throw new Error("Found a source, but no line and column");
              }
              if (segment.length === 3) {
                throw new Error("Found a source and line, but no column");
              }
              cachedSegments[str] = segment;
            }
            mapping.generatedColumn = previousGeneratedColumn + segment[0];
            previousGeneratedColumn = mapping.generatedColumn;
            if (segment.length > 1) {
              mapping.source = previousSource + segment[1];
              previousSource += segment[1];
              mapping.originalLine = previousOriginalLine + segment[2];
              previousOriginalLine = mapping.originalLine;
              mapping.originalLine += 1;
              mapping.originalColumn = previousOriginalColumn + segment[3];
              previousOriginalColumn = mapping.originalColumn;
              if (segment.length > 4) {
                mapping.name = previousName + segment[4];
                previousName += segment[4];
              }
            }
            generatedMappings.push(mapping);
            if (typeof mapping.originalLine === "number") {
              originalMappings.push(mapping);
            }
          }
        }
        quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
        this.__generatedMappings = generatedMappings;
        quickSort(originalMappings, util.compareByOriginalPositions);
        this.__originalMappings = originalMappings;
      };
      BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
        if (aNeedle[aLineName] <= 0) {
          throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
        }
        if (aNeedle[aColumnName] < 0) {
          throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
        }
        return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
      };
      BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
        for (var index = 0; index < this._generatedMappings.length; ++index) {
          var mapping = this._generatedMappings[index];
          if (index + 1 < this._generatedMappings.length) {
            var nextMapping = this._generatedMappings[index + 1];
            if (mapping.generatedLine === nextMapping.generatedLine) {
              mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
              continue;
            }
          }
          mapping.lastGeneratedColumn = Infinity;
        }
      };
      BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
        var needle = {
          generatedLine: util.getArg(aArgs, "line"),
          generatedColumn: util.getArg(aArgs, "column")
        };
        var index = this._findMapping(
          needle,
          this._generatedMappings,
          "generatedLine",
          "generatedColumn",
          util.compareByGeneratedPositionsDeflated,
          util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
        );
        if (index >= 0) {
          var mapping = this._generatedMappings[index];
          if (mapping.generatedLine === needle.generatedLine) {
            var source = util.getArg(mapping, "source", null);
            if (source !== null) {
              source = this._sources.at(source);
              source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
            }
            var name = util.getArg(mapping, "name", null);
            if (name !== null) {
              name = this._names.at(name);
            }
            return {
              source,
              line: util.getArg(mapping, "originalLine", null),
              column: util.getArg(mapping, "originalColumn", null),
              name
            };
          }
        }
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      };
      BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
        if (!this.sourcesContent) {
          return false;
        }
        return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
          return sc == null;
        });
      };
      BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
        if (!this.sourcesContent) {
          return null;
        }
        var index = this._findSourceIndex(aSource);
        if (index >= 0) {
          return this.sourcesContent[index];
        }
        var relativeSource = aSource;
        if (this.sourceRoot != null) {
          relativeSource = util.relative(this.sourceRoot, relativeSource);
        }
        var url;
        if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
          var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
          if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
          }
          if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
            return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
          }
        }
        if (nullOnMissing) {
          return null;
        } else {
          throw new Error('"' + relativeSource + '" is not in the SourceMap.');
        }
      };
      BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
        var source = util.getArg(aArgs, "source");
        source = this._findSourceIndex(source);
        if (source < 0) {
          return {
            line: null,
            column: null,
            lastColumn: null
          };
        }
        var needle = {
          source,
          originalLine: util.getArg(aArgs, "line"),
          originalColumn: util.getArg(aArgs, "column")
        };
        var index = this._findMapping(
          needle,
          this._originalMappings,
          "originalLine",
          "originalColumn",
          util.compareByOriginalPositions,
          util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
        );
        if (index >= 0) {
          var mapping = this._originalMappings[index];
          if (mapping.source === needle.source) {
            return {
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            };
          }
        }
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      };
      exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
      function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
        var sourceMap = aSourceMap;
        if (typeof aSourceMap === "string") {
          sourceMap = util.parseSourceMapInput(aSourceMap);
        }
        var version2 = util.getArg(sourceMap, "version");
        var sections = util.getArg(sourceMap, "sections");
        if (version2 != this._version) {
          throw new Error("Unsupported version: " + version2);
        }
        this._sources = new ArraySet();
        this._names = new ArraySet();
        var lastOffset = {
          line: -1,
          column: 0
        };
        this._sections = sections.map(function(s) {
          if (s.url) {
            throw new Error("Support for url field in sections not implemented.");
          }
          var offset = util.getArg(s, "offset");
          var offsetLine = util.getArg(offset, "line");
          var offsetColumn = util.getArg(offset, "column");
          if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
            throw new Error("Section offsets must be ordered and non-overlapping.");
          }
          lastOffset = offset;
          return {
            generatedOffset: {
              // The offset fields are 0-based, but we use 1-based indices when
              // encoding/decoding from VLQ.
              generatedLine: offsetLine + 1,
              generatedColumn: offsetColumn + 1
            },
            consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
          };
        });
      }
      IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
      IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
      IndexedSourceMapConsumer.prototype._version = 3;
      Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
        get: function() {
          var sources = [];
          for (var i = 0; i < this._sections.length; i++) {
            for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
              sources.push(this._sections[i].consumer.sources[j]);
            }
          }
          return sources;
        }
      });
      IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
        var needle = {
          generatedLine: util.getArg(aArgs, "line"),
          generatedColumn: util.getArg(aArgs, "column")
        };
        var sectionIndex = binarySearch.search(
          needle,
          this._sections,
          function(needle2, section2) {
            var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
            if (cmp) {
              return cmp;
            }
            return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
          }
        );
        var section = this._sections[sectionIndex];
        if (!section) {
          return {
            source: null,
            line: null,
            column: null,
            name: null
          };
        }
        return section.consumer.originalPositionFor({
          line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
          column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          bias: aArgs.bias
        });
      };
      IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
        return this._sections.every(function(s) {
          return s.consumer.hasContentsOfAllSources();
        });
      };
      IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
        for (var i = 0; i < this._sections.length; i++) {
          var section = this._sections[i];
          var content = section.consumer.sourceContentFor(aSource, true);
          if (content) {
            return content;
          }
        }
        if (nullOnMissing) {
          return null;
        } else {
          throw new Error('"' + aSource + '" is not in the SourceMap.');
        }
      };
      IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
        for (var i = 0; i < this._sections.length; i++) {
          var section = this._sections[i];
          if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
            continue;
          }
          var generatedPosition = section.consumer.generatedPositionFor(aArgs);
          if (generatedPosition) {
            var ret3 = {
              line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
              column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
            };
            return ret3;
          }
        }
        return {
          line: null,
          column: null
        };
      };
      IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        for (var i = 0; i < this._sections.length; i++) {
          var section = this._sections[i];
          var sectionMappings = section.consumer._generatedMappings;
          for (var j = 0; j < sectionMappings.length; j++) {
            var mapping = sectionMappings[j];
            var source = section.consumer._sources.at(mapping.source);
            source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
            this._sources.add(source);
            source = this._sources.indexOf(source);
            var name = null;
            if (mapping.name) {
              name = section.consumer._names.at(mapping.name);
              this._names.add(name);
              name = this._names.indexOf(name);
            }
            var adjustedMapping = {
              source,
              generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
              generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
              originalLine: mapping.originalLine,
              originalColumn: mapping.originalColumn,
              name
            };
            this.__generatedMappings.push(adjustedMapping);
            if (typeof adjustedMapping.originalLine === "number") {
              this.__originalMappings.push(adjustedMapping);
            }
          }
        }
        quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
        quickSort(this.__originalMappings, util.compareByOriginalPositions);
      };
      exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-node.js
  var require_source_node = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/lib/source-node.js"(exports) {
      var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
      var util = require_util();
      var REGEX_NEWLINE = /(\r?\n)/;
      var NEWLINE_CODE = 10;
      var isSourceNode = "$$$isSourceNode$$$";
      function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
        this.children = [];
        this.sourceContents = {};
        this.line = aLine == null ? null : aLine;
        this.column = aColumn == null ? null : aColumn;
        this.source = aSource == null ? null : aSource;
        this.name = aName == null ? null : aName;
        this[isSourceNode] = true;
        if (aChunks != null)
          this.add(aChunks);
      }
      SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
        var node = new SourceNode();
        var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
        var remainingLinesIndex = 0;
        var shiftNextLine = function() {
          var lineContents = getNextLine();
          var newLine = getNextLine() || "";
          return lineContents + newLine;
          function getNextLine() {
            return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
          }
        };
        var lastGeneratedLine = 1, lastGeneratedColumn = 0;
        var lastMapping = null;
        aSourceMapConsumer.eachMapping(function(mapping) {
          if (lastMapping !== null) {
            if (lastGeneratedLine < mapping.generatedLine) {
              addMappingWithCode(lastMapping, shiftNextLine());
              lastGeneratedLine++;
              lastGeneratedColumn = 0;
            } else {
              var nextLine = remainingLines[remainingLinesIndex] || "";
              var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
              remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
              addMappingWithCode(lastMapping, code);
              lastMapping = mapping;
              return;
            }
          }
          while (lastGeneratedLine < mapping.generatedLine) {
            node.add(shiftNextLine());
            lastGeneratedLine++;
          }
          if (lastGeneratedColumn < mapping.generatedColumn) {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            node.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
          }
          lastMapping = mapping;
        }, this);
        if (remainingLinesIndex < remainingLines.length) {
          if (lastMapping) {
            addMappingWithCode(lastMapping, shiftNextLine());
          }
          node.add(remainingLines.splice(remainingLinesIndex).join(""));
        }
        aSourceMapConsumer.sources.forEach(function(sourceFile) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            if (aRelativePath != null) {
              sourceFile = util.join(aRelativePath, sourceFile);
            }
            node.setSourceContent(sourceFile, content);
          }
        });
        return node;
        function addMappingWithCode(mapping, code) {
          if (mapping === null || mapping.source === void 0) {
            node.add(code);
          } else {
            var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
            node.add(new SourceNode(
              mapping.originalLine,
              mapping.originalColumn,
              source,
              code,
              mapping.name
            ));
          }
        }
      };
      SourceNode.prototype.add = function SourceNode_add(aChunk) {
        if (Array.isArray(aChunk)) {
          aChunk.forEach(function(chunk) {
            this.add(chunk);
          }, this);
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          if (aChunk) {
            this.children.push(aChunk);
          }
        } else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
      SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
        if (Array.isArray(aChunk)) {
          for (var i = aChunk.length - 1; i >= 0; i--) {
            this.prepend(aChunk[i]);
          }
        } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
          this.children.unshift(aChunk);
        } else {
          throw new TypeError(
            "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
          );
        }
        return this;
      };
      SourceNode.prototype.walk = function SourceNode_walk(aFn) {
        var chunk;
        for (var i = 0, len = this.children.length; i < len; i++) {
          chunk = this.children[i];
          if (chunk[isSourceNode]) {
            chunk.walk(aFn);
          } else {
            if (chunk !== "") {
              aFn(chunk, {
                source: this.source,
                line: this.line,
                column: this.column,
                name: this.name
              });
            }
          }
        }
      };
      SourceNode.prototype.join = function SourceNode_join(aSep) {
        var newChildren;
        var i;
        var len = this.children.length;
        if (len > 0) {
          newChildren = [];
          for (i = 0; i < len - 1; i++) {
            newChildren.push(this.children[i]);
            newChildren.push(aSep);
          }
          newChildren.push(this.children[i]);
          this.children = newChildren;
        }
        return this;
      };
      SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
        var lastChild = this.children[this.children.length - 1];
        if (lastChild[isSourceNode]) {
          lastChild.replaceRight(aPattern, aReplacement);
        } else if (typeof lastChild === "string") {
          this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
        } else {
          this.children.push("".replace(aPattern, aReplacement));
        }
        return this;
      };
      SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
        this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
      };
      SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
        for (var i = 0, len = this.children.length; i < len; i++) {
          if (this.children[i][isSourceNode]) {
            this.children[i].walkSourceContents(aFn);
          }
        }
        var sources = Object.keys(this.sourceContents);
        for (var i = 0, len = sources.length; i < len; i++) {
          aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
        }
      };
      SourceNode.prototype.toString = function SourceNode_toString() {
        var str = "";
        this.walk(function(chunk) {
          str += chunk;
        });
        return str;
      };
      SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
        var generated = {
          code: "",
          line: 1,
          column: 0
        };
        var map2 = new SourceMapGenerator(aArgs);
        var sourceMappingActive = false;
        var lastOriginalSource = null;
        var lastOriginalLine = null;
        var lastOriginalColumn = null;
        var lastOriginalName = null;
        this.walk(function(chunk, original) {
          generated.code += chunk;
          if (original.source !== null && original.line !== null && original.column !== null) {
            if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
              map2.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
            lastOriginalSource = original.source;
            lastOriginalLine = original.line;
            lastOriginalColumn = original.column;
            lastOriginalName = original.name;
            sourceMappingActive = true;
          } else if (sourceMappingActive) {
            map2.addMapping({
              generated: {
                line: generated.line,
                column: generated.column
              }
            });
            lastOriginalSource = null;
            sourceMappingActive = false;
          }
          for (var idx = 0, length = chunk.length; idx < length; idx++) {
            if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
              generated.line++;
              generated.column = 0;
              if (idx + 1 === length) {
                lastOriginalSource = null;
                sourceMappingActive = false;
              } else if (sourceMappingActive) {
                map2.addMapping({
                  source: original.source,
                  original: {
                    line: original.line,
                    column: original.column
                  },
                  generated: {
                    line: generated.line,
                    column: generated.column
                  },
                  name: original.name
                });
              }
            } else {
              generated.column++;
            }
          }
        });
        this.walkSourceContents(function(sourceFile, sourceContent) {
          map2.setSourceContent(sourceFile, sourceContent);
        });
        return { code: generated.code, map: map2 };
      };
      exports.SourceNode = SourceNode;
    }
  });

  // ../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/source-map.js
  var require_source_map = __commonJS({
    "../../node_modules/.pnpm/source-map@0.6.1/node_modules/source-map/source-map.js"(exports) {
      exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
      exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
      exports.SourceNode = require_source_node().SourceNode;
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/code-gen.js
  var require_code_gen = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/code-gen.js"(exports, module2) {
      "use strict";
      exports.__esModule = true;
      var _utils = require_utils();
      var SourceNode = void 0;
      try {
        if (typeof define !== "function" || !define.amd) {
          SourceMap = require_source_map();
          SourceNode = SourceMap.SourceNode;
        }
      } catch (err) {
      }
      var SourceMap;
      if (!SourceNode) {
        SourceNode = function(line, column, srcFile, chunks) {
          this.src = "";
          if (chunks) {
            this.add(chunks);
          }
        };
        SourceNode.prototype = {
          add: function add3(chunks) {
            if (_utils.isArray(chunks)) {
              chunks = chunks.join("");
            }
            this.src += chunks;
          },
          prepend: function prepend(chunks) {
            if (_utils.isArray(chunks)) {
              chunks = chunks.join("");
            }
            this.src = chunks + this.src;
          },
          toStringWithSourceMap: function toStringWithSourceMap() {
            return { code: this.toString() };
          },
          toString: function toString3() {
            return this.src;
          }
        };
      }
      function castChunk(chunk, codeGen, loc) {
        if (_utils.isArray(chunk)) {
          var ret3 = [];
          for (var i = 0, len = chunk.length; i < len; i++) {
            ret3.push(codeGen.wrap(chunk[i], loc));
          }
          return ret3;
        } else if (typeof chunk === "boolean" || typeof chunk === "number") {
          return chunk + "";
        }
        return chunk;
      }
      function CodeGen(srcFile) {
        this.srcFile = srcFile;
        this.source = [];
      }
      CodeGen.prototype = {
        isEmpty: function isEmpty() {
          return !this.source.length;
        },
        prepend: function prepend(source, loc) {
          this.source.unshift(this.wrap(source, loc));
        },
        push: function push(source, loc) {
          this.source.push(this.wrap(source, loc));
        },
        merge: function merge() {
          var source = this.empty();
          this.each(function(line) {
            source.add(["  ", line, "\n"]);
          });
          return source;
        },
        each: function each(iter) {
          for (var i = 0, len = this.source.length; i < len; i++) {
            iter(this.source[i]);
          }
        },
        empty: function empty() {
          var loc = this.currentLocation || { start: {} };
          return new SourceNode(loc.start.line, loc.start.column, this.srcFile);
        },
        wrap: function wrap(chunk) {
          var loc = arguments.length <= 1 || arguments[1] === void 0 ? this.currentLocation || { start: {} } : arguments[1];
          if (chunk instanceof SourceNode) {
            return chunk;
          }
          chunk = castChunk(chunk, this, loc);
          return new SourceNode(loc.start.line, loc.start.column, this.srcFile, chunk);
        },
        functionCall: function functionCall(fn, type3, params) {
          params = this.generateList(params);
          return this.wrap([fn, type3 ? "." + type3 + "(" : "(", params, ")"]);
        },
        quotedString: function quotedString(str) {
          return '"' + (str + "").replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029") + '"';
        },
        objectLiteral: function objectLiteral(obj) {
          var _this = this;
          var pairs = [];
          Object.keys(obj).forEach(function(key) {
            var value = castChunk(obj[key], _this);
            if (value !== "undefined") {
              pairs.push([_this.quotedString(key), ":", value]);
            }
          });
          var ret3 = this.generateList(pairs);
          ret3.prepend("{");
          ret3.add("}");
          return ret3;
        },
        generateList: function generateList(entries) {
          var ret3 = this.empty();
          for (var i = 0, len = entries.length; i < len; i++) {
            if (i) {
              ret3.add(",");
            }
            ret3.add(castChunk(entries[i], this));
          }
          return ret3;
        },
        generateArray: function generateArray(entries) {
          var ret3 = this.generateList(entries);
          ret3.prepend("[");
          ret3.add("]");
          return ret3;
        }
      };
      exports["default"] = CodeGen;
      module2.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js
  var require_javascript_compiler = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/javascript-compiler.js"(exports, module2) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _base = require_base();
      var _exception = require_exception();
      var _exception2 = _interopRequireDefault(_exception);
      var _utils = require_utils();
      var _codeGen = require_code_gen();
      var _codeGen2 = _interopRequireDefault(_codeGen);
      function Literal(value) {
        this.value = value;
      }
      function JavaScriptCompiler() {
      }
      JavaScriptCompiler.prototype = {
        // PUBLIC API: You can override these methods in a subclass to provide
        // alternative compiled forms for name lookup and buffering semantics
        nameLookup: function nameLookup(parent, name) {
          return this.internalNameLookup(parent, name);
        },
        depthedLookup: function depthedLookup(name) {
          return [this.aliasable("container.lookup"), "(depths, ", JSON.stringify(name), ")"];
        },
        compilerInfo: function compilerInfo() {
          var revision = _base.COMPILER_REVISION, versions3 = _base.REVISION_CHANGES[revision];
          return [revision, versions3];
        },
        appendToBuffer: function appendToBuffer(source, location, explicit) {
          if (!_utils.isArray(source)) {
            source = [source];
          }
          source = this.source.wrap(source, location);
          if (this.environment.isSimple) {
            return ["return ", source, ";"];
          } else if (explicit) {
            return ["buffer += ", source, ";"];
          } else {
            source.appendToBuffer = true;
            return source;
          }
        },
        initializeBuffer: function initializeBuffer() {
          return this.quotedString("");
        },
        // END PUBLIC API
        internalNameLookup: function internalNameLookup(parent, name) {
          this.lookupPropertyFunctionIsUsed = true;
          return ["lookupProperty(", parent, ",", JSON.stringify(name), ")"];
        },
        lookupPropertyFunctionIsUsed: false,
        compile: function compile6(environment, options, context2, asObject) {
          this.environment = environment;
          this.options = options;
          this.stringParams = this.options.stringParams;
          this.trackIds = this.options.trackIds;
          this.precompile = !asObject;
          this.name = this.environment.name;
          this.isChild = !!context2;
          this.context = context2 || {
            decorators: [],
            programs: [],
            environments: []
          };
          this.preamble();
          this.stackSlot = 0;
          this.stackVars = [];
          this.aliases = {};
          this.registers = { list: [] };
          this.hashes = [];
          this.compileStack = [];
          this.inlineStack = [];
          this.blockParams = [];
          this.compileChildren(environment, options);
          this.useDepths = this.useDepths || environment.useDepths || environment.useDecorators || this.options.compat;
          this.useBlockParams = this.useBlockParams || environment.useBlockParams;
          var opcodes = environment.opcodes, opcode = void 0, firstLoc = void 0, i = void 0, l = void 0;
          for (i = 0, l = opcodes.length; i < l; i++) {
            opcode = opcodes[i];
            this.source.currentLocation = opcode.loc;
            firstLoc = firstLoc || opcode.loc;
            this[opcode.opcode].apply(this, opcode.args);
          }
          this.source.currentLocation = firstLoc;
          this.pushSource("");
          if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
            throw new _exception2["default"]("Compile completed with content left on stack");
          }
          if (!this.decorators.isEmpty()) {
            this.useDecorators = true;
            this.decorators.prepend(["var decorators = container.decorators, ", this.lookupPropertyFunctionVarDeclaration(), ";\n"]);
            this.decorators.push("return fn;");
            if (asObject) {
              this.decorators = Function.apply(this, ["fn", "props", "container", "depth0", "data", "blockParams", "depths", this.decorators.merge()]);
            } else {
              this.decorators.prepend("function(fn, props, container, depth0, data, blockParams, depths) {\n");
              this.decorators.push("}\n");
              this.decorators = this.decorators.merge();
            }
          } else {
            this.decorators = void 0;
          }
          var fn = this.createFunctionContext(asObject);
          if (!this.isChild) {
            var ret3 = {
              compiler: this.compilerInfo(),
              main: fn
            };
            if (this.decorators) {
              ret3.main_d = this.decorators;
              ret3.useDecorators = true;
            }
            var _context = this.context;
            var programs = _context.programs;
            var decorators = _context.decorators;
            for (i = 0, l = programs.length; i < l; i++) {
              if (programs[i]) {
                ret3[i] = programs[i];
                if (decorators[i]) {
                  ret3[i + "_d"] = decorators[i];
                  ret3.useDecorators = true;
                }
              }
            }
            if (this.environment.usePartial) {
              ret3.usePartial = true;
            }
            if (this.options.data) {
              ret3.useData = true;
            }
            if (this.useDepths) {
              ret3.useDepths = true;
            }
            if (this.useBlockParams) {
              ret3.useBlockParams = true;
            }
            if (this.options.compat) {
              ret3.compat = true;
            }
            if (!asObject) {
              ret3.compiler = JSON.stringify(ret3.compiler);
              this.source.currentLocation = { start: { line: 1, column: 0 } };
              ret3 = this.objectLiteral(ret3);
              if (options.srcName) {
                ret3 = ret3.toStringWithSourceMap({ file: options.destName });
                ret3.map = ret3.map && ret3.map.toString();
              } else {
                ret3 = ret3.toString();
              }
            } else {
              ret3.compilerOptions = this.options;
            }
            return ret3;
          } else {
            return fn;
          }
        },
        preamble: function preamble() {
          this.lastContext = 0;
          this.source = new _codeGen2["default"](this.options.srcName);
          this.decorators = new _codeGen2["default"](this.options.srcName);
        },
        createFunctionContext: function createFunctionContext(asObject) {
          var _this = this;
          var varDeclarations = "";
          var locals = this.stackVars.concat(this.registers.list);
          if (locals.length > 0) {
            varDeclarations += ", " + locals.join(", ");
          }
          var aliasCount = 0;
          Object.keys(this.aliases).forEach(function(alias) {
            var node = _this.aliases[alias];
            if (node.children && node.referenceCount > 1) {
              varDeclarations += ", alias" + ++aliasCount + "=" + alias;
              node.children[0] = "alias" + aliasCount;
            }
          });
          if (this.lookupPropertyFunctionIsUsed) {
            varDeclarations += ", " + this.lookupPropertyFunctionVarDeclaration();
          }
          var params = ["container", "depth0", "helpers", "partials", "data"];
          if (this.useBlockParams || this.useDepths) {
            params.push("blockParams");
          }
          if (this.useDepths) {
            params.push("depths");
          }
          var source = this.mergeSource(varDeclarations);
          if (asObject) {
            params.push(source);
            return Function.apply(this, params);
          } else {
            return this.source.wrap(["function(", params.join(","), ") {\n  ", source, "}"]);
          }
        },
        mergeSource: function mergeSource(varDeclarations) {
          var isSimple = this.environment.isSimple, appendOnly = !this.forceBuffer, appendFirst = void 0, sourceSeen = void 0, bufferStart = void 0, bufferEnd = void 0;
          this.source.each(function(line) {
            if (line.appendToBuffer) {
              if (bufferStart) {
                line.prepend("  + ");
              } else {
                bufferStart = line;
              }
              bufferEnd = line;
            } else {
              if (bufferStart) {
                if (!sourceSeen) {
                  appendFirst = true;
                } else {
                  bufferStart.prepend("buffer += ");
                }
                bufferEnd.add(";");
                bufferStart = bufferEnd = void 0;
              }
              sourceSeen = true;
              if (!isSimple) {
                appendOnly = false;
              }
            }
          });
          if (appendOnly) {
            if (bufferStart) {
              bufferStart.prepend("return ");
              bufferEnd.add(";");
            } else if (!sourceSeen) {
              this.source.push('return "";');
            }
          } else {
            varDeclarations += ", buffer = " + (appendFirst ? "" : this.initializeBuffer());
            if (bufferStart) {
              bufferStart.prepend("return buffer + ");
              bufferEnd.add(";");
            } else {
              this.source.push("return buffer;");
            }
          }
          if (varDeclarations) {
            this.source.prepend("var " + varDeclarations.substring(2) + (appendFirst ? "" : ";\n"));
          }
          return this.source.merge();
        },
        lookupPropertyFunctionVarDeclaration: function lookupPropertyFunctionVarDeclaration() {
          return "\n      lookupProperty = container.lookupProperty || function(parent, propertyName) {\n        if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {\n          return parent[propertyName];\n        }\n        return undefined\n    }\n    ".trim();
        },
        // [blockValue]
        //
        // On stack, before: hash, inverse, program, value
        // On stack, after: return value of blockHelperMissing
        //
        // The purpose of this opcode is to take a block of the form
        // `{{#this.foo}}...{{/this.foo}}`, resolve the value of `foo`, and
        // replace it on the stack with the result of properly
        // invoking blockHelperMissing.
        blockValue: function blockValue(name) {
          var blockHelperMissing = this.aliasable("container.hooks.blockHelperMissing"), params = [this.contextName(0)];
          this.setupHelperArgs(name, 0, params);
          var blockName = this.popStack();
          params.splice(1, 0, blockName);
          this.push(this.source.functionCall(blockHelperMissing, "call", params));
        },
        // [ambiguousBlockValue]
        //
        // On stack, before: hash, inverse, program, value
        // Compiler value, before: lastHelper=value of last found helper, if any
        // On stack, after, if no lastHelper: same as [blockValue]
        // On stack, after, if lastHelper: value
        ambiguousBlockValue: function ambiguousBlockValue() {
          var blockHelperMissing = this.aliasable("container.hooks.blockHelperMissing"), params = [this.contextName(0)];
          this.setupHelperArgs("", 0, params, true);
          this.flushInline();
          var current = this.topStack();
          params.splice(1, 0, current);
          this.pushSource(["if (!", this.lastHelper, ") { ", current, " = ", this.source.functionCall(blockHelperMissing, "call", params), "}"]);
        },
        // [appendContent]
        //
        // On stack, before: ...
        // On stack, after: ...
        //
        // Appends the string value of `content` to the current buffer
        appendContent: function appendContent(content) {
          if (this.pendingContent) {
            content = this.pendingContent + content;
          } else {
            this.pendingLocation = this.source.currentLocation;
          }
          this.pendingContent = content;
        },
        // [append]
        //
        // On stack, before: value, ...
        // On stack, after: ...
        //
        // Coerces `value` to a String and appends it to the current buffer.
        //
        // If `value` is truthy, or 0, it is coerced into a string and appended
        // Otherwise, the empty string is appended
        append: function append() {
          if (this.isInline()) {
            this.replaceStack(function(current) {
              return [" != null ? ", current, ' : ""'];
            });
            this.pushSource(this.appendToBuffer(this.popStack()));
          } else {
            var local = this.popStack();
            this.pushSource(["if (", local, " != null) { ", this.appendToBuffer(local, void 0, true), " }"]);
            if (this.environment.isSimple) {
              this.pushSource(["else { ", this.appendToBuffer("''", void 0, true), " }"]);
            }
          }
        },
        // [appendEscaped]
        //
        // On stack, before: value, ...
        // On stack, after: ...
        //
        // Escape `value` and append it to the buffer
        appendEscaped: function appendEscaped() {
          this.pushSource(this.appendToBuffer([this.aliasable("container.escapeExpression"), "(", this.popStack(), ")"]));
        },
        // [getContext]
        //
        // On stack, before: ...
        // On stack, after: ...
        // Compiler value, after: lastContext=depth
        //
        // Set the value of the `lastContext` compiler value to the depth
        getContext: function getContext(depth) {
          this.lastContext = depth;
        },
        // [pushContext]
        //
        // On stack, before: ...
        // On stack, after: currentContext, ...
        //
        // Pushes the value of the current context onto the stack.
        pushContext: function pushContext() {
          this.pushStackLiteral(this.contextName(this.lastContext));
        },
        // [lookupOnContext]
        //
        // On stack, before: ...
        // On stack, after: currentContext[name], ...
        //
        // Looks up the value of `name` on the current context and pushes
        // it onto the stack.
        lookupOnContext: function lookupOnContext(parts, falsy, strict, scoped) {
          var i = 0;
          if (!scoped && this.options.compat && !this.lastContext) {
            this.push(this.depthedLookup(parts[i++]));
          } else {
            this.pushContext();
          }
          this.resolvePath("context", parts, i, falsy, strict);
        },
        // [lookupBlockParam]
        //
        // On stack, before: ...
        // On stack, after: blockParam[name], ...
        //
        // Looks up the value of `parts` on the given block param and pushes
        // it onto the stack.
        lookupBlockParam: function lookupBlockParam(blockParamId, parts) {
          this.useBlockParams = true;
          this.push(["blockParams[", blockParamId[0], "][", blockParamId[1], "]"]);
          this.resolvePath("context", parts, 1);
        },
        // [lookupData]
        //
        // On stack, before: ...
        // On stack, after: data, ...
        //
        // Push the data lookup operator
        lookupData: function lookupData(depth, parts, strict) {
          if (!depth) {
            this.pushStackLiteral("data");
          } else {
            this.pushStackLiteral("container.data(data, " + depth + ")");
          }
          this.resolvePath("data", parts, 0, true, strict);
        },
        resolvePath: function resolvePath(type3, parts, i, falsy, strict) {
          var _this2 = this;
          if (this.options.strict || this.options.assumeObjects) {
            this.push(strictLookup(this.options.strict && strict, this, parts, type3));
            return;
          }
          var len = parts.length;
          for (; i < len; i++) {
            this.replaceStack(function(current) {
              var lookup = _this2.nameLookup(current, parts[i], type3);
              if (!falsy) {
                return [" != null ? ", lookup, " : ", current];
              } else {
                return [" && ", lookup];
              }
            });
          }
        },
        // [resolvePossibleLambda]
        //
        // On stack, before: value, ...
        // On stack, after: resolved value, ...
        //
        // If the `value` is a lambda, replace it on the stack by
        // the return value of the lambda
        resolvePossibleLambda: function resolvePossibleLambda() {
          this.push([this.aliasable("container.lambda"), "(", this.popStack(), ", ", this.contextName(0), ")"]);
        },
        // [pushStringParam]
        //
        // On stack, before: ...
        // On stack, after: string, currentContext, ...
        //
        // This opcode is designed for use in string mode, which
        // provides the string value of a parameter along with its
        // depth rather than resolving it immediately.
        pushStringParam: function pushStringParam(string2, type3) {
          this.pushContext();
          this.pushString(type3);
          if (type3 !== "SubExpression") {
            if (typeof string2 === "string") {
              this.pushString(string2);
            } else {
              this.pushStackLiteral(string2);
            }
          }
        },
        emptyHash: function emptyHash(omitEmpty) {
          if (this.trackIds) {
            this.push("{}");
          }
          if (this.stringParams) {
            this.push("{}");
            this.push("{}");
          }
          this.pushStackLiteral(omitEmpty ? "undefined" : "{}");
        },
        pushHash: function pushHash() {
          if (this.hash) {
            this.hashes.push(this.hash);
          }
          this.hash = { values: {}, types: [], contexts: [], ids: [] };
        },
        popHash: function popHash() {
          var hash5 = this.hash;
          this.hash = this.hashes.pop();
          if (this.trackIds) {
            this.push(this.objectLiteral(hash5.ids));
          }
          if (this.stringParams) {
            this.push(this.objectLiteral(hash5.contexts));
            this.push(this.objectLiteral(hash5.types));
          }
          this.push(this.objectLiteral(hash5.values));
        },
        // [pushString]
        //
        // On stack, before: ...
        // On stack, after: quotedString(string), ...
        //
        // Push a quoted version of `string` onto the stack
        pushString: function pushString(string2) {
          this.pushStackLiteral(this.quotedString(string2));
        },
        // [pushLiteral]
        //
        // On stack, before: ...
        // On stack, after: value, ...
        //
        // Pushes a value onto the stack. This operation prevents
        // the compiler from creating a temporary variable to hold
        // it.
        pushLiteral: function pushLiteral(value) {
          this.pushStackLiteral(value);
        },
        // [pushProgram]
        //
        // On stack, before: ...
        // On stack, after: program(guid), ...
        //
        // Push a program expression onto the stack. This takes
        // a compile-time guid and converts it into a runtime-accessible
        // expression.
        pushProgram: function pushProgram(guid) {
          if (guid != null) {
            this.pushStackLiteral(this.programExpression(guid));
          } else {
            this.pushStackLiteral(null);
          }
        },
        // [registerDecorator]
        //
        // On stack, before: hash, program, params..., ...
        // On stack, after: ...
        //
        // Pops off the decorator's parameters, invokes the decorator,
        // and inserts the decorator into the decorators list.
        registerDecorator: function registerDecorator(paramSize, name) {
          var foundDecorator = this.nameLookup("decorators", name, "decorator"), options = this.setupHelperArgs(name, paramSize);
          this.decorators.push(["fn = ", this.decorators.functionCall(foundDecorator, "", ["fn", "props", "container", options]), " || fn;"]);
        },
        // [invokeHelper]
        //
        // On stack, before: hash, inverse, program, params..., ...
        // On stack, after: result of helper invocation
        //
        // Pops off the helper's parameters, invokes the helper,
        // and pushes the helper's return value onto the stack.
        //
        // If the helper is not found, `helperMissing` is called.
        invokeHelper: function invokeHelper(paramSize, name, isSimple) {
          var nonHelper = this.popStack(), helper = this.setupHelper(paramSize, name);
          var possibleFunctionCalls = [];
          if (isSimple) {
            possibleFunctionCalls.push(helper.name);
          }
          possibleFunctionCalls.push(nonHelper);
          if (!this.options.strict) {
            possibleFunctionCalls.push(this.aliasable("container.hooks.helperMissing"));
          }
          var functionLookupCode = ["(", this.itemsSeparatedBy(possibleFunctionCalls, "||"), ")"];
          var functionCall = this.source.functionCall(functionLookupCode, "call", helper.callParams);
          this.push(functionCall);
        },
        itemsSeparatedBy: function itemsSeparatedBy(items, separator) {
          var result = [];
          result.push(items[0]);
          for (var i = 1; i < items.length; i++) {
            result.push(separator, items[i]);
          }
          return result;
        },
        // [invokeKnownHelper]
        //
        // On stack, before: hash, inverse, program, params..., ...
        // On stack, after: result of helper invocation
        //
        // This operation is used when the helper is known to exist,
        // so a `helperMissing` fallback is not required.
        invokeKnownHelper: function invokeKnownHelper(paramSize, name) {
          var helper = this.setupHelper(paramSize, name);
          this.push(this.source.functionCall(helper.name, "call", helper.callParams));
        },
        // [invokeAmbiguous]
        //
        // On stack, before: hash, inverse, program, params..., ...
        // On stack, after: result of disambiguation
        //
        // This operation is used when an expression like `{{foo}}`
        // is provided, but we don't know at compile-time whether it
        // is a helper or a path.
        //
        // This operation emits more code than the other options,
        // and can be avoided by passing the `knownHelpers` and
        // `knownHelpersOnly` flags at compile-time.
        invokeAmbiguous: function invokeAmbiguous(name, helperCall) {
          this.useRegister("helper");
          var nonHelper = this.popStack();
          this.emptyHash();
          var helper = this.setupHelper(0, name, helperCall);
          var helperName = this.lastHelper = this.nameLookup("helpers", name, "helper");
          var lookup = ["(", "(helper = ", helperName, " || ", nonHelper, ")"];
          if (!this.options.strict) {
            lookup[0] = "(helper = ";
            lookup.push(" != null ? helper : ", this.aliasable("container.hooks.helperMissing"));
          }
          this.push(["(", lookup, helper.paramsInit ? ["),(", helper.paramsInit] : [], "),", "(typeof helper === ", this.aliasable('"function"'), " ? ", this.source.functionCall("helper", "call", helper.callParams), " : helper))"]);
        },
        // [invokePartial]
        //
        // On stack, before: context, ...
        // On stack after: result of partial invocation
        //
        // This operation pops off a context, invokes a partial with that context,
        // and pushes the result of the invocation back.
        invokePartial: function invokePartial(isDynamic, name, indent) {
          var params = [], options = this.setupParams(name, 1, params);
          if (isDynamic) {
            name = this.popStack();
            delete options.name;
          }
          if (indent) {
            options.indent = JSON.stringify(indent);
          }
          options.helpers = "helpers";
          options.partials = "partials";
          options.decorators = "container.decorators";
          if (!isDynamic) {
            params.unshift(this.nameLookup("partials", name, "partial"));
          } else {
            params.unshift(name);
          }
          if (this.options.compat) {
            options.depths = "depths";
          }
          options = this.objectLiteral(options);
          params.push(options);
          this.push(this.source.functionCall("container.invokePartial", "", params));
        },
        // [assignToHash]
        //
        // On stack, before: value, ..., hash, ...
        // On stack, after: ..., hash, ...
        //
        // Pops a value off the stack and assigns it to the current hash
        assignToHash: function assignToHash(key) {
          var value = this.popStack(), context2 = void 0, type3 = void 0, id = void 0;
          if (this.trackIds) {
            id = this.popStack();
          }
          if (this.stringParams) {
            type3 = this.popStack();
            context2 = this.popStack();
          }
          var hash5 = this.hash;
          if (context2) {
            hash5.contexts[key] = context2;
          }
          if (type3) {
            hash5.types[key] = type3;
          }
          if (id) {
            hash5.ids[key] = id;
          }
          hash5.values[key] = value;
        },
        pushId: function pushId(type3, name, child) {
          if (type3 === "BlockParam") {
            this.pushStackLiteral("blockParams[" + name[0] + "].path[" + name[1] + "]" + (child ? " + " + JSON.stringify("." + child) : ""));
          } else if (type3 === "PathExpression") {
            this.pushString(name);
          } else if (type3 === "SubExpression") {
            this.pushStackLiteral("true");
          } else {
            this.pushStackLiteral("null");
          }
        },
        // HELPERS
        compiler: JavaScriptCompiler,
        compileChildren: function compileChildren(environment, options) {
          var children = environment.children, child = void 0, compiler = void 0;
          for (var i = 0, l = children.length; i < l; i++) {
            child = children[i];
            compiler = new this.compiler();
            var existing = this.matchExistingProgram(child);
            if (existing == null) {
              this.context.programs.push("");
              var index = this.context.programs.length;
              child.index = index;
              child.name = "program" + index;
              this.context.programs[index] = compiler.compile(child, options, this.context, !this.precompile);
              this.context.decorators[index] = compiler.decorators;
              this.context.environments[index] = child;
              this.useDepths = this.useDepths || compiler.useDepths;
              this.useBlockParams = this.useBlockParams || compiler.useBlockParams;
              child.useDepths = this.useDepths;
              child.useBlockParams = this.useBlockParams;
            } else {
              child.index = existing.index;
              child.name = "program" + existing.index;
              this.useDepths = this.useDepths || existing.useDepths;
              this.useBlockParams = this.useBlockParams || existing.useBlockParams;
            }
          }
        },
        matchExistingProgram: function matchExistingProgram(child) {
          for (var i = 0, len = this.context.environments.length; i < len; i++) {
            var environment = this.context.environments[i];
            if (environment && environment.equals(child)) {
              return environment;
            }
          }
        },
        programExpression: function programExpression(guid) {
          var child = this.environment.children[guid], programParams = [child.index, "data", child.blockParams];
          if (this.useBlockParams || this.useDepths) {
            programParams.push("blockParams");
          }
          if (this.useDepths) {
            programParams.push("depths");
          }
          return "container.program(" + programParams.join(", ") + ")";
        },
        useRegister: function useRegister(name) {
          if (!this.registers[name]) {
            this.registers[name] = true;
            this.registers.list.push(name);
          }
        },
        push: function push(expr) {
          if (!(expr instanceof Literal)) {
            expr = this.source.wrap(expr);
          }
          this.inlineStack.push(expr);
          return expr;
        },
        pushStackLiteral: function pushStackLiteral(item) {
          this.push(new Literal(item));
        },
        pushSource: function pushSource(source) {
          if (this.pendingContent) {
            this.source.push(this.appendToBuffer(this.source.quotedString(this.pendingContent), this.pendingLocation));
            this.pendingContent = void 0;
          }
          if (source) {
            this.source.push(source);
          }
        },
        replaceStack: function replaceStack(callback) {
          var prefix = ["("], stack = void 0, createdStack = void 0, usedLiteral = void 0;
          if (!this.isInline()) {
            throw new _exception2["default"]("replaceStack on non-inline");
          }
          var top = this.popStack(true);
          if (top instanceof Literal) {
            stack = [top.value];
            prefix = ["(", stack];
            usedLiteral = true;
          } else {
            createdStack = true;
            var _name = this.incrStack();
            prefix = ["((", this.push(_name), " = ", top, ")"];
            stack = this.topStack();
          }
          var item = callback.call(this, stack);
          if (!usedLiteral) {
            this.popStack();
          }
          if (createdStack) {
            this.stackSlot--;
          }
          this.push(prefix.concat(item, ")"));
        },
        incrStack: function incrStack() {
          this.stackSlot++;
          if (this.stackSlot > this.stackVars.length) {
            this.stackVars.push("stack" + this.stackSlot);
          }
          return this.topStackName();
        },
        topStackName: function topStackName() {
          return "stack" + this.stackSlot;
        },
        flushInline: function flushInline() {
          var inlineStack = this.inlineStack;
          this.inlineStack = [];
          for (var i = 0, len = inlineStack.length; i < len; i++) {
            var entry = inlineStack[i];
            if (entry instanceof Literal) {
              this.compileStack.push(entry);
            } else {
              var stack = this.incrStack();
              this.pushSource([stack, " = ", entry, ";"]);
              this.compileStack.push(stack);
            }
          }
        },
        isInline: function isInline() {
          return this.inlineStack.length;
        },
        popStack: function popStack(wrapped) {
          var inline = this.isInline(), item = (inline ? this.inlineStack : this.compileStack).pop();
          if (!wrapped && item instanceof Literal) {
            return item.value;
          } else {
            if (!inline) {
              if (!this.stackSlot) {
                throw new _exception2["default"]("Invalid stack pop");
              }
              this.stackSlot--;
            }
            return item;
          }
        },
        topStack: function topStack() {
          var stack = this.isInline() ? this.inlineStack : this.compileStack, item = stack[stack.length - 1];
          if (item instanceof Literal) {
            return item.value;
          } else {
            return item;
          }
        },
        contextName: function contextName(context2) {
          if (this.useDepths && context2) {
            return "depths[" + context2 + "]";
          } else {
            return "depth" + context2;
          }
        },
        quotedString: function quotedString(str) {
          return this.source.quotedString(str);
        },
        objectLiteral: function objectLiteral(obj) {
          return this.source.objectLiteral(obj);
        },
        aliasable: function aliasable(name) {
          var ret3 = this.aliases[name];
          if (ret3) {
            ret3.referenceCount++;
            return ret3;
          }
          ret3 = this.aliases[name] = this.source.wrap(name);
          ret3.aliasable = true;
          ret3.referenceCount = 1;
          return ret3;
        },
        setupHelper: function setupHelper(paramSize, name, blockHelper) {
          var params = [], paramsInit = this.setupHelperArgs(name, paramSize, params, blockHelper);
          var foundHelper = this.nameLookup("helpers", name, "helper"), callContext = this.aliasable(this.contextName(0) + " != null ? " + this.contextName(0) + " : (container.nullContext || {})");
          return {
            params,
            paramsInit,
            name: foundHelper,
            callParams: [callContext].concat(params)
          };
        },
        setupParams: function setupParams(helper, paramSize, params) {
          var options = {}, contexts = [], types2 = [], ids = [], objectArgs = !params, param = void 0;
          if (objectArgs) {
            params = [];
          }
          options.name = this.quotedString(helper);
          options.hash = this.popStack();
          if (this.trackIds) {
            options.hashIds = this.popStack();
          }
          if (this.stringParams) {
            options.hashTypes = this.popStack();
            options.hashContexts = this.popStack();
          }
          var inverse = this.popStack(), program2 = this.popStack();
          if (program2 || inverse) {
            options.fn = program2 || "container.noop";
            options.inverse = inverse || "container.noop";
          }
          var i = paramSize;
          while (i--) {
            param = this.popStack();
            params[i] = param;
            if (this.trackIds) {
              ids[i] = this.popStack();
            }
            if (this.stringParams) {
              types2[i] = this.popStack();
              contexts[i] = this.popStack();
            }
          }
          if (objectArgs) {
            options.args = this.source.generateArray(params);
          }
          if (this.trackIds) {
            options.ids = this.source.generateArray(ids);
          }
          if (this.stringParams) {
            options.types = this.source.generateArray(types2);
            options.contexts = this.source.generateArray(contexts);
          }
          if (this.options.data) {
            options.data = "data";
          }
          if (this.useBlockParams) {
            options.blockParams = "blockParams";
          }
          return options;
        },
        setupHelperArgs: function setupHelperArgs(helper, paramSize, params, useRegister) {
          var options = this.setupParams(helper, paramSize, params);
          options.loc = JSON.stringify(this.source.currentLocation);
          options = this.objectLiteral(options);
          if (useRegister) {
            this.useRegister("options");
            params.push("options");
            return ["options=", options];
          } else if (params) {
            params.push(options);
            return "";
          } else {
            return options;
          }
        }
      };
      (function() {
        var reservedWords = "break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield await null true false".split(" ");
        var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};
        for (var i = 0, l = reservedWords.length; i < l; i++) {
          compilerWords[reservedWords[i]] = true;
        }
      })();
      JavaScriptCompiler.isValidJavaScriptVariableName = function(name) {
        return !JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name);
      };
      function strictLookup(requireTerminal, compiler, parts, type3) {
        var stack = compiler.popStack(), i = 0, len = parts.length;
        if (requireTerminal) {
          len--;
        }
        for (; i < len; i++) {
          stack = compiler.nameLookup(stack, parts[i], type3);
        }
        if (requireTerminal) {
          return [compiler.aliasable("container.strict"), "(", stack, ", ", compiler.quotedString(parts[i]), ", ", JSON.stringify(compiler.source.currentLocation), " )"];
        } else {
          return stack;
        }
      }
      exports["default"] = JavaScriptCompiler;
      module2.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars.js
  var require_handlebars = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars.js"(exports, module2) {
      "use strict";
      exports.__esModule = true;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _handlebarsRuntime = require_handlebars_runtime();
      var _handlebarsRuntime2 = _interopRequireDefault(_handlebarsRuntime);
      var _handlebarsCompilerAst = require_ast();
      var _handlebarsCompilerAst2 = _interopRequireDefault(_handlebarsCompilerAst);
      var _handlebarsCompilerBase = require_base2();
      var _handlebarsCompilerCompiler = require_compiler();
      var _handlebarsCompilerJavascriptCompiler = require_javascript_compiler();
      var _handlebarsCompilerJavascriptCompiler2 = _interopRequireDefault(_handlebarsCompilerJavascriptCompiler);
      var _handlebarsCompilerVisitor = require_visitor();
      var _handlebarsCompilerVisitor2 = _interopRequireDefault(_handlebarsCompilerVisitor);
      var _handlebarsNoConflict = require_no_conflict();
      var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
      var _create = _handlebarsRuntime2["default"].create;
      function create10() {
        var hb = _create();
        hb.compile = function(input, options) {
          return _handlebarsCompilerCompiler.compile(input, options, hb);
        };
        hb.precompile = function(input, options) {
          return _handlebarsCompilerCompiler.precompile(input, options, hb);
        };
        hb.AST = _handlebarsCompilerAst2["default"];
        hb.Compiler = _handlebarsCompilerCompiler.Compiler;
        hb.JavaScriptCompiler = _handlebarsCompilerJavascriptCompiler2["default"];
        hb.Parser = _handlebarsCompilerBase.parser;
        hb.parse = _handlebarsCompilerBase.parse;
        hb.parseWithoutProcessing = _handlebarsCompilerBase.parseWithoutProcessing;
        return hb;
      }
      var inst = create10();
      inst.create = create10;
      _handlebarsNoConflict2["default"](inst);
      inst.Visitor = _handlebarsCompilerVisitor2["default"];
      inst["default"] = inst;
      exports["default"] = inst;
      module2.exports = exports["default"];
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/printer.js
  var require_printer = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/dist/cjs/handlebars/compiler/printer.js"(exports) {
      "use strict";
      exports.__esModule = true;
      exports.print = print2;
      exports.PrintVisitor = PrintVisitor;
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { "default": obj };
      }
      var _visitor = require_visitor();
      var _visitor2 = _interopRequireDefault(_visitor);
      function print2(ast) {
        return new PrintVisitor().accept(ast);
      }
      function PrintVisitor() {
        this.padding = 0;
      }
      PrintVisitor.prototype = new _visitor2["default"]();
      PrintVisitor.prototype.pad = function(string2) {
        var out = "";
        for (var i = 0, l = this.padding; i < l; i++) {
          out += "  ";
        }
        out += string2 + "\n";
        return out;
      };
      PrintVisitor.prototype.Program = function(program2) {
        var out = "", body = program2.body, i = void 0, l = void 0;
        if (program2.blockParams) {
          var blockParams = "BLOCK PARAMS: [";
          for (i = 0, l = program2.blockParams.length; i < l; i++) {
            blockParams += " " + program2.blockParams[i];
          }
          blockParams += " ]";
          out += this.pad(blockParams);
        }
        for (i = 0, l = body.length; i < l; i++) {
          out += this.accept(body[i]);
        }
        this.padding--;
        return out;
      };
      PrintVisitor.prototype.MustacheStatement = function(mustache) {
        return this.pad("{{ " + this.SubExpression(mustache) + " }}");
      };
      PrintVisitor.prototype.Decorator = function(mustache) {
        return this.pad("{{ DIRECTIVE " + this.SubExpression(mustache) + " }}");
      };
      PrintVisitor.prototype.BlockStatement = PrintVisitor.prototype.DecoratorBlock = function(block) {
        var out = "";
        out += this.pad((block.type === "DecoratorBlock" ? "DIRECTIVE " : "") + "BLOCK:");
        this.padding++;
        out += this.pad(this.SubExpression(block));
        if (block.program) {
          out += this.pad("PROGRAM:");
          this.padding++;
          out += this.accept(block.program);
          this.padding--;
        }
        if (block.inverse) {
          if (block.program) {
            this.padding++;
          }
          out += this.pad("{{^}}");
          this.padding++;
          out += this.accept(block.inverse);
          this.padding--;
          if (block.program) {
            this.padding--;
          }
        }
        this.padding--;
        return out;
      };
      PrintVisitor.prototype.PartialStatement = function(partial) {
        var content = "PARTIAL:" + partial.name.original;
        if (partial.params[0]) {
          content += " " + this.accept(partial.params[0]);
        }
        if (partial.hash) {
          content += " " + this.accept(partial.hash);
        }
        return this.pad("{{> " + content + " }}");
      };
      PrintVisitor.prototype.PartialBlockStatement = function(partial) {
        var content = "PARTIAL BLOCK:" + partial.name.original;
        if (partial.params[0]) {
          content += " " + this.accept(partial.params[0]);
        }
        if (partial.hash) {
          content += " " + this.accept(partial.hash);
        }
        content += " " + this.pad("PROGRAM:");
        this.padding++;
        content += this.accept(partial.program);
        this.padding--;
        return this.pad("{{> " + content + " }}");
      };
      PrintVisitor.prototype.ContentStatement = function(content) {
        return this.pad("CONTENT[ '" + content.value + "' ]");
      };
      PrintVisitor.prototype.CommentStatement = function(comment) {
        return this.pad("{{! '" + comment.value + "' }}");
      };
      PrintVisitor.prototype.SubExpression = function(sexpr) {
        var params = sexpr.params, paramStrings = [], hash5 = void 0;
        for (var i = 0, l = params.length; i < l; i++) {
          paramStrings.push(this.accept(params[i]));
        }
        params = "[" + paramStrings.join(", ") + "]";
        hash5 = sexpr.hash ? " " + this.accept(sexpr.hash) : "";
        return this.accept(sexpr.path) + " " + params + hash5;
      };
      PrintVisitor.prototype.PathExpression = function(id) {
        var path4 = id.parts.join("/");
        return (id.data ? "@" : "") + "PATH:" + path4;
      };
      PrintVisitor.prototype.StringLiteral = function(string2) {
        return '"' + string2.value + '"';
      };
      PrintVisitor.prototype.NumberLiteral = function(number4) {
        return "NUMBER{" + number4.value + "}";
      };
      PrintVisitor.prototype.BooleanLiteral = function(bool3) {
        return "BOOLEAN{" + bool3.value + "}";
      };
      PrintVisitor.prototype.UndefinedLiteral = function() {
        return "UNDEFINED";
      };
      PrintVisitor.prototype.NullLiteral = function() {
        return "NULL";
      };
      PrintVisitor.prototype.Hash = function(hash5) {
        var pairs = hash5.pairs, joinedPairs = [];
        for (var i = 0, l = pairs.length; i < l; i++) {
          joinedPairs.push(this.accept(pairs[i]));
        }
        return "HASH{" + joinedPairs.join(", ") + "}";
      };
      PrintVisitor.prototype.HashPair = function(pair) {
        return pair.key + "=" + this.accept(pair.value);
      };
    }
  });

  // ../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/lib/index.js
  var require_lib = __commonJS({
    "../../node_modules/.pnpm/handlebars@4.7.7/node_modules/handlebars/lib/index.js"(exports, module2) {
      var handlebars = require_handlebars()["default"];
      var printer = require_printer();
      handlebars.PrintVisitor = printer.PrintVisitor;
      handlebars.print = printer.print;
      module2.exports = handlebars;
      function extension(module3, filename) {
        var fs4 = __require2("fs");
        var templateString = fs4.readFileSync(filename, "utf8");
        module3.exports = handlebars.compile(templateString);
      }
      if (typeof __require2 !== "undefined" && __require2.extensions) {
        __require2.extensions[".handlebars"] = extension;
        __require2.extensions[".hbs"] = extension;
      }
    }
  });

  // ../../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js
  var require_color_name = __commonJS({
    "../../node_modules/.pnpm/color-name@1.1.4/node_modules/color-name/index.js"(exports, module2) {
      "use strict";
      module2.exports = {
        "aliceblue": [240, 248, 255],
        "antiquewhite": [250, 235, 215],
        "aqua": [0, 255, 255],
        "aquamarine": [127, 255, 212],
        "azure": [240, 255, 255],
        "beige": [245, 245, 220],
        "bisque": [255, 228, 196],
        "black": [0, 0, 0],
        "blanchedalmond": [255, 235, 205],
        "blue": [0, 0, 255],
        "blueviolet": [138, 43, 226],
        "brown": [165, 42, 42],
        "burlywood": [222, 184, 135],
        "cadetblue": [95, 158, 160],
        "chartreuse": [127, 255, 0],
        "chocolate": [210, 105, 30],
        "coral": [255, 127, 80],
        "cornflowerblue": [100, 149, 237],
        "cornsilk": [255, 248, 220],
        "crimson": [220, 20, 60],
        "cyan": [0, 255, 255],
        "darkblue": [0, 0, 139],
        "darkcyan": [0, 139, 139],
        "darkgoldenrod": [184, 134, 11],
        "darkgray": [169, 169, 169],
        "darkgreen": [0, 100, 0],
        "darkgrey": [169, 169, 169],
        "darkkhaki": [189, 183, 107],
        "darkmagenta": [139, 0, 139],
        "darkolivegreen": [85, 107, 47],
        "darkorange": [255, 140, 0],
        "darkorchid": [153, 50, 204],
        "darkred": [139, 0, 0],
        "darksalmon": [233, 150, 122],
        "darkseagreen": [143, 188, 143],
        "darkslateblue": [72, 61, 139],
        "darkslategray": [47, 79, 79],
        "darkslategrey": [47, 79, 79],
        "darkturquoise": [0, 206, 209],
        "darkviolet": [148, 0, 211],
        "deeppink": [255, 20, 147],
        "deepskyblue": [0, 191, 255],
        "dimgray": [105, 105, 105],
        "dimgrey": [105, 105, 105],
        "dodgerblue": [30, 144, 255],
        "firebrick": [178, 34, 34],
        "floralwhite": [255, 250, 240],
        "forestgreen": [34, 139, 34],
        "fuchsia": [255, 0, 255],
        "gainsboro": [220, 220, 220],
        "ghostwhite": [248, 248, 255],
        "gold": [255, 215, 0],
        "goldenrod": [218, 165, 32],
        "gray": [128, 128, 128],
        "green": [0, 128, 0],
        "greenyellow": [173, 255, 47],
        "grey": [128, 128, 128],
        "honeydew": [240, 255, 240],
        "hotpink": [255, 105, 180],
        "indianred": [205, 92, 92],
        "indigo": [75, 0, 130],
        "ivory": [255, 255, 240],
        "khaki": [240, 230, 140],
        "lavender": [230, 230, 250],
        "lavenderblush": [255, 240, 245],
        "lawngreen": [124, 252, 0],
        "lemonchiffon": [255, 250, 205],
        "lightblue": [173, 216, 230],
        "lightcoral": [240, 128, 128],
        "lightcyan": [224, 255, 255],
        "lightgoldenrodyellow": [250, 250, 210],
        "lightgray": [211, 211, 211],
        "lightgreen": [144, 238, 144],
        "lightgrey": [211, 211, 211],
        "lightpink": [255, 182, 193],
        "lightsalmon": [255, 160, 122],
        "lightseagreen": [32, 178, 170],
        "lightskyblue": [135, 206, 250],
        "lightslategray": [119, 136, 153],
        "lightslategrey": [119, 136, 153],
        "lightsteelblue": [176, 196, 222],
        "lightyellow": [255, 255, 224],
        "lime": [0, 255, 0],
        "limegreen": [50, 205, 50],
        "linen": [250, 240, 230],
        "magenta": [255, 0, 255],
        "maroon": [128, 0, 0],
        "mediumaquamarine": [102, 205, 170],
        "mediumblue": [0, 0, 205],
        "mediumorchid": [186, 85, 211],
        "mediumpurple": [147, 112, 219],
        "mediumseagreen": [60, 179, 113],
        "mediumslateblue": [123, 104, 238],
        "mediumspringgreen": [0, 250, 154],
        "mediumturquoise": [72, 209, 204],
        "mediumvioletred": [199, 21, 133],
        "midnightblue": [25, 25, 112],
        "mintcream": [245, 255, 250],
        "mistyrose": [255, 228, 225],
        "moccasin": [255, 228, 181],
        "navajowhite": [255, 222, 173],
        "navy": [0, 0, 128],
        "oldlace": [253, 245, 230],
        "olive": [128, 128, 0],
        "olivedrab": [107, 142, 35],
        "orange": [255, 165, 0],
        "orangered": [255, 69, 0],
        "orchid": [218, 112, 214],
        "palegoldenrod": [238, 232, 170],
        "palegreen": [152, 251, 152],
        "paleturquoise": [175, 238, 238],
        "palevioletred": [219, 112, 147],
        "papayawhip": [255, 239, 213],
        "peachpuff": [255, 218, 185],
        "peru": [205, 133, 63],
        "pink": [255, 192, 203],
        "plum": [221, 160, 221],
        "powderblue": [176, 224, 230],
        "purple": [128, 0, 128],
        "rebeccapurple": [102, 51, 153],
        "red": [255, 0, 0],
        "rosybrown": [188, 143, 143],
        "royalblue": [65, 105, 225],
        "saddlebrown": [139, 69, 19],
        "salmon": [250, 128, 114],
        "sandybrown": [244, 164, 96],
        "seagreen": [46, 139, 87],
        "seashell": [255, 245, 238],
        "sienna": [160, 82, 45],
        "silver": [192, 192, 192],
        "skyblue": [135, 206, 235],
        "slateblue": [106, 90, 205],
        "slategray": [112, 128, 144],
        "slategrey": [112, 128, 144],
        "snow": [255, 250, 250],
        "springgreen": [0, 255, 127],
        "steelblue": [70, 130, 180],
        "tan": [210, 180, 140],
        "teal": [0, 128, 128],
        "thistle": [216, 191, 216],
        "tomato": [255, 99, 71],
        "turquoise": [64, 224, 208],
        "violet": [238, 130, 238],
        "wheat": [245, 222, 179],
        "white": [255, 255, 255],
        "whitesmoke": [245, 245, 245],
        "yellow": [255, 255, 0],
        "yellowgreen": [154, 205, 50]
      };
    }
  });

  // ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js
  var require_conversions = __commonJS({
    "../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/conversions.js"(exports, module2) {
      var cssKeywords = require_color_name();
      var reverseKeywords = {};
      for (const key of Object.keys(cssKeywords)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
      var convert2 = {
        rgb: { channels: 3, labels: "rgb" },
        hsl: { channels: 3, labels: "hsl" },
        hsv: { channels: 3, labels: "hsv" },
        hwb: { channels: 3, labels: "hwb" },
        cmyk: { channels: 4, labels: "cmyk" },
        xyz: { channels: 3, labels: "xyz" },
        lab: { channels: 3, labels: "lab" },
        lch: { channels: 3, labels: "lch" },
        hex: { channels: 1, labels: ["hex"] },
        keyword: { channels: 1, labels: ["keyword"] },
        ansi16: { channels: 1, labels: ["ansi16"] },
        ansi256: { channels: 1, labels: ["ansi256"] },
        hcg: { channels: 3, labels: ["h", "c", "g"] },
        apple: { channels: 3, labels: ["r16", "g16", "b16"] },
        gray: { channels: 1, labels: ["gray"] }
      };
      module2.exports = convert2;
      for (const model of Object.keys(convert2)) {
        if (!("channels" in convert2[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert2[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert2[model].labels.length !== convert2[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        const { channels, labels } = convert2[model];
        delete convert2[model].channels;
        delete convert2[model].labels;
        Object.defineProperty(convert2[model], "channels", { value: channels });
        Object.defineProperty(convert2[model], "labels", { value: labels });
      }
      convert2.rgb.hsl = function(rgb) {
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        const min = Math.min(r, g, b);
        const max2 = Math.max(r, g, b);
        const delta = max2 - min;
        let h;
        let s;
        if (max2 === min) {
          h = 0;
        } else if (r === max2) {
          h = (g - b) / delta;
        } else if (g === max2) {
          h = 2 + (b - r) / delta;
        } else if (b === max2) {
          h = 4 + (r - g) / delta;
        }
        h = Math.min(h * 60, 360);
        if (h < 0) {
          h += 360;
        }
        const l = (min + max2) / 2;
        if (max2 === min) {
          s = 0;
        } else if (l <= 0.5) {
          s = delta / (max2 + min);
        } else {
          s = delta / (2 - max2 - min);
        }
        return [h, s * 100, l * 100];
      };
      convert2.rgb.hsv = function(rgb) {
        let rdif;
        let gdif;
        let bdif;
        let h;
        let s;
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        const v = Math.max(r, g, b);
        const diff = v - Math.min(r, g, b);
        const diffc = function(c) {
          return (v - c) / 6 / diff + 1 / 2;
        };
        if (diff === 0) {
          h = 0;
          s = 0;
        } else {
          s = diff / v;
          rdif = diffc(r);
          gdif = diffc(g);
          bdif = diffc(b);
          if (r === v) {
            h = bdif - gdif;
          } else if (g === v) {
            h = 1 / 3 + rdif - bdif;
          } else if (b === v) {
            h = 2 / 3 + gdif - rdif;
          }
          if (h < 0) {
            h += 1;
          } else if (h > 1) {
            h -= 1;
          }
        }
        return [
          h * 360,
          s * 100,
          v * 100
        ];
      };
      convert2.rgb.hwb = function(rgb) {
        const r = rgb[0];
        const g = rgb[1];
        let b = rgb[2];
        const h = convert2.rgb.hsl(rgb)[0];
        const w = 1 / 255 * Math.min(r, Math.min(g, b));
        b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
        return [h, w * 100, b * 100];
      };
      convert2.rgb.cmyk = function(rgb) {
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        const k = Math.min(1 - r, 1 - g, 1 - b);
        const c = (1 - r - k) / (1 - k) || 0;
        const m = (1 - g - k) / (1 - k) || 0;
        const y = (1 - b - k) / (1 - k) || 0;
        return [c * 100, m * 100, y * 100, k * 100];
      };
      function comparativeDistance(x, y) {
        return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
      }
      convert2.rgb.keyword = function(rgb) {
        const reversed = reverseKeywords[rgb];
        if (reversed) {
          return reversed;
        }
        let currentClosestDistance = Infinity;
        let currentClosestKeyword;
        for (const keyword of Object.keys(cssKeywords)) {
          const value = cssKeywords[keyword];
          const distance = comparativeDistance(rgb, value);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
        return currentClosestKeyword;
      };
      convert2.keyword.rgb = function(keyword) {
        return cssKeywords[keyword];
      };
      convert2.rgb.xyz = function(rgb) {
        let r = rgb[0] / 255;
        let g = rgb[1] / 255;
        let b = rgb[2] / 255;
        r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
        g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
        b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
        const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
        const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
        const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
        return [x * 100, y * 100, z * 100];
      };
      convert2.rgb.lab = function(rgb) {
        const xyz = convert2.rgb.xyz(rgb);
        let x = xyz[0];
        let y = xyz[1];
        let z = xyz[2];
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
        y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
        z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
        const l = 116 * y - 16;
        const a = 500 * (x - y);
        const b = 200 * (y - z);
        return [l, a, b];
      };
      convert2.hsl.rgb = function(hsl) {
        const h = hsl[0] / 360;
        const s = hsl[1] / 100;
        const l = hsl[2] / 100;
        let t2;
        let t3;
        let val;
        if (s === 0) {
          val = l * 255;
          return [val, val, val];
        }
        if (l < 0.5) {
          t2 = l * (1 + s);
        } else {
          t2 = l + s - l * s;
        }
        const t1 = 2 * l - t2;
        const rgb = [0, 0, 0];
        for (let i = 0; i < 3; i++) {
          t3 = h + 1 / 3 * -(i - 1);
          if (t3 < 0) {
            t3++;
          }
          if (t3 > 1) {
            t3--;
          }
          if (6 * t3 < 1) {
            val = t1 + (t2 - t1) * 6 * t3;
          } else if (2 * t3 < 1) {
            val = t2;
          } else if (3 * t3 < 2) {
            val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
          } else {
            val = t1;
          }
          rgb[i] = val * 255;
        }
        return rgb;
      };
      convert2.hsl.hsv = function(hsl) {
        const h = hsl[0];
        let s = hsl[1] / 100;
        let l = hsl[2] / 100;
        let smin = s;
        const lmin = Math.max(l, 0.01);
        l *= 2;
        s *= l <= 1 ? l : 2 - l;
        smin *= lmin <= 1 ? lmin : 2 - lmin;
        const v = (l + s) / 2;
        const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
        return [h, sv * 100, v * 100];
      };
      convert2.hsv.rgb = function(hsv) {
        const h = hsv[0] / 60;
        const s = hsv[1] / 100;
        let v = hsv[2] / 100;
        const hi = Math.floor(h) % 6;
        const f2 = h - Math.floor(h);
        const p = 255 * v * (1 - s);
        const q = 255 * v * (1 - s * f2);
        const t = 255 * v * (1 - s * (1 - f2));
        v *= 255;
        switch (hi) {
          case 0:
            return [v, t, p];
          case 1:
            return [q, v, p];
          case 2:
            return [p, v, t];
          case 3:
            return [p, q, v];
          case 4:
            return [t, p, v];
          case 5:
            return [v, p, q];
        }
      };
      convert2.hsv.hsl = function(hsv) {
        const h = hsv[0];
        const s = hsv[1] / 100;
        const v = hsv[2] / 100;
        const vmin = Math.max(v, 0.01);
        let sl;
        let l;
        l = (2 - s) * v;
        const lmin = (2 - s) * vmin;
        sl = s * vmin;
        sl /= lmin <= 1 ? lmin : 2 - lmin;
        sl = sl || 0;
        l /= 2;
        return [h, sl * 100, l * 100];
      };
      convert2.hwb.rgb = function(hwb) {
        const h = hwb[0] / 360;
        let wh = hwb[1] / 100;
        let bl = hwb[2] / 100;
        const ratio = wh + bl;
        let f2;
        if (ratio > 1) {
          wh /= ratio;
          bl /= ratio;
        }
        const i = Math.floor(6 * h);
        const v = 1 - bl;
        f2 = 6 * h - i;
        if ((i & 1) !== 0) {
          f2 = 1 - f2;
        }
        const n = wh + f2 * (v - wh);
        let r;
        let g;
        let b;
        switch (i) {
          default:
          case 6:
          case 0:
            r = v;
            g = n;
            b = wh;
            break;
          case 1:
            r = n;
            g = v;
            b = wh;
            break;
          case 2:
            r = wh;
            g = v;
            b = n;
            break;
          case 3:
            r = wh;
            g = n;
            b = v;
            break;
          case 4:
            r = n;
            g = wh;
            b = v;
            break;
          case 5:
            r = v;
            g = wh;
            b = n;
            break;
        }
        return [r * 255, g * 255, b * 255];
      };
      convert2.cmyk.rgb = function(cmyk) {
        const c = cmyk[0] / 100;
        const m = cmyk[1] / 100;
        const y = cmyk[2] / 100;
        const k = cmyk[3] / 100;
        const r = 1 - Math.min(1, c * (1 - k) + k);
        const g = 1 - Math.min(1, m * (1 - k) + k);
        const b = 1 - Math.min(1, y * (1 - k) + k);
        return [r * 255, g * 255, b * 255];
      };
      convert2.xyz.rgb = function(xyz) {
        const x = xyz[0] / 100;
        const y = xyz[1] / 100;
        const z = xyz[2] / 100;
        let r;
        let g;
        let b;
        r = x * 3.2406 + y * -1.5372 + z * -0.4986;
        g = x * -0.9689 + y * 1.8758 + z * 0.0415;
        b = x * 0.0557 + y * -0.204 + z * 1.057;
        r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
        g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
        b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
        r = Math.min(Math.max(0, r), 1);
        g = Math.min(Math.max(0, g), 1);
        b = Math.min(Math.max(0, b), 1);
        return [r * 255, g * 255, b * 255];
      };
      convert2.xyz.lab = function(xyz) {
        let x = xyz[0];
        let y = xyz[1];
        let z = xyz[2];
        x /= 95.047;
        y /= 100;
        z /= 108.883;
        x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
        y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
        z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
        const l = 116 * y - 16;
        const a = 500 * (x - y);
        const b = 200 * (y - z);
        return [l, a, b];
      };
      convert2.lab.xyz = function(lab) {
        const l = lab[0];
        const a = lab[1];
        const b = lab[2];
        let x;
        let y;
        let z;
        y = (l + 16) / 116;
        x = a / 500 + y;
        z = y - b / 200;
        const y2 = y ** 3;
        const x2 = x ** 3;
        const z2 = z ** 3;
        y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
        x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
        z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
        x *= 95.047;
        y *= 100;
        z *= 108.883;
        return [x, y, z];
      };
      convert2.lab.lch = function(lab) {
        const l = lab[0];
        const a = lab[1];
        const b = lab[2];
        let h;
        const hr = Math.atan2(b, a);
        h = hr * 360 / 2 / Math.PI;
        if (h < 0) {
          h += 360;
        }
        const c = Math.sqrt(a * a + b * b);
        return [l, c, h];
      };
      convert2.lch.lab = function(lch) {
        const l = lch[0];
        const c = lch[1];
        const h = lch[2];
        const hr = h / 360 * 2 * Math.PI;
        const a = c * Math.cos(hr);
        const b = c * Math.sin(hr);
        return [l, a, b];
      };
      convert2.rgb.ansi16 = function(args, saturation = null) {
        const [r, g, b] = args;
        let value = saturation === null ? convert2.rgb.hsv(args)[2] : saturation;
        value = Math.round(value / 50);
        if (value === 0) {
          return 30;
        }
        let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
        if (value === 2) {
          ansi += 60;
        }
        return ansi;
      };
      convert2.hsv.ansi16 = function(args) {
        return convert2.rgb.ansi16(convert2.hsv.rgb(args), args[2]);
      };
      convert2.rgb.ansi256 = function(args) {
        const r = args[0];
        const g = args[1];
        const b = args[2];
        if (r === g && g === b) {
          if (r < 8) {
            return 16;
          }
          if (r > 248) {
            return 231;
          }
          return Math.round((r - 8) / 247 * 24) + 232;
        }
        const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
        return ansi;
      };
      convert2.ansi16.rgb = function(args) {
        let color = args % 10;
        if (color === 0 || color === 7) {
          if (args > 50) {
            color += 3.5;
          }
          color = color / 10.5 * 255;
          return [color, color, color];
        }
        const mult = (~~(args > 50) + 1) * 0.5;
        const r = (color & 1) * mult * 255;
        const g = (color >> 1 & 1) * mult * 255;
        const b = (color >> 2 & 1) * mult * 255;
        return [r, g, b];
      };
      convert2.ansi256.rgb = function(args) {
        if (args >= 232) {
          const c = (args - 232) * 10 + 8;
          return [c, c, c];
        }
        args -= 16;
        let rem;
        const r = Math.floor(args / 36) / 5 * 255;
        const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
        const b = rem % 6 / 5 * 255;
        return [r, g, b];
      };
      convert2.rgb.hex = function(args) {
        const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
        const string2 = integer.toString(16).toUpperCase();
        return "000000".substring(string2.length) + string2;
      };
      convert2.hex.rgb = function(args) {
        const match3 = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!match3) {
          return [0, 0, 0];
        }
        let colorString = match3[0];
        if (match3[0].length === 3) {
          colorString = colorString.split("").map((char) => {
            return char + char;
          }).join("");
        }
        const integer = parseInt(colorString, 16);
        const r = integer >> 16 & 255;
        const g = integer >> 8 & 255;
        const b = integer & 255;
        return [r, g, b];
      };
      convert2.rgb.hcg = function(rgb) {
        const r = rgb[0] / 255;
        const g = rgb[1] / 255;
        const b = rgb[2] / 255;
        const max2 = Math.max(Math.max(r, g), b);
        const min = Math.min(Math.min(r, g), b);
        const chroma = max2 - min;
        let grayscale;
        let hue;
        if (chroma < 1) {
          grayscale = min / (1 - chroma);
        } else {
          grayscale = 0;
        }
        if (chroma <= 0) {
          hue = 0;
        } else if (max2 === r) {
          hue = (g - b) / chroma % 6;
        } else if (max2 === g) {
          hue = 2 + (b - r) / chroma;
        } else {
          hue = 4 + (r - g) / chroma;
        }
        hue /= 6;
        hue %= 1;
        return [hue * 360, chroma * 100, grayscale * 100];
      };
      convert2.hsl.hcg = function(hsl) {
        const s = hsl[1] / 100;
        const l = hsl[2] / 100;
        const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
        let f2 = 0;
        if (c < 1) {
          f2 = (l - 0.5 * c) / (1 - c);
        }
        return [hsl[0], c * 100, f2 * 100];
      };
      convert2.hsv.hcg = function(hsv) {
        const s = hsv[1] / 100;
        const v = hsv[2] / 100;
        const c = s * v;
        let f2 = 0;
        if (c < 1) {
          f2 = (v - c) / (1 - c);
        }
        return [hsv[0], c * 100, f2 * 100];
      };
      convert2.hcg.rgb = function(hcg) {
        const h = hcg[0] / 360;
        const c = hcg[1] / 100;
        const g = hcg[2] / 100;
        if (c === 0) {
          return [g * 255, g * 255, g * 255];
        }
        const pure = [0, 0, 0];
        const hi = h % 1 * 6;
        const v = hi % 1;
        const w = 1 - v;
        let mg = 0;
        switch (Math.floor(hi)) {
          case 0:
            pure[0] = 1;
            pure[1] = v;
            pure[2] = 0;
            break;
          case 1:
            pure[0] = w;
            pure[1] = 1;
            pure[2] = 0;
            break;
          case 2:
            pure[0] = 0;
            pure[1] = 1;
            pure[2] = v;
            break;
          case 3:
            pure[0] = 0;
            pure[1] = w;
            pure[2] = 1;
            break;
          case 4:
            pure[0] = v;
            pure[1] = 0;
            pure[2] = 1;
            break;
          default:
            pure[0] = 1;
            pure[1] = 0;
            pure[2] = w;
        }
        mg = (1 - c) * g;
        return [
          (c * pure[0] + mg) * 255,
          (c * pure[1] + mg) * 255,
          (c * pure[2] + mg) * 255
        ];
      };
      convert2.hcg.hsv = function(hcg) {
        const c = hcg[1] / 100;
        const g = hcg[2] / 100;
        const v = c + g * (1 - c);
        let f2 = 0;
        if (v > 0) {
          f2 = c / v;
        }
        return [hcg[0], f2 * 100, v * 100];
      };
      convert2.hcg.hsl = function(hcg) {
        const c = hcg[1] / 100;
        const g = hcg[2] / 100;
        const l = g * (1 - c) + 0.5 * c;
        let s = 0;
        if (l > 0 && l < 0.5) {
          s = c / (2 * l);
        } else if (l >= 0.5 && l < 1) {
          s = c / (2 * (1 - l));
        }
        return [hcg[0], s * 100, l * 100];
      };
      convert2.hcg.hwb = function(hcg) {
        const c = hcg[1] / 100;
        const g = hcg[2] / 100;
        const v = c + g * (1 - c);
        return [hcg[0], (v - c) * 100, (1 - v) * 100];
      };
      convert2.hwb.hcg = function(hwb) {
        const w = hwb[1] / 100;
        const b = hwb[2] / 100;
        const v = 1 - b;
        const c = v - w;
        let g = 0;
        if (c < 1) {
          g = (v - c) / (1 - c);
        }
        return [hwb[0], c * 100, g * 100];
      };
      convert2.apple.rgb = function(apple) {
        return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
      };
      convert2.rgb.apple = function(rgb) {
        return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
      };
      convert2.gray.rgb = function(args) {
        return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
      };
      convert2.gray.hsl = function(args) {
        return [0, 0, args[0]];
      };
      convert2.gray.hsv = convert2.gray.hsl;
      convert2.gray.hwb = function(gray) {
        return [0, 100, gray[0]];
      };
      convert2.gray.cmyk = function(gray) {
        return [0, 0, 0, gray[0]];
      };
      convert2.gray.lab = function(gray) {
        return [gray[0], 0, 0];
      };
      convert2.gray.hex = function(gray) {
        const val = Math.round(gray[0] / 100 * 255) & 255;
        const integer = (val << 16) + (val << 8) + val;
        const string2 = integer.toString(16).toUpperCase();
        return "000000".substring(string2.length) + string2;
      };
      convert2.rgb.gray = function(rgb) {
        const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
        return [val / 255 * 100];
      };
    }
  });

  // ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js
  var require_route = __commonJS({
    "../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/route.js"(exports, module2) {
      var conversions = require_conversions();
      function buildGraph() {
        const graph = {};
        const models = Object.keys(conversions);
        for (let len = models.length, i = 0; i < len; i++) {
          graph[models[i]] = {
            // http://jsperf.com/1-vs-infinity
            // micro-opt, but this is simple.
            distance: -1,
            parent: null
          };
        }
        return graph;
      }
      function deriveBFS(fromModel) {
        const graph = buildGraph();
        const queue = [fromModel];
        graph[fromModel].distance = 0;
        while (queue.length) {
          const current = queue.pop();
          const adjacents = Object.keys(conversions[current]);
          for (let len = adjacents.length, i = 0; i < len; i++) {
            const adjacent = adjacents[i];
            const node = graph[adjacent];
            if (node.distance === -1) {
              node.distance = graph[current].distance + 1;
              node.parent = current;
              queue.unshift(adjacent);
            }
          }
        }
        return graph;
      }
      function link(from, to) {
        return function(args) {
          return to(from(args));
        };
      }
      function wrapConversion(toModel, graph) {
        const path4 = [graph[toModel].parent, toModel];
        let fn = conversions[graph[toModel].parent][toModel];
        let cur = graph[toModel].parent;
        while (graph[cur].parent) {
          path4.unshift(graph[cur].parent);
          fn = link(conversions[graph[cur].parent][cur], fn);
          cur = graph[cur].parent;
        }
        fn.conversion = path4;
        return fn;
      }
      module2.exports = function(fromModel) {
        const graph = deriveBFS(fromModel);
        const conversion = {};
        const models = Object.keys(graph);
        for (let len = models.length, i = 0; i < len; i++) {
          const toModel = models[i];
          const node = graph[toModel];
          if (node.parent === null) {
            continue;
          }
          conversion[toModel] = wrapConversion(toModel, graph);
        }
        return conversion;
      };
    }
  });

  // ../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js
  var require_color_convert = __commonJS({
    "../../node_modules/.pnpm/color-convert@2.0.1/node_modules/color-convert/index.js"(exports, module2) {
      var conversions = require_conversions();
      var route = require_route();
      var convert2 = {};
      var models = Object.keys(conversions);
      function wrapRaw(fn) {
        const wrappedFn = function(...args) {
          const arg0 = args[0];
          if (arg0 === void 0 || arg0 === null) {
            return arg0;
          }
          if (arg0.length > 1) {
            args = arg0;
          }
          return fn(args);
        };
        if ("conversion" in fn) {
          wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
      }
      function wrapRounded(fn) {
        const wrappedFn = function(...args) {
          const arg0 = args[0];
          if (arg0 === void 0 || arg0 === null) {
            return arg0;
          }
          if (arg0.length > 1) {
            args = arg0;
          }
          const result = fn(args);
          if (typeof result === "object") {
            for (let len = result.length, i = 0; i < len; i++) {
              result[i] = Math.round(result[i]);
            }
          }
          return result;
        };
        if ("conversion" in fn) {
          wrappedFn.conversion = fn.conversion;
        }
        return wrappedFn;
      }
      models.forEach((fromModel) => {
        convert2[fromModel] = {};
        Object.defineProperty(convert2[fromModel], "channels", { value: conversions[fromModel].channels });
        Object.defineProperty(convert2[fromModel], "labels", { value: conversions[fromModel].labels });
        const routes = route(fromModel);
        const routeModels = Object.keys(routes);
        routeModels.forEach((toModel) => {
          const fn = routes[toModel];
          convert2[fromModel][toModel] = wrapRounded(fn);
          convert2[fromModel][toModel].raw = wrapRaw(fn);
        });
      });
      module2.exports = convert2;
    }
  });

  // ../../node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js
  var require_ansi_styles = __commonJS({
    "../../node_modules/.pnpm/ansi-styles@4.3.0/node_modules/ansi-styles/index.js"(exports, module2) {
      "use strict";
      var wrapAnsi16 = (fn, offset) => (...args) => {
        const code = fn(...args);
        return `\x1B[${code + offset}m`;
      };
      var wrapAnsi256 = (fn, offset) => (...args) => {
        const code = fn(...args);
        return `\x1B[${38 + offset};5;${code}m`;
      };
      var wrapAnsi16m = (fn, offset) => (...args) => {
        const rgb = fn(...args);
        return `\x1B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
      };
      var ansi2ansi = (n) => n;
      var rgb2rgb = (r, g, b) => [r, g, b];
      var setLazyProperty = (object2, property, get) => {
        Object.defineProperty(object2, property, {
          get: () => {
            const value = get();
            Object.defineProperty(object2, property, {
              value,
              enumerable: true,
              configurable: true
            });
            return value;
          },
          enumerable: true,
          configurable: true
        });
      };
      var colorConvert;
      var makeDynamicStyles = (wrap, targetSpace, identity2, isBackground) => {
        if (colorConvert === void 0) {
          colorConvert = require_color_convert();
        }
        const offset = isBackground ? 10 : 0;
        const styles = {};
        for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
          const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
          if (sourceSpace === targetSpace) {
            styles[name] = wrap(identity2, offset);
          } else if (typeof suite === "object") {
            styles[name] = wrap(suite[targetSpace], offset);
          }
        }
        return styles;
      };
      function assembleStyles() {
        const codes = /* @__PURE__ */ new Map();
        const styles = {
          modifier: {
            reset: [0, 0],
            // 21 isn't widely supported and 22 does the same thing
            bold: [1, 22],
            dim: [2, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            hidden: [8, 28],
            strikethrough: [9, 29]
          },
          color: {
            black: [30, 39],
            red: [31, 39],
            green: [32, 39],
            yellow: [33, 39],
            blue: [34, 39],
            magenta: [35, 39],
            cyan: [36, 39],
            white: [37, 39],
            // Bright color
            blackBright: [90, 39],
            redBright: [91, 39],
            greenBright: [92, 39],
            yellowBright: [93, 39],
            blueBright: [94, 39],
            magentaBright: [95, 39],
            cyanBright: [96, 39],
            whiteBright: [97, 39]
          },
          bgColor: {
            bgBlack: [40, 49],
            bgRed: [41, 49],
            bgGreen: [42, 49],
            bgYellow: [43, 49],
            bgBlue: [44, 49],
            bgMagenta: [45, 49],
            bgCyan: [46, 49],
            bgWhite: [47, 49],
            // Bright color
            bgBlackBright: [100, 49],
            bgRedBright: [101, 49],
            bgGreenBright: [102, 49],
            bgYellowBright: [103, 49],
            bgBlueBright: [104, 49],
            bgMagentaBright: [105, 49],
            bgCyanBright: [106, 49],
            bgWhiteBright: [107, 49]
          }
        };
        styles.color.gray = styles.color.blackBright;
        styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
        styles.color.grey = styles.color.blackBright;
        styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
        for (const [groupName, group] of Object.entries(styles)) {
          for (const [styleName, style] of Object.entries(group)) {
            styles[styleName] = {
              open: `\x1B[${style[0]}m`,
              close: `\x1B[${style[1]}m`
            };
            group[styleName] = styles[styleName];
            codes.set(style[0], style[1]);
          }
          Object.defineProperty(styles, groupName, {
            value: group,
            enumerable: false
          });
        }
        Object.defineProperty(styles, "codes", {
          value: codes,
          enumerable: false
        });
        styles.color.close = "\x1B[39m";
        styles.bgColor.close = "\x1B[49m";
        setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
        setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
        setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
        setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
        setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
        setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
        return styles;
      }
      Object.defineProperty(module2, "exports", {
        enumerable: true,
        get: assembleStyles
      });
    }
  });

  // ../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js
  var require_has_flag = __commonJS({
    "../../node_modules/.pnpm/has-flag@4.0.0/node_modules/has-flag/index.js"(exports, module2) {
      "use strict";
      module2.exports = (flag, argv = process.argv) => {
        const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
        const position = argv.indexOf(prefix + flag);
        const terminatorPosition = argv.indexOf("--");
        return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
      };
    }
  });

  // ../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js
  var require_supports_color = __commonJS({
    "../../node_modules/.pnpm/supports-color@7.2.0/node_modules/supports-color/index.js"(exports, module2) {
      "use strict";
      var os = __require2("os");
      var tty = __require2("tty");
      var hasFlag = require_has_flag();
      var { env } = process;
      var forceColor;
      if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
        forceColor = 0;
      } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
        forceColor = 1;
      }
      if ("FORCE_COLOR" in env) {
        if (env.FORCE_COLOR === "true") {
          forceColor = 1;
        } else if (env.FORCE_COLOR === "false") {
          forceColor = 0;
        } else {
          forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
        }
      }
      function translateLevel(level) {
        if (level === 0) {
          return false;
        }
        return {
          level,
          hasBasic: true,
          has256: level >= 2,
          has16m: level >= 3
        };
      }
      function supportsColor(haveStream, streamIsTTY) {
        if (forceColor === 0) {
          return 0;
        }
        if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
          return 3;
        }
        if (hasFlag("color=256")) {
          return 2;
        }
        if (haveStream && !streamIsTTY && forceColor === void 0) {
          return 0;
        }
        const min = forceColor || 0;
        if (env.TERM === "dumb") {
          return min;
        }
        if (process.platform === "win32") {
          const osRelease = os.release().split(".");
          if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
            return Number(osRelease[2]) >= 14931 ? 3 : 2;
          }
          return 1;
        }
        if ("CI" in env) {
          if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
            return 1;
          }
          return min;
        }
        if ("TEAMCITY_VERSION" in env) {
          return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
        }
        if (env.COLORTERM === "truecolor") {
          return 3;
        }
        if ("TERM_PROGRAM" in env) {
          const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
          switch (env.TERM_PROGRAM) {
            case "iTerm.app":
              return version2 >= 3 ? 3 : 2;
            case "Apple_Terminal":
              return 2;
          }
        }
        if (/-256(color)?$/i.test(env.TERM)) {
          return 2;
        }
        if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
          return 1;
        }
        if ("COLORTERM" in env) {
          return 1;
        }
        return min;
      }
      function getSupportLevel(stream2) {
        const level = supportsColor(stream2, stream2 && stream2.isTTY);
        return translateLevel(level);
      }
      module2.exports = {
        supportsColor: getSupportLevel,
        stdout: translateLevel(supportsColor(true, tty.isatty(1))),
        stderr: translateLevel(supportsColor(true, tty.isatty(2)))
      };
    }
  });

  // ../../node_modules/.pnpm/chalk@4.0.0/node_modules/chalk/source/util.js
  var require_util2 = __commonJS({
    "../../node_modules/.pnpm/chalk@4.0.0/node_modules/chalk/source/util.js"(exports, module2) {
      "use strict";
      var stringReplaceAll = (string2, substring, replacer) => {
        let index = string2.indexOf(substring);
        if (index === -1) {
          return string2;
        }
        const substringLength = substring.length;
        let endIndex = 0;
        let returnValue = "";
        do {
          returnValue += string2.substr(endIndex, index - endIndex) + substring + replacer;
          endIndex = index + substringLength;
          index = string2.indexOf(substring, endIndex);
        } while (index !== -1);
        returnValue += string2.substr(endIndex);
        return returnValue;
      };
      var stringEncaseCRLFWithFirstIndex = (string2, prefix, postfix, index) => {
        let endIndex = 0;
        let returnValue = "";
        do {
          const gotCR = string2[index - 1] === "\r";
          returnValue += string2.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
          endIndex = index + 1;
          index = string2.indexOf("\n", endIndex);
        } while (index !== -1);
        returnValue += string2.substr(endIndex);
        return returnValue;
      };
      module2.exports = {
        stringReplaceAll,
        stringEncaseCRLFWithFirstIndex
      };
    }
  });

  // ../../node_modules/.pnpm/chalk@4.0.0/node_modules/chalk/source/templates.js
  var require_templates = __commonJS({
    "../../node_modules/.pnpm/chalk@4.0.0/node_modules/chalk/source/templates.js"(exports, module2) {
      "use strict";
      var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
      var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
      var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
      var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
      var ESCAPES = /* @__PURE__ */ new Map([
        ["n", "\n"],
        ["r", "\r"],
        ["t", "	"],
        ["b", "\b"],
        ["f", "\f"],
        ["v", "\v"],
        ["0", "\0"],
        ["\\", "\\"],
        ["e", "\x1B"],
        ["a", "\x07"]
      ]);
      function unescape2(c) {
        const u = c[0] === "u";
        const bracket = c[1] === "{";
        if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
          return String.fromCharCode(parseInt(c.slice(1), 16));
        }
        if (u && bracket) {
          return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
        }
        return ESCAPES.get(c) || c;
      }
      function parseArguments(name, arguments_) {
        const results = [];
        const chunks = arguments_.trim().split(/\s*,\s*/g);
        let matches;
        for (const chunk of chunks) {
          const number4 = Number(chunk);
          if (!Number.isNaN(number4)) {
            results.push(number4);
          } else if (matches = chunk.match(STRING_REGEX)) {
            results.push(matches[2].replace(ESCAPE_REGEX, (m, escape2, character) => escape2 ? unescape2(escape2) : character));
          } else {
            throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
          }
        }
        return results;
      }
      function parseStyle(style) {
        STYLE_REGEX.lastIndex = 0;
        const results = [];
        let matches;
        while ((matches = STYLE_REGEX.exec(style)) !== null) {
          const name = matches[1];
          if (matches[2]) {
            const args = parseArguments(name, matches[2]);
            results.push([name].concat(args));
          } else {
            results.push([name]);
          }
        }
        return results;
      }
      function buildStyle(chalk3, styles) {
        const enabled = {};
        for (const layer of styles) {
          for (const style of layer.styles) {
            enabled[style[0]] = layer.inverse ? null : style.slice(1);
          }
        }
        let current = chalk3;
        for (const [styleName, styles2] of Object.entries(enabled)) {
          if (!Array.isArray(styles2)) {
            continue;
          }
          if (!(styleName in current)) {
            throw new Error(`Unknown Chalk style: ${styleName}`);
          }
          current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
        }
        return current;
      }
      module2.exports = (chalk3, temporary) => {
        const styles = [];
        const chunks = [];
        let chunk = [];
        temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
          if (escapeCharacter) {
            chunk.push(unescape2(escapeCharacter));
          } else if (style) {
            const string2 = chunk.join("");
            chunk = [];
            chunks.push(styles.length === 0 ? string2 : buildStyle(chalk3, styles)(string2));
            styles.push({ inverse, styles: parseStyle(style) });
          } else if (close) {
            if (styles.length === 0) {
              throw new Error("Found extraneous } in Chalk template literal");
            }
            chunks.push(buildStyle(chalk3, styles)(chunk.join("")));
            chunk = [];
            styles.pop();
          } else {
            chunk.push(character);
          }
        });
        chunks.push(chunk.join(""));
        if (styles.length > 0) {
          const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
          throw new Error(errMessage);
        }
        return chunks.join("");
      };
    }
  });

  // ../../node_modules/.pnpm/chalk@4.0.0/node_modules/chalk/source/index.js
  var require_source = __commonJS({
    "../../node_modules/.pnpm/chalk@4.0.0/node_modules/chalk/source/index.js"(exports, module2) {
      "use strict";
      var ansiStyles = require_ansi_styles();
      var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color();
      var {
        stringReplaceAll,
        stringEncaseCRLFWithFirstIndex
      } = require_util2();
      var levelMapping = [
        "ansi",
        "ansi",
        "ansi256",
        "ansi16m"
      ];
      var styles = /* @__PURE__ */ Object.create(null);
      var applyOptions = (object2, options = {}) => {
        if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
          throw new Error("The `level` option should be an integer from 0 to 3");
        }
        const colorLevel = stdoutColor ? stdoutColor.level : 0;
        object2.level = options.level === void 0 ? colorLevel : options.level;
      };
      var ChalkClass = class {
        constructor(options) {
          return chalkFactory(options);
        }
      };
      var chalkFactory = (options) => {
        const chalk4 = {};
        applyOptions(chalk4, options);
        chalk4.template = (...arguments_) => chalkTag(chalk4.template, ...arguments_);
        Object.setPrototypeOf(chalk4, Chalk.prototype);
        Object.setPrototypeOf(chalk4.template, chalk4);
        chalk4.template.constructor = () => {
          throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
        };
        chalk4.template.Instance = ChalkClass;
        return chalk4.template;
      };
      function Chalk(options) {
        return chalkFactory(options);
      }
      for (const [styleName, style] of Object.entries(ansiStyles)) {
        styles[styleName] = {
          get() {
            const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
            Object.defineProperty(this, styleName, { value: builder });
            return builder;
          }
        };
      }
      styles.visible = {
        get() {
          const builder = createBuilder(this, this._styler, true);
          Object.defineProperty(this, "visible", { value: builder });
          return builder;
        }
      };
      var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
      for (const model of usedModels) {
        styles[model] = {
          get() {
            const { level } = this;
            return function(...arguments_) {
              const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
              return createBuilder(this, styler, this._isEmpty);
            };
          }
        };
      }
      for (const model of usedModels) {
        const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
        styles[bgModel] = {
          get() {
            const { level } = this;
            return function(...arguments_) {
              const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
              return createBuilder(this, styler, this._isEmpty);
            };
          }
        };
      }
      var proto = Object.defineProperties(() => {
      }, {
        ...styles,
        level: {
          enumerable: true,
          get() {
            return this._generator.level;
          },
          set(level) {
            this._generator.level = level;
          }
        }
      });
      var createStyler = (open, close, parent) => {
        let openAll;
        let closeAll;
        if (parent === void 0) {
          openAll = open;
          closeAll = close;
        } else {
          openAll = parent.openAll + open;
          closeAll = close + parent.closeAll;
        }
        return {
          open,
          close,
          openAll,
          closeAll,
          parent
        };
      };
      var createBuilder = (self2, _styler, _isEmpty) => {
        const builder = (...arguments_) => {
          return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
        };
        Object.setPrototypeOf(builder, proto);
        builder._generator = self2;
        builder._styler = _styler;
        builder._isEmpty = _isEmpty;
        return builder;
      };
      var applyStyle = (self2, string2) => {
        if (self2.level <= 0 || !string2) {
          return self2._isEmpty ? "" : string2;
        }
        let styler = self2._styler;
        if (styler === void 0) {
          return string2;
        }
        const { openAll, closeAll } = styler;
        if (string2.indexOf("\x1B") !== -1) {
          while (styler !== void 0) {
            string2 = stringReplaceAll(string2, styler.close, styler.open);
            styler = styler.parent;
          }
        }
        const lfIndex = string2.indexOf("\n");
        if (lfIndex !== -1) {
          string2 = stringEncaseCRLFWithFirstIndex(string2, closeAll, openAll, lfIndex);
        }
        return openAll + string2 + closeAll;
      };
      var template;
      var chalkTag = (chalk4, ...strings) => {
        const [firstString] = strings;
        if (!Array.isArray(firstString)) {
          return strings.join(" ");
        }
        const arguments_ = strings.slice(1);
        const parts = [firstString.raw[0]];
        for (let i = 1; i < firstString.length; i++) {
          parts.push(
            String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"),
            String(firstString.raw[i])
          );
        }
        if (template === void 0) {
          template = require_templates();
        }
        return template(chalk4, parts.join(""));
      };
      Object.defineProperties(Chalk.prototype, styles);
      var chalk3 = Chalk();
      chalk3.supportsColor = stdoutColor;
      chalk3.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
      chalk3.stderr.supportsColor = stderrColor;
      module2.exports = chalk3;
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/styles.js
  var require_styles = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/styles.js"(exports, module2) {
      var styles = {};
      module2["exports"] = styles;
      var codes = {
        reset: [0, 0],
        bold: [1, 22],
        dim: [2, 22],
        italic: [3, 23],
        underline: [4, 24],
        inverse: [7, 27],
        hidden: [8, 28],
        strikethrough: [9, 29],
        black: [30, 39],
        red: [31, 39],
        green: [32, 39],
        yellow: [33, 39],
        blue: [34, 39],
        magenta: [35, 39],
        cyan: [36, 39],
        white: [37, 39],
        gray: [90, 39],
        grey: [90, 39],
        bgBlack: [40, 49],
        bgRed: [41, 49],
        bgGreen: [42, 49],
        bgYellow: [43, 49],
        bgBlue: [44, 49],
        bgMagenta: [45, 49],
        bgCyan: [46, 49],
        bgWhite: [47, 49],
        // legacy styles for colors pre v1.0.0
        blackBG: [40, 49],
        redBG: [41, 49],
        greenBG: [42, 49],
        yellowBG: [43, 49],
        blueBG: [44, 49],
        magentaBG: [45, 49],
        cyanBG: [46, 49],
        whiteBG: [47, 49]
      };
      Object.keys(codes).forEach(function(key) {
        var val = codes[key];
        var style = styles[key] = [];
        style.open = "\x1B[" + val[0] + "m";
        style.close = "\x1B[" + val[1] + "m";
      });
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/system/supports-colors.js
  var require_supports_colors = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/system/supports-colors.js"(exports, module2) {
      var argv = process.argv;
      module2.exports = function() {
        if (argv.indexOf("--no-color") !== -1 || argv.indexOf("--color=false") !== -1) {
          return false;
        }
        if (argv.indexOf("--color") !== -1 || argv.indexOf("--color=true") !== -1 || argv.indexOf("--color=always") !== -1) {
          return true;
        }
        if (process.stdout && !process.stdout.isTTY) {
          return false;
        }
        if (process.platform === "win32") {
          return true;
        }
        if ("COLORTERM" in process.env) {
          return true;
        }
        if (process.env.TERM === "dumb") {
          return false;
        }
        if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
          return true;
        }
        return false;
      }();
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/custom/trap.js
  var require_trap = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/custom/trap.js"(exports, module2) {
      module2["exports"] = function runTheTrap(text, options) {
        var result = "";
        text = text || "Run the trap, drop the bass";
        text = text.split("");
        var trap = {
          a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
          b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
          c: ["\xA9", "\u023B", "\u03FE"],
          d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
          e: ["\xCB", "\u0115", "\u018E", "\u0258", "\u03A3", "\u03BE", "\u04BC", "\u0A6C"],
          f: ["\u04FA"],
          g: ["\u0262"],
          h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
          i: ["\u0F0F"],
          j: ["\u0134"],
          k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
          l: ["\u0139"],
          m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
          n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
          o: ["\xD8", "\xF5", "\xF8", "\u01FE", "\u0298", "\u047A", "\u05DD", "\u06DD", "\u0E4F"],
          p: ["\u01F7", "\u048E"],
          q: ["\u09CD"],
          r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
          s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
          t: ["\u0141", "\u0166", "\u0373"],
          u: ["\u01B1", "\u054D"],
          v: ["\u05D8"],
          w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
          x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
          y: ["\xA5", "\u04B0", "\u04CB"],
          z: ["\u01B5", "\u0240"]
        };
        text.forEach(function(c) {
          c = c.toLowerCase();
          var chars = trap[c] || [" "];
          var rand = Math.floor(Math.random() * chars.length);
          if (typeof trap[c] !== "undefined") {
            result += trap[c][rand];
          } else {
            result += c;
          }
        });
        return result;
      };
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/custom/zalgo.js
  var require_zalgo = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/custom/zalgo.js"(exports, module2) {
      module2["exports"] = function zalgo(text, options) {
        text = text || "   he is here   ";
        var soul = {
          "up": [
            "\u030D",
            "\u030E",
            "\u0304",
            "\u0305",
            "\u033F",
            "\u0311",
            "\u0306",
            "\u0310",
            "\u0352",
            "\u0357",
            "\u0351",
            "\u0307",
            "\u0308",
            "\u030A",
            "\u0342",
            "\u0313",
            "\u0308",
            "\u034A",
            "\u034B",
            "\u034C",
            "\u0303",
            "\u0302",
            "\u030C",
            "\u0350",
            "\u0300",
            "\u0301",
            "\u030B",
            "\u030F",
            "\u0312",
            "\u0313",
            "\u0314",
            "\u033D",
            "\u0309",
            "\u0363",
            "\u0364",
            "\u0365",
            "\u0366",
            "\u0367",
            "\u0368",
            "\u0369",
            "\u036A",
            "\u036B",
            "\u036C",
            "\u036D",
            "\u036E",
            "\u036F",
            "\u033E",
            "\u035B",
            "\u0346",
            "\u031A"
          ],
          "down": [
            "\u0316",
            "\u0317",
            "\u0318",
            "\u0319",
            "\u031C",
            "\u031D",
            "\u031E",
            "\u031F",
            "\u0320",
            "\u0324",
            "\u0325",
            "\u0326",
            "\u0329",
            "\u032A",
            "\u032B",
            "\u032C",
            "\u032D",
            "\u032E",
            "\u032F",
            "\u0330",
            "\u0331",
            "\u0332",
            "\u0333",
            "\u0339",
            "\u033A",
            "\u033B",
            "\u033C",
            "\u0345",
            "\u0347",
            "\u0348",
            "\u0349",
            "\u034D",
            "\u034E",
            "\u0353",
            "\u0354",
            "\u0355",
            "\u0356",
            "\u0359",
            "\u035A",
            "\u0323"
          ],
          "mid": [
            "\u0315",
            "\u031B",
            "\u0300",
            "\u0301",
            "\u0358",
            "\u0321",
            "\u0322",
            "\u0327",
            "\u0328",
            "\u0334",
            "\u0335",
            "\u0336",
            "\u035C",
            "\u035D",
            "\u035E",
            "\u035F",
            "\u0360",
            "\u0362",
            "\u0338",
            "\u0337",
            "\u0361",
            " \u0489"
          ]
        }, all = [].concat(soul.up, soul.down, soul.mid), zalgo2 = {};
        function randomNumber(range) {
          var r = Math.floor(Math.random() * range);
          return r;
        }
        function is_char(character) {
          var bool3 = false;
          all.filter(function(i) {
            bool3 = i === character;
          });
          return bool3;
        }
        function heComes(text2, options2) {
          var result = "", counts, l;
          options2 = options2 || {};
          options2["up"] = options2["up"] || true;
          options2["mid"] = options2["mid"] || true;
          options2["down"] = options2["down"] || true;
          options2["size"] = options2["size"] || "maxi";
          text2 = text2.split("");
          for (l in text2) {
            if (is_char(l)) {
              continue;
            }
            result = result + text2[l];
            counts = { "up": 0, "down": 0, "mid": 0 };
            switch (options2.size) {
              case "mini":
                counts.up = randomNumber(8);
                counts.min = randomNumber(2);
                counts.down = randomNumber(8);
                break;
              case "maxi":
                counts.up = randomNumber(16) + 3;
                counts.min = randomNumber(4) + 1;
                counts.down = randomNumber(64) + 3;
                break;
              default:
                counts.up = randomNumber(8) + 1;
                counts.mid = randomNumber(6) / 2;
                counts.down = randomNumber(8) + 1;
                break;
            }
            var arr = ["up", "mid", "down"];
            for (var d in arr) {
              var index = arr[d];
              for (var i = 0; i <= counts[index]; i++) {
                if (options2[index]) {
                  result = result + soul[index][randomNumber(soul[index].length)];
                }
              }
            }
          }
          return result;
        }
        return heComes(text);
      };
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/maps/america.js
  var require_america = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/maps/america.js"(exports, module2) {
      var colors = require_colors();
      module2["exports"] = function() {
        return function(letter, i, exploded) {
          if (letter === " ")
            return letter;
          switch (i % 3) {
            case 0:
              return colors.red(letter);
            case 1:
              return colors.white(letter);
            case 2:
              return colors.blue(letter);
          }
        };
      }();
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/maps/zebra.js
  var require_zebra = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/maps/zebra.js"(exports, module2) {
      var colors = require_colors();
      module2["exports"] = function(letter, i, exploded) {
        return i % 2 === 0 ? letter : colors.inverse(letter);
      };
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/maps/rainbow.js
  var require_rainbow = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/maps/rainbow.js"(exports, module2) {
      var colors = require_colors();
      module2["exports"] = function() {
        var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
        return function(letter, i, exploded) {
          if (letter === " ") {
            return letter;
          } else {
            return colors[rainbowColors[i++ % rainbowColors.length]](letter);
          }
        };
      }();
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/maps/random.js
  var require_random = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/maps/random.js"(exports, module2) {
      var colors = require_colors();
      module2["exports"] = function() {
        var available = ["underline", "inverse", "grey", "yellow", "red", "green", "blue", "white", "cyan", "magenta"];
        return function(letter, i, exploded) {
          return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 1))]](letter);
        };
      }();
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/colors.js
  var require_colors = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/lib/colors.js"(exports, module2) {
      var colors = {};
      module2["exports"] = colors;
      colors.themes = {};
      var ansiStyles = colors.styles = require_styles();
      var defineProps = Object.defineProperties;
      colors.supportsColor = require_supports_colors();
      if (typeof colors.enabled === "undefined") {
        colors.enabled = colors.supportsColor;
      }
      colors.stripColors = colors.strip = function(str) {
        return ("" + str).replace(/\x1B\[\d+m/g, "");
      };
      var stylize = colors.stylize = function stylize2(str, style) {
        return ansiStyles[style].open + str + ansiStyles[style].close;
      };
      var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
      var escapeStringRegexp = function(str) {
        if (typeof str !== "string") {
          throw new TypeError("Expected a string");
        }
        return str.replace(matchOperatorsRe, "\\$&");
      };
      function build3(_styles) {
        var builder = function builder2() {
          return applyStyle.apply(builder2, arguments);
        };
        builder._styles = _styles;
        builder.__proto__ = proto;
        return builder;
      }
      var styles = function() {
        var ret3 = {};
        ansiStyles.grey = ansiStyles.gray;
        Object.keys(ansiStyles).forEach(function(key) {
          ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
          ret3[key] = {
            get: function() {
              return build3(this._styles.concat(key));
            }
          };
        });
        return ret3;
      }();
      var proto = defineProps(function colors2() {
      }, styles);
      function applyStyle() {
        var args = arguments;
        var argsLen = args.length;
        var str = argsLen !== 0 && String(arguments[0]);
        if (argsLen > 1) {
          for (var a = 1; a < argsLen; a++) {
            str += " " + args[a];
          }
        }
        if (!colors.enabled || !str) {
          return str;
        }
        var nestedStyles = this._styles;
        var i = nestedStyles.length;
        while (i--) {
          var code = ansiStyles[nestedStyles[i]];
          str = code.open + str.replace(code.closeRe, code.open) + code.close;
        }
        return str;
      }
      function applyTheme(theme) {
        for (var style in theme) {
          (function(style2) {
            colors[style2] = function(str) {
              return colors[theme[style2]](str);
            };
          })(style);
        }
      }
      colors.setTheme = function(theme) {
        if (typeof theme === "string") {
          try {
            colors.themes[theme] = __require2(theme);
            applyTheme(colors.themes[theme]);
            return colors.themes[theme];
          } catch (err) {
            console.log(err);
            return err;
          }
        } else {
          applyTheme(theme);
        }
      };
      function init2() {
        var ret3 = {};
        Object.keys(styles).forEach(function(name) {
          ret3[name] = {
            get: function() {
              return build3([name]);
            }
          };
        });
        return ret3;
      }
      var sequencer = function sequencer2(map3, str) {
        var exploded = str.split(""), i = 0;
        exploded = exploded.map(map3);
        return exploded.join("");
      };
      colors.trap = require_trap();
      colors.zalgo = require_zalgo();
      colors.maps = {};
      colors.maps.america = require_america();
      colors.maps.zebra = require_zebra();
      colors.maps.rainbow = require_rainbow();
      colors.maps.random = require_random();
      for (map2 in colors.maps) {
        (function(map3) {
          colors[map3] = function(str) {
            return sequencer(colors.maps[map3], str);
          };
        })(map2);
      }
      var map2;
      defineProps(colors, init2());
    }
  });

  // ../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/safe.js
  var require_safe = __commonJS({
    "../../node_modules/.pnpm/colors@1.0.3/node_modules/colors/safe.js"(exports, module2) {
      var colors = require_colors();
      module2["exports"] = colors;
    }
  });

  // ../../node_modules/.pnpm/cli-table@0.3.11/node_modules/cli-table/lib/utils.js
  var require_utils2 = __commonJS({
    "../../node_modules/.pnpm/cli-table@0.3.11/node_modules/cli-table/lib/utils.js"(exports) {
      exports.repeat = function(str, times) {
        return Array(times + 1).join(str);
      };
      exports.pad = function(str, len, pad3, dir) {
        if (len + 1 >= str.length)
          switch (dir) {
            case "left":
              str = Array(len + 1 - str.length).join(pad3) + str;
              break;
            case "both":
              var right = Math.ceil((padlen = len - str.length) / 2);
              var left = padlen - right;
              str = Array(left + 1).join(pad3) + str + Array(right + 1).join(pad3);
              break;
            default:
              str = str + Array(len + 1 - str.length).join(pad3);
          }
        ;
        return str;
      };
      exports.truncate = function(str, length, chr) {
        chr = chr || "\u2026";
        return str.length >= length ? str.substr(0, length - chr.length) + chr : str;
      };
      function options(defaults2, opts) {
        for (var p in opts) {
          if (p === "__proto__" || p === "constructor" || p === "prototype") {
            continue;
          }
          if (opts[p] && opts[p].constructor && opts[p].constructor === Object) {
            defaults2[p] = defaults2[p] || {};
            options(defaults2[p], opts[p]);
          } else {
            defaults2[p] = opts[p];
          }
        }
        return defaults2;
      }
      exports.options = options;
      exports.strlen = function(str) {
        var code = /\u001b\[(?:\d*;){0,5}\d*m/g;
        var stripped = ("" + str).replace(code, "");
        var split4 = stripped.split("\n");
        return split4.reduce(function(memo, s) {
          return s.length > memo ? s.length : memo;
        }, 0);
      };
    }
  });

  // ../../node_modules/.pnpm/cli-table@0.3.11/node_modules/cli-table/lib/index.js
  var require_lib2 = __commonJS({
    "../../node_modules/.pnpm/cli-table@0.3.11/node_modules/cli-table/lib/index.js"(exports, module2) {
      var colors = require_safe();
      var utils = require_utils2();
      var repeat = utils.repeat;
      var truncate = utils.truncate;
      var pad3 = utils.pad;
      function Table(options) {
        this.options = utils.options({
          chars: {
            "top": "\u2500",
            "top-mid": "\u252C",
            "top-left": "\u250C",
            "top-right": "\u2510",
            "bottom": "\u2500",
            "bottom-mid": "\u2534",
            "bottom-left": "\u2514",
            "bottom-right": "\u2518",
            "left": "\u2502",
            "left-mid": "\u251C",
            "mid": "\u2500",
            "mid-mid": "\u253C",
            "right": "\u2502",
            "right-mid": "\u2524",
            "middle": "\u2502"
          },
          truncate: "\u2026",
          colWidths: [],
          colAligns: [],
          style: {
            "padding-left": 1,
            "padding-right": 1,
            head: ["red"],
            border: ["grey"],
            compact: false
          },
          head: []
        }, options);
        if (options && options.rows) {
          for (var i = 0; i < options.rows.length; i++) {
            this.push(options.rows[i]);
          }
        }
      }
      Table.prototype.__proto__ = Array.prototype;
      Table.prototype.__defineGetter__("width", function() {
        var str = this.toString().split("\n");
        if (str.length)
          return str[0].length;
        return 0;
      });
      Table.prototype.render;
      Table.prototype.toString = function() {
        var ret3 = "", options = this.options, style = options.style, head = options.head, chars = options.chars, truncater = options.truncate, colWidths = options.colWidths || new Array(this.head.length), totalWidth = 0;
        if (!head.length && !this.length)
          return "";
        if (!colWidths.length) {
          var all_rows = this.slice(0);
          if (head.length) {
            all_rows = all_rows.concat([head]);
          }
          ;
          all_rows.forEach(function(cells) {
            if (typeof cells === "object" && cells.length) {
              extractColumnWidths(cells);
            } else {
              var header_cell = Object.keys(cells)[0], value_cell = cells[header_cell];
              colWidths[0] = Math.max(colWidths[0] || 0, get_width(header_cell) || 0);
              if (typeof value_cell === "object" && value_cell.length) {
                extractColumnWidths(value_cell, 1);
              } else {
                colWidths[1] = Math.max(colWidths[1] || 0, get_width(value_cell) || 0);
              }
            }
          });
        }
        ;
        totalWidth = (colWidths.length == 1 ? colWidths[0] : colWidths.reduce(
          function(a, b) {
            return a + b;
          }
        )) + colWidths.length + 1;
        function extractColumnWidths(arr, offset) {
          var offset = offset || 0;
          arr.forEach(function(cell, i) {
            colWidths[i + offset] = Math.max(colWidths[i + offset] || 0, get_width(cell) || 0);
          });
        }
        ;
        function get_width(obj) {
          return typeof obj == "object" && obj.width != void 0 ? obj.width : (typeof obj == "object" ? utils.strlen(obj.text) : utils.strlen(obj)) + (style["padding-left"] || 0) + (style["padding-right"] || 0);
        }
        function line(line2, left, right, intersection) {
          var width = 0, line2 = left + repeat(line2, totalWidth - 2) + right;
          colWidths.forEach(function(w, i) {
            if (i == colWidths.length - 1)
              return;
            width += w + 1;
            line2 = line2.substr(0, width) + intersection + line2.substr(width + 1);
          });
          return applyStyles(options.style.border, line2);
        }
        ;
        function lineTop() {
          var l2 = line(
            chars.top,
            chars["top-left"] || chars.top,
            chars["top-right"] || chars.top,
            chars["top-mid"]
          );
          if (l2)
            ret3 += l2 + "\n";
        }
        ;
        function generateRow(items, style2) {
          var cells = [], max_height = 0;
          if (!Array.isArray(items) && typeof items === "object") {
            var key = Object.keys(items)[0], value = items[key], first_cell_head = true;
            if (Array.isArray(value)) {
              items = value;
              items.unshift(key);
            } else {
              items = [key, value];
            }
          }
          items.forEach(function(item, i) {
            var contents = item.toString().split("\n").reduce(function(memo, l2) {
              memo.push(string2(l2, i));
              return memo;
            }, []);
            var height = contents.length;
            if (height > max_height) {
              max_height = height;
            }
            ;
            cells.push({ contents, height });
          });
          var lines = new Array(max_height);
          cells.forEach(function(cell, i) {
            cell.contents.forEach(function(line2, j2) {
              if (!lines[j2]) {
                lines[j2] = [];
              }
              ;
              if (style2 || first_cell_head && i === 0 && options.style.head) {
                line2 = applyStyles(options.style.head, line2);
              }
              lines[j2].push(line2);
            });
            for (var j = cell.height, l2 = max_height; j < l2; j++) {
              if (!lines[j]) {
                lines[j] = [];
              }
              ;
              lines[j].push(string2("", i));
            }
          });
          var ret4 = "";
          lines.forEach(function(line2, index) {
            if (ret4.length > 0) {
              ret4 += "\n" + applyStyles(options.style.border, chars.left);
            }
            ret4 += line2.join(applyStyles(options.style.border, chars.middle)) + applyStyles(options.style.border, chars.right);
          });
          return applyStyles(options.style.border, chars.left) + ret4;
        }
        ;
        function applyStyles(styles, subject) {
          if (!subject)
            return "";
          styles.forEach(function(style2) {
            subject = colors[style2](subject);
          });
          return subject;
        }
        ;
        function string2(str, index) {
          var str = String(typeof str == "object" && str.text ? str.text : str), length = utils.strlen(str), width = colWidths[index] - (style["padding-left"] || 0) - (style["padding-right"] || 0), align = options.colAligns[index] || "left";
          return repeat(" ", style["padding-left"] || 0) + (length == width ? str : length < width ? pad3(str, width + (str.length - length), " ", align == "left" ? "right" : align == "middle" ? "both" : "left") : truncater ? truncate(str, width, truncater) : str) + repeat(" ", style["padding-right"] || 0);
        }
        ;
        if (head.length) {
          lineTop();
          ret3 += generateRow(head, style.head) + "\n";
        }
        if (this.length)
          this.forEach(function(cells, i) {
            if (!head.length && i == 0)
              lineTop();
            else {
              if (!style.compact || i < !!head.length ? 1 : cells.length == 0) {
                var l2 = line(
                  chars.mid,
                  chars["left-mid"],
                  chars["right-mid"],
                  chars["mid-mid"]
                );
                if (l2)
                  ret3 += l2 + "\n";
              }
            }
            if (cells.hasOwnProperty("length") && !cells.length) {
              return;
            } else {
              ret3 += generateRow(cells) + "\n";
            }
            ;
          });
        var l = line(
          chars.bottom,
          chars["bottom-left"] || chars.bottom,
          chars["bottom-right"] || chars.bottom,
          chars["bottom-mid"]
        );
        if (l)
          ret3 += l;
        else
          ret3 = ret3.slice(0, -1);
        return ret3;
      };
      module2.exports = Table;
      module2.exports.version = "0.0.1";
    }
  });

  // ../../node_modules/.pnpm/lodash.camelcase@4.3.0/node_modules/lodash.camelcase/index.js
  var require_lodash = __commonJS({
    "../../node_modules/.pnpm/lodash.camelcase@4.3.0/node_modules/lodash.camelcase/index.js"(exports, module2) {
      var INFINITY = 1 / 0;
      var symbolTag = "[object Symbol]";
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
      var rsComboSymbolsRange = "\\u20d0-\\u20f0";
      var rsDingbatRange = "\\u2700-\\u27bf";
      var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
      var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
      var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
      var rsPunctuationRange = "\\u2000-\\u206f";
      var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
      var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]";
      var rsAstral = "[" + rsAstralRange + "]";
      var rsBreak = "[" + rsBreakRange + "]";
      var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
      var rsDigits = "\\d+";
      var rsDingbat = "[" + rsDingbatRange + "]";
      var rsLower = "[" + rsLowerRange + "]";
      var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
      var rsFitz = "\\ud83c[\\udffb-\\udfff]";
      var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
      var rsNonAstral = "[^" + rsAstralRange + "]";
      var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
      var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
      var rsUpper = "[" + rsUpperRange + "]";
      var rsZWJ = "\\u200d";
      var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
      var rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
      var rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
      var rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
      var reOptMod = rsModifier + "?";
      var rsOptVar = "[" + rsVarRange + "]?";
      var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
      var rsSeq = rsOptVar + reOptMod + rsOptJoin;
      var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
      var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
        rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
        rsUpper + "+" + rsOptUpperContr,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        // Latin Extended-A block.
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "ss"
      };
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      function arrayReduce(array2, iteratee, accumulator, initAccum) {
        var index = -1, length = array2 ? array2.length : 0;
        if (initAccum && length) {
          accumulator = array2[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array2[index], index, array2);
        }
        return accumulator;
      }
      function asciiToArray(string2) {
        return string2.split("");
      }
      function asciiWords(string2) {
        return string2.match(reAsciiWord) || [];
      }
      function basePropertyOf(object2) {
        return function(key) {
          return object2 == null ? void 0 : object2[key];
        };
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      function hasUnicode(string2) {
        return reHasUnicode.test(string2);
      }
      function hasUnicodeWord(string2) {
        return reHasUnicodeWord.test(string2);
      }
      function stringToArray(string2) {
        return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
      }
      function unicodeToArray(string2) {
        return string2.match(reUnicode) || [];
      }
      function unicodeWords(string2) {
        return string2.match(reUnicodeWord) || [];
      }
      var objectProto = Object.prototype;
      var objectToString = objectProto.toString;
      var Symbol2 = root.Symbol;
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolToString2 = symbolProto ? symbolProto.toString : void 0;
      function baseSlice(array2, start, end) {
        var index = -1, length = array2.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result = Array(length);
        while (++index < length) {
          result[index] = array2[index + start];
        }
        return result;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isSymbol(value)) {
          return symbolToString2 ? symbolToString2.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      function castSlice(array2, start, end) {
        var length = array2.length;
        end = end === void 0 ? length : end;
        return !start && end >= length ? array2 : baseSlice(array2, start, end);
      }
      function createCaseFirst(methodName) {
        return function(string2) {
          string2 = toString3(string2);
          var strSymbols = hasUnicode(string2) ? stringToArray(string2) : void 0;
          var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string2) {
          return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
        };
      }
      function isObjectLike2(value) {
        return !!value && typeof value == "object";
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike2(value) && objectToString.call(value) == symbolTag;
      }
      function toString3(value) {
        return value == null ? "" : baseToString(value);
      }
      var camelCase3 = createCompounder(function(result, word, index) {
        word = word.toLowerCase();
        return result + (index ? capitalize(word) : word);
      });
      function capitalize(string2) {
        return upperFirst3(toString3(string2).toLowerCase());
      }
      function deburr(string2) {
        string2 = toString3(string2);
        return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      var upperFirst3 = createCaseFirst("toUpperCase");
      function words(string2, pattern, guard) {
        string2 = toString3(string2);
        pattern = guard ? void 0 : pattern;
        if (pattern === void 0) {
          return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
        }
        return string2.match(pattern) || [];
      }
      module2.exports = camelCase3;
    }
  });

  // ../../node_modules/.pnpm/toml@3.0.0/node_modules/toml/lib/parser.js
  var require_parser2 = __commonJS({
    "../../node_modules/.pnpm/toml@3.0.0/node_modules/toml/lib/parser.js"(exports, module2) {
      module2.exports = function() {
        function peg$subclass(child, parent) {
          function ctor() {
            this.constructor = child;
          }
          ctor.prototype = parent.prototype;
          child.prototype = new ctor();
        }
        function SyntaxError2(message, expected, found, offset, line, column) {
          this.message = message;
          this.expected = expected;
          this.found = found;
          this.offset = offset;
          this.line = line;
          this.column = column;
          this.name = "SyntaxError";
        }
        peg$subclass(SyntaxError2, Error);
        function parse3(input) {
          var options = arguments.length > 1 ? arguments[1] : {}, peg$FAILED = {}, peg$startRuleFunctions = { start: peg$parsestart }, peg$startRuleFunction = peg$parsestart, peg$c0 = [], peg$c1 = function() {
            return nodes;
          }, peg$c2 = peg$FAILED, peg$c3 = "#", peg$c4 = { type: "literal", value: "#", description: '"#"' }, peg$c5 = void 0, peg$c6 = { type: "any", description: "any character" }, peg$c7 = "[", peg$c8 = { type: "literal", value: "[", description: '"["' }, peg$c9 = "]", peg$c10 = { type: "literal", value: "]", description: '"]"' }, peg$c11 = function(name) {
            addNode(node("ObjectPath", name, line, column));
          }, peg$c12 = function(name) {
            addNode(node("ArrayPath", name, line, column));
          }, peg$c13 = function(parts, name) {
            return parts.concat(name);
          }, peg$c14 = function(name) {
            return [name];
          }, peg$c15 = function(name) {
            return name;
          }, peg$c16 = ".", peg$c17 = { type: "literal", value: ".", description: '"."' }, peg$c18 = "=", peg$c19 = { type: "literal", value: "=", description: '"="' }, peg$c20 = function(key, value) {
            addNode(node("Assign", value, line, column, key));
          }, peg$c21 = function(chars) {
            return chars.join("");
          }, peg$c22 = function(node2) {
            return node2.value;
          }, peg$c23 = '"""', peg$c24 = { type: "literal", value: '"""', description: '"\\"\\"\\""' }, peg$c25 = null, peg$c26 = function(chars) {
            return node("String", chars.join(""), line, column);
          }, peg$c27 = '"', peg$c28 = { type: "literal", value: '"', description: '"\\""' }, peg$c29 = "'''", peg$c30 = { type: "literal", value: "'''", description: `"'''"` }, peg$c31 = "'", peg$c32 = { type: "literal", value: "'", description: `"'"` }, peg$c33 = function(char) {
            return char;
          }, peg$c34 = function(char) {
            return char;
          }, peg$c35 = "\\", peg$c36 = { type: "literal", value: "\\", description: '"\\\\"' }, peg$c37 = function() {
            return "";
          }, peg$c38 = "e", peg$c39 = { type: "literal", value: "e", description: '"e"' }, peg$c40 = "E", peg$c41 = { type: "literal", value: "E", description: '"E"' }, peg$c42 = function(left, right) {
            return node("Float", parseFloat(left + "e" + right), line, column);
          }, peg$c43 = function(text2) {
            return node("Float", parseFloat(text2), line, column);
          }, peg$c44 = "+", peg$c45 = { type: "literal", value: "+", description: '"+"' }, peg$c46 = function(digits) {
            return digits.join("");
          }, peg$c47 = "-", peg$c48 = { type: "literal", value: "-", description: '"-"' }, peg$c49 = function(digits) {
            return "-" + digits.join("");
          }, peg$c50 = function(text2) {
            return node("Integer", parseInt(text2, 10), line, column);
          }, peg$c51 = "true", peg$c52 = { type: "literal", value: "true", description: '"true"' }, peg$c53 = function() {
            return node("Boolean", true, line, column);
          }, peg$c54 = "false", peg$c55 = { type: "literal", value: "false", description: '"false"' }, peg$c56 = function() {
            return node("Boolean", false, line, column);
          }, peg$c57 = function() {
            return node("Array", [], line, column);
          }, peg$c58 = function(value) {
            return node("Array", value ? [value] : [], line, column);
          }, peg$c59 = function(values) {
            return node("Array", values, line, column);
          }, peg$c60 = function(values, value) {
            return node("Array", values.concat(value), line, column);
          }, peg$c61 = function(value) {
            return value;
          }, peg$c62 = ",", peg$c63 = { type: "literal", value: ",", description: '","' }, peg$c64 = "{", peg$c65 = { type: "literal", value: "{", description: '"{"' }, peg$c66 = "}", peg$c67 = { type: "literal", value: "}", description: '"}"' }, peg$c68 = function(values) {
            return node("InlineTable", values, line, column);
          }, peg$c69 = function(key, value) {
            return node("InlineTableValue", value, line, column, key);
          }, peg$c70 = function(digits) {
            return "." + digits;
          }, peg$c71 = function(date2) {
            return date2.join("");
          }, peg$c72 = ":", peg$c73 = { type: "literal", value: ":", description: '":"' }, peg$c74 = function(time) {
            return time.join("");
          }, peg$c75 = "T", peg$c76 = { type: "literal", value: "T", description: '"T"' }, peg$c77 = "Z", peg$c78 = { type: "literal", value: "Z", description: '"Z"' }, peg$c79 = function(date2, time) {
            return node("Date", /* @__PURE__ */ new Date(date2 + "T" + time + "Z"), line, column);
          }, peg$c80 = function(date2, time) {
            return node("Date", /* @__PURE__ */ new Date(date2 + "T" + time), line, column);
          }, peg$c81 = /^[ \t]/, peg$c82 = { type: "class", value: "[ \\t]", description: "[ \\t]" }, peg$c83 = "\n", peg$c84 = { type: "literal", value: "\n", description: '"\\n"' }, peg$c85 = "\r", peg$c86 = { type: "literal", value: "\r", description: '"\\r"' }, peg$c87 = /^[0-9a-f]/i, peg$c88 = { type: "class", value: "[0-9a-f]i", description: "[0-9a-f]i" }, peg$c89 = /^[0-9]/, peg$c90 = { type: "class", value: "[0-9]", description: "[0-9]" }, peg$c91 = "_", peg$c92 = { type: "literal", value: "_", description: '"_"' }, peg$c93 = function() {
            return "";
          }, peg$c94 = /^[A-Za-z0-9_\-]/, peg$c95 = { type: "class", value: "[A-Za-z0-9_\\-]", description: "[A-Za-z0-9_\\-]" }, peg$c96 = function(d) {
            return d.join("");
          }, peg$c97 = '\\"', peg$c98 = { type: "literal", value: '\\"', description: '"\\\\\\""' }, peg$c99 = function() {
            return '"';
          }, peg$c100 = "\\\\", peg$c101 = { type: "literal", value: "\\\\", description: '"\\\\\\\\"' }, peg$c102 = function() {
            return "\\";
          }, peg$c103 = "\\b", peg$c104 = { type: "literal", value: "\\b", description: '"\\\\b"' }, peg$c105 = function() {
            return "\b";
          }, peg$c106 = "\\t", peg$c107 = { type: "literal", value: "\\t", description: '"\\\\t"' }, peg$c108 = function() {
            return "	";
          }, peg$c109 = "\\n", peg$c110 = { type: "literal", value: "\\n", description: '"\\\\n"' }, peg$c111 = function() {
            return "\n";
          }, peg$c112 = "\\f", peg$c113 = { type: "literal", value: "\\f", description: '"\\\\f"' }, peg$c114 = function() {
            return "\f";
          }, peg$c115 = "\\r", peg$c116 = { type: "literal", value: "\\r", description: '"\\\\r"' }, peg$c117 = function() {
            return "\r";
          }, peg$c118 = "\\U", peg$c119 = { type: "literal", value: "\\U", description: '"\\\\U"' }, peg$c120 = function(digits) {
            return convertCodePoint(digits.join(""));
          }, peg$c121 = "\\u", peg$c122 = { type: "literal", value: "\\u", description: '"\\\\u"' }, peg$currPos = 0, peg$reportedPos = 0, peg$cachedPos = 0, peg$cachedPosDetails = { line: 1, column: 1, seenCR: false }, peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$cache = {}, peg$result;
          if ("startRule" in options) {
            if (!(options.startRule in peg$startRuleFunctions)) {
              throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
            }
            peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
          }
          function text() {
            return input.substring(peg$reportedPos, peg$currPos);
          }
          function offset() {
            return peg$reportedPos;
          }
          function line() {
            return peg$computePosDetails(peg$reportedPos).line;
          }
          function column() {
            return peg$computePosDetails(peg$reportedPos).column;
          }
          function expected(description) {
            throw peg$buildException(
              null,
              [{ type: "other", description }],
              peg$reportedPos
            );
          }
          function error2(message) {
            throw peg$buildException(message, null, peg$reportedPos);
          }
          function peg$computePosDetails(pos) {
            function advance(details, startPos, endPos) {
              var p, ch;
              for (p = startPos; p < endPos; p++) {
                ch = input.charAt(p);
                if (ch === "\n") {
                  if (!details.seenCR) {
                    details.line++;
                  }
                  details.column = 1;
                  details.seenCR = false;
                } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
                  details.line++;
                  details.column = 1;
                  details.seenCR = true;
                } else {
                  details.column++;
                  details.seenCR = false;
                }
              }
            }
            if (peg$cachedPos !== pos) {
              if (peg$cachedPos > pos) {
                peg$cachedPos = 0;
                peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
              }
              advance(peg$cachedPosDetails, peg$cachedPos, pos);
              peg$cachedPos = pos;
            }
            return peg$cachedPosDetails;
          }
          function peg$fail(expected2) {
            if (peg$currPos < peg$maxFailPos) {
              return;
            }
            if (peg$currPos > peg$maxFailPos) {
              peg$maxFailPos = peg$currPos;
              peg$maxFailExpected = [];
            }
            peg$maxFailExpected.push(expected2);
          }
          function peg$buildException(message, expected2, pos) {
            function cleanupExpected(expected3) {
              var i = 1;
              expected3.sort(function(a, b) {
                if (a.description < b.description) {
                  return -1;
                } else if (a.description > b.description) {
                  return 1;
                } else {
                  return 0;
                }
              });
              while (i < expected3.length) {
                if (expected3[i - 1] === expected3[i]) {
                  expected3.splice(i, 1);
                } else {
                  i++;
                }
              }
            }
            function buildMessage(expected3, found2) {
              function stringEscape(s) {
                function hex(ch) {
                  return ch.charCodeAt(0).toString(16).toUpperCase();
                }
                return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\x08/g, "\\b").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\f/g, "\\f").replace(/\r/g, "\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) {
                  return "\\x0" + hex(ch);
                }).replace(/[\x10-\x1F\x80-\xFF]/g, function(ch) {
                  return "\\x" + hex(ch);
                }).replace(/[\u0180-\u0FFF]/g, function(ch) {
                  return "\\u0" + hex(ch);
                }).replace(/[\u1080-\uFFFF]/g, function(ch) {
                  return "\\u" + hex(ch);
                });
              }
              var expectedDescs = new Array(expected3.length), expectedDesc, foundDesc, i;
              for (i = 0; i < expected3.length; i++) {
                expectedDescs[i] = expected3[i].description;
              }
              expectedDesc = expected3.length > 1 ? expectedDescs.slice(0, -1).join(", ") + " or " + expectedDescs[expected3.length - 1] : expectedDescs[0];
              foundDesc = found2 ? '"' + stringEscape(found2) + '"' : "end of input";
              return "Expected " + expectedDesc + " but " + foundDesc + " found.";
            }
            var posDetails = peg$computePosDetails(pos), found = pos < input.length ? input.charAt(pos) : null;
            if (expected2 !== null) {
              cleanupExpected(expected2);
            }
            return new SyntaxError2(
              message !== null ? message : buildMessage(expected2, found),
              expected2,
              found,
              pos,
              posDetails.line,
              posDetails.column
            );
          }
          function peg$parsestart() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 0, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseline();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseline();
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c1();
            }
            s0 = s1;
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseline() {
            var s0, s1, s2, s3, s4, s5, s6;
            var key = peg$currPos * 49 + 1, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseS();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseexpression();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseS();
                }
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parsecomment();
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parsecomment();
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseNL();
                    if (s6 !== peg$FAILED) {
                      while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        s6 = peg$parseNL();
                      }
                    } else {
                      s5 = peg$c2;
                    }
                    if (s5 === peg$FAILED) {
                      s5 = peg$parseEOF();
                    }
                    if (s5 !== peg$FAILED) {
                      s1 = [s1, s2, s3, s4, s5];
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parseS();
              if (s2 !== peg$FAILED) {
                while (s2 !== peg$FAILED) {
                  s1.push(s2);
                  s2 = peg$parseS();
                }
              } else {
                s1 = peg$c2;
              }
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parseNL();
                if (s3 !== peg$FAILED) {
                  while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$parseNL();
                  }
                } else {
                  s2 = peg$c2;
                }
                if (s2 === peg$FAILED) {
                  s2 = peg$parseEOF();
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$parseNL();
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseexpression() {
            var s0;
            var key = peg$currPos * 49 + 2, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$parsecomment();
            if (s0 === peg$FAILED) {
              s0 = peg$parsepath();
              if (s0 === peg$FAILED) {
                s0 = peg$parsetablearray();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseassignment();
                }
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsecomment() {
            var s0, s1, s2, s3, s4, s5;
            var key = peg$currPos * 49 + 3, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 35) {
              s1 = peg$c3;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c4);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$currPos;
              s4 = peg$currPos;
              peg$silentFails++;
              s5 = peg$parseNL();
              if (s5 === peg$FAILED) {
                s5 = peg$parseEOF();
              }
              peg$silentFails--;
              if (s5 === peg$FAILED) {
                s4 = peg$c5;
              } else {
                peg$currPos = s4;
                s4 = peg$c2;
              }
              if (s4 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s5 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s5 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c6);
                  }
                }
                if (s5 !== peg$FAILED) {
                  s4 = [s4, s5];
                  s3 = s4;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c2;
                }
              } else {
                peg$currPos = s3;
                s3 = peg$c2;
              }
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$currPos;
                s4 = peg$currPos;
                peg$silentFails++;
                s5 = peg$parseNL();
                if (s5 === peg$FAILED) {
                  s5 = peg$parseEOF();
                }
                peg$silentFails--;
                if (s5 === peg$FAILED) {
                  s4 = peg$c5;
                } else {
                  peg$currPos = s4;
                  s4 = peg$c2;
                }
                if (s4 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s5 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s5 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c6);
                    }
                  }
                  if (s5 !== peg$FAILED) {
                    s4 = [s4, s5];
                    s3 = s4;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$c2;
                  }
                } else {
                  peg$currPos = s3;
                  s3 = peg$c2;
                }
              }
              if (s2 !== peg$FAILED) {
                s1 = [s1, s2];
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsepath() {
            var s0, s1, s2, s3, s4, s5;
            var key = peg$currPos * 49 + 4, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
              s1 = peg$c7;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseS();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseS();
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parsetable_key();
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parseS();
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parseS();
                  }
                  if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 93) {
                      s5 = peg$c9;
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c10);
                      }
                    }
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c11(s3);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsetablearray() {
            var s0, s1, s2, s3, s4, s5, s6, s7;
            var key = peg$currPos * 49 + 5, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
              s1 = peg$c7;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 91) {
                s2 = peg$c7;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c8);
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseS();
                }
                if (s3 !== peg$FAILED) {
                  s4 = peg$parsetable_key();
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseS();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseS();
                    }
                    if (s5 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 93) {
                        s6 = peg$c9;
                        peg$currPos++;
                      } else {
                        s6 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c10);
                        }
                      }
                      if (s6 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 93) {
                          s7 = peg$c9;
                          peg$currPos++;
                        } else {
                          s7 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c10);
                          }
                        }
                        if (s7 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c12(s4);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsetable_key() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 6, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsedot_ended_table_key_part();
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parsedot_ended_table_key_part();
              }
            } else {
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsetable_key_part();
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c13(s1, s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsetable_key_part();
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c14(s1);
              }
              s0 = s1;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsetable_key_part() {
            var s0, s1, s2, s3, s4;
            var key = peg$currPos * 49 + 7, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseS();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsekey();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseS();
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c15(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parseS();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseS();
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsequoted_key();
                if (s2 !== peg$FAILED) {
                  s3 = [];
                  s4 = peg$parseS();
                  while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$parseS();
                  }
                  if (s3 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c15(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsedot_ended_table_key_part() {
            var s0, s1, s2, s3, s4, s5, s6;
            var key = peg$currPos * 49 + 8, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseS();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsekey();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseS();
                }
                if (s3 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 46) {
                    s4 = peg$c16;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c17);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseS();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseS();
                    }
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c15(s2);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parseS();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseS();
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsequoted_key();
                if (s2 !== peg$FAILED) {
                  s3 = [];
                  s4 = peg$parseS();
                  while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$parseS();
                  }
                  if (s3 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 46) {
                      s4 = peg$c16;
                      peg$currPos++;
                    } else {
                      s4 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c17);
                      }
                    }
                    if (s4 !== peg$FAILED) {
                      s5 = [];
                      s6 = peg$parseS();
                      while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        s6 = peg$parseS();
                      }
                      if (s5 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c15(s2);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseassignment() {
            var s0, s1, s2, s3, s4, s5;
            var key = peg$currPos * 49 + 9, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$parsekey();
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseS();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseS();
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 61) {
                  s3 = peg$c18;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c19);
                  }
                }
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parseS();
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parseS();
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parsevalue();
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c20(s1, s5);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsequoted_key();
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parseS();
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parseS();
                }
                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 61) {
                    s3 = peg$c18;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c19);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    s4 = [];
                    s5 = peg$parseS();
                    while (s5 !== peg$FAILED) {
                      s4.push(s5);
                      s5 = peg$parseS();
                    }
                    if (s4 !== peg$FAILED) {
                      s5 = peg$parsevalue();
                      if (s5 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c20(s1, s5);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsekey() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 10, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseASCII_BASIC();
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseASCII_BASIC();
              }
            } else {
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c21(s1);
            }
            s0 = s1;
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsequoted_key() {
            var s0, s1;
            var key = peg$currPos * 49 + 11, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$parsedouble_quoted_single_line_string();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c22(s1);
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsesingle_quoted_single_line_string();
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c22(s1);
              }
              s0 = s1;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsevalue() {
            var s0;
            var key = peg$currPos * 49 + 12, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$parsestring();
            if (s0 === peg$FAILED) {
              s0 = peg$parsedatetime();
              if (s0 === peg$FAILED) {
                s0 = peg$parsefloat();
                if (s0 === peg$FAILED) {
                  s0 = peg$parseinteger();
                  if (s0 === peg$FAILED) {
                    s0 = peg$parseboolean();
                    if (s0 === peg$FAILED) {
                      s0 = peg$parsearray();
                      if (s0 === peg$FAILED) {
                        s0 = peg$parseinline_table();
                      }
                    }
                  }
                }
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsestring() {
            var s0;
            var key = peg$currPos * 49 + 13, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$parsedouble_quoted_multiline_string();
            if (s0 === peg$FAILED) {
              s0 = peg$parsedouble_quoted_single_line_string();
              if (s0 === peg$FAILED) {
                s0 = peg$parsesingle_quoted_multiline_string();
                if (s0 === peg$FAILED) {
                  s0 = peg$parsesingle_quoted_single_line_string();
                }
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsedouble_quoted_multiline_string() {
            var s0, s1, s2, s3, s4;
            var key = peg$currPos * 49 + 14, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 3) === peg$c23) {
              s1 = peg$c23;
              peg$currPos += 3;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c24);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseNL();
              if (s2 === peg$FAILED) {
                s2 = peg$c25;
              }
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parsemultiline_string_char();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parsemultiline_string_char();
                }
                if (s3 !== peg$FAILED) {
                  if (input.substr(peg$currPos, 3) === peg$c23) {
                    s4 = peg$c23;
                    peg$currPos += 3;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c24);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c26(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsedouble_quoted_single_line_string() {
            var s0, s1, s2, s3;
            var key = peg$currPos * 49 + 15, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 34) {
              s1 = peg$c27;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c28);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parsestring_char();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parsestring_char();
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 34) {
                  s3 = peg$c27;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c28);
                  }
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c26(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsesingle_quoted_multiline_string() {
            var s0, s1, s2, s3, s4;
            var key = peg$currPos * 49 + 16, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 3) === peg$c29) {
              s1 = peg$c29;
              peg$currPos += 3;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c30);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseNL();
              if (s2 === peg$FAILED) {
                s2 = peg$c25;
              }
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parsemultiline_literal_char();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parsemultiline_literal_char();
                }
                if (s3 !== peg$FAILED) {
                  if (input.substr(peg$currPos, 3) === peg$c29) {
                    s4 = peg$c29;
                    peg$currPos += 3;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c30);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c26(s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsesingle_quoted_single_line_string() {
            var s0, s1, s2, s3;
            var key = peg$currPos * 49 + 17, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 39) {
              s1 = peg$c31;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c32);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseliteral_char();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseliteral_char();
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 39) {
                  s3 = peg$c31;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c32);
                  }
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c26(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsestring_char() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 18, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$parseESCAPED();
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$currPos;
              peg$silentFails++;
              if (input.charCodeAt(peg$currPos) === 34) {
                s2 = peg$c27;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c28);
                }
              }
              peg$silentFails--;
              if (s2 === peg$FAILED) {
                s1 = peg$c5;
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
              if (s1 !== peg$FAILED) {
                if (input.length > peg$currPos) {
                  s2 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c6);
                  }
                }
                if (s2 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c33(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseliteral_char() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 19, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (input.charCodeAt(peg$currPos) === 39) {
              s2 = peg$c31;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c32);
              }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = peg$c5;
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c33(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsemultiline_string_char() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 20, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$parseESCAPED();
            if (s0 === peg$FAILED) {
              s0 = peg$parsemultiline_string_delim();
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                s1 = peg$currPos;
                peg$silentFails++;
                if (input.substr(peg$currPos, 3) === peg$c23) {
                  s2 = peg$c23;
                  peg$currPos += 3;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c24);
                  }
                }
                peg$silentFails--;
                if (s2 === peg$FAILED) {
                  s1 = peg$c5;
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
                if (s1 !== peg$FAILED) {
                  if (input.length > peg$currPos) {
                    s2 = input.charAt(peg$currPos);
                    peg$currPos++;
                  } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c6);
                    }
                  }
                  if (s2 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c34(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsemultiline_string_delim() {
            var s0, s1, s2, s3, s4;
            var key = peg$currPos * 49 + 21, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 92) {
              s1 = peg$c35;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c36);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseNL();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseNLS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseNLS();
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c37();
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsemultiline_literal_char() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 22, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$currPos;
            peg$silentFails++;
            if (input.substr(peg$currPos, 3) === peg$c29) {
              s2 = peg$c29;
              peg$currPos += 3;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c30);
              }
            }
            peg$silentFails--;
            if (s2 === peg$FAILED) {
              s1 = peg$c5;
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              if (input.length > peg$currPos) {
                s2 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c6);
                }
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c33(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsefloat() {
            var s0, s1, s2, s3;
            var key = peg$currPos * 49 + 23, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$parsefloat_text();
            if (s1 === peg$FAILED) {
              s1 = peg$parseinteger_text();
            }
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 101) {
                s2 = peg$c38;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c39);
                }
              }
              if (s2 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 69) {
                  s2 = peg$c40;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c41);
                  }
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parseinteger_text();
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c42(s1, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsefloat_text();
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c43(s1);
              }
              s0 = s1;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsefloat_text() {
            var s0, s1, s2, s3, s4, s5;
            var key = peg$currPos * 49 + 24, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 43) {
              s1 = peg$c44;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c45);
              }
            }
            if (s1 === peg$FAILED) {
              s1 = peg$c25;
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parseDIGITS();
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                  s4 = peg$c16;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseDIGITS();
                  if (s5 !== peg$FAILED) {
                    s3 = [s3, s4, s5];
                    s2 = s3;
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c46(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 45) {
                s1 = peg$c47;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c48);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = peg$parseDIGITS();
                if (s3 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 46) {
                    s4 = peg$c16;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c17);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseDIGITS();
                    if (s5 !== peg$FAILED) {
                      s3 = [s3, s4, s5];
                      s2 = s3;
                    } else {
                      peg$currPos = s2;
                      s2 = peg$c2;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
                if (s2 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c49(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseinteger() {
            var s0, s1;
            var key = peg$currPos * 49 + 25, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$parseinteger_text();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c50(s1);
            }
            s0 = s1;
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseinteger_text() {
            var s0, s1, s2, s3, s4;
            var key = peg$currPos * 49 + 26, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 43) {
              s1 = peg$c44;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c45);
              }
            }
            if (s1 === peg$FAILED) {
              s1 = peg$c25;
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseDIGIT_OR_UNDER();
              if (s3 !== peg$FAILED) {
                while (s3 !== peg$FAILED) {
                  s2.push(s3);
                  s3 = peg$parseDIGIT_OR_UNDER();
                }
              } else {
                s2 = peg$c2;
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$currPos;
                peg$silentFails++;
                if (input.charCodeAt(peg$currPos) === 46) {
                  s4 = peg$c16;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c17);
                  }
                }
                peg$silentFails--;
                if (s4 === peg$FAILED) {
                  s3 = peg$c5;
                } else {
                  peg$currPos = s3;
                  s3 = peg$c2;
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c46(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 45) {
                s1 = peg$c47;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c48);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parseDIGIT_OR_UNDER();
                if (s3 !== peg$FAILED) {
                  while (s3 !== peg$FAILED) {
                    s2.push(s3);
                    s3 = peg$parseDIGIT_OR_UNDER();
                  }
                } else {
                  s2 = peg$c2;
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$currPos;
                  peg$silentFails++;
                  if (input.charCodeAt(peg$currPos) === 46) {
                    s4 = peg$c16;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c17);
                    }
                  }
                  peg$silentFails--;
                  if (s4 === peg$FAILED) {
                    s3 = peg$c5;
                  } else {
                    peg$currPos = s3;
                    s3 = peg$c2;
                  }
                  if (s3 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c49(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseboolean() {
            var s0, s1;
            var key = peg$currPos * 49 + 27, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 4) === peg$c51) {
              s1 = peg$c51;
              peg$currPos += 4;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c52);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c53();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 5) === peg$c54) {
                s1 = peg$c54;
                peg$currPos += 5;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c55);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c56();
              }
              s0 = s1;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsearray() {
            var s0, s1, s2, s3, s4;
            var key = peg$currPos * 49 + 28, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 91) {
              s1 = peg$c7;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c8);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parsearray_sep();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parsearray_sep();
              }
              if (s2 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 93) {
                  s3 = peg$c9;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c10);
                  }
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c57();
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 91) {
                s1 = peg$c7;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c8);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsearray_value();
                if (s2 === peg$FAILED) {
                  s2 = peg$c25;
                }
                if (s2 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s3 = peg$c9;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c10);
                    }
                  }
                  if (s3 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c58(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 91) {
                  s1 = peg$c7;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c8);
                  }
                }
                if (s1 !== peg$FAILED) {
                  s2 = [];
                  s3 = peg$parsearray_value_list();
                  if (s3 !== peg$FAILED) {
                    while (s3 !== peg$FAILED) {
                      s2.push(s3);
                      s3 = peg$parsearray_value_list();
                    }
                  } else {
                    s2 = peg$c2;
                  }
                  if (s2 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 93) {
                      s3 = peg$c9;
                      peg$currPos++;
                    } else {
                      s3 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c10);
                      }
                    }
                    if (s3 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c59(s2);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 91) {
                    s1 = peg$c7;
                    peg$currPos++;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c8);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    s2 = [];
                    s3 = peg$parsearray_value_list();
                    if (s3 !== peg$FAILED) {
                      while (s3 !== peg$FAILED) {
                        s2.push(s3);
                        s3 = peg$parsearray_value_list();
                      }
                    } else {
                      s2 = peg$c2;
                    }
                    if (s2 !== peg$FAILED) {
                      s3 = peg$parsearray_value();
                      if (s3 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 93) {
                          s4 = peg$c9;
                          peg$currPos++;
                        } else {
                          s4 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c10);
                          }
                        }
                        if (s4 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c60(s2, s3);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                }
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsearray_value() {
            var s0, s1, s2, s3, s4;
            var key = peg$currPos * 49 + 29, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsearray_sep();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsearray_sep();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsevalue();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parsearray_sep();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parsearray_sep();
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c61(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsearray_value_list() {
            var s0, s1, s2, s3, s4, s5, s6;
            var key = peg$currPos * 49 + 30, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parsearray_sep();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parsearray_sep();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsevalue();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parsearray_sep();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parsearray_sep();
                }
                if (s3 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 44) {
                    s4 = peg$c62;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c63);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parsearray_sep();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parsearray_sep();
                    }
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c61(s2);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsearray_sep() {
            var s0;
            var key = peg$currPos * 49 + 31, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$parseS();
            if (s0 === peg$FAILED) {
              s0 = peg$parseNL();
              if (s0 === peg$FAILED) {
                s0 = peg$parsecomment();
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseinline_table() {
            var s0, s1, s2, s3, s4, s5;
            var key = peg$currPos * 49 + 32, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 123) {
              s1 = peg$c64;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c65);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = [];
              s3 = peg$parseS();
              while (s3 !== peg$FAILED) {
                s2.push(s3);
                s3 = peg$parseS();
              }
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseinline_table_assignment();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseinline_table_assignment();
                }
                if (s3 !== peg$FAILED) {
                  s4 = [];
                  s5 = peg$parseS();
                  while (s5 !== peg$FAILED) {
                    s4.push(s5);
                    s5 = peg$parseS();
                  }
                  if (s4 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 125) {
                      s5 = peg$c66;
                      peg$currPos++;
                    } else {
                      s5 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c67);
                      }
                    }
                    if (s5 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c68(s3);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseinline_table_assignment() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
            var key = peg$currPos * 49 + 33, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseS();
            while (s2 !== peg$FAILED) {
              s1.push(s2);
              s2 = peg$parseS();
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parsekey();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseS();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseS();
                }
                if (s3 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 61) {
                    s4 = peg$c18;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c19);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    s5 = [];
                    s6 = peg$parseS();
                    while (s6 !== peg$FAILED) {
                      s5.push(s6);
                      s6 = peg$parseS();
                    }
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parsevalue();
                      if (s6 !== peg$FAILED) {
                        s7 = [];
                        s8 = peg$parseS();
                        while (s8 !== peg$FAILED) {
                          s7.push(s8);
                          s8 = peg$parseS();
                        }
                        if (s7 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 44) {
                            s8 = peg$c62;
                            peg$currPos++;
                          } else {
                            s8 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c63);
                            }
                          }
                          if (s8 !== peg$FAILED) {
                            s9 = [];
                            s10 = peg$parseS();
                            while (s10 !== peg$FAILED) {
                              s9.push(s10);
                              s10 = peg$parseS();
                            }
                            if (s9 !== peg$FAILED) {
                              peg$reportedPos = s0;
                              s1 = peg$c69(s2, s6);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$c2;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$c2;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = [];
              s2 = peg$parseS();
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseS();
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$parsekey();
                if (s2 !== peg$FAILED) {
                  s3 = [];
                  s4 = peg$parseS();
                  while (s4 !== peg$FAILED) {
                    s3.push(s4);
                    s4 = peg$parseS();
                  }
                  if (s3 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 61) {
                      s4 = peg$c18;
                      peg$currPos++;
                    } else {
                      s4 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c19);
                      }
                    }
                    if (s4 !== peg$FAILED) {
                      s5 = [];
                      s6 = peg$parseS();
                      while (s6 !== peg$FAILED) {
                        s5.push(s6);
                        s6 = peg$parseS();
                      }
                      if (s5 !== peg$FAILED) {
                        s6 = peg$parsevalue();
                        if (s6 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c69(s2, s6);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsesecfragment() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 34, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 46) {
              s1 = peg$c16;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c17);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$parseDIGITS();
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c70(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsedate() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;
            var key = peg$currPos * 49 + 35, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$parseDIGIT_OR_UNDER();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseDIGIT_OR_UNDER();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseDIGIT_OR_UNDER();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseDIGIT_OR_UNDER();
                  if (s5 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 45) {
                      s6 = peg$c47;
                      peg$currPos++;
                    } else {
                      s6 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c48);
                      }
                    }
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parseDIGIT_OR_UNDER();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parseDIGIT_OR_UNDER();
                        if (s8 !== peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 45) {
                            s9 = peg$c47;
                            peg$currPos++;
                          } else {
                            s9 = peg$FAILED;
                            if (peg$silentFails === 0) {
                              peg$fail(peg$c48);
                            }
                          }
                          if (s9 !== peg$FAILED) {
                            s10 = peg$parseDIGIT_OR_UNDER();
                            if (s10 !== peg$FAILED) {
                              s11 = peg$parseDIGIT_OR_UNDER();
                              if (s11 !== peg$FAILED) {
                                s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11];
                                s1 = s2;
                              } else {
                                peg$currPos = s1;
                                s1 = peg$c2;
                              }
                            } else {
                              peg$currPos = s1;
                              s1 = peg$c2;
                            }
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c71(s1);
            }
            s0 = s1;
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsetime() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
            var key = peg$currPos * 49 + 36, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$parseDIGIT_OR_UNDER();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseDIGIT_OR_UNDER();
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                  s4 = peg$c72;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c73);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseDIGIT_OR_UNDER();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseDIGIT_OR_UNDER();
                    if (s6 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 58) {
                        s7 = peg$c72;
                        peg$currPos++;
                      } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c73);
                        }
                      }
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parseDIGIT_OR_UNDER();
                        if (s8 !== peg$FAILED) {
                          s9 = peg$parseDIGIT_OR_UNDER();
                          if (s9 !== peg$FAILED) {
                            s10 = peg$parsesecfragment();
                            if (s10 === peg$FAILED) {
                              s10 = peg$c25;
                            }
                            if (s10 !== peg$FAILED) {
                              s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10];
                              s1 = s2;
                            } else {
                              peg$currPos = s1;
                              s1 = peg$c2;
                            }
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c74(s1);
            }
            s0 = s1;
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsetime_with_offset() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16;
            var key = peg$currPos * 49 + 37, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$parseDIGIT_OR_UNDER();
            if (s2 !== peg$FAILED) {
              s3 = peg$parseDIGIT_OR_UNDER();
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 58) {
                  s4 = peg$c72;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c73);
                  }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseDIGIT_OR_UNDER();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseDIGIT_OR_UNDER();
                    if (s6 !== peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 58) {
                        s7 = peg$c72;
                        peg$currPos++;
                      } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c73);
                        }
                      }
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parseDIGIT_OR_UNDER();
                        if (s8 !== peg$FAILED) {
                          s9 = peg$parseDIGIT_OR_UNDER();
                          if (s9 !== peg$FAILED) {
                            s10 = peg$parsesecfragment();
                            if (s10 === peg$FAILED) {
                              s10 = peg$c25;
                            }
                            if (s10 !== peg$FAILED) {
                              if (input.charCodeAt(peg$currPos) === 45) {
                                s11 = peg$c47;
                                peg$currPos++;
                              } else {
                                s11 = peg$FAILED;
                                if (peg$silentFails === 0) {
                                  peg$fail(peg$c48);
                                }
                              }
                              if (s11 === peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 43) {
                                  s11 = peg$c44;
                                  peg$currPos++;
                                } else {
                                  s11 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$c45);
                                  }
                                }
                              }
                              if (s11 !== peg$FAILED) {
                                s12 = peg$parseDIGIT_OR_UNDER();
                                if (s12 !== peg$FAILED) {
                                  s13 = peg$parseDIGIT_OR_UNDER();
                                  if (s13 !== peg$FAILED) {
                                    if (input.charCodeAt(peg$currPos) === 58) {
                                      s14 = peg$c72;
                                      peg$currPos++;
                                    } else {
                                      s14 = peg$FAILED;
                                      if (peg$silentFails === 0) {
                                        peg$fail(peg$c73);
                                      }
                                    }
                                    if (s14 !== peg$FAILED) {
                                      s15 = peg$parseDIGIT_OR_UNDER();
                                      if (s15 !== peg$FAILED) {
                                        s16 = peg$parseDIGIT_OR_UNDER();
                                        if (s16 !== peg$FAILED) {
                                          s2 = [s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16];
                                          s1 = s2;
                                        } else {
                                          peg$currPos = s1;
                                          s1 = peg$c2;
                                        }
                                      } else {
                                        peg$currPos = s1;
                                        s1 = peg$c2;
                                      }
                                    } else {
                                      peg$currPos = s1;
                                      s1 = peg$c2;
                                    }
                                  } else {
                                    peg$currPos = s1;
                                    s1 = peg$c2;
                                  }
                                } else {
                                  peg$currPos = s1;
                                  s1 = peg$c2;
                                }
                              } else {
                                peg$currPos = s1;
                                s1 = peg$c2;
                              }
                            } else {
                              peg$currPos = s1;
                              s1 = peg$c2;
                            }
                          } else {
                            peg$currPos = s1;
                            s1 = peg$c2;
                          }
                        } else {
                          peg$currPos = s1;
                          s1 = peg$c2;
                        }
                      } else {
                        peg$currPos = s1;
                        s1 = peg$c2;
                      }
                    } else {
                      peg$currPos = s1;
                      s1 = peg$c2;
                    }
                  } else {
                    peg$currPos = s1;
                    s1 = peg$c2;
                  }
                } else {
                  peg$currPos = s1;
                  s1 = peg$c2;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$c2;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c74(s1);
            }
            s0 = s1;
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parsedatetime() {
            var s0, s1, s2, s3, s4;
            var key = peg$currPos * 49 + 38, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = peg$parsedate();
            if (s1 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 84) {
                s2 = peg$c75;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c76);
                }
              }
              if (s2 !== peg$FAILED) {
                s3 = peg$parsetime();
                if (s3 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 90) {
                    s4 = peg$c77;
                    peg$currPos++;
                  } else {
                    s4 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c78);
                    }
                  }
                  if (s4 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c79(s1, s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsedate();
              if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 84) {
                  s2 = peg$c75;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c76);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s3 = peg$parsetime_with_offset();
                  if (s3 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c80(s1, s3);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseS() {
            var s0;
            var key = peg$currPos * 49 + 39, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            if (peg$c81.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c82);
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseNL() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 40, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            if (input.charCodeAt(peg$currPos) === 10) {
              s0 = peg$c83;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c84);
              }
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 13) {
                s1 = peg$c85;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c86);
                }
              }
              if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 10) {
                  s2 = peg$c83;
                  peg$currPos++;
                } else {
                  s2 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c84);
                  }
                }
                if (s2 !== peg$FAILED) {
                  s1 = [s1, s2];
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseNLS() {
            var s0;
            var key = peg$currPos * 49 + 41, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$parseNL();
            if (s0 === peg$FAILED) {
              s0 = peg$parseS();
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseEOF() {
            var s0, s1;
            var key = peg$currPos * 49 + 42, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            peg$silentFails++;
            if (input.length > peg$currPos) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c6);
              }
            }
            peg$silentFails--;
            if (s1 === peg$FAILED) {
              s0 = peg$c5;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseHEX() {
            var s0;
            var key = peg$currPos * 49 + 43, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            if (peg$c87.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c88);
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseDIGIT_OR_UNDER() {
            var s0, s1;
            var key = peg$currPos * 49 + 44, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            if (peg$c89.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c90);
              }
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.charCodeAt(peg$currPos) === 95) {
                s1 = peg$c91;
                peg$currPos++;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c92);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c93();
              }
              s0 = s1;
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseASCII_BASIC() {
            var s0;
            var key = peg$currPos * 49 + 45, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            if (peg$c94.test(input.charAt(peg$currPos))) {
              s0 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c95);
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseDIGITS() {
            var s0, s1, s2;
            var key = peg$currPos * 49 + 46, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            s1 = [];
            s2 = peg$parseDIGIT_OR_UNDER();
            if (s2 !== peg$FAILED) {
              while (s2 !== peg$FAILED) {
                s1.push(s2);
                s2 = peg$parseDIGIT_OR_UNDER();
              }
            } else {
              s1 = peg$c2;
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c96(s1);
            }
            s0 = s1;
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseESCAPED() {
            var s0, s1;
            var key = peg$currPos * 49 + 47, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c97) {
              s1 = peg$c97;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c98);
              }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c99();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c100) {
                s1 = peg$c100;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c101);
                }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c102();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c103) {
                  s1 = peg$c103;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c104);
                  }
                }
                if (s1 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c105();
                }
                s0 = s1;
                if (s0 === peg$FAILED) {
                  s0 = peg$currPos;
                  if (input.substr(peg$currPos, 2) === peg$c106) {
                    s1 = peg$c106;
                    peg$currPos += 2;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c107);
                    }
                  }
                  if (s1 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c108();
                  }
                  s0 = s1;
                  if (s0 === peg$FAILED) {
                    s0 = peg$currPos;
                    if (input.substr(peg$currPos, 2) === peg$c109) {
                      s1 = peg$c109;
                      peg$currPos += 2;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c110);
                      }
                    }
                    if (s1 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c111();
                    }
                    s0 = s1;
                    if (s0 === peg$FAILED) {
                      s0 = peg$currPos;
                      if (input.substr(peg$currPos, 2) === peg$c112) {
                        s1 = peg$c112;
                        peg$currPos += 2;
                      } else {
                        s1 = peg$FAILED;
                        if (peg$silentFails === 0) {
                          peg$fail(peg$c113);
                        }
                      }
                      if (s1 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c114();
                      }
                      s0 = s1;
                      if (s0 === peg$FAILED) {
                        s0 = peg$currPos;
                        if (input.substr(peg$currPos, 2) === peg$c115) {
                          s1 = peg$c115;
                          peg$currPos += 2;
                        } else {
                          s1 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c116);
                          }
                        }
                        if (s1 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c117();
                        }
                        s0 = s1;
                        if (s0 === peg$FAILED) {
                          s0 = peg$parseESCAPED_UNICODE();
                        }
                      }
                    }
                  }
                }
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          function peg$parseESCAPED_UNICODE() {
            var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;
            var key = peg$currPos * 49 + 48, cached = peg$cache[key];
            if (cached) {
              peg$currPos = cached.nextPos;
              return cached.result;
            }
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c118) {
              s1 = peg$c118;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c119);
              }
            }
            if (s1 !== peg$FAILED) {
              s2 = peg$currPos;
              s3 = peg$parseHEX();
              if (s3 !== peg$FAILED) {
                s4 = peg$parseHEX();
                if (s4 !== peg$FAILED) {
                  s5 = peg$parseHEX();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseHEX();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parseHEX();
                      if (s7 !== peg$FAILED) {
                        s8 = peg$parseHEX();
                        if (s8 !== peg$FAILED) {
                          s9 = peg$parseHEX();
                          if (s9 !== peg$FAILED) {
                            s10 = peg$parseHEX();
                            if (s10 !== peg$FAILED) {
                              s3 = [s3, s4, s5, s6, s7, s8, s9, s10];
                              s2 = s3;
                            } else {
                              peg$currPos = s2;
                              s2 = peg$c2;
                            }
                          } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                          }
                        } else {
                          peg$currPos = s2;
                          s2 = peg$c2;
                        }
                      } else {
                        peg$currPos = s2;
                        s2 = peg$c2;
                      }
                    } else {
                      peg$currPos = s2;
                      s2 = peg$c2;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$c2;
              }
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c120(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c121) {
                s1 = peg$c121;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) {
                  peg$fail(peg$c122);
                }
              }
              if (s1 !== peg$FAILED) {
                s2 = peg$currPos;
                s3 = peg$parseHEX();
                if (s3 !== peg$FAILED) {
                  s4 = peg$parseHEX();
                  if (s4 !== peg$FAILED) {
                    s5 = peg$parseHEX();
                    if (s5 !== peg$FAILED) {
                      s6 = peg$parseHEX();
                      if (s6 !== peg$FAILED) {
                        s3 = [s3, s4, s5, s6];
                        s2 = s3;
                      } else {
                        peg$currPos = s2;
                        s2 = peg$c2;
                      }
                    } else {
                      peg$currPos = s2;
                      s2 = peg$c2;
                    }
                  } else {
                    peg$currPos = s2;
                    s2 = peg$c2;
                  }
                } else {
                  peg$currPos = s2;
                  s2 = peg$c2;
                }
                if (s2 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c120(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            }
            peg$cache[key] = { nextPos: peg$currPos, result: s0 };
            return s0;
          }
          var nodes = [];
          function genError(err, line2, col) {
            var ex = new Error(err);
            ex.line = line2;
            ex.column = col;
            throw ex;
          }
          function addNode(node2) {
            nodes.push(node2);
          }
          function node(type3, value, line2, column2, key) {
            var obj = { type: type3, value, line: line2(), column: column2() };
            if (key)
              obj.key = key;
            return obj;
          }
          function convertCodePoint(str, line2, col) {
            var num = parseInt("0x" + str);
            if (!isFinite(num) || Math.floor(num) != num || num < 0 || num > 1114111 || num > 55295 && num < 57344) {
              genError("Invalid Unicode escape code: " + str, line2, col);
            } else {
              return fromCodePoint(num);
            }
          }
          function fromCodePoint() {
            var MAX_SIZE = 16384;
            var codeUnits = [];
            var highSurrogate;
            var lowSurrogate;
            var index = -1;
            var length = arguments.length;
            if (!length) {
              return "";
            }
            var result = "";
            while (++index < length) {
              var codePoint = Number(arguments[index]);
              if (codePoint <= 65535) {
                codeUnits.push(codePoint);
              } else {
                codePoint -= 65536;
                highSurrogate = (codePoint >> 10) + 55296;
                lowSurrogate = codePoint % 1024 + 56320;
                codeUnits.push(highSurrogate, lowSurrogate);
              }
              if (index + 1 == length || codeUnits.length > MAX_SIZE) {
                result += String.fromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
              }
            }
            return result;
          }
          peg$result = peg$startRuleFunction();
          if (peg$result !== peg$FAILED && peg$currPos === input.length) {
            return peg$result;
          } else {
            if (peg$result !== peg$FAILED && peg$currPos < input.length) {
              peg$fail({ type: "end", description: "end of input" });
            }
            throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
          }
        }
        return {
          SyntaxError: SyntaxError2,
          parse: parse3
        };
      }();
    }
  });

  // ../../node_modules/.pnpm/toml@3.0.0/node_modules/toml/lib/compiler.js
  var require_compiler2 = __commonJS({
    "../../node_modules/.pnpm/toml@3.0.0/node_modules/toml/lib/compiler.js"(exports, module2) {
      "use strict";
      function compile6(nodes) {
        var assignedPaths = [];
        var valueAssignments = [];
        var currentPath = "";
        var data = /* @__PURE__ */ Object.create(null);
        var context2 = data;
        var arrayMode = false;
        return reduce(nodes);
        function reduce(nodes2) {
          var node;
          for (var i = 0; i < nodes2.length; i++) {
            node = nodes2[i];
            switch (node.type) {
              case "Assign":
                assign(node);
                break;
              case "ObjectPath":
                setPath(node);
                break;
              case "ArrayPath":
                addTableArray(node);
                break;
            }
          }
          return data;
        }
        function genError(err, line, col) {
          var ex = new Error(err);
          ex.line = line;
          ex.column = col;
          throw ex;
        }
        function assign(node) {
          var key = node.key;
          var value = node.value;
          var line = node.line;
          var column = node.column;
          var fullPath;
          if (currentPath) {
            fullPath = currentPath + "." + key;
          } else {
            fullPath = key;
          }
          if (typeof context2[key] !== "undefined") {
            genError("Cannot redefine existing key '" + fullPath + "'.", line, column);
          }
          context2[key] = reduceValueNode(value);
          if (!pathAssigned(fullPath)) {
            assignedPaths.push(fullPath);
            valueAssignments.push(fullPath);
          }
        }
        function pathAssigned(path4) {
          return assignedPaths.indexOf(path4) !== -1;
        }
        function reduceValueNode(node) {
          if (node.type === "Array") {
            return reduceArrayWithTypeChecking(node.value);
          } else if (node.type === "InlineTable") {
            return reduceInlineTableNode(node.value);
          } else {
            return node.value;
          }
        }
        function reduceInlineTableNode(values) {
          var obj = /* @__PURE__ */ Object.create(null);
          for (var i = 0; i < values.length; i++) {
            var val = values[i];
            if (val.value.type === "InlineTable") {
              obj[val.key] = reduceInlineTableNode(val.value.value);
            } else if (val.type === "InlineTableValue") {
              obj[val.key] = reduceValueNode(val.value);
            }
          }
          return obj;
        }
        function setPath(node) {
          var path4 = node.value;
          var quotedPath = path4.map(quoteDottedString).join(".");
          var line = node.line;
          var column = node.column;
          if (pathAssigned(quotedPath)) {
            genError("Cannot redefine existing key '" + path4 + "'.", line, column);
          }
          assignedPaths.push(quotedPath);
          context2 = deepRef(data, path4, /* @__PURE__ */ Object.create(null), line, column);
          currentPath = path4;
        }
        function addTableArray(node) {
          var path4 = node.value;
          var quotedPath = path4.map(quoteDottedString).join(".");
          var line = node.line;
          var column = node.column;
          if (!pathAssigned(quotedPath)) {
            assignedPaths.push(quotedPath);
          }
          assignedPaths = assignedPaths.filter(function(p) {
            return p.indexOf(quotedPath) !== 0;
          });
          assignedPaths.push(quotedPath);
          context2 = deepRef(data, path4, [], line, column);
          currentPath = quotedPath;
          if (context2 instanceof Array) {
            var newObj = /* @__PURE__ */ Object.create(null);
            context2.push(newObj);
            context2 = newObj;
          } else {
            genError("Cannot redefine existing key '" + path4 + "'.", line, column);
          }
        }
        function deepRef(start, keys4, value, line, column) {
          var traversed = [];
          var traversedPath = "";
          var path4 = keys4.join(".");
          var ctx = start;
          for (var i = 0; i < keys4.length; i++) {
            var key = keys4[i];
            traversed.push(key);
            traversedPath = traversed.join(".");
            if (typeof ctx[key] === "undefined") {
              if (i === keys4.length - 1) {
                ctx[key] = value;
              } else {
                ctx[key] = /* @__PURE__ */ Object.create(null);
              }
            } else if (i !== keys4.length - 1 && valueAssignments.indexOf(traversedPath) > -1) {
              genError("Cannot redefine existing key '" + traversedPath + "'.", line, column);
            }
            ctx = ctx[key];
            if (ctx instanceof Array && ctx.length && i < keys4.length - 1) {
              ctx = ctx[ctx.length - 1];
            }
          }
          return ctx;
        }
        function reduceArrayWithTypeChecking(array2) {
          var firstType = null;
          for (var i = 0; i < array2.length; i++) {
            var node = array2[i];
            if (firstType === null) {
              firstType = node.type;
            } else {
              if (node.type !== firstType) {
                genError("Cannot add value of type " + node.type + " to array of type " + firstType + ".", node.line, node.column);
              }
            }
          }
          return array2.map(reduceValueNode);
        }
        function quoteDottedString(str) {
          if (str.indexOf(".") > -1) {
            return '"' + str + '"';
          } else {
            return str;
          }
        }
      }
      module2.exports = {
        compile: compile6
      };
    }
  });

  // ../../node_modules/.pnpm/toml@3.0.0/node_modules/toml/index.js
  var require_toml = __commonJS({
    "../../node_modules/.pnpm/toml@3.0.0/node_modules/toml/index.js"(exports, module2) {
      var parser = require_parser2();
      var compiler = require_compiler2();
      module2.exports = {
        parse: function(input) {
          var nodes = parser.parse(input.toString());
          return compiler.compile(nodes);
        }
      };
    }
  });

  // ../../node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js
  var require_bn = __commonJS({
    "../../node_modules/.pnpm/bn.js@5.2.1/node_modules/bn.js/lib/bn.js"(exports, module2) {
      (function(module3, exports2) {
        "use strict";
        function assert5(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN2(number4, base, endian) {
          if (BN2.isBN(number4)) {
            return number4;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number4 !== null) {
            if (base === "le" || base === "be") {
              endian = base;
              base = 10;
            }
            this._init(number4 || 0, base || 10, endian || "be");
          }
        }
        if (typeof module3 === "object") {
          module3.exports = BN2;
        } else {
          exports2.BN = BN2;
        }
        BN2.BN = BN2;
        BN2.wordSize = 26;
        var Buffer2;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer2 = window.Buffer;
          } else {
            Buffer2 = __require2("buffer").Buffer;
          }
        } catch (e) {
        }
        BN2.isBN = function isBN(num) {
          if (num instanceof BN2) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
        };
        BN2.max = function max2(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN2.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN2.prototype._init = function init2(number4, base, endian) {
          if (typeof number4 === "number") {
            return this._initNumber(number4, base, endian);
          }
          if (typeof number4 === "object") {
            return this._initArray(number4, base, endian);
          }
          if (base === "hex") {
            base = 16;
          }
          assert5(base === (base | 0) && base >= 2 && base <= 36);
          number4 = number4.toString().replace(/\s+/g, "");
          var start = 0;
          if (number4[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number4.length) {
            if (base === 16) {
              this._parseHex(number4, start, endian);
            } else {
              this._parseBase(number4, base, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base, endian);
              }
            }
          }
        };
        BN2.prototype._initNumber = function _initNumber(number4, base, endian) {
          if (number4 < 0) {
            this.negative = 1;
            number4 = -number4;
          }
          if (number4 < 67108864) {
            this.words = [number4 & 67108863];
            this.length = 1;
          } else if (number4 < 4503599627370496) {
            this.words = [
              number4 & 67108863,
              number4 / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert5(number4 < 9007199254740992);
            this.words = [
              number4 & 67108863,
              number4 / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        };
        BN2.prototype._initArray = function _initArray(number4, base, endian) {
          assert5(typeof number4.length === "number");
          if (number4.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number4.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          if (endian === "be") {
            for (i = number4.length - 1, j = 0; i >= 0; i -= 3) {
              w = number4[i] | number4[i - 1] << 8 | number4[i - 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j = 0; i < number4.length; i += 3) {
              w = number4[i] | number4[i + 1] << 8 | number4[i + 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this._strip();
        };
        function parseHex4Bits(string2, index) {
          var c = string2.charCodeAt(index);
          if (c >= 48 && c <= 57) {
            return c - 48;
          } else if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            assert5(false, "Invalid character in " + string2);
          }
        }
        function parseHexByte(string2, lowerBound, index) {
          var r = parseHex4Bits(string2, index);
          if (index - 1 >= lowerBound) {
            r |= parseHex4Bits(string2, index - 1) << 4;
          }
          return r;
        }
        BN2.prototype._parseHex = function _parseHex(number4, start, endian) {
          this.length = Math.ceil((number4.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var off = 0;
          var j = 0;
          var w;
          if (endian === "be") {
            for (i = number4.length - 1; i >= start; i -= 2) {
              w = parseHexByte(number4, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number4.length - start;
            for (i = parseLength % 2 === 0 ? start + 1 : start; i < number4.length; i += 2) {
              w = parseHexByte(number4, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this._strip();
        };
        function parseBase(str, start, end, mul) {
          var r = 0;
          var b = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            if (c >= 49) {
              b = c - 49 + 10;
            } else if (c >= 17) {
              b = c - 17 + 10;
            } else {
              b = c;
            }
            assert5(c >= 0 && b < mul, "Invalid character");
            r += b;
          }
          return r;
        }
        BN2.prototype._parseBase = function _parseBase(number4, base, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base | 0;
          var total = number4.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number4, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number4, i, number4.length, base);
            for (i = 0; i < mod; i++) {
              pow *= base;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this._strip();
        };
        BN2.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        function move(dest, src) {
          dest.words = src.words;
          dest.length = src.length;
          dest.negative = src.negative;
          dest.red = src.red;
        }
        BN2.prototype._move = function _move(dest) {
          move(dest, this);
        };
        BN2.prototype.clone = function clone5() {
          var r = new BN2(null);
          this.copy(r);
          return r;
        };
        BN2.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN2.prototype._strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN2.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        if (typeof Symbol !== "undefined" && typeof Symbol.for === "function") {
          try {
            BN2.prototype[Symbol.for("nodejs.util.inspect.custom")] = inspect2;
          } catch (e) {
            BN2.prototype.inspect = inspect2;
          }
        } else {
          BN2.prototype.inspect = inspect2;
        }
        function inspect2() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        }
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN2.prototype.toString = function toString3(base, padding) {
          base = base || 10;
          padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w = this.words[i];
              var word = ((w << off | carry) & 16777215).toString(16);
              carry = w >>> 24 - off & 16777215;
              off += 2;
              if (off >= 26) {
                off -= 26;
                i--;
              }
              if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base];
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modrn(groupBase).toString(base);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert5(false, "Base should be between 2 and 36");
        };
        BN2.prototype.toNumber = function toNumber3() {
          var ret3 = this.words[0];
          if (this.length === 2) {
            ret3 += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret3 += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert5(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret3 : ret3;
        };
        BN2.prototype.toJSON = function toJSON() {
          return this.toString(16, 2);
        };
        if (Buffer2) {
          BN2.prototype.toBuffer = function toBuffer(endian, length) {
            return this.toArrayLike(Buffer2, endian, length);
          };
        }
        BN2.prototype.toArray = function toArray2(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        var allocate = function allocate2(ArrayType4, size) {
          if (ArrayType4.allocUnsafe) {
            return ArrayType4.allocUnsafe(size);
          }
          return new ArrayType4(size);
        };
        BN2.prototype.toArrayLike = function toArrayLike(ArrayType4, endian, length) {
          this._strip();
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert5(byteLength <= reqLength, "byte array longer than desired length");
          assert5(reqLength > 0, "Requested array length <= 0");
          var res = allocate(ArrayType4, reqLength);
          var postfix = endian === "le" ? "LE" : "BE";
          this["_toArrayLike" + postfix](res, byteLength);
          return res;
        };
        BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
          var position = 0;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position++] = word & 255;
            if (position < res.length) {
              res[position++] = word >> 8 & 255;
            }
            if (position < res.length) {
              res[position++] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position < res.length) {
                res[position++] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position < res.length) {
            res[position++] = carry;
            while (position < res.length) {
              res[position++] = 0;
            }
          }
        };
        BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
          var position = res.length - 1;
          var carry = 0;
          for (var i = 0, shift = 0; i < this.length; i++) {
            var word = this.words[i] << shift | carry;
            res[position--] = word & 255;
            if (position >= 0) {
              res[position--] = word >> 8 & 255;
            }
            if (position >= 0) {
              res[position--] = word >> 16 & 255;
            }
            if (shift === 6) {
              if (position >= 0) {
                res[position--] = word >> 24 & 255;
              }
              carry = 0;
              shift = 0;
            } else {
              carry = word >>> 24;
              shift += 2;
            }
          }
          if (position >= 0) {
            res[position--] = carry;
            while (position >= 0) {
              res[position--] = 0;
            }
          }
        };
        if (Math.clz32) {
          BN2.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        } else {
          BN2.prototype._countBits = function _countBits(w) {
            var t = w;
            var r = 0;
            if (t >= 4096) {
              r += 13;
              t >>>= 13;
            }
            if (t >= 64) {
              r += 7;
              t >>>= 7;
            }
            if (t >= 8) {
              r += 4;
              t >>>= 4;
            }
            if (t >= 2) {
              r += 2;
              t >>>= 2;
            }
            return r + t;
          };
        }
        BN2.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0)
            return 26;
          var t = w;
          var r = 0;
          if ((t & 8191) === 0) {
            r += 13;
            t >>>= 13;
          }
          if ((t & 127) === 0) {
            r += 7;
            t >>>= 7;
          }
          if ((t & 15) === 0) {
            r += 4;
            t >>>= 4;
          }
          if ((t & 3) === 0) {
            r += 2;
            t >>>= 2;
          }
          if ((t & 1) === 0) {
            r++;
          }
          return r;
        };
        BN2.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1];
          var hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0; bit < w.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = num.words[off] >>> wbit & 1;
          }
          return w;
        }
        BN2.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26)
              break;
          }
          return r;
        };
        BN2.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN2.prototype.toTwos = function toTwos2(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN2.prototype.fromTwos = function fromTwos2(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN2.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN2.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN2.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN2.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this._strip();
        };
        BN2.prototype.ior = function ior(num) {
          assert5((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN2.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN2.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN2.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b.length;
          return this._strip();
        };
        BN2.prototype.iand = function iand(num) {
          assert5((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN2.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN2.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN2.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = a.words[i] ^ b.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this._strip();
        };
        BN2.prototype.ixor = function ixor(num) {
          assert5((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN2.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN2.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN2.prototype.inotn = function inotn(width) {
          assert5(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this._strip();
        };
        BN2.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN2.prototype.setn = function setn(bit, val) {
          assert5(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this._strip();
        };
        BN2.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN2.prototype.add = function add3(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN2.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this._strip();
        };
        BN2.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r = a * b;
          var lo = r & 67108863;
          var carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1; k < len; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j | 0;
              a = self2.words[i] | 0;
              b = num.words[j] | 0;
              r = a * b + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out._strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o = out.words;
          var c = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b2 = b[2] | 0;
          var bl2 = b2 & 8191;
          var bh2 = b2 >>> 13;
          var b3 = b[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c !== 0) {
            o[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j;
              var a = self2.words[i] | 0;
              var b = num.words[j] | 0;
              var r = a * b;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out._strip();
        }
        function jumboMulTo(self2, num, out) {
          return bigMulTo(self2, num, out);
        }
        BN2.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y) {
          this.x = x;
          this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t = new Array(N);
          var l = BN2.prototype._countBits(N) - 1;
          for (var i = 0; i < N; i++) {
            t[i] = this.revBin(i, l, N);
          }
          return t;
        };
        FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1)
            return x;
          var rb = 0;
          for (var i = 0; i < l; i++) {
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i = 0; i < N; i++) {
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1; s < N; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1;
          var odd = N & 1;
          var i = 0;
          for (N = N / 2 | 0; N; N = N >>> 1) {
            i++;
          }
          return 1 << i + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1)
            return;
          for (var i = 0; i < N / 2; i++) {
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i = 0; i < N / 2; i++) {
            var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 67108863;
            if (w < 67108864) {
              carry = 0;
            } else {
              carry = w / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
          var carry = 0;
          for (var i = 0; i < len; i++) {
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i = 2 * len; i < N; ++i) {
            rws[i] = 0;
          }
          assert5(carry === 0);
          assert5((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i = 0; i < N; i++) {
            ph[i] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length);
          var rbt = this.makeRBT(N);
          var _ = this.stub(N);
          var rws = new Array(N);
          var rwst = new Array(N);
          var iwst = new Array(N);
          var nrws = new Array(N);
          var nrwst = new Array(N);
          var niwst = new Array(N);
          var rmws = out.words;
          rmws.length = N;
          this.convert13b(x.words, x.length, rws, N);
          this.convert13b(y.words, y.length, nrws, N);
          this.transform(rws, _, rwst, iwst, N, rbt);
          this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i = 0; i < N; i++) {
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
          }
          this.conjugate(rwst, iwst, N);
          this.transform(rwst, iwst, rmws, _, N, rbt);
          this.conjugate(rmws, _, N);
          this.normalize13b(rmws, N);
          out.negative = x.negative ^ y.negative;
          out.length = x.length + y.length;
          return out._strip();
        };
        BN2.prototype.mul = function mul(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN2.prototype.mulf = function mulf(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN2.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN2.prototype.imuln = function imuln(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert5(typeof num === "number");
          assert5(num < 67108864);
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = (this.words[i] | 0) * num;
            var lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return isNegNum ? this.ineg() : this;
        };
        BN2.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN2.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN2.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN2.prototype.pow = function pow(num) {
          var w = toBitArray(num);
          if (w.length === 0)
            return new BN2(1);
          var res = this;
          for (var i = 0; i < w.length; i++, res = res.sqr()) {
            if (w[i] !== 0)
              break;
          }
          if (++i < w.length) {
            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
              if (w[i] === 0)
                continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN2.prototype.iushln = function iushln(bits) {
          assert5(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c | carry;
              carry = newCarry >>> 26 - r;
            }
            if (carry) {
              this.words[i] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this._strip();
        };
        BN2.prototype.ishln = function ishln(bits) {
          assert5(this.negative === 0);
          return this.iushln(bits);
        };
        BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert5(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r = bits % 26;
          var s = Math.min((bits - r) / 26, this.length);
          var mask2 = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0) {
          } else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask2;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this._strip();
        };
        BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert5(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN2.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN2.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN2.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN2.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN2.prototype.testn = function testn(bit) {
          assert5(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s)
            return false;
          var w = this.words[s];
          return !!(w & q);
        };
        BN2.prototype.imaskn = function imaskn(bits) {
          assert5(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          assert5(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask2 = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask2;
          }
          return this._strip();
        };
        BN2.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN2.prototype.iaddn = function iaddn(num) {
          assert5(typeof num === "number");
          assert5(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN2.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN2.prototype.isubn = function isubn(num) {
          assert5(typeof num === "number");
          assert5(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this._strip();
        };
        BN2.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN2.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN2.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN2.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w;
          var carry = 0;
          for (i = 0; i < num.length; i++) {
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 67108863;
            carry = (w >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 67108863;
          }
          if (carry === 0)
            return this._strip();
          assert5(carry === -1);
          carry = 0;
          for (i = 0; i < this.length; i++) {
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 67108863;
          }
          this.negative = 1;
          return this._strip();
        };
        BN2.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN2(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i = 0; i < q.length; i++) {
              q.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj;
            }
          }
          if (q) {
            q._strip();
          }
          a._strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN2.prototype.divmod = function divmod(num, mode, positive) {
          assert5(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN2(0),
              mod: new BN2(0)
            };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN2(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN2(this.modrn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN2(this.modrn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN2.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN2.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN2.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN2.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN2.prototype.modrn = function modrn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert5(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p * acc + (this.words[i] | 0)) % num;
          }
          return isNegNum ? -acc : acc;
        };
        BN2.prototype.modn = function modn(num) {
          return this.modrn(num);
        };
        BN2.prototype.idivn = function idivn(num) {
          var isNegNum = num < 0;
          if (isNegNum)
            num = -num;
          assert5(num <= 67108863);
          var carry = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w = (this.words[i] | 0) + carry * 67108864;
            this.words[i] = w / num | 0;
            carry = w % num;
          }
          this._strip();
          return isNegNum ? this.ineg() : this;
        };
        BN2.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN2.prototype.egcd = function egcd(p) {
          assert5(p.negative === 0);
          assert5(!p.isZero());
          var x = this;
          var y = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A = new BN2(1);
          var B = new BN2(0);
          var C = new BN2(0);
          var D = new BN2(1);
          var g = 0;
          while (x.isEven() && y.isEven()) {
            x.iushrn(1);
            y.iushrn(1);
            ++g;
          }
          var yp = y.clone();
          var xp = x.clone();
          while (!x.isZero()) {
            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              x.iushrn(i);
              while (i-- > 0) {
                if (A.isOdd() || B.isOdd()) {
                  A.iadd(yp);
                  B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp);
                  D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0) {
              x.isub(y);
              A.isub(C);
              B.isub(D);
            } else {
              y.isub(x);
              C.isub(A);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y.iushln(g)
          };
        };
        BN2.prototype._invmp = function _invmp(p) {
          assert5(p.negative === 0);
          assert5(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x1 = new BN2(1);
          var x2 = new BN2(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x1.isub(x2);
            } else {
              b.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN2.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b;
              b = t;
            } else if (r === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN2.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN2.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN2.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN2.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN2.prototype.bincn = function bincn(bit) {
          assert5(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i = s; carry !== 0 && i < this.length; i++) {
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 67108863;
            this.words[i] = w;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN2.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this._strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert5(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b)
              continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN2.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN2.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN2.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN2.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN2.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN2.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN2.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN2.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN2.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN2.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        };
        BN2.red = function red2(num) {
          return new Red(num);
        };
        BN2.prototype.toRed = function toRed(ctx) {
          assert5(!this.red, "Already a number in reduction context");
          assert5(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN2.prototype.fromRed = function fromRed() {
          assert5(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN2.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN2.prototype.forceRed = function forceRed(ctx) {
          assert5(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN2.prototype.redAdd = function redAdd(num) {
          assert5(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN2.prototype.redIAdd = function redIAdd(num) {
          assert5(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN2.prototype.redSub = function redSub(num) {
          assert5(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN2.prototype.redISub = function redISub(num) {
          assert5(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN2.prototype.redShl = function redShl(num) {
          assert5(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN2.prototype.redMul = function redMul(num) {
          assert5(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN2.prototype.redIMul = function redIMul(num) {
          assert5(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN2.prototype.redSqr = function redSqr() {
          assert5(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN2.prototype.redISqr = function redISqr() {
          assert5(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN2.prototype.redSqrt = function redSqrt() {
          assert5(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN2.prototype.redInvm = function redInvm() {
          assert5(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN2.prototype.redNeg = function redNeg() {
          assert5(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN2.prototype.redPow = function redPow(num) {
          assert5(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name, p) {
          this.name = name;
          this.p = new BN2(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN2(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN2(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            if (r.strip !== void 0) {
              r.strip();
            } else {
              r._strip();
            }
          }
          return r;
        };
        MPrime.prototype.split = function split4(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split4(input, output3) {
          var mask2 = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output3.words[i] = input.words[i];
          }
          output3.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output3.words[output3.length++] = prev & mask2;
          for (i = 10; i < input.length; i++) {
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask2) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w = num.words[i] | 0;
            lo += w * 977;
            num.words[i] = lo & 67108863;
            lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i = 0; i < num.length; i++) {
            var hi = (num.words[i] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN2._prime = function prime(name) {
          if (primes[name])
            return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN2._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert5(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert5(a.negative === 0, "red works only with positives");
          assert5(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert5((a.negative | b.negative) === 0, "red works only with positives");
          assert5(
            a.red && a.red === b.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          move(a, a.umod(this.m)._forceRed(this));
          return a;
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add3(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert5(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN2(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert5(!q.isZero());
          var one = new BN2(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN2(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r = this.pow(a, q.addn(1).iushrn(1));
          var t = this.pow(a, q);
          var m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert5(i < m);
            var b = this.pow(c, new BN2(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN2(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN2(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN2.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN2(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t = a.imul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN2(0)._forceRed(this);
          var t = a.mul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module2 === "undefined" || module2, exports);
    }
  });

  // ../../node_modules/.pnpm/bech32@2.0.0/node_modules/bech32/dist/index.js
  var require_dist = __commonJS({
    "../../node_modules/.pnpm/bech32@2.0.0/node_modules/bech32/dist/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bech32m = exports.bech32 = void 0;
      var ALPHABET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";
      var ALPHABET_MAP = {};
      for (let z = 0; z < ALPHABET.length; z++) {
        const x = ALPHABET.charAt(z);
        ALPHABET_MAP[x] = z;
      }
      function polymodStep(pre) {
        const b = pre >> 25;
        return (pre & 33554431) << 5 ^ -(b >> 0 & 1) & 996825010 ^ -(b >> 1 & 1) & 642813549 ^ -(b >> 2 & 1) & 513874426 ^ -(b >> 3 & 1) & 1027748829 ^ -(b >> 4 & 1) & 705979059;
      }
      function prefixChk(prefix) {
        let chk = 1;
        for (let i = 0; i < prefix.length; ++i) {
          const c = prefix.charCodeAt(i);
          if (c < 33 || c > 126)
            return "Invalid prefix (" + prefix + ")";
          chk = polymodStep(chk) ^ c >> 5;
        }
        chk = polymodStep(chk);
        for (let i = 0; i < prefix.length; ++i) {
          const v = prefix.charCodeAt(i);
          chk = polymodStep(chk) ^ v & 31;
        }
        return chk;
      }
      function convert2(data, inBits, outBits, pad3) {
        let value = 0;
        let bits = 0;
        const maxV = (1 << outBits) - 1;
        const result = [];
        for (let i = 0; i < data.length; ++i) {
          value = value << inBits | data[i];
          bits += inBits;
          while (bits >= outBits) {
            bits -= outBits;
            result.push(value >> bits & maxV);
          }
        }
        if (pad3) {
          if (bits > 0) {
            result.push(value << outBits - bits & maxV);
          }
        } else {
          if (bits >= inBits)
            return "Excess padding";
          if (value << outBits - bits & maxV)
            return "Non-zero padding";
        }
        return result;
      }
      function toWords(bytes3) {
        return convert2(bytes3, 8, 5, true);
      }
      function fromWordsUnsafe(words) {
        const res = convert2(words, 5, 8, false);
        if (Array.isArray(res))
          return res;
      }
      function fromWords(words) {
        const res = convert2(words, 5, 8, false);
        if (Array.isArray(res))
          return res;
        throw new Error(res);
      }
      function getLibraryFromEncoding(encoding) {
        let ENCODING_CONST;
        if (encoding === "bech32") {
          ENCODING_CONST = 1;
        } else {
          ENCODING_CONST = 734539939;
        }
        function encode(prefix, words, LIMIT) {
          LIMIT = LIMIT || 90;
          if (prefix.length + 7 + words.length > LIMIT)
            throw new TypeError("Exceeds length limit");
          prefix = prefix.toLowerCase();
          let chk = prefixChk(prefix);
          if (typeof chk === "string")
            throw new Error(chk);
          let result = prefix + "1";
          for (let i = 0; i < words.length; ++i) {
            const x = words[i];
            if (x >> 5 !== 0)
              throw new Error("Non 5-bit word");
            chk = polymodStep(chk) ^ x;
            result += ALPHABET.charAt(x);
          }
          for (let i = 0; i < 6; ++i) {
            chk = polymodStep(chk);
          }
          chk ^= ENCODING_CONST;
          for (let i = 0; i < 6; ++i) {
            const v = chk >> (5 - i) * 5 & 31;
            result += ALPHABET.charAt(v);
          }
          return result;
        }
        function __decode(str, LIMIT) {
          LIMIT = LIMIT || 90;
          if (str.length < 8)
            return str + " too short";
          if (str.length > LIMIT)
            return "Exceeds length limit";
          const lowered = str.toLowerCase();
          const uppered = str.toUpperCase();
          if (str !== lowered && str !== uppered)
            return "Mixed-case string " + str;
          str = lowered;
          const split4 = str.lastIndexOf("1");
          if (split4 === -1)
            return "No separator character for " + str;
          if (split4 === 0)
            return "Missing prefix for " + str;
          const prefix = str.slice(0, split4);
          const wordChars = str.slice(split4 + 1);
          if (wordChars.length < 6)
            return "Data too short";
          let chk = prefixChk(prefix);
          if (typeof chk === "string")
            return chk;
          const words = [];
          for (let i = 0; i < wordChars.length; ++i) {
            const c = wordChars.charAt(i);
            const v = ALPHABET_MAP[c];
            if (v === void 0)
              return "Unknown character " + c;
            chk = polymodStep(chk) ^ v;
            if (i + 6 >= wordChars.length)
              continue;
            words.push(v);
          }
          if (chk !== ENCODING_CONST)
            return "Invalid checksum for " + str;
          return { prefix, words };
        }
        function decodeUnsafe(str, LIMIT) {
          const res = __decode(str, LIMIT);
          if (typeof res === "object")
            return res;
        }
        function decode(str, LIMIT) {
          const res = __decode(str, LIMIT);
          if (typeof res === "object")
            return res;
          throw new Error(res);
        }
        return {
          decodeUnsafe,
          decode,
          encode,
          toWords,
          fromWordsUnsafe,
          fromWords
        };
      }
      exports.bech32 = getLibraryFromEncoding("bech32");
      exports.bech32m = getLibraryFromEncoding("bech32m");
    }
  });

  // ../../node_modules/.pnpm/webidl-conversions@3.0.1/node_modules/webidl-conversions/lib/index.js
  var require_lib3 = __commonJS({
    "../../node_modules/.pnpm/webidl-conversions@3.0.1/node_modules/webidl-conversions/lib/index.js"(exports, module2) {
      "use strict";
      var conversions = {};
      module2.exports = conversions;
      function sign(x) {
        return x < 0 ? -1 : 1;
      }
      function evenRound(x) {
        if (x % 1 === 0.5 && (x & 1) === 0) {
          return Math.floor(x);
        } else {
          return Math.round(x);
        }
      }
      function createNumberConversion(bitLength, typeOpts) {
        if (!typeOpts.unsigned) {
          --bitLength;
        }
        const lowerBound = typeOpts.unsigned ? 0 : -Math.pow(2, bitLength);
        const upperBound = Math.pow(2, bitLength) - 1;
        const moduloVal = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength) : Math.pow(2, bitLength);
        const moduloBound = typeOpts.moduloBitLength ? Math.pow(2, typeOpts.moduloBitLength - 1) : Math.pow(2, bitLength - 1);
        return function(V, opts) {
          if (!opts)
            opts = {};
          let x = +V;
          if (opts.enforceRange) {
            if (!Number.isFinite(x)) {
              throw new TypeError("Argument is not a finite number");
            }
            x = sign(x) * Math.floor(Math.abs(x));
            if (x < lowerBound || x > upperBound) {
              throw new TypeError("Argument is not in byte range");
            }
            return x;
          }
          if (!isNaN(x) && opts.clamp) {
            x = evenRound(x);
            if (x < lowerBound)
              x = lowerBound;
            if (x > upperBound)
              x = upperBound;
            return x;
          }
          if (!Number.isFinite(x) || x === 0) {
            return 0;
          }
          x = sign(x) * Math.floor(Math.abs(x));
          x = x % moduloVal;
          if (!typeOpts.unsigned && x >= moduloBound) {
            return x - moduloVal;
          } else if (typeOpts.unsigned) {
            if (x < 0) {
              x += moduloVal;
            } else if (x === -0) {
              return 0;
            }
          }
          return x;
        };
      }
      conversions["void"] = function() {
        return void 0;
      };
      conversions["boolean"] = function(val) {
        return !!val;
      };
      conversions["byte"] = createNumberConversion(8, { unsigned: false });
      conversions["octet"] = createNumberConversion(8, { unsigned: true });
      conversions["short"] = createNumberConversion(16, { unsigned: false });
      conversions["unsigned short"] = createNumberConversion(16, { unsigned: true });
      conversions["long"] = createNumberConversion(32, { unsigned: false });
      conversions["unsigned long"] = createNumberConversion(32, { unsigned: true });
      conversions["long long"] = createNumberConversion(32, { unsigned: false, moduloBitLength: 64 });
      conversions["unsigned long long"] = createNumberConversion(32, { unsigned: true, moduloBitLength: 64 });
      conversions["double"] = function(V) {
        const x = +V;
        if (!Number.isFinite(x)) {
          throw new TypeError("Argument is not a finite floating-point value");
        }
        return x;
      };
      conversions["unrestricted double"] = function(V) {
        const x = +V;
        if (isNaN(x)) {
          throw new TypeError("Argument is NaN");
        }
        return x;
      };
      conversions["float"] = conversions["double"];
      conversions["unrestricted float"] = conversions["unrestricted double"];
      conversions["DOMString"] = function(V, opts) {
        if (!opts)
          opts = {};
        if (opts.treatNullAsEmptyString && V === null) {
          return "";
        }
        return String(V);
      };
      conversions["ByteString"] = function(V, opts) {
        const x = String(V);
        let c = void 0;
        for (let i = 0; (c = x.codePointAt(i)) !== void 0; ++i) {
          if (c > 255) {
            throw new TypeError("Argument is not a valid bytestring");
          }
        }
        return x;
      };
      conversions["USVString"] = function(V) {
        const S = String(V);
        const n = S.length;
        const U = [];
        for (let i = 0; i < n; ++i) {
          const c = S.charCodeAt(i);
          if (c < 55296 || c > 57343) {
            U.push(String.fromCodePoint(c));
          } else if (56320 <= c && c <= 57343) {
            U.push(String.fromCodePoint(65533));
          } else {
            if (i === n - 1) {
              U.push(String.fromCodePoint(65533));
            } else {
              const d = S.charCodeAt(i + 1);
              if (56320 <= d && d <= 57343) {
                const a = c & 1023;
                const b = d & 1023;
                U.push(String.fromCodePoint((2 << 15) + (2 << 9) * a + b));
                ++i;
              } else {
                U.push(String.fromCodePoint(65533));
              }
            }
          }
        }
        return U.join("");
      };
      conversions["Date"] = function(V, opts) {
        if (!(V instanceof Date)) {
          throw new TypeError("Argument is not a Date object");
        }
        if (isNaN(V)) {
          return void 0;
        }
        return V;
      };
      conversions["RegExp"] = function(V, opts) {
        if (!(V instanceof RegExp)) {
          V = new RegExp(V);
        }
        return V;
      };
    }
  });

  // ../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/utils.js
  var require_utils3 = __commonJS({
    "../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/utils.js"(exports, module2) {
      "use strict";
      module2.exports.mixin = function mixin(target, source) {
        const keys4 = Object.getOwnPropertyNames(source);
        for (let i = 0; i < keys4.length; ++i) {
          Object.defineProperty(target, keys4[i], Object.getOwnPropertyDescriptor(source, keys4[i]));
        }
      };
      module2.exports.wrapperSymbol = Symbol("wrapper");
      module2.exports.implSymbol = Symbol("impl");
      module2.exports.wrapperForImpl = function(impl) {
        return impl[module2.exports.wrapperSymbol];
      };
      module2.exports.implForWrapper = function(wrapper) {
        return wrapper[module2.exports.implSymbol];
      };
    }
  });

  // ../../node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/lib/mappingTable.json
  var require_mappingTable = __commonJS({
    "../../node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/lib/mappingTable.json"(exports, module2) {
      module2.exports = [[[0, 44], "disallowed_STD3_valid"], [[45, 46], "valid"], [[47, 47], "disallowed_STD3_valid"], [[48, 57], "valid"], [[58, 64], "disallowed_STD3_valid"], [[65, 65], "mapped", [97]], [[66, 66], "mapped", [98]], [[67, 67], "mapped", [99]], [[68, 68], "mapped", [100]], [[69, 69], "mapped", [101]], [[70, 70], "mapped", [102]], [[71, 71], "mapped", [103]], [[72, 72], "mapped", [104]], [[73, 73], "mapped", [105]], [[74, 74], "mapped", [106]], [[75, 75], "mapped", [107]], [[76, 76], "mapped", [108]], [[77, 77], "mapped", [109]], [[78, 78], "mapped", [110]], [[79, 79], "mapped", [111]], [[80, 80], "mapped", [112]], [[81, 81], "mapped", [113]], [[82, 82], "mapped", [114]], [[83, 83], "mapped", [115]], [[84, 84], "mapped", [116]], [[85, 85], "mapped", [117]], [[86, 86], "mapped", [118]], [[87, 87], "mapped", [119]], [[88, 88], "mapped", [120]], [[89, 89], "mapped", [121]], [[90, 90], "mapped", [122]], [[91, 96], "disallowed_STD3_valid"], [[97, 122], "valid"], [[123, 127], "disallowed_STD3_valid"], [[128, 159], "disallowed"], [[160, 160], "disallowed_STD3_mapped", [32]], [[161, 167], "valid", [], "NV8"], [[168, 168], "disallowed_STD3_mapped", [32, 776]], [[169, 169], "valid", [], "NV8"], [[170, 170], "mapped", [97]], [[171, 172], "valid", [], "NV8"], [[173, 173], "ignored"], [[174, 174], "valid", [], "NV8"], [[175, 175], "disallowed_STD3_mapped", [32, 772]], [[176, 177], "valid", [], "NV8"], [[178, 178], "mapped", [50]], [[179, 179], "mapped", [51]], [[180, 180], "disallowed_STD3_mapped", [32, 769]], [[181, 181], "mapped", [956]], [[182, 182], "valid", [], "NV8"], [[183, 183], "valid"], [[184, 184], "disallowed_STD3_mapped", [32, 807]], [[185, 185], "mapped", [49]], [[186, 186], "mapped", [111]], [[187, 187], "valid", [], "NV8"], [[188, 188], "mapped", [49, 8260, 52]], [[189, 189], "mapped", [49, 8260, 50]], [[190, 190], "mapped", [51, 8260, 52]], [[191, 191], "valid", [], "NV8"], [[192, 192], "mapped", [224]], [[193, 193], "mapped", [225]], [[194, 194], "mapped", [226]], [[195, 195], "mapped", [227]], [[196, 196], "mapped", [228]], [[197, 197], "mapped", [229]], [[198, 198], "mapped", [230]], [[199, 199], "mapped", [231]], [[200, 200], "mapped", [232]], [[201, 201], "mapped", [233]], [[202, 202], "mapped", [234]], [[203, 203], "mapped", [235]], [[204, 204], "mapped", [236]], [[205, 205], "mapped", [237]], [[206, 206], "mapped", [238]], [[207, 207], "mapped", [239]], [[208, 208], "mapped", [240]], [[209, 209], "mapped", [241]], [[210, 210], "mapped", [242]], [[211, 211], "mapped", [243]], [[212, 212], "mapped", [244]], [[213, 213], "mapped", [245]], [[214, 214], "mapped", [246]], [[215, 215], "valid", [], "NV8"], [[216, 216], "mapped", [248]], [[217, 217], "mapped", [249]], [[218, 218], "mapped", [250]], [[219, 219], "mapped", [251]], [[220, 220], "mapped", [252]], [[221, 221], "mapped", [253]], [[222, 222], "mapped", [254]], [[223, 223], "deviation", [115, 115]], [[224, 246], "valid"], [[247, 247], "valid", [], "NV8"], [[248, 255], "valid"], [[256, 256], "mapped", [257]], [[257, 257], "valid"], [[258, 258], "mapped", [259]], [[259, 259], "valid"], [[260, 260], "mapped", [261]], [[261, 261], "valid"], [[262, 262], "mapped", [263]], [[263, 263], "valid"], [[264, 264], "mapped", [265]], [[265, 265], "valid"], [[266, 266], "mapped", [267]], [[267, 267], "valid"], [[268, 268], "mapped", [269]], [[269, 269], "valid"], [[270, 270], "mapped", [271]], [[271, 271], "valid"], [[272, 272], "mapped", [273]], [[273, 273], "valid"], [[274, 274], "mapped", [275]], [[275, 275], "valid"], [[276, 276], "mapped", [277]], [[277, 277], "valid"], [[278, 278], "mapped", [279]], [[279, 279], "valid"], [[280, 280], "mapped", [281]], [[281, 281], "valid"], [[282, 282], "mapped", [283]], [[283, 283], "valid"], [[284, 284], "mapped", [285]], [[285, 285], "valid"], [[286, 286], "mapped", [287]], [[287, 287], "valid"], [[288, 288], "mapped", [289]], [[289, 289], "valid"], [[290, 290], "mapped", [291]], [[291, 291], "valid"], [[292, 292], "mapped", [293]], [[293, 293], "valid"], [[294, 294], "mapped", [295]], [[295, 295], "valid"], [[296, 296], "mapped", [297]], [[297, 297], "valid"], [[298, 298], "mapped", [299]], [[299, 299], "valid"], [[300, 300], "mapped", [301]], [[301, 301], "valid"], [[302, 302], "mapped", [303]], [[303, 303], "valid"], [[304, 304], "mapped", [105, 775]], [[305, 305], "valid"], [[306, 307], "mapped", [105, 106]], [[308, 308], "mapped", [309]], [[309, 309], "valid"], [[310, 310], "mapped", [311]], [[311, 312], "valid"], [[313, 313], "mapped", [314]], [[314, 314], "valid"], [[315, 315], "mapped", [316]], [[316, 316], "valid"], [[317, 317], "mapped", [318]], [[318, 318], "valid"], [[319, 320], "mapped", [108, 183]], [[321, 321], "mapped", [322]], [[322, 322], "valid"], [[323, 323], "mapped", [324]], [[324, 324], "valid"], [[325, 325], "mapped", [326]], [[326, 326], "valid"], [[327, 327], "mapped", [328]], [[328, 328], "valid"], [[329, 329], "mapped", [700, 110]], [[330, 330], "mapped", [331]], [[331, 331], "valid"], [[332, 332], "mapped", [333]], [[333, 333], "valid"], [[334, 334], "mapped", [335]], [[335, 335], "valid"], [[336, 336], "mapped", [337]], [[337, 337], "valid"], [[338, 338], "mapped", [339]], [[339, 339], "valid"], [[340, 340], "mapped", [341]], [[341, 341], "valid"], [[342, 342], "mapped", [343]], [[343, 343], "valid"], [[344, 344], "mapped", [345]], [[345, 345], "valid"], [[346, 346], "mapped", [347]], [[347, 347], "valid"], [[348, 348], "mapped", [349]], [[349, 349], "valid"], [[350, 350], "mapped", [351]], [[351, 351], "valid"], [[352, 352], "mapped", [353]], [[353, 353], "valid"], [[354, 354], "mapped", [355]], [[355, 355], "valid"], [[356, 356], "mapped", [357]], [[357, 357], "valid"], [[358, 358], "mapped", [359]], [[359, 359], "valid"], [[360, 360], "mapped", [361]], [[361, 361], "valid"], [[362, 362], "mapped", [363]], [[363, 363], "valid"], [[364, 364], "mapped", [365]], [[365, 365], "valid"], [[366, 366], "mapped", [367]], [[367, 367], "valid"], [[368, 368], "mapped", [369]], [[369, 369], "valid"], [[370, 370], "mapped", [371]], [[371, 371], "valid"], [[372, 372], "mapped", [373]], [[373, 373], "valid"], [[374, 374], "mapped", [375]], [[375, 375], "valid"], [[376, 376], "mapped", [255]], [[377, 377], "mapped", [378]], [[378, 378], "valid"], [[379, 379], "mapped", [380]], [[380, 380], "valid"], [[381, 381], "mapped", [382]], [[382, 382], "valid"], [[383, 383], "mapped", [115]], [[384, 384], "valid"], [[385, 385], "mapped", [595]], [[386, 386], "mapped", [387]], [[387, 387], "valid"], [[388, 388], "mapped", [389]], [[389, 389], "valid"], [[390, 390], "mapped", [596]], [[391, 391], "mapped", [392]], [[392, 392], "valid"], [[393, 393], "mapped", [598]], [[394, 394], "mapped", [599]], [[395, 395], "mapped", [396]], [[396, 397], "valid"], [[398, 398], "mapped", [477]], [[399, 399], "mapped", [601]], [[400, 400], "mapped", [603]], [[401, 401], "mapped", [402]], [[402, 402], "valid"], [[403, 403], "mapped", [608]], [[404, 404], "mapped", [611]], [[405, 405], "valid"], [[406, 406], "mapped", [617]], [[407, 407], "mapped", [616]], [[408, 408], "mapped", [409]], [[409, 411], "valid"], [[412, 412], "mapped", [623]], [[413, 413], "mapped", [626]], [[414, 414], "valid"], [[415, 415], "mapped", [629]], [[416, 416], "mapped", [417]], [[417, 417], "valid"], [[418, 418], "mapped", [419]], [[419, 419], "valid"], [[420, 420], "mapped", [421]], [[421, 421], "valid"], [[422, 422], "mapped", [640]], [[423, 423], "mapped", [424]], [[424, 424], "valid"], [[425, 425], "mapped", [643]], [[426, 427], "valid"], [[428, 428], "mapped", [429]], [[429, 429], "valid"], [[430, 430], "mapped", [648]], [[431, 431], "mapped", [432]], [[432, 432], "valid"], [[433, 433], "mapped", [650]], [[434, 434], "mapped", [651]], [[435, 435], "mapped", [436]], [[436, 436], "valid"], [[437, 437], "mapped", [438]], [[438, 438], "valid"], [[439, 439], "mapped", [658]], [[440, 440], "mapped", [441]], [[441, 443], "valid"], [[444, 444], "mapped", [445]], [[445, 451], "valid"], [[452, 454], "mapped", [100, 382]], [[455, 457], "mapped", [108, 106]], [[458, 460], "mapped", [110, 106]], [[461, 461], "mapped", [462]], [[462, 462], "valid"], [[463, 463], "mapped", [464]], [[464, 464], "valid"], [[465, 465], "mapped", [466]], [[466, 466], "valid"], [[467, 467], "mapped", [468]], [[468, 468], "valid"], [[469, 469], "mapped", [470]], [[470, 470], "valid"], [[471, 471], "mapped", [472]], [[472, 472], "valid"], [[473, 473], "mapped", [474]], [[474, 474], "valid"], [[475, 475], "mapped", [476]], [[476, 477], "valid"], [[478, 478], "mapped", [479]], [[479, 479], "valid"], [[480, 480], "mapped", [481]], [[481, 481], "valid"], [[482, 482], "mapped", [483]], [[483, 483], "valid"], [[484, 484], "mapped", [485]], [[485, 485], "valid"], [[486, 486], "mapped", [487]], [[487, 487], "valid"], [[488, 488], "mapped", [489]], [[489, 489], "valid"], [[490, 490], "mapped", [491]], [[491, 491], "valid"], [[492, 492], "mapped", [493]], [[493, 493], "valid"], [[494, 494], "mapped", [495]], [[495, 496], "valid"], [[497, 499], "mapped", [100, 122]], [[500, 500], "mapped", [501]], [[501, 501], "valid"], [[502, 502], "mapped", [405]], [[503, 503], "mapped", [447]], [[504, 504], "mapped", [505]], [[505, 505], "valid"], [[506, 506], "mapped", [507]], [[507, 507], "valid"], [[508, 508], "mapped", [509]], [[509, 509], "valid"], [[510, 510], "mapped", [511]], [[511, 511], "valid"], [[512, 512], "mapped", [513]], [[513, 513], "valid"], [[514, 514], "mapped", [515]], [[515, 515], "valid"], [[516, 516], "mapped", [517]], [[517, 517], "valid"], [[518, 518], "mapped", [519]], [[519, 519], "valid"], [[520, 520], "mapped", [521]], [[521, 521], "valid"], [[522, 522], "mapped", [523]], [[523, 523], "valid"], [[524, 524], "mapped", [525]], [[525, 525], "valid"], [[526, 526], "mapped", [527]], [[527, 527], "valid"], [[528, 528], "mapped", [529]], [[529, 529], "valid"], [[530, 530], "mapped", [531]], [[531, 531], "valid"], [[532, 532], "mapped", [533]], [[533, 533], "valid"], [[534, 534], "mapped", [535]], [[535, 535], "valid"], [[536, 536], "mapped", [537]], [[537, 537], "valid"], [[538, 538], "mapped", [539]], [[539, 539], "valid"], [[540, 540], "mapped", [541]], [[541, 541], "valid"], [[542, 542], "mapped", [543]], [[543, 543], "valid"], [[544, 544], "mapped", [414]], [[545, 545], "valid"], [[546, 546], "mapped", [547]], [[547, 547], "valid"], [[548, 548], "mapped", [549]], [[549, 549], "valid"], [[550, 550], "mapped", [551]], [[551, 551], "valid"], [[552, 552], "mapped", [553]], [[553, 553], "valid"], [[554, 554], "mapped", [555]], [[555, 555], "valid"], [[556, 556], "mapped", [557]], [[557, 557], "valid"], [[558, 558], "mapped", [559]], [[559, 559], "valid"], [[560, 560], "mapped", [561]], [[561, 561], "valid"], [[562, 562], "mapped", [563]], [[563, 563], "valid"], [[564, 566], "valid"], [[567, 569], "valid"], [[570, 570], "mapped", [11365]], [[571, 571], "mapped", [572]], [[572, 572], "valid"], [[573, 573], "mapped", [410]], [[574, 574], "mapped", [11366]], [[575, 576], "valid"], [[577, 577], "mapped", [578]], [[578, 578], "valid"], [[579, 579], "mapped", [384]], [[580, 580], "mapped", [649]], [[581, 581], "mapped", [652]], [[582, 582], "mapped", [583]], [[583, 583], "valid"], [[584, 584], "mapped", [585]], [[585, 585], "valid"], [[586, 586], "mapped", [587]], [[587, 587], "valid"], [[588, 588], "mapped", [589]], [[589, 589], "valid"], [[590, 590], "mapped", [591]], [[591, 591], "valid"], [[592, 680], "valid"], [[681, 685], "valid"], [[686, 687], "valid"], [[688, 688], "mapped", [104]], [[689, 689], "mapped", [614]], [[690, 690], "mapped", [106]], [[691, 691], "mapped", [114]], [[692, 692], "mapped", [633]], [[693, 693], "mapped", [635]], [[694, 694], "mapped", [641]], [[695, 695], "mapped", [119]], [[696, 696], "mapped", [121]], [[697, 705], "valid"], [[706, 709], "valid", [], "NV8"], [[710, 721], "valid"], [[722, 727], "valid", [], "NV8"], [[728, 728], "disallowed_STD3_mapped", [32, 774]], [[729, 729], "disallowed_STD3_mapped", [32, 775]], [[730, 730], "disallowed_STD3_mapped", [32, 778]], [[731, 731], "disallowed_STD3_mapped", [32, 808]], [[732, 732], "disallowed_STD3_mapped", [32, 771]], [[733, 733], "disallowed_STD3_mapped", [32, 779]], [[734, 734], "valid", [], "NV8"], [[735, 735], "valid", [], "NV8"], [[736, 736], "mapped", [611]], [[737, 737], "mapped", [108]], [[738, 738], "mapped", [115]], [[739, 739], "mapped", [120]], [[740, 740], "mapped", [661]], [[741, 745], "valid", [], "NV8"], [[746, 747], "valid", [], "NV8"], [[748, 748], "valid"], [[749, 749], "valid", [], "NV8"], [[750, 750], "valid"], [[751, 767], "valid", [], "NV8"], [[768, 831], "valid"], [[832, 832], "mapped", [768]], [[833, 833], "mapped", [769]], [[834, 834], "valid"], [[835, 835], "mapped", [787]], [[836, 836], "mapped", [776, 769]], [[837, 837], "mapped", [953]], [[838, 846], "valid"], [[847, 847], "ignored"], [[848, 855], "valid"], [[856, 860], "valid"], [[861, 863], "valid"], [[864, 865], "valid"], [[866, 866], "valid"], [[867, 879], "valid"], [[880, 880], "mapped", [881]], [[881, 881], "valid"], [[882, 882], "mapped", [883]], [[883, 883], "valid"], [[884, 884], "mapped", [697]], [[885, 885], "valid"], [[886, 886], "mapped", [887]], [[887, 887], "valid"], [[888, 889], "disallowed"], [[890, 890], "disallowed_STD3_mapped", [32, 953]], [[891, 893], "valid"], [[894, 894], "disallowed_STD3_mapped", [59]], [[895, 895], "mapped", [1011]], [[896, 899], "disallowed"], [[900, 900], "disallowed_STD3_mapped", [32, 769]], [[901, 901], "disallowed_STD3_mapped", [32, 776, 769]], [[902, 902], "mapped", [940]], [[903, 903], "mapped", [183]], [[904, 904], "mapped", [941]], [[905, 905], "mapped", [942]], [[906, 906], "mapped", [943]], [[907, 907], "disallowed"], [[908, 908], "mapped", [972]], [[909, 909], "disallowed"], [[910, 910], "mapped", [973]], [[911, 911], "mapped", [974]], [[912, 912], "valid"], [[913, 913], "mapped", [945]], [[914, 914], "mapped", [946]], [[915, 915], "mapped", [947]], [[916, 916], "mapped", [948]], [[917, 917], "mapped", [949]], [[918, 918], "mapped", [950]], [[919, 919], "mapped", [951]], [[920, 920], "mapped", [952]], [[921, 921], "mapped", [953]], [[922, 922], "mapped", [954]], [[923, 923], "mapped", [955]], [[924, 924], "mapped", [956]], [[925, 925], "mapped", [957]], [[926, 926], "mapped", [958]], [[927, 927], "mapped", [959]], [[928, 928], "mapped", [960]], [[929, 929], "mapped", [961]], [[930, 930], "disallowed"], [[931, 931], "mapped", [963]], [[932, 932], "mapped", [964]], [[933, 933], "mapped", [965]], [[934, 934], "mapped", [966]], [[935, 935], "mapped", [967]], [[936, 936], "mapped", [968]], [[937, 937], "mapped", [969]], [[938, 938], "mapped", [970]], [[939, 939], "mapped", [971]], [[940, 961], "valid"], [[962, 962], "deviation", [963]], [[963, 974], "valid"], [[975, 975], "mapped", [983]], [[976, 976], "mapped", [946]], [[977, 977], "mapped", [952]], [[978, 978], "mapped", [965]], [[979, 979], "mapped", [973]], [[980, 980], "mapped", [971]], [[981, 981], "mapped", [966]], [[982, 982], "mapped", [960]], [[983, 983], "valid"], [[984, 984], "mapped", [985]], [[985, 985], "valid"], [[986, 986], "mapped", [987]], [[987, 987], "valid"], [[988, 988], "mapped", [989]], [[989, 989], "valid"], [[990, 990], "mapped", [991]], [[991, 991], "valid"], [[992, 992], "mapped", [993]], [[993, 993], "valid"], [[994, 994], "mapped", [995]], [[995, 995], "valid"], [[996, 996], "mapped", [997]], [[997, 997], "valid"], [[998, 998], "mapped", [999]], [[999, 999], "valid"], [[1e3, 1e3], "mapped", [1001]], [[1001, 1001], "valid"], [[1002, 1002], "mapped", [1003]], [[1003, 1003], "valid"], [[1004, 1004], "mapped", [1005]], [[1005, 1005], "valid"], [[1006, 1006], "mapped", [1007]], [[1007, 1007], "valid"], [[1008, 1008], "mapped", [954]], [[1009, 1009], "mapped", [961]], [[1010, 1010], "mapped", [963]], [[1011, 1011], "valid"], [[1012, 1012], "mapped", [952]], [[1013, 1013], "mapped", [949]], [[1014, 1014], "valid", [], "NV8"], [[1015, 1015], "mapped", [1016]], [[1016, 1016], "valid"], [[1017, 1017], "mapped", [963]], [[1018, 1018], "mapped", [1019]], [[1019, 1019], "valid"], [[1020, 1020], "valid"], [[1021, 1021], "mapped", [891]], [[1022, 1022], "mapped", [892]], [[1023, 1023], "mapped", [893]], [[1024, 1024], "mapped", [1104]], [[1025, 1025], "mapped", [1105]], [[1026, 1026], "mapped", [1106]], [[1027, 1027], "mapped", [1107]], [[1028, 1028], "mapped", [1108]], [[1029, 1029], "mapped", [1109]], [[1030, 1030], "mapped", [1110]], [[1031, 1031], "mapped", [1111]], [[1032, 1032], "mapped", [1112]], [[1033, 1033], "mapped", [1113]], [[1034, 1034], "mapped", [1114]], [[1035, 1035], "mapped", [1115]], [[1036, 1036], "mapped", [1116]], [[1037, 1037], "mapped", [1117]], [[1038, 1038], "mapped", [1118]], [[1039, 1039], "mapped", [1119]], [[1040, 1040], "mapped", [1072]], [[1041, 1041], "mapped", [1073]], [[1042, 1042], "mapped", [1074]], [[1043, 1043], "mapped", [1075]], [[1044, 1044], "mapped", [1076]], [[1045, 1045], "mapped", [1077]], [[1046, 1046], "mapped", [1078]], [[1047, 1047], "mapped", [1079]], [[1048, 1048], "mapped", [1080]], [[1049, 1049], "mapped", [1081]], [[1050, 1050], "mapped", [1082]], [[1051, 1051], "mapped", [1083]], [[1052, 1052], "mapped", [1084]], [[1053, 1053], "mapped", [1085]], [[1054, 1054], "mapped", [1086]], [[1055, 1055], "mapped", [1087]], [[1056, 1056], "mapped", [1088]], [[1057, 1057], "mapped", [1089]], [[1058, 1058], "mapped", [1090]], [[1059, 1059], "mapped", [1091]], [[1060, 1060], "mapped", [1092]], [[1061, 1061], "mapped", [1093]], [[1062, 1062], "mapped", [1094]], [[1063, 1063], "mapped", [1095]], [[1064, 1064], "mapped", [1096]], [[1065, 1065], "mapped", [1097]], [[1066, 1066], "mapped", [1098]], [[1067, 1067], "mapped", [1099]], [[1068, 1068], "mapped", [1100]], [[1069, 1069], "mapped", [1101]], [[1070, 1070], "mapped", [1102]], [[1071, 1071], "mapped", [1103]], [[1072, 1103], "valid"], [[1104, 1104], "valid"], [[1105, 1116], "valid"], [[1117, 1117], "valid"], [[1118, 1119], "valid"], [[1120, 1120], "mapped", [1121]], [[1121, 1121], "valid"], [[1122, 1122], "mapped", [1123]], [[1123, 1123], "valid"], [[1124, 1124], "mapped", [1125]], [[1125, 1125], "valid"], [[1126, 1126], "mapped", [1127]], [[1127, 1127], "valid"], [[1128, 1128], "mapped", [1129]], [[1129, 1129], "valid"], [[1130, 1130], "mapped", [1131]], [[1131, 1131], "valid"], [[1132, 1132], "mapped", [1133]], [[1133, 1133], "valid"], [[1134, 1134], "mapped", [1135]], [[1135, 1135], "valid"], [[1136, 1136], "mapped", [1137]], [[1137, 1137], "valid"], [[1138, 1138], "mapped", [1139]], [[1139, 1139], "valid"], [[1140, 1140], "mapped", [1141]], [[1141, 1141], "valid"], [[1142, 1142], "mapped", [1143]], [[1143, 1143], "valid"], [[1144, 1144], "mapped", [1145]], [[1145, 1145], "valid"], [[1146, 1146], "mapped", [1147]], [[1147, 1147], "valid"], [[1148, 1148], "mapped", [1149]], [[1149, 1149], "valid"], [[1150, 1150], "mapped", [1151]], [[1151, 1151], "valid"], [[1152, 1152], "mapped", [1153]], [[1153, 1153], "valid"], [[1154, 1154], "valid", [], "NV8"], [[1155, 1158], "valid"], [[1159, 1159], "valid"], [[1160, 1161], "valid", [], "NV8"], [[1162, 1162], "mapped", [1163]], [[1163, 1163], "valid"], [[1164, 1164], "mapped", [1165]], [[1165, 1165], "valid"], [[1166, 1166], "mapped", [1167]], [[1167, 1167], "valid"], [[1168, 1168], "mapped", [1169]], [[1169, 1169], "valid"], [[1170, 1170], "mapped", [1171]], [[1171, 1171], "valid"], [[1172, 1172], "mapped", [1173]], [[1173, 1173], "valid"], [[1174, 1174], "mapped", [1175]], [[1175, 1175], "valid"], [[1176, 1176], "mapped", [1177]], [[1177, 1177], "valid"], [[1178, 1178], "mapped", [1179]], [[1179, 1179], "valid"], [[1180, 1180], "mapped", [1181]], [[1181, 1181], "valid"], [[1182, 1182], "mapped", [1183]], [[1183, 1183], "valid"], [[1184, 1184], "mapped", [1185]], [[1185, 1185], "valid"], [[1186, 1186], "mapped", [1187]], [[1187, 1187], "valid"], [[1188, 1188], "mapped", [1189]], [[1189, 1189], "valid"], [[1190, 1190], "mapped", [1191]], [[1191, 1191], "valid"], [[1192, 1192], "mapped", [1193]], [[1193, 1193], "valid"], [[1194, 1194], "mapped", [1195]], [[1195, 1195], "valid"], [[1196, 1196], "mapped", [1197]], [[1197, 1197], "valid"], [[1198, 1198], "mapped", [1199]], [[1199, 1199], "valid"], [[1200, 1200], "mapped", [1201]], [[1201, 1201], "valid"], [[1202, 1202], "mapped", [1203]], [[1203, 1203], "valid"], [[1204, 1204], "mapped", [1205]], [[1205, 1205], "valid"], [[1206, 1206], "mapped", [1207]], [[1207, 1207], "valid"], [[1208, 1208], "mapped", [1209]], [[1209, 1209], "valid"], [[1210, 1210], "mapped", [1211]], [[1211, 1211], "valid"], [[1212, 1212], "mapped", [1213]], [[1213, 1213], "valid"], [[1214, 1214], "mapped", [1215]], [[1215, 1215], "valid"], [[1216, 1216], "disallowed"], [[1217, 1217], "mapped", [1218]], [[1218, 1218], "valid"], [[1219, 1219], "mapped", [1220]], [[1220, 1220], "valid"], [[1221, 1221], "mapped", [1222]], [[1222, 1222], "valid"], [[1223, 1223], "mapped", [1224]], [[1224, 1224], "valid"], [[1225, 1225], "mapped", [1226]], [[1226, 1226], "valid"], [[1227, 1227], "mapped", [1228]], [[1228, 1228], "valid"], [[1229, 1229], "mapped", [1230]], [[1230, 1230], "valid"], [[1231, 1231], "valid"], [[1232, 1232], "mapped", [1233]], [[1233, 1233], "valid"], [[1234, 1234], "mapped", [1235]], [[1235, 1235], "valid"], [[1236, 1236], "mapped", [1237]], [[1237, 1237], "valid"], [[1238, 1238], "mapped", [1239]], [[1239, 1239], "valid"], [[1240, 1240], "mapped", [1241]], [[1241, 1241], "valid"], [[1242, 1242], "mapped", [1243]], [[1243, 1243], "valid"], [[1244, 1244], "mapped", [1245]], [[1245, 1245], "valid"], [[1246, 1246], "mapped", [1247]], [[1247, 1247], "valid"], [[1248, 1248], "mapped", [1249]], [[1249, 1249], "valid"], [[1250, 1250], "mapped", [1251]], [[1251, 1251], "valid"], [[1252, 1252], "mapped", [1253]], [[1253, 1253], "valid"], [[1254, 1254], "mapped", [1255]], [[1255, 1255], "valid"], [[1256, 1256], "mapped", [1257]], [[1257, 1257], "valid"], [[1258, 1258], "mapped", [1259]], [[1259, 1259], "valid"], [[1260, 1260], "mapped", [1261]], [[1261, 1261], "valid"], [[1262, 1262], "mapped", [1263]], [[1263, 1263], "valid"], [[1264, 1264], "mapped", [1265]], [[1265, 1265], "valid"], [[1266, 1266], "mapped", [1267]], [[1267, 1267], "valid"], [[1268, 1268], "mapped", [1269]], [[1269, 1269], "valid"], [[1270, 1270], "mapped", [1271]], [[1271, 1271], "valid"], [[1272, 1272], "mapped", [1273]], [[1273, 1273], "valid"], [[1274, 1274], "mapped", [1275]], [[1275, 1275], "valid"], [[1276, 1276], "mapped", [1277]], [[1277, 1277], "valid"], [[1278, 1278], "mapped", [1279]], [[1279, 1279], "valid"], [[1280, 1280], "mapped", [1281]], [[1281, 1281], "valid"], [[1282, 1282], "mapped", [1283]], [[1283, 1283], "valid"], [[1284, 1284], "mapped", [1285]], [[1285, 1285], "valid"], [[1286, 1286], "mapped", [1287]], [[1287, 1287], "valid"], [[1288, 1288], "mapped", [1289]], [[1289, 1289], "valid"], [[1290, 1290], "mapped", [1291]], [[1291, 1291], "valid"], [[1292, 1292], "mapped", [1293]], [[1293, 1293], "valid"], [[1294, 1294], "mapped", [1295]], [[1295, 1295], "valid"], [[1296, 1296], "mapped", [1297]], [[1297, 1297], "valid"], [[1298, 1298], "mapped", [1299]], [[1299, 1299], "valid"], [[1300, 1300], "mapped", [1301]], [[1301, 1301], "valid"], [[1302, 1302], "mapped", [1303]], [[1303, 1303], "valid"], [[1304, 1304], "mapped", [1305]], [[1305, 1305], "valid"], [[1306, 1306], "mapped", [1307]], [[1307, 1307], "valid"], [[1308, 1308], "mapped", [1309]], [[1309, 1309], "valid"], [[1310, 1310], "mapped", [1311]], [[1311, 1311], "valid"], [[1312, 1312], "mapped", [1313]], [[1313, 1313], "valid"], [[1314, 1314], "mapped", [1315]], [[1315, 1315], "valid"], [[1316, 1316], "mapped", [1317]], [[1317, 1317], "valid"], [[1318, 1318], "mapped", [1319]], [[1319, 1319], "valid"], [[1320, 1320], "mapped", [1321]], [[1321, 1321], "valid"], [[1322, 1322], "mapped", [1323]], [[1323, 1323], "valid"], [[1324, 1324], "mapped", [1325]], [[1325, 1325], "valid"], [[1326, 1326], "mapped", [1327]], [[1327, 1327], "valid"], [[1328, 1328], "disallowed"], [[1329, 1329], "mapped", [1377]], [[1330, 1330], "mapped", [1378]], [[1331, 1331], "mapped", [1379]], [[1332, 1332], "mapped", [1380]], [[1333, 1333], "mapped", [1381]], [[1334, 1334], "mapped", [1382]], [[1335, 1335], "mapped", [1383]], [[1336, 1336], "mapped", [1384]], [[1337, 1337], "mapped", [1385]], [[1338, 1338], "mapped", [1386]], [[1339, 1339], "mapped", [1387]], [[1340, 1340], "mapped", [1388]], [[1341, 1341], "mapped", [1389]], [[1342, 1342], "mapped", [1390]], [[1343, 1343], "mapped", [1391]], [[1344, 1344], "mapped", [1392]], [[1345, 1345], "mapped", [1393]], [[1346, 1346], "mapped", [1394]], [[1347, 1347], "mapped", [1395]], [[1348, 1348], "mapped", [1396]], [[1349, 1349], "mapped", [1397]], [[1350, 1350], "mapped", [1398]], [[1351, 1351], "mapped", [1399]], [[1352, 1352], "mapped", [1400]], [[1353, 1353], "mapped", [1401]], [[1354, 1354], "mapped", [1402]], [[1355, 1355], "mapped", [1403]], [[1356, 1356], "mapped", [1404]], [[1357, 1357], "mapped", [1405]], [[1358, 1358], "mapped", [1406]], [[1359, 1359], "mapped", [1407]], [[1360, 1360], "mapped", [1408]], [[1361, 1361], "mapped", [1409]], [[1362, 1362], "mapped", [1410]], [[1363, 1363], "mapped", [1411]], [[1364, 1364], "mapped", [1412]], [[1365, 1365], "mapped", [1413]], [[1366, 1366], "mapped", [1414]], [[1367, 1368], "disallowed"], [[1369, 1369], "valid"], [[1370, 1375], "valid", [], "NV8"], [[1376, 1376], "disallowed"], [[1377, 1414], "valid"], [[1415, 1415], "mapped", [1381, 1410]], [[1416, 1416], "disallowed"], [[1417, 1417], "valid", [], "NV8"], [[1418, 1418], "valid", [], "NV8"], [[1419, 1420], "disallowed"], [[1421, 1422], "valid", [], "NV8"], [[1423, 1423], "valid", [], "NV8"], [[1424, 1424], "disallowed"], [[1425, 1441], "valid"], [[1442, 1442], "valid"], [[1443, 1455], "valid"], [[1456, 1465], "valid"], [[1466, 1466], "valid"], [[1467, 1469], "valid"], [[1470, 1470], "valid", [], "NV8"], [[1471, 1471], "valid"], [[1472, 1472], "valid", [], "NV8"], [[1473, 1474], "valid"], [[1475, 1475], "valid", [], "NV8"], [[1476, 1476], "valid"], [[1477, 1477], "valid"], [[1478, 1478], "valid", [], "NV8"], [[1479, 1479], "valid"], [[1480, 1487], "disallowed"], [[1488, 1514], "valid"], [[1515, 1519], "disallowed"], [[1520, 1524], "valid"], [[1525, 1535], "disallowed"], [[1536, 1539], "disallowed"], [[1540, 1540], "disallowed"], [[1541, 1541], "disallowed"], [[1542, 1546], "valid", [], "NV8"], [[1547, 1547], "valid", [], "NV8"], [[1548, 1548], "valid", [], "NV8"], [[1549, 1551], "valid", [], "NV8"], [[1552, 1557], "valid"], [[1558, 1562], "valid"], [[1563, 1563], "valid", [], "NV8"], [[1564, 1564], "disallowed"], [[1565, 1565], "disallowed"], [[1566, 1566], "valid", [], "NV8"], [[1567, 1567], "valid", [], "NV8"], [[1568, 1568], "valid"], [[1569, 1594], "valid"], [[1595, 1599], "valid"], [[1600, 1600], "valid", [], "NV8"], [[1601, 1618], "valid"], [[1619, 1621], "valid"], [[1622, 1624], "valid"], [[1625, 1630], "valid"], [[1631, 1631], "valid"], [[1632, 1641], "valid"], [[1642, 1645], "valid", [], "NV8"], [[1646, 1647], "valid"], [[1648, 1652], "valid"], [[1653, 1653], "mapped", [1575, 1652]], [[1654, 1654], "mapped", [1608, 1652]], [[1655, 1655], "mapped", [1735, 1652]], [[1656, 1656], "mapped", [1610, 1652]], [[1657, 1719], "valid"], [[1720, 1721], "valid"], [[1722, 1726], "valid"], [[1727, 1727], "valid"], [[1728, 1742], "valid"], [[1743, 1743], "valid"], [[1744, 1747], "valid"], [[1748, 1748], "valid", [], "NV8"], [[1749, 1756], "valid"], [[1757, 1757], "disallowed"], [[1758, 1758], "valid", [], "NV8"], [[1759, 1768], "valid"], [[1769, 1769], "valid", [], "NV8"], [[1770, 1773], "valid"], [[1774, 1775], "valid"], [[1776, 1785], "valid"], [[1786, 1790], "valid"], [[1791, 1791], "valid"], [[1792, 1805], "valid", [], "NV8"], [[1806, 1806], "disallowed"], [[1807, 1807], "disallowed"], [[1808, 1836], "valid"], [[1837, 1839], "valid"], [[1840, 1866], "valid"], [[1867, 1868], "disallowed"], [[1869, 1871], "valid"], [[1872, 1901], "valid"], [[1902, 1919], "valid"], [[1920, 1968], "valid"], [[1969, 1969], "valid"], [[1970, 1983], "disallowed"], [[1984, 2037], "valid"], [[2038, 2042], "valid", [], "NV8"], [[2043, 2047], "disallowed"], [[2048, 2093], "valid"], [[2094, 2095], "disallowed"], [[2096, 2110], "valid", [], "NV8"], [[2111, 2111], "disallowed"], [[2112, 2139], "valid"], [[2140, 2141], "disallowed"], [[2142, 2142], "valid", [], "NV8"], [[2143, 2207], "disallowed"], [[2208, 2208], "valid"], [[2209, 2209], "valid"], [[2210, 2220], "valid"], [[2221, 2226], "valid"], [[2227, 2228], "valid"], [[2229, 2274], "disallowed"], [[2275, 2275], "valid"], [[2276, 2302], "valid"], [[2303, 2303], "valid"], [[2304, 2304], "valid"], [[2305, 2307], "valid"], [[2308, 2308], "valid"], [[2309, 2361], "valid"], [[2362, 2363], "valid"], [[2364, 2381], "valid"], [[2382, 2382], "valid"], [[2383, 2383], "valid"], [[2384, 2388], "valid"], [[2389, 2389], "valid"], [[2390, 2391], "valid"], [[2392, 2392], "mapped", [2325, 2364]], [[2393, 2393], "mapped", [2326, 2364]], [[2394, 2394], "mapped", [2327, 2364]], [[2395, 2395], "mapped", [2332, 2364]], [[2396, 2396], "mapped", [2337, 2364]], [[2397, 2397], "mapped", [2338, 2364]], [[2398, 2398], "mapped", [2347, 2364]], [[2399, 2399], "mapped", [2351, 2364]], [[2400, 2403], "valid"], [[2404, 2405], "valid", [], "NV8"], [[2406, 2415], "valid"], [[2416, 2416], "valid", [], "NV8"], [[2417, 2418], "valid"], [[2419, 2423], "valid"], [[2424, 2424], "valid"], [[2425, 2426], "valid"], [[2427, 2428], "valid"], [[2429, 2429], "valid"], [[2430, 2431], "valid"], [[2432, 2432], "valid"], [[2433, 2435], "valid"], [[2436, 2436], "disallowed"], [[2437, 2444], "valid"], [[2445, 2446], "disallowed"], [[2447, 2448], "valid"], [[2449, 2450], "disallowed"], [[2451, 2472], "valid"], [[2473, 2473], "disallowed"], [[2474, 2480], "valid"], [[2481, 2481], "disallowed"], [[2482, 2482], "valid"], [[2483, 2485], "disallowed"], [[2486, 2489], "valid"], [[2490, 2491], "disallowed"], [[2492, 2492], "valid"], [[2493, 2493], "valid"], [[2494, 2500], "valid"], [[2501, 2502], "disallowed"], [[2503, 2504], "valid"], [[2505, 2506], "disallowed"], [[2507, 2509], "valid"], [[2510, 2510], "valid"], [[2511, 2518], "disallowed"], [[2519, 2519], "valid"], [[2520, 2523], "disallowed"], [[2524, 2524], "mapped", [2465, 2492]], [[2525, 2525], "mapped", [2466, 2492]], [[2526, 2526], "disallowed"], [[2527, 2527], "mapped", [2479, 2492]], [[2528, 2531], "valid"], [[2532, 2533], "disallowed"], [[2534, 2545], "valid"], [[2546, 2554], "valid", [], "NV8"], [[2555, 2555], "valid", [], "NV8"], [[2556, 2560], "disallowed"], [[2561, 2561], "valid"], [[2562, 2562], "valid"], [[2563, 2563], "valid"], [[2564, 2564], "disallowed"], [[2565, 2570], "valid"], [[2571, 2574], "disallowed"], [[2575, 2576], "valid"], [[2577, 2578], "disallowed"], [[2579, 2600], "valid"], [[2601, 2601], "disallowed"], [[2602, 2608], "valid"], [[2609, 2609], "disallowed"], [[2610, 2610], "valid"], [[2611, 2611], "mapped", [2610, 2620]], [[2612, 2612], "disallowed"], [[2613, 2613], "valid"], [[2614, 2614], "mapped", [2616, 2620]], [[2615, 2615], "disallowed"], [[2616, 2617], "valid"], [[2618, 2619], "disallowed"], [[2620, 2620], "valid"], [[2621, 2621], "disallowed"], [[2622, 2626], "valid"], [[2627, 2630], "disallowed"], [[2631, 2632], "valid"], [[2633, 2634], "disallowed"], [[2635, 2637], "valid"], [[2638, 2640], "disallowed"], [[2641, 2641], "valid"], [[2642, 2648], "disallowed"], [[2649, 2649], "mapped", [2582, 2620]], [[2650, 2650], "mapped", [2583, 2620]], [[2651, 2651], "mapped", [2588, 2620]], [[2652, 2652], "valid"], [[2653, 2653], "disallowed"], [[2654, 2654], "mapped", [2603, 2620]], [[2655, 2661], "disallowed"], [[2662, 2676], "valid"], [[2677, 2677], "valid"], [[2678, 2688], "disallowed"], [[2689, 2691], "valid"], [[2692, 2692], "disallowed"], [[2693, 2699], "valid"], [[2700, 2700], "valid"], [[2701, 2701], "valid"], [[2702, 2702], "disallowed"], [[2703, 2705], "valid"], [[2706, 2706], "disallowed"], [[2707, 2728], "valid"], [[2729, 2729], "disallowed"], [[2730, 2736], "valid"], [[2737, 2737], "disallowed"], [[2738, 2739], "valid"], [[2740, 2740], "disallowed"], [[2741, 2745], "valid"], [[2746, 2747], "disallowed"], [[2748, 2757], "valid"], [[2758, 2758], "disallowed"], [[2759, 2761], "valid"], [[2762, 2762], "disallowed"], [[2763, 2765], "valid"], [[2766, 2767], "disallowed"], [[2768, 2768], "valid"], [[2769, 2783], "disallowed"], [[2784, 2784], "valid"], [[2785, 2787], "valid"], [[2788, 2789], "disallowed"], [[2790, 2799], "valid"], [[2800, 2800], "valid", [], "NV8"], [[2801, 2801], "valid", [], "NV8"], [[2802, 2808], "disallowed"], [[2809, 2809], "valid"], [[2810, 2816], "disallowed"], [[2817, 2819], "valid"], [[2820, 2820], "disallowed"], [[2821, 2828], "valid"], [[2829, 2830], "disallowed"], [[2831, 2832], "valid"], [[2833, 2834], "disallowed"], [[2835, 2856], "valid"], [[2857, 2857], "disallowed"], [[2858, 2864], "valid"], [[2865, 2865], "disallowed"], [[2866, 2867], "valid"], [[2868, 2868], "disallowed"], [[2869, 2869], "valid"], [[2870, 2873], "valid"], [[2874, 2875], "disallowed"], [[2876, 2883], "valid"], [[2884, 2884], "valid"], [[2885, 2886], "disallowed"], [[2887, 2888], "valid"], [[2889, 2890], "disallowed"], [[2891, 2893], "valid"], [[2894, 2901], "disallowed"], [[2902, 2903], "valid"], [[2904, 2907], "disallowed"], [[2908, 2908], "mapped", [2849, 2876]], [[2909, 2909], "mapped", [2850, 2876]], [[2910, 2910], "disallowed"], [[2911, 2913], "valid"], [[2914, 2915], "valid"], [[2916, 2917], "disallowed"], [[2918, 2927], "valid"], [[2928, 2928], "valid", [], "NV8"], [[2929, 2929], "valid"], [[2930, 2935], "valid", [], "NV8"], [[2936, 2945], "disallowed"], [[2946, 2947], "valid"], [[2948, 2948], "disallowed"], [[2949, 2954], "valid"], [[2955, 2957], "disallowed"], [[2958, 2960], "valid"], [[2961, 2961], "disallowed"], [[2962, 2965], "valid"], [[2966, 2968], "disallowed"], [[2969, 2970], "valid"], [[2971, 2971], "disallowed"], [[2972, 2972], "valid"], [[2973, 2973], "disallowed"], [[2974, 2975], "valid"], [[2976, 2978], "disallowed"], [[2979, 2980], "valid"], [[2981, 2983], "disallowed"], [[2984, 2986], "valid"], [[2987, 2989], "disallowed"], [[2990, 2997], "valid"], [[2998, 2998], "valid"], [[2999, 3001], "valid"], [[3002, 3005], "disallowed"], [[3006, 3010], "valid"], [[3011, 3013], "disallowed"], [[3014, 3016], "valid"], [[3017, 3017], "disallowed"], [[3018, 3021], "valid"], [[3022, 3023], "disallowed"], [[3024, 3024], "valid"], [[3025, 3030], "disallowed"], [[3031, 3031], "valid"], [[3032, 3045], "disallowed"], [[3046, 3046], "valid"], [[3047, 3055], "valid"], [[3056, 3058], "valid", [], "NV8"], [[3059, 3066], "valid", [], "NV8"], [[3067, 3071], "disallowed"], [[3072, 3072], "valid"], [[3073, 3075], "valid"], [[3076, 3076], "disallowed"], [[3077, 3084], "valid"], [[3085, 3085], "disallowed"], [[3086, 3088], "valid"], [[3089, 3089], "disallowed"], [[3090, 3112], "valid"], [[3113, 3113], "disallowed"], [[3114, 3123], "valid"], [[3124, 3124], "valid"], [[3125, 3129], "valid"], [[3130, 3132], "disallowed"], [[3133, 3133], "valid"], [[3134, 3140], "valid"], [[3141, 3141], "disallowed"], [[3142, 3144], "valid"], [[3145, 3145], "disallowed"], [[3146, 3149], "valid"], [[3150, 3156], "disallowed"], [[3157, 3158], "valid"], [[3159, 3159], "disallowed"], [[3160, 3161], "valid"], [[3162, 3162], "valid"], [[3163, 3167], "disallowed"], [[3168, 3169], "valid"], [[3170, 3171], "valid"], [[3172, 3173], "disallowed"], [[3174, 3183], "valid"], [[3184, 3191], "disallowed"], [[3192, 3199], "valid", [], "NV8"], [[3200, 3200], "disallowed"], [[3201, 3201], "valid"], [[3202, 3203], "valid"], [[3204, 3204], "disallowed"], [[3205, 3212], "valid"], [[3213, 3213], "disallowed"], [[3214, 3216], "valid"], [[3217, 3217], "disallowed"], [[3218, 3240], "valid"], [[3241, 3241], "disallowed"], [[3242, 3251], "valid"], [[3252, 3252], "disallowed"], [[3253, 3257], "valid"], [[3258, 3259], "disallowed"], [[3260, 3261], "valid"], [[3262, 3268], "valid"], [[3269, 3269], "disallowed"], [[3270, 3272], "valid"], [[3273, 3273], "disallowed"], [[3274, 3277], "valid"], [[3278, 3284], "disallowed"], [[3285, 3286], "valid"], [[3287, 3293], "disallowed"], [[3294, 3294], "valid"], [[3295, 3295], "disallowed"], [[3296, 3297], "valid"], [[3298, 3299], "valid"], [[3300, 3301], "disallowed"], [[3302, 3311], "valid"], [[3312, 3312], "disallowed"], [[3313, 3314], "valid"], [[3315, 3328], "disallowed"], [[3329, 3329], "valid"], [[3330, 3331], "valid"], [[3332, 3332], "disallowed"], [[3333, 3340], "valid"], [[3341, 3341], "disallowed"], [[3342, 3344], "valid"], [[3345, 3345], "disallowed"], [[3346, 3368], "valid"], [[3369, 3369], "valid"], [[3370, 3385], "valid"], [[3386, 3386], "valid"], [[3387, 3388], "disallowed"], [[3389, 3389], "valid"], [[3390, 3395], "valid"], [[3396, 3396], "valid"], [[3397, 3397], "disallowed"], [[3398, 3400], "valid"], [[3401, 3401], "disallowed"], [[3402, 3405], "valid"], [[3406, 3406], "valid"], [[3407, 3414], "disallowed"], [[3415, 3415], "valid"], [[3416, 3422], "disallowed"], [[3423, 3423], "valid"], [[3424, 3425], "valid"], [[3426, 3427], "valid"], [[3428, 3429], "disallowed"], [[3430, 3439], "valid"], [[3440, 3445], "valid", [], "NV8"], [[3446, 3448], "disallowed"], [[3449, 3449], "valid", [], "NV8"], [[3450, 3455], "valid"], [[3456, 3457], "disallowed"], [[3458, 3459], "valid"], [[3460, 3460], "disallowed"], [[3461, 3478], "valid"], [[3479, 3481], "disallowed"], [[3482, 3505], "valid"], [[3506, 3506], "disallowed"], [[3507, 3515], "valid"], [[3516, 3516], "disallowed"], [[3517, 3517], "valid"], [[3518, 3519], "disallowed"], [[3520, 3526], "valid"], [[3527, 3529], "disallowed"], [[3530, 3530], "valid"], [[3531, 3534], "disallowed"], [[3535, 3540], "valid"], [[3541, 3541], "disallowed"], [[3542, 3542], "valid"], [[3543, 3543], "disallowed"], [[3544, 3551], "valid"], [[3552, 3557], "disallowed"], [[3558, 3567], "valid"], [[3568, 3569], "disallowed"], [[3570, 3571], "valid"], [[3572, 3572], "valid", [], "NV8"], [[3573, 3584], "disallowed"], [[3585, 3634], "valid"], [[3635, 3635], "mapped", [3661, 3634]], [[3636, 3642], "valid"], [[3643, 3646], "disallowed"], [[3647, 3647], "valid", [], "NV8"], [[3648, 3662], "valid"], [[3663, 3663], "valid", [], "NV8"], [[3664, 3673], "valid"], [[3674, 3675], "valid", [], "NV8"], [[3676, 3712], "disallowed"], [[3713, 3714], "valid"], [[3715, 3715], "disallowed"], [[3716, 3716], "valid"], [[3717, 3718], "disallowed"], [[3719, 3720], "valid"], [[3721, 3721], "disallowed"], [[3722, 3722], "valid"], [[3723, 3724], "disallowed"], [[3725, 3725], "valid"], [[3726, 3731], "disallowed"], [[3732, 3735], "valid"], [[3736, 3736], "disallowed"], [[3737, 3743], "valid"], [[3744, 3744], "disallowed"], [[3745, 3747], "valid"], [[3748, 3748], "disallowed"], [[3749, 3749], "valid"], [[3750, 3750], "disallowed"], [[3751, 3751], "valid"], [[3752, 3753], "disallowed"], [[3754, 3755], "valid"], [[3756, 3756], "disallowed"], [[3757, 3762], "valid"], [[3763, 3763], "mapped", [3789, 3762]], [[3764, 3769], "valid"], [[3770, 3770], "disallowed"], [[3771, 3773], "valid"], [[3774, 3775], "disallowed"], [[3776, 3780], "valid"], [[3781, 3781], "disallowed"], [[3782, 3782], "valid"], [[3783, 3783], "disallowed"], [[3784, 3789], "valid"], [[3790, 3791], "disallowed"], [[3792, 3801], "valid"], [[3802, 3803], "disallowed"], [[3804, 3804], "mapped", [3755, 3737]], [[3805, 3805], "mapped", [3755, 3745]], [[3806, 3807], "valid"], [[3808, 3839], "disallowed"], [[3840, 3840], "valid"], [[3841, 3850], "valid", [], "NV8"], [[3851, 3851], "valid"], [[3852, 3852], "mapped", [3851]], [[3853, 3863], "valid", [], "NV8"], [[3864, 3865], "valid"], [[3866, 3871], "valid", [], "NV8"], [[3872, 3881], "valid"], [[3882, 3892], "valid", [], "NV8"], [[3893, 3893], "valid"], [[3894, 3894], "valid", [], "NV8"], [[3895, 3895], "valid"], [[3896, 3896], "valid", [], "NV8"], [[3897, 3897], "valid"], [[3898, 3901], "valid", [], "NV8"], [[3902, 3906], "valid"], [[3907, 3907], "mapped", [3906, 4023]], [[3908, 3911], "valid"], [[3912, 3912], "disallowed"], [[3913, 3916], "valid"], [[3917, 3917], "mapped", [3916, 4023]], [[3918, 3921], "valid"], [[3922, 3922], "mapped", [3921, 4023]], [[3923, 3926], "valid"], [[3927, 3927], "mapped", [3926, 4023]], [[3928, 3931], "valid"], [[3932, 3932], "mapped", [3931, 4023]], [[3933, 3944], "valid"], [[3945, 3945], "mapped", [3904, 4021]], [[3946, 3946], "valid"], [[3947, 3948], "valid"], [[3949, 3952], "disallowed"], [[3953, 3954], "valid"], [[3955, 3955], "mapped", [3953, 3954]], [[3956, 3956], "valid"], [[3957, 3957], "mapped", [3953, 3956]], [[3958, 3958], "mapped", [4018, 3968]], [[3959, 3959], "mapped", [4018, 3953, 3968]], [[3960, 3960], "mapped", [4019, 3968]], [[3961, 3961], "mapped", [4019, 3953, 3968]], [[3962, 3968], "valid"], [[3969, 3969], "mapped", [3953, 3968]], [[3970, 3972], "valid"], [[3973, 3973], "valid", [], "NV8"], [[3974, 3979], "valid"], [[3980, 3983], "valid"], [[3984, 3986], "valid"], [[3987, 3987], "mapped", [3986, 4023]], [[3988, 3989], "valid"], [[3990, 3990], "valid"], [[3991, 3991], "valid"], [[3992, 3992], "disallowed"], [[3993, 3996], "valid"], [[3997, 3997], "mapped", [3996, 4023]], [[3998, 4001], "valid"], [[4002, 4002], "mapped", [4001, 4023]], [[4003, 4006], "valid"], [[4007, 4007], "mapped", [4006, 4023]], [[4008, 4011], "valid"], [[4012, 4012], "mapped", [4011, 4023]], [[4013, 4013], "valid"], [[4014, 4016], "valid"], [[4017, 4023], "valid"], [[4024, 4024], "valid"], [[4025, 4025], "mapped", [3984, 4021]], [[4026, 4028], "valid"], [[4029, 4029], "disallowed"], [[4030, 4037], "valid", [], "NV8"], [[4038, 4038], "valid"], [[4039, 4044], "valid", [], "NV8"], [[4045, 4045], "disallowed"], [[4046, 4046], "valid", [], "NV8"], [[4047, 4047], "valid", [], "NV8"], [[4048, 4049], "valid", [], "NV8"], [[4050, 4052], "valid", [], "NV8"], [[4053, 4056], "valid", [], "NV8"], [[4057, 4058], "valid", [], "NV8"], [[4059, 4095], "disallowed"], [[4096, 4129], "valid"], [[4130, 4130], "valid"], [[4131, 4135], "valid"], [[4136, 4136], "valid"], [[4137, 4138], "valid"], [[4139, 4139], "valid"], [[4140, 4146], "valid"], [[4147, 4149], "valid"], [[4150, 4153], "valid"], [[4154, 4159], "valid"], [[4160, 4169], "valid"], [[4170, 4175], "valid", [], "NV8"], [[4176, 4185], "valid"], [[4186, 4249], "valid"], [[4250, 4253], "valid"], [[4254, 4255], "valid", [], "NV8"], [[4256, 4293], "disallowed"], [[4294, 4294], "disallowed"], [[4295, 4295], "mapped", [11559]], [[4296, 4300], "disallowed"], [[4301, 4301], "mapped", [11565]], [[4302, 4303], "disallowed"], [[4304, 4342], "valid"], [[4343, 4344], "valid"], [[4345, 4346], "valid"], [[4347, 4347], "valid", [], "NV8"], [[4348, 4348], "mapped", [4316]], [[4349, 4351], "valid"], [[4352, 4441], "valid", [], "NV8"], [[4442, 4446], "valid", [], "NV8"], [[4447, 4448], "disallowed"], [[4449, 4514], "valid", [], "NV8"], [[4515, 4519], "valid", [], "NV8"], [[4520, 4601], "valid", [], "NV8"], [[4602, 4607], "valid", [], "NV8"], [[4608, 4614], "valid"], [[4615, 4615], "valid"], [[4616, 4678], "valid"], [[4679, 4679], "valid"], [[4680, 4680], "valid"], [[4681, 4681], "disallowed"], [[4682, 4685], "valid"], [[4686, 4687], "disallowed"], [[4688, 4694], "valid"], [[4695, 4695], "disallowed"], [[4696, 4696], "valid"], [[4697, 4697], "disallowed"], [[4698, 4701], "valid"], [[4702, 4703], "disallowed"], [[4704, 4742], "valid"], [[4743, 4743], "valid"], [[4744, 4744], "valid"], [[4745, 4745], "disallowed"], [[4746, 4749], "valid"], [[4750, 4751], "disallowed"], [[4752, 4782], "valid"], [[4783, 4783], "valid"], [[4784, 4784], "valid"], [[4785, 4785], "disallowed"], [[4786, 4789], "valid"], [[4790, 4791], "disallowed"], [[4792, 4798], "valid"], [[4799, 4799], "disallowed"], [[4800, 4800], "valid"], [[4801, 4801], "disallowed"], [[4802, 4805], "valid"], [[4806, 4807], "disallowed"], [[4808, 4814], "valid"], [[4815, 4815], "valid"], [[4816, 4822], "valid"], [[4823, 4823], "disallowed"], [[4824, 4846], "valid"], [[4847, 4847], "valid"], [[4848, 4878], "valid"], [[4879, 4879], "valid"], [[4880, 4880], "valid"], [[4881, 4881], "disallowed"], [[4882, 4885], "valid"], [[4886, 4887], "disallowed"], [[4888, 4894], "valid"], [[4895, 4895], "valid"], [[4896, 4934], "valid"], [[4935, 4935], "valid"], [[4936, 4954], "valid"], [[4955, 4956], "disallowed"], [[4957, 4958], "valid"], [[4959, 4959], "valid"], [[4960, 4960], "valid", [], "NV8"], [[4961, 4988], "valid", [], "NV8"], [[4989, 4991], "disallowed"], [[4992, 5007], "valid"], [[5008, 5017], "valid", [], "NV8"], [[5018, 5023], "disallowed"], [[5024, 5108], "valid"], [[5109, 5109], "valid"], [[5110, 5111], "disallowed"], [[5112, 5112], "mapped", [5104]], [[5113, 5113], "mapped", [5105]], [[5114, 5114], "mapped", [5106]], [[5115, 5115], "mapped", [5107]], [[5116, 5116], "mapped", [5108]], [[5117, 5117], "mapped", [5109]], [[5118, 5119], "disallowed"], [[5120, 5120], "valid", [], "NV8"], [[5121, 5740], "valid"], [[5741, 5742], "valid", [], "NV8"], [[5743, 5750], "valid"], [[5751, 5759], "valid"], [[5760, 5760], "disallowed"], [[5761, 5786], "valid"], [[5787, 5788], "valid", [], "NV8"], [[5789, 5791], "disallowed"], [[5792, 5866], "valid"], [[5867, 5872], "valid", [], "NV8"], [[5873, 5880], "valid"], [[5881, 5887], "disallowed"], [[5888, 5900], "valid"], [[5901, 5901], "disallowed"], [[5902, 5908], "valid"], [[5909, 5919], "disallowed"], [[5920, 5940], "valid"], [[5941, 5942], "valid", [], "NV8"], [[5943, 5951], "disallowed"], [[5952, 5971], "valid"], [[5972, 5983], "disallowed"], [[5984, 5996], "valid"], [[5997, 5997], "disallowed"], [[5998, 6e3], "valid"], [[6001, 6001], "disallowed"], [[6002, 6003], "valid"], [[6004, 6015], "disallowed"], [[6016, 6067], "valid"], [[6068, 6069], "disallowed"], [[6070, 6099], "valid"], [[6100, 6102], "valid", [], "NV8"], [[6103, 6103], "valid"], [[6104, 6107], "valid", [], "NV8"], [[6108, 6108], "valid"], [[6109, 6109], "valid"], [[6110, 6111], "disallowed"], [[6112, 6121], "valid"], [[6122, 6127], "disallowed"], [[6128, 6137], "valid", [], "NV8"], [[6138, 6143], "disallowed"], [[6144, 6149], "valid", [], "NV8"], [[6150, 6150], "disallowed"], [[6151, 6154], "valid", [], "NV8"], [[6155, 6157], "ignored"], [[6158, 6158], "disallowed"], [[6159, 6159], "disallowed"], [[6160, 6169], "valid"], [[6170, 6175], "disallowed"], [[6176, 6263], "valid"], [[6264, 6271], "disallowed"], [[6272, 6313], "valid"], [[6314, 6314], "valid"], [[6315, 6319], "disallowed"], [[6320, 6389], "valid"], [[6390, 6399], "disallowed"], [[6400, 6428], "valid"], [[6429, 6430], "valid"], [[6431, 6431], "disallowed"], [[6432, 6443], "valid"], [[6444, 6447], "disallowed"], [[6448, 6459], "valid"], [[6460, 6463], "disallowed"], [[6464, 6464], "valid", [], "NV8"], [[6465, 6467], "disallowed"], [[6468, 6469], "valid", [], "NV8"], [[6470, 6509], "valid"], [[6510, 6511], "disallowed"], [[6512, 6516], "valid"], [[6517, 6527], "disallowed"], [[6528, 6569], "valid"], [[6570, 6571], "valid"], [[6572, 6575], "disallowed"], [[6576, 6601], "valid"], [[6602, 6607], "disallowed"], [[6608, 6617], "valid"], [[6618, 6618], "valid", [], "XV8"], [[6619, 6621], "disallowed"], [[6622, 6623], "valid", [], "NV8"], [[6624, 6655], "valid", [], "NV8"], [[6656, 6683], "valid"], [[6684, 6685], "disallowed"], [[6686, 6687], "valid", [], "NV8"], [[6688, 6750], "valid"], [[6751, 6751], "disallowed"], [[6752, 6780], "valid"], [[6781, 6782], "disallowed"], [[6783, 6793], "valid"], [[6794, 6799], "disallowed"], [[6800, 6809], "valid"], [[6810, 6815], "disallowed"], [[6816, 6822], "valid", [], "NV8"], [[6823, 6823], "valid"], [[6824, 6829], "valid", [], "NV8"], [[6830, 6831], "disallowed"], [[6832, 6845], "valid"], [[6846, 6846], "valid", [], "NV8"], [[6847, 6911], "disallowed"], [[6912, 6987], "valid"], [[6988, 6991], "disallowed"], [[6992, 7001], "valid"], [[7002, 7018], "valid", [], "NV8"], [[7019, 7027], "valid"], [[7028, 7036], "valid", [], "NV8"], [[7037, 7039], "disallowed"], [[7040, 7082], "valid"], [[7083, 7085], "valid"], [[7086, 7097], "valid"], [[7098, 7103], "valid"], [[7104, 7155], "valid"], [[7156, 7163], "disallowed"], [[7164, 7167], "valid", [], "NV8"], [[7168, 7223], "valid"], [[7224, 7226], "disallowed"], [[7227, 7231], "valid", [], "NV8"], [[7232, 7241], "valid"], [[7242, 7244], "disallowed"], [[7245, 7293], "valid"], [[7294, 7295], "valid", [], "NV8"], [[7296, 7359], "disallowed"], [[7360, 7367], "valid", [], "NV8"], [[7368, 7375], "disallowed"], [[7376, 7378], "valid"], [[7379, 7379], "valid", [], "NV8"], [[7380, 7410], "valid"], [[7411, 7414], "valid"], [[7415, 7415], "disallowed"], [[7416, 7417], "valid"], [[7418, 7423], "disallowed"], [[7424, 7467], "valid"], [[7468, 7468], "mapped", [97]], [[7469, 7469], "mapped", [230]], [[7470, 7470], "mapped", [98]], [[7471, 7471], "valid"], [[7472, 7472], "mapped", [100]], [[7473, 7473], "mapped", [101]], [[7474, 7474], "mapped", [477]], [[7475, 7475], "mapped", [103]], [[7476, 7476], "mapped", [104]], [[7477, 7477], "mapped", [105]], [[7478, 7478], "mapped", [106]], [[7479, 7479], "mapped", [107]], [[7480, 7480], "mapped", [108]], [[7481, 7481], "mapped", [109]], [[7482, 7482], "mapped", [110]], [[7483, 7483], "valid"], [[7484, 7484], "mapped", [111]], [[7485, 7485], "mapped", [547]], [[7486, 7486], "mapped", [112]], [[7487, 7487], "mapped", [114]], [[7488, 7488], "mapped", [116]], [[7489, 7489], "mapped", [117]], [[7490, 7490], "mapped", [119]], [[7491, 7491], "mapped", [97]], [[7492, 7492], "mapped", [592]], [[7493, 7493], "mapped", [593]], [[7494, 7494], "mapped", [7426]], [[7495, 7495], "mapped", [98]], [[7496, 7496], "mapped", [100]], [[7497, 7497], "mapped", [101]], [[7498, 7498], "mapped", [601]], [[7499, 7499], "mapped", [603]], [[7500, 7500], "mapped", [604]], [[7501, 7501], "mapped", [103]], [[7502, 7502], "valid"], [[7503, 7503], "mapped", [107]], [[7504, 7504], "mapped", [109]], [[7505, 7505], "mapped", [331]], [[7506, 7506], "mapped", [111]], [[7507, 7507], "mapped", [596]], [[7508, 7508], "mapped", [7446]], [[7509, 7509], "mapped", [7447]], [[7510, 7510], "mapped", [112]], [[7511, 7511], "mapped", [116]], [[7512, 7512], "mapped", [117]], [[7513, 7513], "mapped", [7453]], [[7514, 7514], "mapped", [623]], [[7515, 7515], "mapped", [118]], [[7516, 7516], "mapped", [7461]], [[7517, 7517], "mapped", [946]], [[7518, 7518], "mapped", [947]], [[7519, 7519], "mapped", [948]], [[7520, 7520], "mapped", [966]], [[7521, 7521], "mapped", [967]], [[7522, 7522], "mapped", [105]], [[7523, 7523], "mapped", [114]], [[7524, 7524], "mapped", [117]], [[7525, 7525], "mapped", [118]], [[7526, 7526], "mapped", [946]], [[7527, 7527], "mapped", [947]], [[7528, 7528], "mapped", [961]], [[7529, 7529], "mapped", [966]], [[7530, 7530], "mapped", [967]], [[7531, 7531], "valid"], [[7532, 7543], "valid"], [[7544, 7544], "mapped", [1085]], [[7545, 7578], "valid"], [[7579, 7579], "mapped", [594]], [[7580, 7580], "mapped", [99]], [[7581, 7581], "mapped", [597]], [[7582, 7582], "mapped", [240]], [[7583, 7583], "mapped", [604]], [[7584, 7584], "mapped", [102]], [[7585, 7585], "mapped", [607]], [[7586, 7586], "mapped", [609]], [[7587, 7587], "mapped", [613]], [[7588, 7588], "mapped", [616]], [[7589, 7589], "mapped", [617]], [[7590, 7590], "mapped", [618]], [[7591, 7591], "mapped", [7547]], [[7592, 7592], "mapped", [669]], [[7593, 7593], "mapped", [621]], [[7594, 7594], "mapped", [7557]], [[7595, 7595], "mapped", [671]], [[7596, 7596], "mapped", [625]], [[7597, 7597], "mapped", [624]], [[7598, 7598], "mapped", [626]], [[7599, 7599], "mapped", [627]], [[7600, 7600], "mapped", [628]], [[7601, 7601], "mapped", [629]], [[7602, 7602], "mapped", [632]], [[7603, 7603], "mapped", [642]], [[7604, 7604], "mapped", [643]], [[7605, 7605], "mapped", [427]], [[7606, 7606], "mapped", [649]], [[7607, 7607], "mapped", [650]], [[7608, 7608], "mapped", [7452]], [[7609, 7609], "mapped", [651]], [[7610, 7610], "mapped", [652]], [[7611, 7611], "mapped", [122]], [[7612, 7612], "mapped", [656]], [[7613, 7613], "mapped", [657]], [[7614, 7614], "mapped", [658]], [[7615, 7615], "mapped", [952]], [[7616, 7619], "valid"], [[7620, 7626], "valid"], [[7627, 7654], "valid"], [[7655, 7669], "valid"], [[7670, 7675], "disallowed"], [[7676, 7676], "valid"], [[7677, 7677], "valid"], [[7678, 7679], "valid"], [[7680, 7680], "mapped", [7681]], [[7681, 7681], "valid"], [[7682, 7682], "mapped", [7683]], [[7683, 7683], "valid"], [[7684, 7684], "mapped", [7685]], [[7685, 7685], "valid"], [[7686, 7686], "mapped", [7687]], [[7687, 7687], "valid"], [[7688, 7688], "mapped", [7689]], [[7689, 7689], "valid"], [[7690, 7690], "mapped", [7691]], [[7691, 7691], "valid"], [[7692, 7692], "mapped", [7693]], [[7693, 7693], "valid"], [[7694, 7694], "mapped", [7695]], [[7695, 7695], "valid"], [[7696, 7696], "mapped", [7697]], [[7697, 7697], "valid"], [[7698, 7698], "mapped", [7699]], [[7699, 7699], "valid"], [[7700, 7700], "mapped", [7701]], [[7701, 7701], "valid"], [[7702, 7702], "mapped", [7703]], [[7703, 7703], "valid"], [[7704, 7704], "mapped", [7705]], [[7705, 7705], "valid"], [[7706, 7706], "mapped", [7707]], [[7707, 7707], "valid"], [[7708, 7708], "mapped", [7709]], [[7709, 7709], "valid"], [[7710, 7710], "mapped", [7711]], [[7711, 7711], "valid"], [[7712, 7712], "mapped", [7713]], [[7713, 7713], "valid"], [[7714, 7714], "mapped", [7715]], [[7715, 7715], "valid"], [[7716, 7716], "mapped", [7717]], [[7717, 7717], "valid"], [[7718, 7718], "mapped", [7719]], [[7719, 7719], "valid"], [[7720, 7720], "mapped", [7721]], [[7721, 7721], "valid"], [[7722, 7722], "mapped", [7723]], [[7723, 7723], "valid"], [[7724, 7724], "mapped", [7725]], [[7725, 7725], "valid"], [[7726, 7726], "mapped", [7727]], [[7727, 7727], "valid"], [[7728, 7728], "mapped", [7729]], [[7729, 7729], "valid"], [[7730, 7730], "mapped", [7731]], [[7731, 7731], "valid"], [[7732, 7732], "mapped", [7733]], [[7733, 7733], "valid"], [[7734, 7734], "mapped", [7735]], [[7735, 7735], "valid"], [[7736, 7736], "mapped", [7737]], [[7737, 7737], "valid"], [[7738, 7738], "mapped", [7739]], [[7739, 7739], "valid"], [[7740, 7740], "mapped", [7741]], [[7741, 7741], "valid"], [[7742, 7742], "mapped", [7743]], [[7743, 7743], "valid"], [[7744, 7744], "mapped", [7745]], [[7745, 7745], "valid"], [[7746, 7746], "mapped", [7747]], [[7747, 7747], "valid"], [[7748, 7748], "mapped", [7749]], [[7749, 7749], "valid"], [[7750, 7750], "mapped", [7751]], [[7751, 7751], "valid"], [[7752, 7752], "mapped", [7753]], [[7753, 7753], "valid"], [[7754, 7754], "mapped", [7755]], [[7755, 7755], "valid"], [[7756, 7756], "mapped", [7757]], [[7757, 7757], "valid"], [[7758, 7758], "mapped", [7759]], [[7759, 7759], "valid"], [[7760, 7760], "mapped", [7761]], [[7761, 7761], "valid"], [[7762, 7762], "mapped", [7763]], [[7763, 7763], "valid"], [[7764, 7764], "mapped", [7765]], [[7765, 7765], "valid"], [[7766, 7766], "mapped", [7767]], [[7767, 7767], "valid"], [[7768, 7768], "mapped", [7769]], [[7769, 7769], "valid"], [[7770, 7770], "mapped", [7771]], [[7771, 7771], "valid"], [[7772, 7772], "mapped", [7773]], [[7773, 7773], "valid"], [[7774, 7774], "mapped", [7775]], [[7775, 7775], "valid"], [[7776, 7776], "mapped", [7777]], [[7777, 7777], "valid"], [[7778, 7778], "mapped", [7779]], [[7779, 7779], "valid"], [[7780, 7780], "mapped", [7781]], [[7781, 7781], "valid"], [[7782, 7782], "mapped", [7783]], [[7783, 7783], "valid"], [[7784, 7784], "mapped", [7785]], [[7785, 7785], "valid"], [[7786, 7786], "mapped", [7787]], [[7787, 7787], "valid"], [[7788, 7788], "mapped", [7789]], [[7789, 7789], "valid"], [[7790, 7790], "mapped", [7791]], [[7791, 7791], "valid"], [[7792, 7792], "mapped", [7793]], [[7793, 7793], "valid"], [[7794, 7794], "mapped", [7795]], [[7795, 7795], "valid"], [[7796, 7796], "mapped", [7797]], [[7797, 7797], "valid"], [[7798, 7798], "mapped", [7799]], [[7799, 7799], "valid"], [[7800, 7800], "mapped", [7801]], [[7801, 7801], "valid"], [[7802, 7802], "mapped", [7803]], [[7803, 7803], "valid"], [[7804, 7804], "mapped", [7805]], [[7805, 7805], "valid"], [[7806, 7806], "mapped", [7807]], [[7807, 7807], "valid"], [[7808, 7808], "mapped", [7809]], [[7809, 7809], "valid"], [[7810, 7810], "mapped", [7811]], [[7811, 7811], "valid"], [[7812, 7812], "mapped", [7813]], [[7813, 7813], "valid"], [[7814, 7814], "mapped", [7815]], [[7815, 7815], "valid"], [[7816, 7816], "mapped", [7817]], [[7817, 7817], "valid"], [[7818, 7818], "mapped", [7819]], [[7819, 7819], "valid"], [[7820, 7820], "mapped", [7821]], [[7821, 7821], "valid"], [[7822, 7822], "mapped", [7823]], [[7823, 7823], "valid"], [[7824, 7824], "mapped", [7825]], [[7825, 7825], "valid"], [[7826, 7826], "mapped", [7827]], [[7827, 7827], "valid"], [[7828, 7828], "mapped", [7829]], [[7829, 7833], "valid"], [[7834, 7834], "mapped", [97, 702]], [[7835, 7835], "mapped", [7777]], [[7836, 7837], "valid"], [[7838, 7838], "mapped", [115, 115]], [[7839, 7839], "valid"], [[7840, 7840], "mapped", [7841]], [[7841, 7841], "valid"], [[7842, 7842], "mapped", [7843]], [[7843, 7843], "valid"], [[7844, 7844], "mapped", [7845]], [[7845, 7845], "valid"], [[7846, 7846], "mapped", [7847]], [[7847, 7847], "valid"], [[7848, 7848], "mapped", [7849]], [[7849, 7849], "valid"], [[7850, 7850], "mapped", [7851]], [[7851, 7851], "valid"], [[7852, 7852], "mapped", [7853]], [[7853, 7853], "valid"], [[7854, 7854], "mapped", [7855]], [[7855, 7855], "valid"], [[7856, 7856], "mapped", [7857]], [[7857, 7857], "valid"], [[7858, 7858], "mapped", [7859]], [[7859, 7859], "valid"], [[7860, 7860], "mapped", [7861]], [[7861, 7861], "valid"], [[7862, 7862], "mapped", [7863]], [[7863, 7863], "valid"], [[7864, 7864], "mapped", [7865]], [[7865, 7865], "valid"], [[7866, 7866], "mapped", [7867]], [[7867, 7867], "valid"], [[7868, 7868], "mapped", [7869]], [[7869, 7869], "valid"], [[7870, 7870], "mapped", [7871]], [[7871, 7871], "valid"], [[7872, 7872], "mapped", [7873]], [[7873, 7873], "valid"], [[7874, 7874], "mapped", [7875]], [[7875, 7875], "valid"], [[7876, 7876], "mapped", [7877]], [[7877, 7877], "valid"], [[7878, 7878], "mapped", [7879]], [[7879, 7879], "valid"], [[7880, 7880], "mapped", [7881]], [[7881, 7881], "valid"], [[7882, 7882], "mapped", [7883]], [[7883, 7883], "valid"], [[7884, 7884], "mapped", [7885]], [[7885, 7885], "valid"], [[7886, 7886], "mapped", [7887]], [[7887, 7887], "valid"], [[7888, 7888], "mapped", [7889]], [[7889, 7889], "valid"], [[7890, 7890], "mapped", [7891]], [[7891, 7891], "valid"], [[7892, 7892], "mapped", [7893]], [[7893, 7893], "valid"], [[7894, 7894], "mapped", [7895]], [[7895, 7895], "valid"], [[7896, 7896], "mapped", [7897]], [[7897, 7897], "valid"], [[7898, 7898], "mapped", [7899]], [[7899, 7899], "valid"], [[7900, 7900], "mapped", [7901]], [[7901, 7901], "valid"], [[7902, 7902], "mapped", [7903]], [[7903, 7903], "valid"], [[7904, 7904], "mapped", [7905]], [[7905, 7905], "valid"], [[7906, 7906], "mapped", [7907]], [[7907, 7907], "valid"], [[7908, 7908], "mapped", [7909]], [[7909, 7909], "valid"], [[7910, 7910], "mapped", [7911]], [[7911, 7911], "valid"], [[7912, 7912], "mapped", [7913]], [[7913, 7913], "valid"], [[7914, 7914], "mapped", [7915]], [[7915, 7915], "valid"], [[7916, 7916], "mapped", [7917]], [[7917, 7917], "valid"], [[7918, 7918], "mapped", [7919]], [[7919, 7919], "valid"], [[7920, 7920], "mapped", [7921]], [[7921, 7921], "valid"], [[7922, 7922], "mapped", [7923]], [[7923, 7923], "valid"], [[7924, 7924], "mapped", [7925]], [[7925, 7925], "valid"], [[7926, 7926], "mapped", [7927]], [[7927, 7927], "valid"], [[7928, 7928], "mapped", [7929]], [[7929, 7929], "valid"], [[7930, 7930], "mapped", [7931]], [[7931, 7931], "valid"], [[7932, 7932], "mapped", [7933]], [[7933, 7933], "valid"], [[7934, 7934], "mapped", [7935]], [[7935, 7935], "valid"], [[7936, 7943], "valid"], [[7944, 7944], "mapped", [7936]], [[7945, 7945], "mapped", [7937]], [[7946, 7946], "mapped", [7938]], [[7947, 7947], "mapped", [7939]], [[7948, 7948], "mapped", [7940]], [[7949, 7949], "mapped", [7941]], [[7950, 7950], "mapped", [7942]], [[7951, 7951], "mapped", [7943]], [[7952, 7957], "valid"], [[7958, 7959], "disallowed"], [[7960, 7960], "mapped", [7952]], [[7961, 7961], "mapped", [7953]], [[7962, 7962], "mapped", [7954]], [[7963, 7963], "mapped", [7955]], [[7964, 7964], "mapped", [7956]], [[7965, 7965], "mapped", [7957]], [[7966, 7967], "disallowed"], [[7968, 7975], "valid"], [[7976, 7976], "mapped", [7968]], [[7977, 7977], "mapped", [7969]], [[7978, 7978], "mapped", [7970]], [[7979, 7979], "mapped", [7971]], [[7980, 7980], "mapped", [7972]], [[7981, 7981], "mapped", [7973]], [[7982, 7982], "mapped", [7974]], [[7983, 7983], "mapped", [7975]], [[7984, 7991], "valid"], [[7992, 7992], "mapped", [7984]], [[7993, 7993], "mapped", [7985]], [[7994, 7994], "mapped", [7986]], [[7995, 7995], "mapped", [7987]], [[7996, 7996], "mapped", [7988]], [[7997, 7997], "mapped", [7989]], [[7998, 7998], "mapped", [7990]], [[7999, 7999], "mapped", [7991]], [[8e3, 8005], "valid"], [[8006, 8007], "disallowed"], [[8008, 8008], "mapped", [8e3]], [[8009, 8009], "mapped", [8001]], [[8010, 8010], "mapped", [8002]], [[8011, 8011], "mapped", [8003]], [[8012, 8012], "mapped", [8004]], [[8013, 8013], "mapped", [8005]], [[8014, 8015], "disallowed"], [[8016, 8023], "valid"], [[8024, 8024], "disallowed"], [[8025, 8025], "mapped", [8017]], [[8026, 8026], "disallowed"], [[8027, 8027], "mapped", [8019]], [[8028, 8028], "disallowed"], [[8029, 8029], "mapped", [8021]], [[8030, 8030], "disallowed"], [[8031, 8031], "mapped", [8023]], [[8032, 8039], "valid"], [[8040, 8040], "mapped", [8032]], [[8041, 8041], "mapped", [8033]], [[8042, 8042], "mapped", [8034]], [[8043, 8043], "mapped", [8035]], [[8044, 8044], "mapped", [8036]], [[8045, 8045], "mapped", [8037]], [[8046, 8046], "mapped", [8038]], [[8047, 8047], "mapped", [8039]], [[8048, 8048], "valid"], [[8049, 8049], "mapped", [940]], [[8050, 8050], "valid"], [[8051, 8051], "mapped", [941]], [[8052, 8052], "valid"], [[8053, 8053], "mapped", [942]], [[8054, 8054], "valid"], [[8055, 8055], "mapped", [943]], [[8056, 8056], "valid"], [[8057, 8057], "mapped", [972]], [[8058, 8058], "valid"], [[8059, 8059], "mapped", [973]], [[8060, 8060], "valid"], [[8061, 8061], "mapped", [974]], [[8062, 8063], "disallowed"], [[8064, 8064], "mapped", [7936, 953]], [[8065, 8065], "mapped", [7937, 953]], [[8066, 8066], "mapped", [7938, 953]], [[8067, 8067], "mapped", [7939, 953]], [[8068, 8068], "mapped", [7940, 953]], [[8069, 8069], "mapped", [7941, 953]], [[8070, 8070], "mapped", [7942, 953]], [[8071, 8071], "mapped", [7943, 953]], [[8072, 8072], "mapped", [7936, 953]], [[8073, 8073], "mapped", [7937, 953]], [[8074, 8074], "mapped", [7938, 953]], [[8075, 8075], "mapped", [7939, 953]], [[8076, 8076], "mapped", [7940, 953]], [[8077, 8077], "mapped", [7941, 953]], [[8078, 8078], "mapped", [7942, 953]], [[8079, 8079], "mapped", [7943, 953]], [[8080, 8080], "mapped", [7968, 953]], [[8081, 8081], "mapped", [7969, 953]], [[8082, 8082], "mapped", [7970, 953]], [[8083, 8083], "mapped", [7971, 953]], [[8084, 8084], "mapped", [7972, 953]], [[8085, 8085], "mapped", [7973, 953]], [[8086, 8086], "mapped", [7974, 953]], [[8087, 8087], "mapped", [7975, 953]], [[8088, 8088], "mapped", [7968, 953]], [[8089, 8089], "mapped", [7969, 953]], [[8090, 8090], "mapped", [7970, 953]], [[8091, 8091], "mapped", [7971, 953]], [[8092, 8092], "mapped", [7972, 953]], [[8093, 8093], "mapped", [7973, 953]], [[8094, 8094], "mapped", [7974, 953]], [[8095, 8095], "mapped", [7975, 953]], [[8096, 8096], "mapped", [8032, 953]], [[8097, 8097], "mapped", [8033, 953]], [[8098, 8098], "mapped", [8034, 953]], [[8099, 8099], "mapped", [8035, 953]], [[8100, 8100], "mapped", [8036, 953]], [[8101, 8101], "mapped", [8037, 953]], [[8102, 8102], "mapped", [8038, 953]], [[8103, 8103], "mapped", [8039, 953]], [[8104, 8104], "mapped", [8032, 953]], [[8105, 8105], "mapped", [8033, 953]], [[8106, 8106], "mapped", [8034, 953]], [[8107, 8107], "mapped", [8035, 953]], [[8108, 8108], "mapped", [8036, 953]], [[8109, 8109], "mapped", [8037, 953]], [[8110, 8110], "mapped", [8038, 953]], [[8111, 8111], "mapped", [8039, 953]], [[8112, 8113], "valid"], [[8114, 8114], "mapped", [8048, 953]], [[8115, 8115], "mapped", [945, 953]], [[8116, 8116], "mapped", [940, 953]], [[8117, 8117], "disallowed"], [[8118, 8118], "valid"], [[8119, 8119], "mapped", [8118, 953]], [[8120, 8120], "mapped", [8112]], [[8121, 8121], "mapped", [8113]], [[8122, 8122], "mapped", [8048]], [[8123, 8123], "mapped", [940]], [[8124, 8124], "mapped", [945, 953]], [[8125, 8125], "disallowed_STD3_mapped", [32, 787]], [[8126, 8126], "mapped", [953]], [[8127, 8127], "disallowed_STD3_mapped", [32, 787]], [[8128, 8128], "disallowed_STD3_mapped", [32, 834]], [[8129, 8129], "disallowed_STD3_mapped", [32, 776, 834]], [[8130, 8130], "mapped", [8052, 953]], [[8131, 8131], "mapped", [951, 953]], [[8132, 8132], "mapped", [942, 953]], [[8133, 8133], "disallowed"], [[8134, 8134], "valid"], [[8135, 8135], "mapped", [8134, 953]], [[8136, 8136], "mapped", [8050]], [[8137, 8137], "mapped", [941]], [[8138, 8138], "mapped", [8052]], [[8139, 8139], "mapped", [942]], [[8140, 8140], "mapped", [951, 953]], [[8141, 8141], "disallowed_STD3_mapped", [32, 787, 768]], [[8142, 8142], "disallowed_STD3_mapped", [32, 787, 769]], [[8143, 8143], "disallowed_STD3_mapped", [32, 787, 834]], [[8144, 8146], "valid"], [[8147, 8147], "mapped", [912]], [[8148, 8149], "disallowed"], [[8150, 8151], "valid"], [[8152, 8152], "mapped", [8144]], [[8153, 8153], "mapped", [8145]], [[8154, 8154], "mapped", [8054]], [[8155, 8155], "mapped", [943]], [[8156, 8156], "disallowed"], [[8157, 8157], "disallowed_STD3_mapped", [32, 788, 768]], [[8158, 8158], "disallowed_STD3_mapped", [32, 788, 769]], [[8159, 8159], "disallowed_STD3_mapped", [32, 788, 834]], [[8160, 8162], "valid"], [[8163, 8163], "mapped", [944]], [[8164, 8167], "valid"], [[8168, 8168], "mapped", [8160]], [[8169, 8169], "mapped", [8161]], [[8170, 8170], "mapped", [8058]], [[8171, 8171], "mapped", [973]], [[8172, 8172], "mapped", [8165]], [[8173, 8173], "disallowed_STD3_mapped", [32, 776, 768]], [[8174, 8174], "disallowed_STD3_mapped", [32, 776, 769]], [[8175, 8175], "disallowed_STD3_mapped", [96]], [[8176, 8177], "disallowed"], [[8178, 8178], "mapped", [8060, 953]], [[8179, 8179], "mapped", [969, 953]], [[8180, 8180], "mapped", [974, 953]], [[8181, 8181], "disallowed"], [[8182, 8182], "valid"], [[8183, 8183], "mapped", [8182, 953]], [[8184, 8184], "mapped", [8056]], [[8185, 8185], "mapped", [972]], [[8186, 8186], "mapped", [8060]], [[8187, 8187], "mapped", [974]], [[8188, 8188], "mapped", [969, 953]], [[8189, 8189], "disallowed_STD3_mapped", [32, 769]], [[8190, 8190], "disallowed_STD3_mapped", [32, 788]], [[8191, 8191], "disallowed"], [[8192, 8202], "disallowed_STD3_mapped", [32]], [[8203, 8203], "ignored"], [[8204, 8205], "deviation", []], [[8206, 8207], "disallowed"], [[8208, 8208], "valid", [], "NV8"], [[8209, 8209], "mapped", [8208]], [[8210, 8214], "valid", [], "NV8"], [[8215, 8215], "disallowed_STD3_mapped", [32, 819]], [[8216, 8227], "valid", [], "NV8"], [[8228, 8230], "disallowed"], [[8231, 8231], "valid", [], "NV8"], [[8232, 8238], "disallowed"], [[8239, 8239], "disallowed_STD3_mapped", [32]], [[8240, 8242], "valid", [], "NV8"], [[8243, 8243], "mapped", [8242, 8242]], [[8244, 8244], "mapped", [8242, 8242, 8242]], [[8245, 8245], "valid", [], "NV8"], [[8246, 8246], "mapped", [8245, 8245]], [[8247, 8247], "mapped", [8245, 8245, 8245]], [[8248, 8251], "valid", [], "NV8"], [[8252, 8252], "disallowed_STD3_mapped", [33, 33]], [[8253, 8253], "valid", [], "NV8"], [[8254, 8254], "disallowed_STD3_mapped", [32, 773]], [[8255, 8262], "valid", [], "NV8"], [[8263, 8263], "disallowed_STD3_mapped", [63, 63]], [[8264, 8264], "disallowed_STD3_mapped", [63, 33]], [[8265, 8265], "disallowed_STD3_mapped", [33, 63]], [[8266, 8269], "valid", [], "NV8"], [[8270, 8274], "valid", [], "NV8"], [[8275, 8276], "valid", [], "NV8"], [[8277, 8278], "valid", [], "NV8"], [[8279, 8279], "mapped", [8242, 8242, 8242, 8242]], [[8280, 8286], "valid", [], "NV8"], [[8287, 8287], "disallowed_STD3_mapped", [32]], [[8288, 8288], "ignored"], [[8289, 8291], "disallowed"], [[8292, 8292], "ignored"], [[8293, 8293], "disallowed"], [[8294, 8297], "disallowed"], [[8298, 8303], "disallowed"], [[8304, 8304], "mapped", [48]], [[8305, 8305], "mapped", [105]], [[8306, 8307], "disallowed"], [[8308, 8308], "mapped", [52]], [[8309, 8309], "mapped", [53]], [[8310, 8310], "mapped", [54]], [[8311, 8311], "mapped", [55]], [[8312, 8312], "mapped", [56]], [[8313, 8313], "mapped", [57]], [[8314, 8314], "disallowed_STD3_mapped", [43]], [[8315, 8315], "mapped", [8722]], [[8316, 8316], "disallowed_STD3_mapped", [61]], [[8317, 8317], "disallowed_STD3_mapped", [40]], [[8318, 8318], "disallowed_STD3_mapped", [41]], [[8319, 8319], "mapped", [110]], [[8320, 8320], "mapped", [48]], [[8321, 8321], "mapped", [49]], [[8322, 8322], "mapped", [50]], [[8323, 8323], "mapped", [51]], [[8324, 8324], "mapped", [52]], [[8325, 8325], "mapped", [53]], [[8326, 8326], "mapped", [54]], [[8327, 8327], "mapped", [55]], [[8328, 8328], "mapped", [56]], [[8329, 8329], "mapped", [57]], [[8330, 8330], "disallowed_STD3_mapped", [43]], [[8331, 8331], "mapped", [8722]], [[8332, 8332], "disallowed_STD3_mapped", [61]], [[8333, 8333], "disallowed_STD3_mapped", [40]], [[8334, 8334], "disallowed_STD3_mapped", [41]], [[8335, 8335], "disallowed"], [[8336, 8336], "mapped", [97]], [[8337, 8337], "mapped", [101]], [[8338, 8338], "mapped", [111]], [[8339, 8339], "mapped", [120]], [[8340, 8340], "mapped", [601]], [[8341, 8341], "mapped", [104]], [[8342, 8342], "mapped", [107]], [[8343, 8343], "mapped", [108]], [[8344, 8344], "mapped", [109]], [[8345, 8345], "mapped", [110]], [[8346, 8346], "mapped", [112]], [[8347, 8347], "mapped", [115]], [[8348, 8348], "mapped", [116]], [[8349, 8351], "disallowed"], [[8352, 8359], "valid", [], "NV8"], [[8360, 8360], "mapped", [114, 115]], [[8361, 8362], "valid", [], "NV8"], [[8363, 8363], "valid", [], "NV8"], [[8364, 8364], "valid", [], "NV8"], [[8365, 8367], "valid", [], "NV8"], [[8368, 8369], "valid", [], "NV8"], [[8370, 8373], "valid", [], "NV8"], [[8374, 8376], "valid", [], "NV8"], [[8377, 8377], "valid", [], "NV8"], [[8378, 8378], "valid", [], "NV8"], [[8379, 8381], "valid", [], "NV8"], [[8382, 8382], "valid", [], "NV8"], [[8383, 8399], "disallowed"], [[8400, 8417], "valid", [], "NV8"], [[8418, 8419], "valid", [], "NV8"], [[8420, 8426], "valid", [], "NV8"], [[8427, 8427], "valid", [], "NV8"], [[8428, 8431], "valid", [], "NV8"], [[8432, 8432], "valid", [], "NV8"], [[8433, 8447], "disallowed"], [[8448, 8448], "disallowed_STD3_mapped", [97, 47, 99]], [[8449, 8449], "disallowed_STD3_mapped", [97, 47, 115]], [[8450, 8450], "mapped", [99]], [[8451, 8451], "mapped", [176, 99]], [[8452, 8452], "valid", [], "NV8"], [[8453, 8453], "disallowed_STD3_mapped", [99, 47, 111]], [[8454, 8454], "disallowed_STD3_mapped", [99, 47, 117]], [[8455, 8455], "mapped", [603]], [[8456, 8456], "valid", [], "NV8"], [[8457, 8457], "mapped", [176, 102]], [[8458, 8458], "mapped", [103]], [[8459, 8462], "mapped", [104]], [[8463, 8463], "mapped", [295]], [[8464, 8465], "mapped", [105]], [[8466, 8467], "mapped", [108]], [[8468, 8468], "valid", [], "NV8"], [[8469, 8469], "mapped", [110]], [[8470, 8470], "mapped", [110, 111]], [[8471, 8472], "valid", [], "NV8"], [[8473, 8473], "mapped", [112]], [[8474, 8474], "mapped", [113]], [[8475, 8477], "mapped", [114]], [[8478, 8479], "valid", [], "NV8"], [[8480, 8480], "mapped", [115, 109]], [[8481, 8481], "mapped", [116, 101, 108]], [[8482, 8482], "mapped", [116, 109]], [[8483, 8483], "valid", [], "NV8"], [[8484, 8484], "mapped", [122]], [[8485, 8485], "valid", [], "NV8"], [[8486, 8486], "mapped", [969]], [[8487, 8487], "valid", [], "NV8"], [[8488, 8488], "mapped", [122]], [[8489, 8489], "valid", [], "NV8"], [[8490, 8490], "mapped", [107]], [[8491, 8491], "mapped", [229]], [[8492, 8492], "mapped", [98]], [[8493, 8493], "mapped", [99]], [[8494, 8494], "valid", [], "NV8"], [[8495, 8496], "mapped", [101]], [[8497, 8497], "mapped", [102]], [[8498, 8498], "disallowed"], [[8499, 8499], "mapped", [109]], [[8500, 8500], "mapped", [111]], [[8501, 8501], "mapped", [1488]], [[8502, 8502], "mapped", [1489]], [[8503, 8503], "mapped", [1490]], [[8504, 8504], "mapped", [1491]], [[8505, 8505], "mapped", [105]], [[8506, 8506], "valid", [], "NV8"], [[8507, 8507], "mapped", [102, 97, 120]], [[8508, 8508], "mapped", [960]], [[8509, 8510], "mapped", [947]], [[8511, 8511], "mapped", [960]], [[8512, 8512], "mapped", [8721]], [[8513, 8516], "valid", [], "NV8"], [[8517, 8518], "mapped", [100]], [[8519, 8519], "mapped", [101]], [[8520, 8520], "mapped", [105]], [[8521, 8521], "mapped", [106]], [[8522, 8523], "valid", [], "NV8"], [[8524, 8524], "valid", [], "NV8"], [[8525, 8525], "valid", [], "NV8"], [[8526, 8526], "valid"], [[8527, 8527], "valid", [], "NV8"], [[8528, 8528], "mapped", [49, 8260, 55]], [[8529, 8529], "mapped", [49, 8260, 57]], [[8530, 8530], "mapped", [49, 8260, 49, 48]], [[8531, 8531], "mapped", [49, 8260, 51]], [[8532, 8532], "mapped", [50, 8260, 51]], [[8533, 8533], "mapped", [49, 8260, 53]], [[8534, 8534], "mapped", [50, 8260, 53]], [[8535, 8535], "mapped", [51, 8260, 53]], [[8536, 8536], "mapped", [52, 8260, 53]], [[8537, 8537], "mapped", [49, 8260, 54]], [[8538, 8538], "mapped", [53, 8260, 54]], [[8539, 8539], "mapped", [49, 8260, 56]], [[8540, 8540], "mapped", [51, 8260, 56]], [[8541, 8541], "mapped", [53, 8260, 56]], [[8542, 8542], "mapped", [55, 8260, 56]], [[8543, 8543], "mapped", [49, 8260]], [[8544, 8544], "mapped", [105]], [[8545, 8545], "mapped", [105, 105]], [[8546, 8546], "mapped", [105, 105, 105]], [[8547, 8547], "mapped", [105, 118]], [[8548, 8548], "mapped", [118]], [[8549, 8549], "mapped", [118, 105]], [[8550, 8550], "mapped", [118, 105, 105]], [[8551, 8551], "mapped", [118, 105, 105, 105]], [[8552, 8552], "mapped", [105, 120]], [[8553, 8553], "mapped", [120]], [[8554, 8554], "mapped", [120, 105]], [[8555, 8555], "mapped", [120, 105, 105]], [[8556, 8556], "mapped", [108]], [[8557, 8557], "mapped", [99]], [[8558, 8558], "mapped", [100]], [[8559, 8559], "mapped", [109]], [[8560, 8560], "mapped", [105]], [[8561, 8561], "mapped", [105, 105]], [[8562, 8562], "mapped", [105, 105, 105]], [[8563, 8563], "mapped", [105, 118]], [[8564, 8564], "mapped", [118]], [[8565, 8565], "mapped", [118, 105]], [[8566, 8566], "mapped", [118, 105, 105]], [[8567, 8567], "mapped", [118, 105, 105, 105]], [[8568, 8568], "mapped", [105, 120]], [[8569, 8569], "mapped", [120]], [[8570, 8570], "mapped", [120, 105]], [[8571, 8571], "mapped", [120, 105, 105]], [[8572, 8572], "mapped", [108]], [[8573, 8573], "mapped", [99]], [[8574, 8574], "mapped", [100]], [[8575, 8575], "mapped", [109]], [[8576, 8578], "valid", [], "NV8"], [[8579, 8579], "disallowed"], [[8580, 8580], "valid"], [[8581, 8584], "valid", [], "NV8"], [[8585, 8585], "mapped", [48, 8260, 51]], [[8586, 8587], "valid", [], "NV8"], [[8588, 8591], "disallowed"], [[8592, 8682], "valid", [], "NV8"], [[8683, 8691], "valid", [], "NV8"], [[8692, 8703], "valid", [], "NV8"], [[8704, 8747], "valid", [], "NV8"], [[8748, 8748], "mapped", [8747, 8747]], [[8749, 8749], "mapped", [8747, 8747, 8747]], [[8750, 8750], "valid", [], "NV8"], [[8751, 8751], "mapped", [8750, 8750]], [[8752, 8752], "mapped", [8750, 8750, 8750]], [[8753, 8799], "valid", [], "NV8"], [[8800, 8800], "disallowed_STD3_valid"], [[8801, 8813], "valid", [], "NV8"], [[8814, 8815], "disallowed_STD3_valid"], [[8816, 8945], "valid", [], "NV8"], [[8946, 8959], "valid", [], "NV8"], [[8960, 8960], "valid", [], "NV8"], [[8961, 8961], "valid", [], "NV8"], [[8962, 9e3], "valid", [], "NV8"], [[9001, 9001], "mapped", [12296]], [[9002, 9002], "mapped", [12297]], [[9003, 9082], "valid", [], "NV8"], [[9083, 9083], "valid", [], "NV8"], [[9084, 9084], "valid", [], "NV8"], [[9085, 9114], "valid", [], "NV8"], [[9115, 9166], "valid", [], "NV8"], [[9167, 9168], "valid", [], "NV8"], [[9169, 9179], "valid", [], "NV8"], [[9180, 9191], "valid", [], "NV8"], [[9192, 9192], "valid", [], "NV8"], [[9193, 9203], "valid", [], "NV8"], [[9204, 9210], "valid", [], "NV8"], [[9211, 9215], "disallowed"], [[9216, 9252], "valid", [], "NV8"], [[9253, 9254], "valid", [], "NV8"], [[9255, 9279], "disallowed"], [[9280, 9290], "valid", [], "NV8"], [[9291, 9311], "disallowed"], [[9312, 9312], "mapped", [49]], [[9313, 9313], "mapped", [50]], [[9314, 9314], "mapped", [51]], [[9315, 9315], "mapped", [52]], [[9316, 9316], "mapped", [53]], [[9317, 9317], "mapped", [54]], [[9318, 9318], "mapped", [55]], [[9319, 9319], "mapped", [56]], [[9320, 9320], "mapped", [57]], [[9321, 9321], "mapped", [49, 48]], [[9322, 9322], "mapped", [49, 49]], [[9323, 9323], "mapped", [49, 50]], [[9324, 9324], "mapped", [49, 51]], [[9325, 9325], "mapped", [49, 52]], [[9326, 9326], "mapped", [49, 53]], [[9327, 9327], "mapped", [49, 54]], [[9328, 9328], "mapped", [49, 55]], [[9329, 9329], "mapped", [49, 56]], [[9330, 9330], "mapped", [49, 57]], [[9331, 9331], "mapped", [50, 48]], [[9332, 9332], "disallowed_STD3_mapped", [40, 49, 41]], [[9333, 9333], "disallowed_STD3_mapped", [40, 50, 41]], [[9334, 9334], "disallowed_STD3_mapped", [40, 51, 41]], [[9335, 9335], "disallowed_STD3_mapped", [40, 52, 41]], [[9336, 9336], "disallowed_STD3_mapped", [40, 53, 41]], [[9337, 9337], "disallowed_STD3_mapped", [40, 54, 41]], [[9338, 9338], "disallowed_STD3_mapped", [40, 55, 41]], [[9339, 9339], "disallowed_STD3_mapped", [40, 56, 41]], [[9340, 9340], "disallowed_STD3_mapped", [40, 57, 41]], [[9341, 9341], "disallowed_STD3_mapped", [40, 49, 48, 41]], [[9342, 9342], "disallowed_STD3_mapped", [40, 49, 49, 41]], [[9343, 9343], "disallowed_STD3_mapped", [40, 49, 50, 41]], [[9344, 9344], "disallowed_STD3_mapped", [40, 49, 51, 41]], [[9345, 9345], "disallowed_STD3_mapped", [40, 49, 52, 41]], [[9346, 9346], "disallowed_STD3_mapped", [40, 49, 53, 41]], [[9347, 9347], "disallowed_STD3_mapped", [40, 49, 54, 41]], [[9348, 9348], "disallowed_STD3_mapped", [40, 49, 55, 41]], [[9349, 9349], "disallowed_STD3_mapped", [40, 49, 56, 41]], [[9350, 9350], "disallowed_STD3_mapped", [40, 49, 57, 41]], [[9351, 9351], "disallowed_STD3_mapped", [40, 50, 48, 41]], [[9352, 9371], "disallowed"], [[9372, 9372], "disallowed_STD3_mapped", [40, 97, 41]], [[9373, 9373], "disallowed_STD3_mapped", [40, 98, 41]], [[9374, 9374], "disallowed_STD3_mapped", [40, 99, 41]], [[9375, 9375], "disallowed_STD3_mapped", [40, 100, 41]], [[9376, 9376], "disallowed_STD3_mapped", [40, 101, 41]], [[9377, 9377], "disallowed_STD3_mapped", [40, 102, 41]], [[9378, 9378], "disallowed_STD3_mapped", [40, 103, 41]], [[9379, 9379], "disallowed_STD3_mapped", [40, 104, 41]], [[9380, 9380], "disallowed_STD3_mapped", [40, 105, 41]], [[9381, 9381], "disallowed_STD3_mapped", [40, 106, 41]], [[9382, 9382], "disallowed_STD3_mapped", [40, 107, 41]], [[9383, 9383], "disallowed_STD3_mapped", [40, 108, 41]], [[9384, 9384], "disallowed_STD3_mapped", [40, 109, 41]], [[9385, 9385], "disallowed_STD3_mapped", [40, 110, 41]], [[9386, 9386], "disallowed_STD3_mapped", [40, 111, 41]], [[9387, 9387], "disallowed_STD3_mapped", [40, 112, 41]], [[9388, 9388], "disallowed_STD3_mapped", [40, 113, 41]], [[9389, 9389], "disallowed_STD3_mapped", [40, 114, 41]], [[9390, 9390], "disallowed_STD3_mapped", [40, 115, 41]], [[9391, 9391], "disallowed_STD3_mapped", [40, 116, 41]], [[9392, 9392], "disallowed_STD3_mapped", [40, 117, 41]], [[9393, 9393], "disallowed_STD3_mapped", [40, 118, 41]], [[9394, 9394], "disallowed_STD3_mapped", [40, 119, 41]], [[9395, 9395], "disallowed_STD3_mapped", [40, 120, 41]], [[9396, 9396], "disallowed_STD3_mapped", [40, 121, 41]], [[9397, 9397], "disallowed_STD3_mapped", [40, 122, 41]], [[9398, 9398], "mapped", [97]], [[9399, 9399], "mapped", [98]], [[9400, 9400], "mapped", [99]], [[9401, 9401], "mapped", [100]], [[9402, 9402], "mapped", [101]], [[9403, 9403], "mapped", [102]], [[9404, 9404], "mapped", [103]], [[9405, 9405], "mapped", [104]], [[9406, 9406], "mapped", [105]], [[9407, 9407], "mapped", [106]], [[9408, 9408], "mapped", [107]], [[9409, 9409], "mapped", [108]], [[9410, 9410], "mapped", [109]], [[9411, 9411], "mapped", [110]], [[9412, 9412], "mapped", [111]], [[9413, 9413], "mapped", [112]], [[9414, 9414], "mapped", [113]], [[9415, 9415], "mapped", [114]], [[9416, 9416], "mapped", [115]], [[9417, 9417], "mapped", [116]], [[9418, 9418], "mapped", [117]], [[9419, 9419], "mapped", [118]], [[9420, 9420], "mapped", [119]], [[9421, 9421], "mapped", [120]], [[9422, 9422], "mapped", [121]], [[9423, 9423], "mapped", [122]], [[9424, 9424], "mapped", [97]], [[9425, 9425], "mapped", [98]], [[9426, 9426], "mapped", [99]], [[9427, 9427], "mapped", [100]], [[9428, 9428], "mapped", [101]], [[9429, 9429], "mapped", [102]], [[9430, 9430], "mapped", [103]], [[9431, 9431], "mapped", [104]], [[9432, 9432], "mapped", [105]], [[9433, 9433], "mapped", [106]], [[9434, 9434], "mapped", [107]], [[9435, 9435], "mapped", [108]], [[9436, 9436], "mapped", [109]], [[9437, 9437], "mapped", [110]], [[9438, 9438], "mapped", [111]], [[9439, 9439], "mapped", [112]], [[9440, 9440], "mapped", [113]], [[9441, 9441], "mapped", [114]], [[9442, 9442], "mapped", [115]], [[9443, 9443], "mapped", [116]], [[9444, 9444], "mapped", [117]], [[9445, 9445], "mapped", [118]], [[9446, 9446], "mapped", [119]], [[9447, 9447], "mapped", [120]], [[9448, 9448], "mapped", [121]], [[9449, 9449], "mapped", [122]], [[9450, 9450], "mapped", [48]], [[9451, 9470], "valid", [], "NV8"], [[9471, 9471], "valid", [], "NV8"], [[9472, 9621], "valid", [], "NV8"], [[9622, 9631], "valid", [], "NV8"], [[9632, 9711], "valid", [], "NV8"], [[9712, 9719], "valid", [], "NV8"], [[9720, 9727], "valid", [], "NV8"], [[9728, 9747], "valid", [], "NV8"], [[9748, 9749], "valid", [], "NV8"], [[9750, 9751], "valid", [], "NV8"], [[9752, 9752], "valid", [], "NV8"], [[9753, 9753], "valid", [], "NV8"], [[9754, 9839], "valid", [], "NV8"], [[9840, 9841], "valid", [], "NV8"], [[9842, 9853], "valid", [], "NV8"], [[9854, 9855], "valid", [], "NV8"], [[9856, 9865], "valid", [], "NV8"], [[9866, 9873], "valid", [], "NV8"], [[9874, 9884], "valid", [], "NV8"], [[9885, 9885], "valid", [], "NV8"], [[9886, 9887], "valid", [], "NV8"], [[9888, 9889], "valid", [], "NV8"], [[9890, 9905], "valid", [], "NV8"], [[9906, 9906], "valid", [], "NV8"], [[9907, 9916], "valid", [], "NV8"], [[9917, 9919], "valid", [], "NV8"], [[9920, 9923], "valid", [], "NV8"], [[9924, 9933], "valid", [], "NV8"], [[9934, 9934], "valid", [], "NV8"], [[9935, 9953], "valid", [], "NV8"], [[9954, 9954], "valid", [], "NV8"], [[9955, 9955], "valid", [], "NV8"], [[9956, 9959], "valid", [], "NV8"], [[9960, 9983], "valid", [], "NV8"], [[9984, 9984], "valid", [], "NV8"], [[9985, 9988], "valid", [], "NV8"], [[9989, 9989], "valid", [], "NV8"], [[9990, 9993], "valid", [], "NV8"], [[9994, 9995], "valid", [], "NV8"], [[9996, 10023], "valid", [], "NV8"], [[10024, 10024], "valid", [], "NV8"], [[10025, 10059], "valid", [], "NV8"], [[10060, 10060], "valid", [], "NV8"], [[10061, 10061], "valid", [], "NV8"], [[10062, 10062], "valid", [], "NV8"], [[10063, 10066], "valid", [], "NV8"], [[10067, 10069], "valid", [], "NV8"], [[10070, 10070], "valid", [], "NV8"], [[10071, 10071], "valid", [], "NV8"], [[10072, 10078], "valid", [], "NV8"], [[10079, 10080], "valid", [], "NV8"], [[10081, 10087], "valid", [], "NV8"], [[10088, 10101], "valid", [], "NV8"], [[10102, 10132], "valid", [], "NV8"], [[10133, 10135], "valid", [], "NV8"], [[10136, 10159], "valid", [], "NV8"], [[10160, 10160], "valid", [], "NV8"], [[10161, 10174], "valid", [], "NV8"], [[10175, 10175], "valid", [], "NV8"], [[10176, 10182], "valid", [], "NV8"], [[10183, 10186], "valid", [], "NV8"], [[10187, 10187], "valid", [], "NV8"], [[10188, 10188], "valid", [], "NV8"], [[10189, 10189], "valid", [], "NV8"], [[10190, 10191], "valid", [], "NV8"], [[10192, 10219], "valid", [], "NV8"], [[10220, 10223], "valid", [], "NV8"], [[10224, 10239], "valid", [], "NV8"], [[10240, 10495], "valid", [], "NV8"], [[10496, 10763], "valid", [], "NV8"], [[10764, 10764], "mapped", [8747, 8747, 8747, 8747]], [[10765, 10867], "valid", [], "NV8"], [[10868, 10868], "disallowed_STD3_mapped", [58, 58, 61]], [[10869, 10869], "disallowed_STD3_mapped", [61, 61]], [[10870, 10870], "disallowed_STD3_mapped", [61, 61, 61]], [[10871, 10971], "valid", [], "NV8"], [[10972, 10972], "mapped", [10973, 824]], [[10973, 11007], "valid", [], "NV8"], [[11008, 11021], "valid", [], "NV8"], [[11022, 11027], "valid", [], "NV8"], [[11028, 11034], "valid", [], "NV8"], [[11035, 11039], "valid", [], "NV8"], [[11040, 11043], "valid", [], "NV8"], [[11044, 11084], "valid", [], "NV8"], [[11085, 11087], "valid", [], "NV8"], [[11088, 11092], "valid", [], "NV8"], [[11093, 11097], "valid", [], "NV8"], [[11098, 11123], "valid", [], "NV8"], [[11124, 11125], "disallowed"], [[11126, 11157], "valid", [], "NV8"], [[11158, 11159], "disallowed"], [[11160, 11193], "valid", [], "NV8"], [[11194, 11196], "disallowed"], [[11197, 11208], "valid", [], "NV8"], [[11209, 11209], "disallowed"], [[11210, 11217], "valid", [], "NV8"], [[11218, 11243], "disallowed"], [[11244, 11247], "valid", [], "NV8"], [[11248, 11263], "disallowed"], [[11264, 11264], "mapped", [11312]], [[11265, 11265], "mapped", [11313]], [[11266, 11266], "mapped", [11314]], [[11267, 11267], "mapped", [11315]], [[11268, 11268], "mapped", [11316]], [[11269, 11269], "mapped", [11317]], [[11270, 11270], "mapped", [11318]], [[11271, 11271], "mapped", [11319]], [[11272, 11272], "mapped", [11320]], [[11273, 11273], "mapped", [11321]], [[11274, 11274], "mapped", [11322]], [[11275, 11275], "mapped", [11323]], [[11276, 11276], "mapped", [11324]], [[11277, 11277], "mapped", [11325]], [[11278, 11278], "mapped", [11326]], [[11279, 11279], "mapped", [11327]], [[11280, 11280], "mapped", [11328]], [[11281, 11281], "mapped", [11329]], [[11282, 11282], "mapped", [11330]], [[11283, 11283], "mapped", [11331]], [[11284, 11284], "mapped", [11332]], [[11285, 11285], "mapped", [11333]], [[11286, 11286], "mapped", [11334]], [[11287, 11287], "mapped", [11335]], [[11288, 11288], "mapped", [11336]], [[11289, 11289], "mapped", [11337]], [[11290, 11290], "mapped", [11338]], [[11291, 11291], "mapped", [11339]], [[11292, 11292], "mapped", [11340]], [[11293, 11293], "mapped", [11341]], [[11294, 11294], "mapped", [11342]], [[11295, 11295], "mapped", [11343]], [[11296, 11296], "mapped", [11344]], [[11297, 11297], "mapped", [11345]], [[11298, 11298], "mapped", [11346]], [[11299, 11299], "mapped", [11347]], [[11300, 11300], "mapped", [11348]], [[11301, 11301], "mapped", [11349]], [[11302, 11302], "mapped", [11350]], [[11303, 11303], "mapped", [11351]], [[11304, 11304], "mapped", [11352]], [[11305, 11305], "mapped", [11353]], [[11306, 11306], "mapped", [11354]], [[11307, 11307], "mapped", [11355]], [[11308, 11308], "mapped", [11356]], [[11309, 11309], "mapped", [11357]], [[11310, 11310], "mapped", [11358]], [[11311, 11311], "disallowed"], [[11312, 11358], "valid"], [[11359, 11359], "disallowed"], [[11360, 11360], "mapped", [11361]], [[11361, 11361], "valid"], [[11362, 11362], "mapped", [619]], [[11363, 11363], "mapped", [7549]], [[11364, 11364], "mapped", [637]], [[11365, 11366], "valid"], [[11367, 11367], "mapped", [11368]], [[11368, 11368], "valid"], [[11369, 11369], "mapped", [11370]], [[11370, 11370], "valid"], [[11371, 11371], "mapped", [11372]], [[11372, 11372], "valid"], [[11373, 11373], "mapped", [593]], [[11374, 11374], "mapped", [625]], [[11375, 11375], "mapped", [592]], [[11376, 11376], "mapped", [594]], [[11377, 11377], "valid"], [[11378, 11378], "mapped", [11379]], [[11379, 11379], "valid"], [[11380, 11380], "valid"], [[11381, 11381], "mapped", [11382]], [[11382, 11383], "valid"], [[11384, 11387], "valid"], [[11388, 11388], "mapped", [106]], [[11389, 11389], "mapped", [118]], [[11390, 11390], "mapped", [575]], [[11391, 11391], "mapped", [576]], [[11392, 11392], "mapped", [11393]], [[11393, 11393], "valid"], [[11394, 11394], "mapped", [11395]], [[11395, 11395], "valid"], [[11396, 11396], "mapped", [11397]], [[11397, 11397], "valid"], [[11398, 11398], "mapped", [11399]], [[11399, 11399], "valid"], [[11400, 11400], "mapped", [11401]], [[11401, 11401], "valid"], [[11402, 11402], "mapped", [11403]], [[11403, 11403], "valid"], [[11404, 11404], "mapped", [11405]], [[11405, 11405], "valid"], [[11406, 11406], "mapped", [11407]], [[11407, 11407], "valid"], [[11408, 11408], "mapped", [11409]], [[11409, 11409], "valid"], [[11410, 11410], "mapped", [11411]], [[11411, 11411], "valid"], [[11412, 11412], "mapped", [11413]], [[11413, 11413], "valid"], [[11414, 11414], "mapped", [11415]], [[11415, 11415], "valid"], [[11416, 11416], "mapped", [11417]], [[11417, 11417], "valid"], [[11418, 11418], "mapped", [11419]], [[11419, 11419], "valid"], [[11420, 11420], "mapped", [11421]], [[11421, 11421], "valid"], [[11422, 11422], "mapped", [11423]], [[11423, 11423], "valid"], [[11424, 11424], "mapped", [11425]], [[11425, 11425], "valid"], [[11426, 11426], "mapped", [11427]], [[11427, 11427], "valid"], [[11428, 11428], "mapped", [11429]], [[11429, 11429], "valid"], [[11430, 11430], "mapped", [11431]], [[11431, 11431], "valid"], [[11432, 11432], "mapped", [11433]], [[11433, 11433], "valid"], [[11434, 11434], "mapped", [11435]], [[11435, 11435], "valid"], [[11436, 11436], "mapped", [11437]], [[11437, 11437], "valid"], [[11438, 11438], "mapped", [11439]], [[11439, 11439], "valid"], [[11440, 11440], "mapped", [11441]], [[11441, 11441], "valid"], [[11442, 11442], "mapped", [11443]], [[11443, 11443], "valid"], [[11444, 11444], "mapped", [11445]], [[11445, 11445], "valid"], [[11446, 11446], "mapped", [11447]], [[11447, 11447], "valid"], [[11448, 11448], "mapped", [11449]], [[11449, 11449], "valid"], [[11450, 11450], "mapped", [11451]], [[11451, 11451], "valid"], [[11452, 11452], "mapped", [11453]], [[11453, 11453], "valid"], [[11454, 11454], "mapped", [11455]], [[11455, 11455], "valid"], [[11456, 11456], "mapped", [11457]], [[11457, 11457], "valid"], [[11458, 11458], "mapped", [11459]], [[11459, 11459], "valid"], [[11460, 11460], "mapped", [11461]], [[11461, 11461], "valid"], [[11462, 11462], "mapped", [11463]], [[11463, 11463], "valid"], [[11464, 11464], "mapped", [11465]], [[11465, 11465], "valid"], [[11466, 11466], "mapped", [11467]], [[11467, 11467], "valid"], [[11468, 11468], "mapped", [11469]], [[11469, 11469], "valid"], [[11470, 11470], "mapped", [11471]], [[11471, 11471], "valid"], [[11472, 11472], "mapped", [11473]], [[11473, 11473], "valid"], [[11474, 11474], "mapped", [11475]], [[11475, 11475], "valid"], [[11476, 11476], "mapped", [11477]], [[11477, 11477], "valid"], [[11478, 11478], "mapped", [11479]], [[11479, 11479], "valid"], [[11480, 11480], "mapped", [11481]], [[11481, 11481], "valid"], [[11482, 11482], "mapped", [11483]], [[11483, 11483], "valid"], [[11484, 11484], "mapped", [11485]], [[11485, 11485], "valid"], [[11486, 11486], "mapped", [11487]], [[11487, 11487], "valid"], [[11488, 11488], "mapped", [11489]], [[11489, 11489], "valid"], [[11490, 11490], "mapped", [11491]], [[11491, 11492], "valid"], [[11493, 11498], "valid", [], "NV8"], [[11499, 11499], "mapped", [11500]], [[11500, 11500], "valid"], [[11501, 11501], "mapped", [11502]], [[11502, 11505], "valid"], [[11506, 11506], "mapped", [11507]], [[11507, 11507], "valid"], [[11508, 11512], "disallowed"], [[11513, 11519], "valid", [], "NV8"], [[11520, 11557], "valid"], [[11558, 11558], "disallowed"], [[11559, 11559], "valid"], [[11560, 11564], "disallowed"], [[11565, 11565], "valid"], [[11566, 11567], "disallowed"], [[11568, 11621], "valid"], [[11622, 11623], "valid"], [[11624, 11630], "disallowed"], [[11631, 11631], "mapped", [11617]], [[11632, 11632], "valid", [], "NV8"], [[11633, 11646], "disallowed"], [[11647, 11647], "valid"], [[11648, 11670], "valid"], [[11671, 11679], "disallowed"], [[11680, 11686], "valid"], [[11687, 11687], "disallowed"], [[11688, 11694], "valid"], [[11695, 11695], "disallowed"], [[11696, 11702], "valid"], [[11703, 11703], "disallowed"], [[11704, 11710], "valid"], [[11711, 11711], "disallowed"], [[11712, 11718], "valid"], [[11719, 11719], "disallowed"], [[11720, 11726], "valid"], [[11727, 11727], "disallowed"], [[11728, 11734], "valid"], [[11735, 11735], "disallowed"], [[11736, 11742], "valid"], [[11743, 11743], "disallowed"], [[11744, 11775], "valid"], [[11776, 11799], "valid", [], "NV8"], [[11800, 11803], "valid", [], "NV8"], [[11804, 11805], "valid", [], "NV8"], [[11806, 11822], "valid", [], "NV8"], [[11823, 11823], "valid"], [[11824, 11824], "valid", [], "NV8"], [[11825, 11825], "valid", [], "NV8"], [[11826, 11835], "valid", [], "NV8"], [[11836, 11842], "valid", [], "NV8"], [[11843, 11903], "disallowed"], [[11904, 11929], "valid", [], "NV8"], [[11930, 11930], "disallowed"], [[11931, 11934], "valid", [], "NV8"], [[11935, 11935], "mapped", [27597]], [[11936, 12018], "valid", [], "NV8"], [[12019, 12019], "mapped", [40863]], [[12020, 12031], "disallowed"], [[12032, 12032], "mapped", [19968]], [[12033, 12033], "mapped", [20008]], [[12034, 12034], "mapped", [20022]], [[12035, 12035], "mapped", [20031]], [[12036, 12036], "mapped", [20057]], [[12037, 12037], "mapped", [20101]], [[12038, 12038], "mapped", [20108]], [[12039, 12039], "mapped", [20128]], [[12040, 12040], "mapped", [20154]], [[12041, 12041], "mapped", [20799]], [[12042, 12042], "mapped", [20837]], [[12043, 12043], "mapped", [20843]], [[12044, 12044], "mapped", [20866]], [[12045, 12045], "mapped", [20886]], [[12046, 12046], "mapped", [20907]], [[12047, 12047], "mapped", [20960]], [[12048, 12048], "mapped", [20981]], [[12049, 12049], "mapped", [20992]], [[12050, 12050], "mapped", [21147]], [[12051, 12051], "mapped", [21241]], [[12052, 12052], "mapped", [21269]], [[12053, 12053], "mapped", [21274]], [[12054, 12054], "mapped", [21304]], [[12055, 12055], "mapped", [21313]], [[12056, 12056], "mapped", [21340]], [[12057, 12057], "mapped", [21353]], [[12058, 12058], "mapped", [21378]], [[12059, 12059], "mapped", [21430]], [[12060, 12060], "mapped", [21448]], [[12061, 12061], "mapped", [21475]], [[12062, 12062], "mapped", [22231]], [[12063, 12063], "mapped", [22303]], [[12064, 12064], "mapped", [22763]], [[12065, 12065], "mapped", [22786]], [[12066, 12066], "mapped", [22794]], [[12067, 12067], "mapped", [22805]], [[12068, 12068], "mapped", [22823]], [[12069, 12069], "mapped", [22899]], [[12070, 12070], "mapped", [23376]], [[12071, 12071], "mapped", [23424]], [[12072, 12072], "mapped", [23544]], [[12073, 12073], "mapped", [23567]], [[12074, 12074], "mapped", [23586]], [[12075, 12075], "mapped", [23608]], [[12076, 12076], "mapped", [23662]], [[12077, 12077], "mapped", [23665]], [[12078, 12078], "mapped", [24027]], [[12079, 12079], "mapped", [24037]], [[12080, 12080], "mapped", [24049]], [[12081, 12081], "mapped", [24062]], [[12082, 12082], "mapped", [24178]], [[12083, 12083], "mapped", [24186]], [[12084, 12084], "mapped", [24191]], [[12085, 12085], "mapped", [24308]], [[12086, 12086], "mapped", [24318]], [[12087, 12087], "mapped", [24331]], [[12088, 12088], "mapped", [24339]], [[12089, 12089], "mapped", [24400]], [[12090, 12090], "mapped", [24417]], [[12091, 12091], "mapped", [24435]], [[12092, 12092], "mapped", [24515]], [[12093, 12093], "mapped", [25096]], [[12094, 12094], "mapped", [25142]], [[12095, 12095], "mapped", [25163]], [[12096, 12096], "mapped", [25903]], [[12097, 12097], "mapped", [25908]], [[12098, 12098], "mapped", [25991]], [[12099, 12099], "mapped", [26007]], [[12100, 12100], "mapped", [26020]], [[12101, 12101], "mapped", [26041]], [[12102, 12102], "mapped", [26080]], [[12103, 12103], "mapped", [26085]], [[12104, 12104], "mapped", [26352]], [[12105, 12105], "mapped", [26376]], [[12106, 12106], "mapped", [26408]], [[12107, 12107], "mapped", [27424]], [[12108, 12108], "mapped", [27490]], [[12109, 12109], "mapped", [27513]], [[12110, 12110], "mapped", [27571]], [[12111, 12111], "mapped", [27595]], [[12112, 12112], "mapped", [27604]], [[12113, 12113], "mapped", [27611]], [[12114, 12114], "mapped", [27663]], [[12115, 12115], "mapped", [27668]], [[12116, 12116], "mapped", [27700]], [[12117, 12117], "mapped", [28779]], [[12118, 12118], "mapped", [29226]], [[12119, 12119], "mapped", [29238]], [[12120, 12120], "mapped", [29243]], [[12121, 12121], "mapped", [29247]], [[12122, 12122], "mapped", [29255]], [[12123, 12123], "mapped", [29273]], [[12124, 12124], "mapped", [29275]], [[12125, 12125], "mapped", [29356]], [[12126, 12126], "mapped", [29572]], [[12127, 12127], "mapped", [29577]], [[12128, 12128], "mapped", [29916]], [[12129, 12129], "mapped", [29926]], [[12130, 12130], "mapped", [29976]], [[12131, 12131], "mapped", [29983]], [[12132, 12132], "mapped", [29992]], [[12133, 12133], "mapped", [3e4]], [[12134, 12134], "mapped", [30091]], [[12135, 12135], "mapped", [30098]], [[12136, 12136], "mapped", [30326]], [[12137, 12137], "mapped", [30333]], [[12138, 12138], "mapped", [30382]], [[12139, 12139], "mapped", [30399]], [[12140, 12140], "mapped", [30446]], [[12141, 12141], "mapped", [30683]], [[12142, 12142], "mapped", [30690]], [[12143, 12143], "mapped", [30707]], [[12144, 12144], "mapped", [31034]], [[12145, 12145], "mapped", [31160]], [[12146, 12146], "mapped", [31166]], [[12147, 12147], "mapped", [31348]], [[12148, 12148], "mapped", [31435]], [[12149, 12149], "mapped", [31481]], [[12150, 12150], "mapped", [31859]], [[12151, 12151], "mapped", [31992]], [[12152, 12152], "mapped", [32566]], [[12153, 12153], "mapped", [32593]], [[12154, 12154], "mapped", [32650]], [[12155, 12155], "mapped", [32701]], [[12156, 12156], "mapped", [32769]], [[12157, 12157], "mapped", [32780]], [[12158, 12158], "mapped", [32786]], [[12159, 12159], "mapped", [32819]], [[12160, 12160], "mapped", [32895]], [[12161, 12161], "mapped", [32905]], [[12162, 12162], "mapped", [33251]], [[12163, 12163], "mapped", [33258]], [[12164, 12164], "mapped", [33267]], [[12165, 12165], "mapped", [33276]], [[12166, 12166], "mapped", [33292]], [[12167, 12167], "mapped", [33307]], [[12168, 12168], "mapped", [33311]], [[12169, 12169], "mapped", [33390]], [[12170, 12170], "mapped", [33394]], [[12171, 12171], "mapped", [33400]], [[12172, 12172], "mapped", [34381]], [[12173, 12173], "mapped", [34411]], [[12174, 12174], "mapped", [34880]], [[12175, 12175], "mapped", [34892]], [[12176, 12176], "mapped", [34915]], [[12177, 12177], "mapped", [35198]], [[12178, 12178], "mapped", [35211]], [[12179, 12179], "mapped", [35282]], [[12180, 12180], "mapped", [35328]], [[12181, 12181], "mapped", [35895]], [[12182, 12182], "mapped", [35910]], [[12183, 12183], "mapped", [35925]], [[12184, 12184], "mapped", [35960]], [[12185, 12185], "mapped", [35997]], [[12186, 12186], "mapped", [36196]], [[12187, 12187], "mapped", [36208]], [[12188, 12188], "mapped", [36275]], [[12189, 12189], "mapped", [36523]], [[12190, 12190], "mapped", [36554]], [[12191, 12191], "mapped", [36763]], [[12192, 12192], "mapped", [36784]], [[12193, 12193], "mapped", [36789]], [[12194, 12194], "mapped", [37009]], [[12195, 12195], "mapped", [37193]], [[12196, 12196], "mapped", [37318]], [[12197, 12197], "mapped", [37324]], [[12198, 12198], "mapped", [37329]], [[12199, 12199], "mapped", [38263]], [[12200, 12200], "mapped", [38272]], [[12201, 12201], "mapped", [38428]], [[12202, 12202], "mapped", [38582]], [[12203, 12203], "mapped", [38585]], [[12204, 12204], "mapped", [38632]], [[12205, 12205], "mapped", [38737]], [[12206, 12206], "mapped", [38750]], [[12207, 12207], "mapped", [38754]], [[12208, 12208], "mapped", [38761]], [[12209, 12209], "mapped", [38859]], [[12210, 12210], "mapped", [38893]], [[12211, 12211], "mapped", [38899]], [[12212, 12212], "mapped", [38913]], [[12213, 12213], "mapped", [39080]], [[12214, 12214], "mapped", [39131]], [[12215, 12215], "mapped", [39135]], [[12216, 12216], "mapped", [39318]], [[12217, 12217], "mapped", [39321]], [[12218, 12218], "mapped", [39340]], [[12219, 12219], "mapped", [39592]], [[12220, 12220], "mapped", [39640]], [[12221, 12221], "mapped", [39647]], [[12222, 12222], "mapped", [39717]], [[12223, 12223], "mapped", [39727]], [[12224, 12224], "mapped", [39730]], [[12225, 12225], "mapped", [39740]], [[12226, 12226], "mapped", [39770]], [[12227, 12227], "mapped", [40165]], [[12228, 12228], "mapped", [40565]], [[12229, 12229], "mapped", [40575]], [[12230, 12230], "mapped", [40613]], [[12231, 12231], "mapped", [40635]], [[12232, 12232], "mapped", [40643]], [[12233, 12233], "mapped", [40653]], [[12234, 12234], "mapped", [40657]], [[12235, 12235], "mapped", [40697]], [[12236, 12236], "mapped", [40701]], [[12237, 12237], "mapped", [40718]], [[12238, 12238], "mapped", [40723]], [[12239, 12239], "mapped", [40736]], [[12240, 12240], "mapped", [40763]], [[12241, 12241], "mapped", [40778]], [[12242, 12242], "mapped", [40786]], [[12243, 12243], "mapped", [40845]], [[12244, 12244], "mapped", [40860]], [[12245, 12245], "mapped", [40864]], [[12246, 12271], "disallowed"], [[12272, 12283], "disallowed"], [[12284, 12287], "disallowed"], [[12288, 12288], "disallowed_STD3_mapped", [32]], [[12289, 12289], "valid", [], "NV8"], [[12290, 12290], "mapped", [46]], [[12291, 12292], "valid", [], "NV8"], [[12293, 12295], "valid"], [[12296, 12329], "valid", [], "NV8"], [[12330, 12333], "valid"], [[12334, 12341], "valid", [], "NV8"], [[12342, 12342], "mapped", [12306]], [[12343, 12343], "valid", [], "NV8"], [[12344, 12344], "mapped", [21313]], [[12345, 12345], "mapped", [21316]], [[12346, 12346], "mapped", [21317]], [[12347, 12347], "valid", [], "NV8"], [[12348, 12348], "valid"], [[12349, 12349], "valid", [], "NV8"], [[12350, 12350], "valid", [], "NV8"], [[12351, 12351], "valid", [], "NV8"], [[12352, 12352], "disallowed"], [[12353, 12436], "valid"], [[12437, 12438], "valid"], [[12439, 12440], "disallowed"], [[12441, 12442], "valid"], [[12443, 12443], "disallowed_STD3_mapped", [32, 12441]], [[12444, 12444], "disallowed_STD3_mapped", [32, 12442]], [[12445, 12446], "valid"], [[12447, 12447], "mapped", [12424, 12426]], [[12448, 12448], "valid", [], "NV8"], [[12449, 12542], "valid"], [[12543, 12543], "mapped", [12467, 12488]], [[12544, 12548], "disallowed"], [[12549, 12588], "valid"], [[12589, 12589], "valid"], [[12590, 12592], "disallowed"], [[12593, 12593], "mapped", [4352]], [[12594, 12594], "mapped", [4353]], [[12595, 12595], "mapped", [4522]], [[12596, 12596], "mapped", [4354]], [[12597, 12597], "mapped", [4524]], [[12598, 12598], "mapped", [4525]], [[12599, 12599], "mapped", [4355]], [[12600, 12600], "mapped", [4356]], [[12601, 12601], "mapped", [4357]], [[12602, 12602], "mapped", [4528]], [[12603, 12603], "mapped", [4529]], [[12604, 12604], "mapped", [4530]], [[12605, 12605], "mapped", [4531]], [[12606, 12606], "mapped", [4532]], [[12607, 12607], "mapped", [4533]], [[12608, 12608], "mapped", [4378]], [[12609, 12609], "mapped", [4358]], [[12610, 12610], "mapped", [4359]], [[12611, 12611], "mapped", [4360]], [[12612, 12612], "mapped", [4385]], [[12613, 12613], "mapped", [4361]], [[12614, 12614], "mapped", [4362]], [[12615, 12615], "mapped", [4363]], [[12616, 12616], "mapped", [4364]], [[12617, 12617], "mapped", [4365]], [[12618, 12618], "mapped", [4366]], [[12619, 12619], "mapped", [4367]], [[12620, 12620], "mapped", [4368]], [[12621, 12621], "mapped", [4369]], [[12622, 12622], "mapped", [4370]], [[12623, 12623], "mapped", [4449]], [[12624, 12624], "mapped", [4450]], [[12625, 12625], "mapped", [4451]], [[12626, 12626], "mapped", [4452]], [[12627, 12627], "mapped", [4453]], [[12628, 12628], "mapped", [4454]], [[12629, 12629], "mapped", [4455]], [[12630, 12630], "mapped", [4456]], [[12631, 12631], "mapped", [4457]], [[12632, 12632], "mapped", [4458]], [[12633, 12633], "mapped", [4459]], [[12634, 12634], "mapped", [4460]], [[12635, 12635], "mapped", [4461]], [[12636, 12636], "mapped", [4462]], [[12637, 12637], "mapped", [4463]], [[12638, 12638], "mapped", [4464]], [[12639, 12639], "mapped", [4465]], [[12640, 12640], "mapped", [4466]], [[12641, 12641], "mapped", [4467]], [[12642, 12642], "mapped", [4468]], [[12643, 12643], "mapped", [4469]], [[12644, 12644], "disallowed"], [[12645, 12645], "mapped", [4372]], [[12646, 12646], "mapped", [4373]], [[12647, 12647], "mapped", [4551]], [[12648, 12648], "mapped", [4552]], [[12649, 12649], "mapped", [4556]], [[12650, 12650], "mapped", [4558]], [[12651, 12651], "mapped", [4563]], [[12652, 12652], "mapped", [4567]], [[12653, 12653], "mapped", [4569]], [[12654, 12654], "mapped", [4380]], [[12655, 12655], "mapped", [4573]], [[12656, 12656], "mapped", [4575]], [[12657, 12657], "mapped", [4381]], [[12658, 12658], "mapped", [4382]], [[12659, 12659], "mapped", [4384]], [[12660, 12660], "mapped", [4386]], [[12661, 12661], "mapped", [4387]], [[12662, 12662], "mapped", [4391]], [[12663, 12663], "mapped", [4393]], [[12664, 12664], "mapped", [4395]], [[12665, 12665], "mapped", [4396]], [[12666, 12666], "mapped", [4397]], [[12667, 12667], "mapped", [4398]], [[12668, 12668], "mapped", [4399]], [[12669, 12669], "mapped", [4402]], [[12670, 12670], "mapped", [4406]], [[12671, 12671], "mapped", [4416]], [[12672, 12672], "mapped", [4423]], [[12673, 12673], "mapped", [4428]], [[12674, 12674], "mapped", [4593]], [[12675, 12675], "mapped", [4594]], [[12676, 12676], "mapped", [4439]], [[12677, 12677], "mapped", [4440]], [[12678, 12678], "mapped", [4441]], [[12679, 12679], "mapped", [4484]], [[12680, 12680], "mapped", [4485]], [[12681, 12681], "mapped", [4488]], [[12682, 12682], "mapped", [4497]], [[12683, 12683], "mapped", [4498]], [[12684, 12684], "mapped", [4500]], [[12685, 12685], "mapped", [4510]], [[12686, 12686], "mapped", [4513]], [[12687, 12687], "disallowed"], [[12688, 12689], "valid", [], "NV8"], [[12690, 12690], "mapped", [19968]], [[12691, 12691], "mapped", [20108]], [[12692, 12692], "mapped", [19977]], [[12693, 12693], "mapped", [22235]], [[12694, 12694], "mapped", [19978]], [[12695, 12695], "mapped", [20013]], [[12696, 12696], "mapped", [19979]], [[12697, 12697], "mapped", [30002]], [[12698, 12698], "mapped", [20057]], [[12699, 12699], "mapped", [19993]], [[12700, 12700], "mapped", [19969]], [[12701, 12701], "mapped", [22825]], [[12702, 12702], "mapped", [22320]], [[12703, 12703], "mapped", [20154]], [[12704, 12727], "valid"], [[12728, 12730], "valid"], [[12731, 12735], "disallowed"], [[12736, 12751], "valid", [], "NV8"], [[12752, 12771], "valid", [], "NV8"], [[12772, 12783], "disallowed"], [[12784, 12799], "valid"], [[12800, 12800], "disallowed_STD3_mapped", [40, 4352, 41]], [[12801, 12801], "disallowed_STD3_mapped", [40, 4354, 41]], [[12802, 12802], "disallowed_STD3_mapped", [40, 4355, 41]], [[12803, 12803], "disallowed_STD3_mapped", [40, 4357, 41]], [[12804, 12804], "disallowed_STD3_mapped", [40, 4358, 41]], [[12805, 12805], "disallowed_STD3_mapped", [40, 4359, 41]], [[12806, 12806], "disallowed_STD3_mapped", [40, 4361, 41]], [[12807, 12807], "disallowed_STD3_mapped", [40, 4363, 41]], [[12808, 12808], "disallowed_STD3_mapped", [40, 4364, 41]], [[12809, 12809], "disallowed_STD3_mapped", [40, 4366, 41]], [[12810, 12810], "disallowed_STD3_mapped", [40, 4367, 41]], [[12811, 12811], "disallowed_STD3_mapped", [40, 4368, 41]], [[12812, 12812], "disallowed_STD3_mapped", [40, 4369, 41]], [[12813, 12813], "disallowed_STD3_mapped", [40, 4370, 41]], [[12814, 12814], "disallowed_STD3_mapped", [40, 44032, 41]], [[12815, 12815], "disallowed_STD3_mapped", [40, 45208, 41]], [[12816, 12816], "disallowed_STD3_mapped", [40, 45796, 41]], [[12817, 12817], "disallowed_STD3_mapped", [40, 46972, 41]], [[12818, 12818], "disallowed_STD3_mapped", [40, 47560, 41]], [[12819, 12819], "disallowed_STD3_mapped", [40, 48148, 41]], [[12820, 12820], "disallowed_STD3_mapped", [40, 49324, 41]], [[12821, 12821], "disallowed_STD3_mapped", [40, 50500, 41]], [[12822, 12822], "disallowed_STD3_mapped", [40, 51088, 41]], [[12823, 12823], "disallowed_STD3_mapped", [40, 52264, 41]], [[12824, 12824], "disallowed_STD3_mapped", [40, 52852, 41]], [[12825, 12825], "disallowed_STD3_mapped", [40, 53440, 41]], [[12826, 12826], "disallowed_STD3_mapped", [40, 54028, 41]], [[12827, 12827], "disallowed_STD3_mapped", [40, 54616, 41]], [[12828, 12828], "disallowed_STD3_mapped", [40, 51452, 41]], [[12829, 12829], "disallowed_STD3_mapped", [40, 50724, 51204, 41]], [[12830, 12830], "disallowed_STD3_mapped", [40, 50724, 54980, 41]], [[12831, 12831], "disallowed"], [[12832, 12832], "disallowed_STD3_mapped", [40, 19968, 41]], [[12833, 12833], "disallowed_STD3_mapped", [40, 20108, 41]], [[12834, 12834], "disallowed_STD3_mapped", [40, 19977, 41]], [[12835, 12835], "disallowed_STD3_mapped", [40, 22235, 41]], [[12836, 12836], "disallowed_STD3_mapped", [40, 20116, 41]], [[12837, 12837], "disallowed_STD3_mapped", [40, 20845, 41]], [[12838, 12838], "disallowed_STD3_mapped", [40, 19971, 41]], [[12839, 12839], "disallowed_STD3_mapped", [40, 20843, 41]], [[12840, 12840], "disallowed_STD3_mapped", [40, 20061, 41]], [[12841, 12841], "disallowed_STD3_mapped", [40, 21313, 41]], [[12842, 12842], "disallowed_STD3_mapped", [40, 26376, 41]], [[12843, 12843], "disallowed_STD3_mapped", [40, 28779, 41]], [[12844, 12844], "disallowed_STD3_mapped", [40, 27700, 41]], [[12845, 12845], "disallowed_STD3_mapped", [40, 26408, 41]], [[12846, 12846], "disallowed_STD3_mapped", [40, 37329, 41]], [[12847, 12847], "disallowed_STD3_mapped", [40, 22303, 41]], [[12848, 12848], "disallowed_STD3_mapped", [40, 26085, 41]], [[12849, 12849], "disallowed_STD3_mapped", [40, 26666, 41]], [[12850, 12850], "disallowed_STD3_mapped", [40, 26377, 41]], [[12851, 12851], "disallowed_STD3_mapped", [40, 31038, 41]], [[12852, 12852], "disallowed_STD3_mapped", [40, 21517, 41]], [[12853, 12853], "disallowed_STD3_mapped", [40, 29305, 41]], [[12854, 12854], "disallowed_STD3_mapped", [40, 36001, 41]], [[12855, 12855], "disallowed_STD3_mapped", [40, 31069, 41]], [[12856, 12856], "disallowed_STD3_mapped", [40, 21172, 41]], [[12857, 12857], "disallowed_STD3_mapped", [40, 20195, 41]], [[12858, 12858], "disallowed_STD3_mapped", [40, 21628, 41]], [[12859, 12859], "disallowed_STD3_mapped", [40, 23398, 41]], [[12860, 12860], "disallowed_STD3_mapped", [40, 30435, 41]], [[12861, 12861], "disallowed_STD3_mapped", [40, 20225, 41]], [[12862, 12862], "disallowed_STD3_mapped", [40, 36039, 41]], [[12863, 12863], "disallowed_STD3_mapped", [40, 21332, 41]], [[12864, 12864], "disallowed_STD3_mapped", [40, 31085, 41]], [[12865, 12865], "disallowed_STD3_mapped", [40, 20241, 41]], [[12866, 12866], "disallowed_STD3_mapped", [40, 33258, 41]], [[12867, 12867], "disallowed_STD3_mapped", [40, 33267, 41]], [[12868, 12868], "mapped", [21839]], [[12869, 12869], "mapped", [24188]], [[12870, 12870], "mapped", [25991]], [[12871, 12871], "mapped", [31631]], [[12872, 12879], "valid", [], "NV8"], [[12880, 12880], "mapped", [112, 116, 101]], [[12881, 12881], "mapped", [50, 49]], [[12882, 12882], "mapped", [50, 50]], [[12883, 12883], "mapped", [50, 51]], [[12884, 12884], "mapped", [50, 52]], [[12885, 12885], "mapped", [50, 53]], [[12886, 12886], "mapped", [50, 54]], [[12887, 12887], "mapped", [50, 55]], [[12888, 12888], "mapped", [50, 56]], [[12889, 12889], "mapped", [50, 57]], [[12890, 12890], "mapped", [51, 48]], [[12891, 12891], "mapped", [51, 49]], [[12892, 12892], "mapped", [51, 50]], [[12893, 12893], "mapped", [51, 51]], [[12894, 12894], "mapped", [51, 52]], [[12895, 12895], "mapped", [51, 53]], [[12896, 12896], "mapped", [4352]], [[12897, 12897], "mapped", [4354]], [[12898, 12898], "mapped", [4355]], [[12899, 12899], "mapped", [4357]], [[12900, 12900], "mapped", [4358]], [[12901, 12901], "mapped", [4359]], [[12902, 12902], "mapped", [4361]], [[12903, 12903], "mapped", [4363]], [[12904, 12904], "mapped", [4364]], [[12905, 12905], "mapped", [4366]], [[12906, 12906], "mapped", [4367]], [[12907, 12907], "mapped", [4368]], [[12908, 12908], "mapped", [4369]], [[12909, 12909], "mapped", [4370]], [[12910, 12910], "mapped", [44032]], [[12911, 12911], "mapped", [45208]], [[12912, 12912], "mapped", [45796]], [[12913, 12913], "mapped", [46972]], [[12914, 12914], "mapped", [47560]], [[12915, 12915], "mapped", [48148]], [[12916, 12916], "mapped", [49324]], [[12917, 12917], "mapped", [50500]], [[12918, 12918], "mapped", [51088]], [[12919, 12919], "mapped", [52264]], [[12920, 12920], "mapped", [52852]], [[12921, 12921], "mapped", [53440]], [[12922, 12922], "mapped", [54028]], [[12923, 12923], "mapped", [54616]], [[12924, 12924], "mapped", [52280, 44256]], [[12925, 12925], "mapped", [51452, 51032]], [[12926, 12926], "mapped", [50864]], [[12927, 12927], "valid", [], "NV8"], [[12928, 12928], "mapped", [19968]], [[12929, 12929], "mapped", [20108]], [[12930, 12930], "mapped", [19977]], [[12931, 12931], "mapped", [22235]], [[12932, 12932], "mapped", [20116]], [[12933, 12933], "mapped", [20845]], [[12934, 12934], "mapped", [19971]], [[12935, 12935], "mapped", [20843]], [[12936, 12936], "mapped", [20061]], [[12937, 12937], "mapped", [21313]], [[12938, 12938], "mapped", [26376]], [[12939, 12939], "mapped", [28779]], [[12940, 12940], "mapped", [27700]], [[12941, 12941], "mapped", [26408]], [[12942, 12942], "mapped", [37329]], [[12943, 12943], "mapped", [22303]], [[12944, 12944], "mapped", [26085]], [[12945, 12945], "mapped", [26666]], [[12946, 12946], "mapped", [26377]], [[12947, 12947], "mapped", [31038]], [[12948, 12948], "mapped", [21517]], [[12949, 12949], "mapped", [29305]], [[12950, 12950], "mapped", [36001]], [[12951, 12951], "mapped", [31069]], [[12952, 12952], "mapped", [21172]], [[12953, 12953], "mapped", [31192]], [[12954, 12954], "mapped", [30007]], [[12955, 12955], "mapped", [22899]], [[12956, 12956], "mapped", [36969]], [[12957, 12957], "mapped", [20778]], [[12958, 12958], "mapped", [21360]], [[12959, 12959], "mapped", [27880]], [[12960, 12960], "mapped", [38917]], [[12961, 12961], "mapped", [20241]], [[12962, 12962], "mapped", [20889]], [[12963, 12963], "mapped", [27491]], [[12964, 12964], "mapped", [19978]], [[12965, 12965], "mapped", [20013]], [[12966, 12966], "mapped", [19979]], [[12967, 12967], "mapped", [24038]], [[12968, 12968], "mapped", [21491]], [[12969, 12969], "mapped", [21307]], [[12970, 12970], "mapped", [23447]], [[12971, 12971], "mapped", [23398]], [[12972, 12972], "mapped", [30435]], [[12973, 12973], "mapped", [20225]], [[12974, 12974], "mapped", [36039]], [[12975, 12975], "mapped", [21332]], [[12976, 12976], "mapped", [22812]], [[12977, 12977], "mapped", [51, 54]], [[12978, 12978], "mapped", [51, 55]], [[12979, 12979], "mapped", [51, 56]], [[12980, 12980], "mapped", [51, 57]], [[12981, 12981], "mapped", [52, 48]], [[12982, 12982], "mapped", [52, 49]], [[12983, 12983], "mapped", [52, 50]], [[12984, 12984], "mapped", [52, 51]], [[12985, 12985], "mapped", [52, 52]], [[12986, 12986], "mapped", [52, 53]], [[12987, 12987], "mapped", [52, 54]], [[12988, 12988], "mapped", [52, 55]], [[12989, 12989], "mapped", [52, 56]], [[12990, 12990], "mapped", [52, 57]], [[12991, 12991], "mapped", [53, 48]], [[12992, 12992], "mapped", [49, 26376]], [[12993, 12993], "mapped", [50, 26376]], [[12994, 12994], "mapped", [51, 26376]], [[12995, 12995], "mapped", [52, 26376]], [[12996, 12996], "mapped", [53, 26376]], [[12997, 12997], "mapped", [54, 26376]], [[12998, 12998], "mapped", [55, 26376]], [[12999, 12999], "mapped", [56, 26376]], [[13e3, 13e3], "mapped", [57, 26376]], [[13001, 13001], "mapped", [49, 48, 26376]], [[13002, 13002], "mapped", [49, 49, 26376]], [[13003, 13003], "mapped", [49, 50, 26376]], [[13004, 13004], "mapped", [104, 103]], [[13005, 13005], "mapped", [101, 114, 103]], [[13006, 13006], "mapped", [101, 118]], [[13007, 13007], "mapped", [108, 116, 100]], [[13008, 13008], "mapped", [12450]], [[13009, 13009], "mapped", [12452]], [[13010, 13010], "mapped", [12454]], [[13011, 13011], "mapped", [12456]], [[13012, 13012], "mapped", [12458]], [[13013, 13013], "mapped", [12459]], [[13014, 13014], "mapped", [12461]], [[13015, 13015], "mapped", [12463]], [[13016, 13016], "mapped", [12465]], [[13017, 13017], "mapped", [12467]], [[13018, 13018], "mapped", [12469]], [[13019, 13019], "mapped", [12471]], [[13020, 13020], "mapped", [12473]], [[13021, 13021], "mapped", [12475]], [[13022, 13022], "mapped", [12477]], [[13023, 13023], "mapped", [12479]], [[13024, 13024], "mapped", [12481]], [[13025, 13025], "mapped", [12484]], [[13026, 13026], "mapped", [12486]], [[13027, 13027], "mapped", [12488]], [[13028, 13028], "mapped", [12490]], [[13029, 13029], "mapped", [12491]], [[13030, 13030], "mapped", [12492]], [[13031, 13031], "mapped", [12493]], [[13032, 13032], "mapped", [12494]], [[13033, 13033], "mapped", [12495]], [[13034, 13034], "mapped", [12498]], [[13035, 13035], "mapped", [12501]], [[13036, 13036], "mapped", [12504]], [[13037, 13037], "mapped", [12507]], [[13038, 13038], "mapped", [12510]], [[13039, 13039], "mapped", [12511]], [[13040, 13040], "mapped", [12512]], [[13041, 13041], "mapped", [12513]], [[13042, 13042], "mapped", [12514]], [[13043, 13043], "mapped", [12516]], [[13044, 13044], "mapped", [12518]], [[13045, 13045], "mapped", [12520]], [[13046, 13046], "mapped", [12521]], [[13047, 13047], "mapped", [12522]], [[13048, 13048], "mapped", [12523]], [[13049, 13049], "mapped", [12524]], [[13050, 13050], "mapped", [12525]], [[13051, 13051], "mapped", [12527]], [[13052, 13052], "mapped", [12528]], [[13053, 13053], "mapped", [12529]], [[13054, 13054], "mapped", [12530]], [[13055, 13055], "disallowed"], [[13056, 13056], "mapped", [12450, 12497, 12540, 12488]], [[13057, 13057], "mapped", [12450, 12523, 12501, 12449]], [[13058, 13058], "mapped", [12450, 12531, 12506, 12450]], [[13059, 13059], "mapped", [12450, 12540, 12523]], [[13060, 13060], "mapped", [12452, 12491, 12531, 12464]], [[13061, 13061], "mapped", [12452, 12531, 12481]], [[13062, 13062], "mapped", [12454, 12457, 12531]], [[13063, 13063], "mapped", [12456, 12473, 12463, 12540, 12489]], [[13064, 13064], "mapped", [12456, 12540, 12459, 12540]], [[13065, 13065], "mapped", [12458, 12531, 12473]], [[13066, 13066], "mapped", [12458, 12540, 12512]], [[13067, 13067], "mapped", [12459, 12452, 12522]], [[13068, 13068], "mapped", [12459, 12521, 12483, 12488]], [[13069, 13069], "mapped", [12459, 12525, 12522, 12540]], [[13070, 13070], "mapped", [12460, 12525, 12531]], [[13071, 13071], "mapped", [12460, 12531, 12510]], [[13072, 13072], "mapped", [12462, 12460]], [[13073, 13073], "mapped", [12462, 12491, 12540]], [[13074, 13074], "mapped", [12461, 12517, 12522, 12540]], [[13075, 13075], "mapped", [12462, 12523, 12480, 12540]], [[13076, 13076], "mapped", [12461, 12525]], [[13077, 13077], "mapped", [12461, 12525, 12464, 12521, 12512]], [[13078, 13078], "mapped", [12461, 12525, 12513, 12540, 12488, 12523]], [[13079, 13079], "mapped", [12461, 12525, 12527, 12483, 12488]], [[13080, 13080], "mapped", [12464, 12521, 12512]], [[13081, 13081], "mapped", [12464, 12521, 12512, 12488, 12531]], [[13082, 13082], "mapped", [12463, 12523, 12476, 12452, 12525]], [[13083, 13083], "mapped", [12463, 12525, 12540, 12493]], [[13084, 13084], "mapped", [12465, 12540, 12473]], [[13085, 13085], "mapped", [12467, 12523, 12490]], [[13086, 13086], "mapped", [12467, 12540, 12509]], [[13087, 13087], "mapped", [12469, 12452, 12463, 12523]], [[13088, 13088], "mapped", [12469, 12531, 12481, 12540, 12512]], [[13089, 13089], "mapped", [12471, 12522, 12531, 12464]], [[13090, 13090], "mapped", [12475, 12531, 12481]], [[13091, 13091], "mapped", [12475, 12531, 12488]], [[13092, 13092], "mapped", [12480, 12540, 12473]], [[13093, 13093], "mapped", [12487, 12471]], [[13094, 13094], "mapped", [12489, 12523]], [[13095, 13095], "mapped", [12488, 12531]], [[13096, 13096], "mapped", [12490, 12494]], [[13097, 13097], "mapped", [12494, 12483, 12488]], [[13098, 13098], "mapped", [12495, 12452, 12484]], [[13099, 13099], "mapped", [12497, 12540, 12475, 12531, 12488]], [[13100, 13100], "mapped", [12497, 12540, 12484]], [[13101, 13101], "mapped", [12496, 12540, 12524, 12523]], [[13102, 13102], "mapped", [12500, 12450, 12473, 12488, 12523]], [[13103, 13103], "mapped", [12500, 12463, 12523]], [[13104, 13104], "mapped", [12500, 12467]], [[13105, 13105], "mapped", [12499, 12523]], [[13106, 13106], "mapped", [12501, 12449, 12521, 12483, 12489]], [[13107, 13107], "mapped", [12501, 12451, 12540, 12488]], [[13108, 13108], "mapped", [12502, 12483, 12471, 12455, 12523]], [[13109, 13109], "mapped", [12501, 12521, 12531]], [[13110, 13110], "mapped", [12504, 12463, 12479, 12540, 12523]], [[13111, 13111], "mapped", [12506, 12477]], [[13112, 13112], "mapped", [12506, 12491, 12498]], [[13113, 13113], "mapped", [12504, 12523, 12484]], [[13114, 13114], "mapped", [12506, 12531, 12473]], [[13115, 13115], "mapped", [12506, 12540, 12472]], [[13116, 13116], "mapped", [12505, 12540, 12479]], [[13117, 13117], "mapped", [12509, 12452, 12531, 12488]], [[13118, 13118], "mapped", [12508, 12523, 12488]], [[13119, 13119], "mapped", [12507, 12531]], [[13120, 13120], "mapped", [12509, 12531, 12489]], [[13121, 13121], "mapped", [12507, 12540, 12523]], [[13122, 13122], "mapped", [12507, 12540, 12531]], [[13123, 13123], "mapped", [12510, 12452, 12463, 12525]], [[13124, 13124], "mapped", [12510, 12452, 12523]], [[13125, 13125], "mapped", [12510, 12483, 12495]], [[13126, 13126], "mapped", [12510, 12523, 12463]], [[13127, 13127], "mapped", [12510, 12531, 12471, 12519, 12531]], [[13128, 13128], "mapped", [12511, 12463, 12525, 12531]], [[13129, 13129], "mapped", [12511, 12522]], [[13130, 13130], "mapped", [12511, 12522, 12496, 12540, 12523]], [[13131, 13131], "mapped", [12513, 12460]], [[13132, 13132], "mapped", [12513, 12460, 12488, 12531]], [[13133, 13133], "mapped", [12513, 12540, 12488, 12523]], [[13134, 13134], "mapped", [12516, 12540, 12489]], [[13135, 13135], "mapped", [12516, 12540, 12523]], [[13136, 13136], "mapped", [12518, 12450, 12531]], [[13137, 13137], "mapped", [12522, 12483, 12488, 12523]], [[13138, 13138], "mapped", [12522, 12521]], [[13139, 13139], "mapped", [12523, 12500, 12540]], [[13140, 13140], "mapped", [12523, 12540, 12502, 12523]], [[13141, 13141], "mapped", [12524, 12512]], [[13142, 13142], "mapped", [12524, 12531, 12488, 12466, 12531]], [[13143, 13143], "mapped", [12527, 12483, 12488]], [[13144, 13144], "mapped", [48, 28857]], [[13145, 13145], "mapped", [49, 28857]], [[13146, 13146], "mapped", [50, 28857]], [[13147, 13147], "mapped", [51, 28857]], [[13148, 13148], "mapped", [52, 28857]], [[13149, 13149], "mapped", [53, 28857]], [[13150, 13150], "mapped", [54, 28857]], [[13151, 13151], "mapped", [55, 28857]], [[13152, 13152], "mapped", [56, 28857]], [[13153, 13153], "mapped", [57, 28857]], [[13154, 13154], "mapped", [49, 48, 28857]], [[13155, 13155], "mapped", [49, 49, 28857]], [[13156, 13156], "mapped", [49, 50, 28857]], [[13157, 13157], "mapped", [49, 51, 28857]], [[13158, 13158], "mapped", [49, 52, 28857]], [[13159, 13159], "mapped", [49, 53, 28857]], [[13160, 13160], "mapped", [49, 54, 28857]], [[13161, 13161], "mapped", [49, 55, 28857]], [[13162, 13162], "mapped", [49, 56, 28857]], [[13163, 13163], "mapped", [49, 57, 28857]], [[13164, 13164], "mapped", [50, 48, 28857]], [[13165, 13165], "mapped", [50, 49, 28857]], [[13166, 13166], "mapped", [50, 50, 28857]], [[13167, 13167], "mapped", [50, 51, 28857]], [[13168, 13168], "mapped", [50, 52, 28857]], [[13169, 13169], "mapped", [104, 112, 97]], [[13170, 13170], "mapped", [100, 97]], [[13171, 13171], "mapped", [97, 117]], [[13172, 13172], "mapped", [98, 97, 114]], [[13173, 13173], "mapped", [111, 118]], [[13174, 13174], "mapped", [112, 99]], [[13175, 13175], "mapped", [100, 109]], [[13176, 13176], "mapped", [100, 109, 50]], [[13177, 13177], "mapped", [100, 109, 51]], [[13178, 13178], "mapped", [105, 117]], [[13179, 13179], "mapped", [24179, 25104]], [[13180, 13180], "mapped", [26157, 21644]], [[13181, 13181], "mapped", [22823, 27491]], [[13182, 13182], "mapped", [26126, 27835]], [[13183, 13183], "mapped", [26666, 24335, 20250, 31038]], [[13184, 13184], "mapped", [112, 97]], [[13185, 13185], "mapped", [110, 97]], [[13186, 13186], "mapped", [956, 97]], [[13187, 13187], "mapped", [109, 97]], [[13188, 13188], "mapped", [107, 97]], [[13189, 13189], "mapped", [107, 98]], [[13190, 13190], "mapped", [109, 98]], [[13191, 13191], "mapped", [103, 98]], [[13192, 13192], "mapped", [99, 97, 108]], [[13193, 13193], "mapped", [107, 99, 97, 108]], [[13194, 13194], "mapped", [112, 102]], [[13195, 13195], "mapped", [110, 102]], [[13196, 13196], "mapped", [956, 102]], [[13197, 13197], "mapped", [956, 103]], [[13198, 13198], "mapped", [109, 103]], [[13199, 13199], "mapped", [107, 103]], [[13200, 13200], "mapped", [104, 122]], [[13201, 13201], "mapped", [107, 104, 122]], [[13202, 13202], "mapped", [109, 104, 122]], [[13203, 13203], "mapped", [103, 104, 122]], [[13204, 13204], "mapped", [116, 104, 122]], [[13205, 13205], "mapped", [956, 108]], [[13206, 13206], "mapped", [109, 108]], [[13207, 13207], "mapped", [100, 108]], [[13208, 13208], "mapped", [107, 108]], [[13209, 13209], "mapped", [102, 109]], [[13210, 13210], "mapped", [110, 109]], [[13211, 13211], "mapped", [956, 109]], [[13212, 13212], "mapped", [109, 109]], [[13213, 13213], "mapped", [99, 109]], [[13214, 13214], "mapped", [107, 109]], [[13215, 13215], "mapped", [109, 109, 50]], [[13216, 13216], "mapped", [99, 109, 50]], [[13217, 13217], "mapped", [109, 50]], [[13218, 13218], "mapped", [107, 109, 50]], [[13219, 13219], "mapped", [109, 109, 51]], [[13220, 13220], "mapped", [99, 109, 51]], [[13221, 13221], "mapped", [109, 51]], [[13222, 13222], "mapped", [107, 109, 51]], [[13223, 13223], "mapped", [109, 8725, 115]], [[13224, 13224], "mapped", [109, 8725, 115, 50]], [[13225, 13225], "mapped", [112, 97]], [[13226, 13226], "mapped", [107, 112, 97]], [[13227, 13227], "mapped", [109, 112, 97]], [[13228, 13228], "mapped", [103, 112, 97]], [[13229, 13229], "mapped", [114, 97, 100]], [[13230, 13230], "mapped", [114, 97, 100, 8725, 115]], [[13231, 13231], "mapped", [114, 97, 100, 8725, 115, 50]], [[13232, 13232], "mapped", [112, 115]], [[13233, 13233], "mapped", [110, 115]], [[13234, 13234], "mapped", [956, 115]], [[13235, 13235], "mapped", [109, 115]], [[13236, 13236], "mapped", [112, 118]], [[13237, 13237], "mapped", [110, 118]], [[13238, 13238], "mapped", [956, 118]], [[13239, 13239], "mapped", [109, 118]], [[13240, 13240], "mapped", [107, 118]], [[13241, 13241], "mapped", [109, 118]], [[13242, 13242], "mapped", [112, 119]], [[13243, 13243], "mapped", [110, 119]], [[13244, 13244], "mapped", [956, 119]], [[13245, 13245], "mapped", [109, 119]], [[13246, 13246], "mapped", [107, 119]], [[13247, 13247], "mapped", [109, 119]], [[13248, 13248], "mapped", [107, 969]], [[13249, 13249], "mapped", [109, 969]], [[13250, 13250], "disallowed"], [[13251, 13251], "mapped", [98, 113]], [[13252, 13252], "mapped", [99, 99]], [[13253, 13253], "mapped", [99, 100]], [[13254, 13254], "mapped", [99, 8725, 107, 103]], [[13255, 13255], "disallowed"], [[13256, 13256], "mapped", [100, 98]], [[13257, 13257], "mapped", [103, 121]], [[13258, 13258], "mapped", [104, 97]], [[13259, 13259], "mapped", [104, 112]], [[13260, 13260], "mapped", [105, 110]], [[13261, 13261], "mapped", [107, 107]], [[13262, 13262], "mapped", [107, 109]], [[13263, 13263], "mapped", [107, 116]], [[13264, 13264], "mapped", [108, 109]], [[13265, 13265], "mapped", [108, 110]], [[13266, 13266], "mapped", [108, 111, 103]], [[13267, 13267], "mapped", [108, 120]], [[13268, 13268], "mapped", [109, 98]], [[13269, 13269], "mapped", [109, 105, 108]], [[13270, 13270], "mapped", [109, 111, 108]], [[13271, 13271], "mapped", [112, 104]], [[13272, 13272], "disallowed"], [[13273, 13273], "mapped", [112, 112, 109]], [[13274, 13274], "mapped", [112, 114]], [[13275, 13275], "mapped", [115, 114]], [[13276, 13276], "mapped", [115, 118]], [[13277, 13277], "mapped", [119, 98]], [[13278, 13278], "mapped", [118, 8725, 109]], [[13279, 13279], "mapped", [97, 8725, 109]], [[13280, 13280], "mapped", [49, 26085]], [[13281, 13281], "mapped", [50, 26085]], [[13282, 13282], "mapped", [51, 26085]], [[13283, 13283], "mapped", [52, 26085]], [[13284, 13284], "mapped", [53, 26085]], [[13285, 13285], "mapped", [54, 26085]], [[13286, 13286], "mapped", [55, 26085]], [[13287, 13287], "mapped", [56, 26085]], [[13288, 13288], "mapped", [57, 26085]], [[13289, 13289], "mapped", [49, 48, 26085]], [[13290, 13290], "mapped", [49, 49, 26085]], [[13291, 13291], "mapped", [49, 50, 26085]], [[13292, 13292], "mapped", [49, 51, 26085]], [[13293, 13293], "mapped", [49, 52, 26085]], [[13294, 13294], "mapped", [49, 53, 26085]], [[13295, 13295], "mapped", [49, 54, 26085]], [[13296, 13296], "mapped", [49, 55, 26085]], [[13297, 13297], "mapped", [49, 56, 26085]], [[13298, 13298], "mapped", [49, 57, 26085]], [[13299, 13299], "mapped", [50, 48, 26085]], [[13300, 13300], "mapped", [50, 49, 26085]], [[13301, 13301], "mapped", [50, 50, 26085]], [[13302, 13302], "mapped", [50, 51, 26085]], [[13303, 13303], "mapped", [50, 52, 26085]], [[13304, 13304], "mapped", [50, 53, 26085]], [[13305, 13305], "mapped", [50, 54, 26085]], [[13306, 13306], "mapped", [50, 55, 26085]], [[13307, 13307], "mapped", [50, 56, 26085]], [[13308, 13308], "mapped", [50, 57, 26085]], [[13309, 13309], "mapped", [51, 48, 26085]], [[13310, 13310], "mapped", [51, 49, 26085]], [[13311, 13311], "mapped", [103, 97, 108]], [[13312, 19893], "valid"], [[19894, 19903], "disallowed"], [[19904, 19967], "valid", [], "NV8"], [[19968, 40869], "valid"], [[40870, 40891], "valid"], [[40892, 40899], "valid"], [[40900, 40907], "valid"], [[40908, 40908], "valid"], [[40909, 40917], "valid"], [[40918, 40959], "disallowed"], [[40960, 42124], "valid"], [[42125, 42127], "disallowed"], [[42128, 42145], "valid", [], "NV8"], [[42146, 42147], "valid", [], "NV8"], [[42148, 42163], "valid", [], "NV8"], [[42164, 42164], "valid", [], "NV8"], [[42165, 42176], "valid", [], "NV8"], [[42177, 42177], "valid", [], "NV8"], [[42178, 42180], "valid", [], "NV8"], [[42181, 42181], "valid", [], "NV8"], [[42182, 42182], "valid", [], "NV8"], [[42183, 42191], "disallowed"], [[42192, 42237], "valid"], [[42238, 42239], "valid", [], "NV8"], [[42240, 42508], "valid"], [[42509, 42511], "valid", [], "NV8"], [[42512, 42539], "valid"], [[42540, 42559], "disallowed"], [[42560, 42560], "mapped", [42561]], [[42561, 42561], "valid"], [[42562, 42562], "mapped", [42563]], [[42563, 42563], "valid"], [[42564, 42564], "mapped", [42565]], [[42565, 42565], "valid"], [[42566, 42566], "mapped", [42567]], [[42567, 42567], "valid"], [[42568, 42568], "mapped", [42569]], [[42569, 42569], "valid"], [[42570, 42570], "mapped", [42571]], [[42571, 42571], "valid"], [[42572, 42572], "mapped", [42573]], [[42573, 42573], "valid"], [[42574, 42574], "mapped", [42575]], [[42575, 42575], "valid"], [[42576, 42576], "mapped", [42577]], [[42577, 42577], "valid"], [[42578, 42578], "mapped", [42579]], [[42579, 42579], "valid"], [[42580, 42580], "mapped", [42581]], [[42581, 42581], "valid"], [[42582, 42582], "mapped", [42583]], [[42583, 42583], "valid"], [[42584, 42584], "mapped", [42585]], [[42585, 42585], "valid"], [[42586, 42586], "mapped", [42587]], [[42587, 42587], "valid"], [[42588, 42588], "mapped", [42589]], [[42589, 42589], "valid"], [[42590, 42590], "mapped", [42591]], [[42591, 42591], "valid"], [[42592, 42592], "mapped", [42593]], [[42593, 42593], "valid"], [[42594, 42594], "mapped", [42595]], [[42595, 42595], "valid"], [[42596, 42596], "mapped", [42597]], [[42597, 42597], "valid"], [[42598, 42598], "mapped", [42599]], [[42599, 42599], "valid"], [[42600, 42600], "mapped", [42601]], [[42601, 42601], "valid"], [[42602, 42602], "mapped", [42603]], [[42603, 42603], "valid"], [[42604, 42604], "mapped", [42605]], [[42605, 42607], "valid"], [[42608, 42611], "valid", [], "NV8"], [[42612, 42619], "valid"], [[42620, 42621], "valid"], [[42622, 42622], "valid", [], "NV8"], [[42623, 42623], "valid"], [[42624, 42624], "mapped", [42625]], [[42625, 42625], "valid"], [[42626, 42626], "mapped", [42627]], [[42627, 42627], "valid"], [[42628, 42628], "mapped", [42629]], [[42629, 42629], "valid"], [[42630, 42630], "mapped", [42631]], [[42631, 42631], "valid"], [[42632, 42632], "mapped", [42633]], [[42633, 42633], "valid"], [[42634, 42634], "mapped", [42635]], [[42635, 42635], "valid"], [[42636, 42636], "mapped", [42637]], [[42637, 42637], "valid"], [[42638, 42638], "mapped", [42639]], [[42639, 42639], "valid"], [[42640, 42640], "mapped", [42641]], [[42641, 42641], "valid"], [[42642, 42642], "mapped", [42643]], [[42643, 42643], "valid"], [[42644, 42644], "mapped", [42645]], [[42645, 42645], "valid"], [[42646, 42646], "mapped", [42647]], [[42647, 42647], "valid"], [[42648, 42648], "mapped", [42649]], [[42649, 42649], "valid"], [[42650, 42650], "mapped", [42651]], [[42651, 42651], "valid"], [[42652, 42652], "mapped", [1098]], [[42653, 42653], "mapped", [1100]], [[42654, 42654], "valid"], [[42655, 42655], "valid"], [[42656, 42725], "valid"], [[42726, 42735], "valid", [], "NV8"], [[42736, 42737], "valid"], [[42738, 42743], "valid", [], "NV8"], [[42744, 42751], "disallowed"], [[42752, 42774], "valid", [], "NV8"], [[42775, 42778], "valid"], [[42779, 42783], "valid"], [[42784, 42785], "valid", [], "NV8"], [[42786, 42786], "mapped", [42787]], [[42787, 42787], "valid"], [[42788, 42788], "mapped", [42789]], [[42789, 42789], "valid"], [[42790, 42790], "mapped", [42791]], [[42791, 42791], "valid"], [[42792, 42792], "mapped", [42793]], [[42793, 42793], "valid"], [[42794, 42794], "mapped", [42795]], [[42795, 42795], "valid"], [[42796, 42796], "mapped", [42797]], [[42797, 42797], "valid"], [[42798, 42798], "mapped", [42799]], [[42799, 42801], "valid"], [[42802, 42802], "mapped", [42803]], [[42803, 42803], "valid"], [[42804, 42804], "mapped", [42805]], [[42805, 42805], "valid"], [[42806, 42806], "mapped", [42807]], [[42807, 42807], "valid"], [[42808, 42808], "mapped", [42809]], [[42809, 42809], "valid"], [[42810, 42810], "mapped", [42811]], [[42811, 42811], "valid"], [[42812, 42812], "mapped", [42813]], [[42813, 42813], "valid"], [[42814, 42814], "mapped", [42815]], [[42815, 42815], "valid"], [[42816, 42816], "mapped", [42817]], [[42817, 42817], "valid"], [[42818, 42818], "mapped", [42819]], [[42819, 42819], "valid"], [[42820, 42820], "mapped", [42821]], [[42821, 42821], "valid"], [[42822, 42822], "mapped", [42823]], [[42823, 42823], "valid"], [[42824, 42824], "mapped", [42825]], [[42825, 42825], "valid"], [[42826, 42826], "mapped", [42827]], [[42827, 42827], "valid"], [[42828, 42828], "mapped", [42829]], [[42829, 42829], "valid"], [[42830, 42830], "mapped", [42831]], [[42831, 42831], "valid"], [[42832, 42832], "mapped", [42833]], [[42833, 42833], "valid"], [[42834, 42834], "mapped", [42835]], [[42835, 42835], "valid"], [[42836, 42836], "mapped", [42837]], [[42837, 42837], "valid"], [[42838, 42838], "mapped", [42839]], [[42839, 42839], "valid"], [[42840, 42840], "mapped", [42841]], [[42841, 42841], "valid"], [[42842, 42842], "mapped", [42843]], [[42843, 42843], "valid"], [[42844, 42844], "mapped", [42845]], [[42845, 42845], "valid"], [[42846, 42846], "mapped", [42847]], [[42847, 42847], "valid"], [[42848, 42848], "mapped", [42849]], [[42849, 42849], "valid"], [[42850, 42850], "mapped", [42851]], [[42851, 42851], "valid"], [[42852, 42852], "mapped", [42853]], [[42853, 42853], "valid"], [[42854, 42854], "mapped", [42855]], [[42855, 42855], "valid"], [[42856, 42856], "mapped", [42857]], [[42857, 42857], "valid"], [[42858, 42858], "mapped", [42859]], [[42859, 42859], "valid"], [[42860, 42860], "mapped", [42861]], [[42861, 42861], "valid"], [[42862, 42862], "mapped", [42863]], [[42863, 42863], "valid"], [[42864, 42864], "mapped", [42863]], [[42865, 42872], "valid"], [[42873, 42873], "mapped", [42874]], [[42874, 42874], "valid"], [[42875, 42875], "mapped", [42876]], [[42876, 42876], "valid"], [[42877, 42877], "mapped", [7545]], [[42878, 42878], "mapped", [42879]], [[42879, 42879], "valid"], [[42880, 42880], "mapped", [42881]], [[42881, 42881], "valid"], [[42882, 42882], "mapped", [42883]], [[42883, 42883], "valid"], [[42884, 42884], "mapped", [42885]], [[42885, 42885], "valid"], [[42886, 42886], "mapped", [42887]], [[42887, 42888], "valid"], [[42889, 42890], "valid", [], "NV8"], [[42891, 42891], "mapped", [42892]], [[42892, 42892], "valid"], [[42893, 42893], "mapped", [613]], [[42894, 42894], "valid"], [[42895, 42895], "valid"], [[42896, 42896], "mapped", [42897]], [[42897, 42897], "valid"], [[42898, 42898], "mapped", [42899]], [[42899, 42899], "valid"], [[42900, 42901], "valid"], [[42902, 42902], "mapped", [42903]], [[42903, 42903], "valid"], [[42904, 42904], "mapped", [42905]], [[42905, 42905], "valid"], [[42906, 42906], "mapped", [42907]], [[42907, 42907], "valid"], [[42908, 42908], "mapped", [42909]], [[42909, 42909], "valid"], [[42910, 42910], "mapped", [42911]], [[42911, 42911], "valid"], [[42912, 42912], "mapped", [42913]], [[42913, 42913], "valid"], [[42914, 42914], "mapped", [42915]], [[42915, 42915], "valid"], [[42916, 42916], "mapped", [42917]], [[42917, 42917], "valid"], [[42918, 42918], "mapped", [42919]], [[42919, 42919], "valid"], [[42920, 42920], "mapped", [42921]], [[42921, 42921], "valid"], [[42922, 42922], "mapped", [614]], [[42923, 42923], "mapped", [604]], [[42924, 42924], "mapped", [609]], [[42925, 42925], "mapped", [620]], [[42926, 42927], "disallowed"], [[42928, 42928], "mapped", [670]], [[42929, 42929], "mapped", [647]], [[42930, 42930], "mapped", [669]], [[42931, 42931], "mapped", [43859]], [[42932, 42932], "mapped", [42933]], [[42933, 42933], "valid"], [[42934, 42934], "mapped", [42935]], [[42935, 42935], "valid"], [[42936, 42998], "disallowed"], [[42999, 42999], "valid"], [[43e3, 43e3], "mapped", [295]], [[43001, 43001], "mapped", [339]], [[43002, 43002], "valid"], [[43003, 43007], "valid"], [[43008, 43047], "valid"], [[43048, 43051], "valid", [], "NV8"], [[43052, 43055], "disallowed"], [[43056, 43065], "valid", [], "NV8"], [[43066, 43071], "disallowed"], [[43072, 43123], "valid"], [[43124, 43127], "valid", [], "NV8"], [[43128, 43135], "disallowed"], [[43136, 43204], "valid"], [[43205, 43213], "disallowed"], [[43214, 43215], "valid", [], "NV8"], [[43216, 43225], "valid"], [[43226, 43231], "disallowed"], [[43232, 43255], "valid"], [[43256, 43258], "valid", [], "NV8"], [[43259, 43259], "valid"], [[43260, 43260], "valid", [], "NV8"], [[43261, 43261], "valid"], [[43262, 43263], "disallowed"], [[43264, 43309], "valid"], [[43310, 43311], "valid", [], "NV8"], [[43312, 43347], "valid"], [[43348, 43358], "disallowed"], [[43359, 43359], "valid", [], "NV8"], [[43360, 43388], "valid", [], "NV8"], [[43389, 43391], "disallowed"], [[43392, 43456], "valid"], [[43457, 43469], "valid", [], "NV8"], [[43470, 43470], "disallowed"], [[43471, 43481], "valid"], [[43482, 43485], "disallowed"], [[43486, 43487], "valid", [], "NV8"], [[43488, 43518], "valid"], [[43519, 43519], "disallowed"], [[43520, 43574], "valid"], [[43575, 43583], "disallowed"], [[43584, 43597], "valid"], [[43598, 43599], "disallowed"], [[43600, 43609], "valid"], [[43610, 43611], "disallowed"], [[43612, 43615], "valid", [], "NV8"], [[43616, 43638], "valid"], [[43639, 43641], "valid", [], "NV8"], [[43642, 43643], "valid"], [[43644, 43647], "valid"], [[43648, 43714], "valid"], [[43715, 43738], "disallowed"], [[43739, 43741], "valid"], [[43742, 43743], "valid", [], "NV8"], [[43744, 43759], "valid"], [[43760, 43761], "valid", [], "NV8"], [[43762, 43766], "valid"], [[43767, 43776], "disallowed"], [[43777, 43782], "valid"], [[43783, 43784], "disallowed"], [[43785, 43790], "valid"], [[43791, 43792], "disallowed"], [[43793, 43798], "valid"], [[43799, 43807], "disallowed"], [[43808, 43814], "valid"], [[43815, 43815], "disallowed"], [[43816, 43822], "valid"], [[43823, 43823], "disallowed"], [[43824, 43866], "valid"], [[43867, 43867], "valid", [], "NV8"], [[43868, 43868], "mapped", [42791]], [[43869, 43869], "mapped", [43831]], [[43870, 43870], "mapped", [619]], [[43871, 43871], "mapped", [43858]], [[43872, 43875], "valid"], [[43876, 43877], "valid"], [[43878, 43887], "disallowed"], [[43888, 43888], "mapped", [5024]], [[43889, 43889], "mapped", [5025]], [[43890, 43890], "mapped", [5026]], [[43891, 43891], "mapped", [5027]], [[43892, 43892], "mapped", [5028]], [[43893, 43893], "mapped", [5029]], [[43894, 43894], "mapped", [5030]], [[43895, 43895], "mapped", [5031]], [[43896, 43896], "mapped", [5032]], [[43897, 43897], "mapped", [5033]], [[43898, 43898], "mapped", [5034]], [[43899, 43899], "mapped", [5035]], [[43900, 43900], "mapped", [5036]], [[43901, 43901], "mapped", [5037]], [[43902, 43902], "mapped", [5038]], [[43903, 43903], "mapped", [5039]], [[43904, 43904], "mapped", [5040]], [[43905, 43905], "mapped", [5041]], [[43906, 43906], "mapped", [5042]], [[43907, 43907], "mapped", [5043]], [[43908, 43908], "mapped", [5044]], [[43909, 43909], "mapped", [5045]], [[43910, 43910], "mapped", [5046]], [[43911, 43911], "mapped", [5047]], [[43912, 43912], "mapped", [5048]], [[43913, 43913], "mapped", [5049]], [[43914, 43914], "mapped", [5050]], [[43915, 43915], "mapped", [5051]], [[43916, 43916], "mapped", [5052]], [[43917, 43917], "mapped", [5053]], [[43918, 43918], "mapped", [5054]], [[43919, 43919], "mapped", [5055]], [[43920, 43920], "mapped", [5056]], [[43921, 43921], "mapped", [5057]], [[43922, 43922], "mapped", [5058]], [[43923, 43923], "mapped", [5059]], [[43924, 43924], "mapped", [5060]], [[43925, 43925], "mapped", [5061]], [[43926, 43926], "mapped", [5062]], [[43927, 43927], "mapped", [5063]], [[43928, 43928], "mapped", [5064]], [[43929, 43929], "mapped", [5065]], [[43930, 43930], "mapped", [5066]], [[43931, 43931], "mapped", [5067]], [[43932, 43932], "mapped", [5068]], [[43933, 43933], "mapped", [5069]], [[43934, 43934], "mapped", [5070]], [[43935, 43935], "mapped", [5071]], [[43936, 43936], "mapped", [5072]], [[43937, 43937], "mapped", [5073]], [[43938, 43938], "mapped", [5074]], [[43939, 43939], "mapped", [5075]], [[43940, 43940], "mapped", [5076]], [[43941, 43941], "mapped", [5077]], [[43942, 43942], "mapped", [5078]], [[43943, 43943], "mapped", [5079]], [[43944, 43944], "mapped", [5080]], [[43945, 43945], "mapped", [5081]], [[43946, 43946], "mapped", [5082]], [[43947, 43947], "mapped", [5083]], [[43948, 43948], "mapped", [5084]], [[43949, 43949], "mapped", [5085]], [[43950, 43950], "mapped", [5086]], [[43951, 43951], "mapped", [5087]], [[43952, 43952], "mapped", [5088]], [[43953, 43953], "mapped", [5089]], [[43954, 43954], "mapped", [5090]], [[43955, 43955], "mapped", [5091]], [[43956, 43956], "mapped", [5092]], [[43957, 43957], "mapped", [5093]], [[43958, 43958], "mapped", [5094]], [[43959, 43959], "mapped", [5095]], [[43960, 43960], "mapped", [5096]], [[43961, 43961], "mapped", [5097]], [[43962, 43962], "mapped", [5098]], [[43963, 43963], "mapped", [5099]], [[43964, 43964], "mapped", [5100]], [[43965, 43965], "mapped", [5101]], [[43966, 43966], "mapped", [5102]], [[43967, 43967], "mapped", [5103]], [[43968, 44010], "valid"], [[44011, 44011], "valid", [], "NV8"], [[44012, 44013], "valid"], [[44014, 44015], "disallowed"], [[44016, 44025], "valid"], [[44026, 44031], "disallowed"], [[44032, 55203], "valid"], [[55204, 55215], "disallowed"], [[55216, 55238], "valid", [], "NV8"], [[55239, 55242], "disallowed"], [[55243, 55291], "valid", [], "NV8"], [[55292, 55295], "disallowed"], [[55296, 57343], "disallowed"], [[57344, 63743], "disallowed"], [[63744, 63744], "mapped", [35912]], [[63745, 63745], "mapped", [26356]], [[63746, 63746], "mapped", [36554]], [[63747, 63747], "mapped", [36040]], [[63748, 63748], "mapped", [28369]], [[63749, 63749], "mapped", [20018]], [[63750, 63750], "mapped", [21477]], [[63751, 63752], "mapped", [40860]], [[63753, 63753], "mapped", [22865]], [[63754, 63754], "mapped", [37329]], [[63755, 63755], "mapped", [21895]], [[63756, 63756], "mapped", [22856]], [[63757, 63757], "mapped", [25078]], [[63758, 63758], "mapped", [30313]], [[63759, 63759], "mapped", [32645]], [[63760, 63760], "mapped", [34367]], [[63761, 63761], "mapped", [34746]], [[63762, 63762], "mapped", [35064]], [[63763, 63763], "mapped", [37007]], [[63764, 63764], "mapped", [27138]], [[63765, 63765], "mapped", [27931]], [[63766, 63766], "mapped", [28889]], [[63767, 63767], "mapped", [29662]], [[63768, 63768], "mapped", [33853]], [[63769, 63769], "mapped", [37226]], [[63770, 63770], "mapped", [39409]], [[63771, 63771], "mapped", [20098]], [[63772, 63772], "mapped", [21365]], [[63773, 63773], "mapped", [27396]], [[63774, 63774], "mapped", [29211]], [[63775, 63775], "mapped", [34349]], [[63776, 63776], "mapped", [40478]], [[63777, 63777], "mapped", [23888]], [[63778, 63778], "mapped", [28651]], [[63779, 63779], "mapped", [34253]], [[63780, 63780], "mapped", [35172]], [[63781, 63781], "mapped", [25289]], [[63782, 63782], "mapped", [33240]], [[63783, 63783], "mapped", [34847]], [[63784, 63784], "mapped", [24266]], [[63785, 63785], "mapped", [26391]], [[63786, 63786], "mapped", [28010]], [[63787, 63787], "mapped", [29436]], [[63788, 63788], "mapped", [37070]], [[63789, 63789], "mapped", [20358]], [[63790, 63790], "mapped", [20919]], [[63791, 63791], "mapped", [21214]], [[63792, 63792], "mapped", [25796]], [[63793, 63793], "mapped", [27347]], [[63794, 63794], "mapped", [29200]], [[63795, 63795], "mapped", [30439]], [[63796, 63796], "mapped", [32769]], [[63797, 63797], "mapped", [34310]], [[63798, 63798], "mapped", [34396]], [[63799, 63799], "mapped", [36335]], [[63800, 63800], "mapped", [38706]], [[63801, 63801], "mapped", [39791]], [[63802, 63802], "mapped", [40442]], [[63803, 63803], "mapped", [30860]], [[63804, 63804], "mapped", [31103]], [[63805, 63805], "mapped", [32160]], [[63806, 63806], "mapped", [33737]], [[63807, 63807], "mapped", [37636]], [[63808, 63808], "mapped", [40575]], [[63809, 63809], "mapped", [35542]], [[63810, 63810], "mapped", [22751]], [[63811, 63811], "mapped", [24324]], [[63812, 63812], "mapped", [31840]], [[63813, 63813], "mapped", [32894]], [[63814, 63814], "mapped", [29282]], [[63815, 63815], "mapped", [30922]], [[63816, 63816], "mapped", [36034]], [[63817, 63817], "mapped", [38647]], [[63818, 63818], "mapped", [22744]], [[63819, 63819], "mapped", [23650]], [[63820, 63820], "mapped", [27155]], [[63821, 63821], "mapped", [28122]], [[63822, 63822], "mapped", [28431]], [[63823, 63823], "mapped", [32047]], [[63824, 63824], "mapped", [32311]], [[63825, 63825], "mapped", [38475]], [[63826, 63826], "mapped", [21202]], [[63827, 63827], "mapped", [32907]], [[63828, 63828], "mapped", [20956]], [[63829, 63829], "mapped", [20940]], [[63830, 63830], "mapped", [31260]], [[63831, 63831], "mapped", [32190]], [[63832, 63832], "mapped", [33777]], [[63833, 63833], "mapped", [38517]], [[63834, 63834], "mapped", [35712]], [[63835, 63835], "mapped", [25295]], [[63836, 63836], "mapped", [27138]], [[63837, 63837], "mapped", [35582]], [[63838, 63838], "mapped", [20025]], [[63839, 63839], "mapped", [23527]], [[63840, 63840], "mapped", [24594]], [[63841, 63841], "mapped", [29575]], [[63842, 63842], "mapped", [30064]], [[63843, 63843], "mapped", [21271]], [[63844, 63844], "mapped", [30971]], [[63845, 63845], "mapped", [20415]], [[63846, 63846], "mapped", [24489]], [[63847, 63847], "mapped", [19981]], [[63848, 63848], "mapped", [27852]], [[63849, 63849], "mapped", [25976]], [[63850, 63850], "mapped", [32034]], [[63851, 63851], "mapped", [21443]], [[63852, 63852], "mapped", [22622]], [[63853, 63853], "mapped", [30465]], [[63854, 63854], "mapped", [33865]], [[63855, 63855], "mapped", [35498]], [[63856, 63856], "mapped", [27578]], [[63857, 63857], "mapped", [36784]], [[63858, 63858], "mapped", [27784]], [[63859, 63859], "mapped", [25342]], [[63860, 63860], "mapped", [33509]], [[63861, 63861], "mapped", [25504]], [[63862, 63862], "mapped", [30053]], [[63863, 63863], "mapped", [20142]], [[63864, 63864], "mapped", [20841]], [[63865, 63865], "mapped", [20937]], [[63866, 63866], "mapped", [26753]], [[63867, 63867], "mapped", [31975]], [[63868, 63868], "mapped", [33391]], [[63869, 63869], "mapped", [35538]], [[63870, 63870], "mapped", [37327]], [[63871, 63871], "mapped", [21237]], [[63872, 63872], "mapped", [21570]], [[63873, 63873], "mapped", [22899]], [[63874, 63874], "mapped", [24300]], [[63875, 63875], "mapped", [26053]], [[63876, 63876], "mapped", [28670]], [[63877, 63877], "mapped", [31018]], [[63878, 63878], "mapped", [38317]], [[63879, 63879], "mapped", [39530]], [[63880, 63880], "mapped", [40599]], [[63881, 63881], "mapped", [40654]], [[63882, 63882], "mapped", [21147]], [[63883, 63883], "mapped", [26310]], [[63884, 63884], "mapped", [27511]], [[63885, 63885], "mapped", [36706]], [[63886, 63886], "mapped", [24180]], [[63887, 63887], "mapped", [24976]], [[63888, 63888], "mapped", [25088]], [[63889, 63889], "mapped", [25754]], [[63890, 63890], "mapped", [28451]], [[63891, 63891], "mapped", [29001]], [[63892, 63892], "mapped", [29833]], [[63893, 63893], "mapped", [31178]], [[63894, 63894], "mapped", [32244]], [[63895, 63895], "mapped", [32879]], [[63896, 63896], "mapped", [36646]], [[63897, 63897], "mapped", [34030]], [[63898, 63898], "mapped", [36899]], [[63899, 63899], "mapped", [37706]], [[63900, 63900], "mapped", [21015]], [[63901, 63901], "mapped", [21155]], [[63902, 63902], "mapped", [21693]], [[63903, 63903], "mapped", [28872]], [[63904, 63904], "mapped", [35010]], [[63905, 63905], "mapped", [35498]], [[63906, 63906], "mapped", [24265]], [[63907, 63907], "mapped", [24565]], [[63908, 63908], "mapped", [25467]], [[63909, 63909], "mapped", [27566]], [[63910, 63910], "mapped", [31806]], [[63911, 63911], "mapped", [29557]], [[63912, 63912], "mapped", [20196]], [[63913, 63913], "mapped", [22265]], [[63914, 63914], "mapped", [23527]], [[63915, 63915], "mapped", [23994]], [[63916, 63916], "mapped", [24604]], [[63917, 63917], "mapped", [29618]], [[63918, 63918], "mapped", [29801]], [[63919, 63919], "mapped", [32666]], [[63920, 63920], "mapped", [32838]], [[63921, 63921], "mapped", [37428]], [[63922, 63922], "mapped", [38646]], [[63923, 63923], "mapped", [38728]], [[63924, 63924], "mapped", [38936]], [[63925, 63925], "mapped", [20363]], [[63926, 63926], "mapped", [31150]], [[63927, 63927], "mapped", [37300]], [[63928, 63928], "mapped", [38584]], [[63929, 63929], "mapped", [24801]], [[63930, 63930], "mapped", [20102]], [[63931, 63931], "mapped", [20698]], [[63932, 63932], "mapped", [23534]], [[63933, 63933], "mapped", [23615]], [[63934, 63934], "mapped", [26009]], [[63935, 63935], "mapped", [27138]], [[63936, 63936], "mapped", [29134]], [[63937, 63937], "mapped", [30274]], [[63938, 63938], "mapped", [34044]], [[63939, 63939], "mapped", [36988]], [[63940, 63940], "mapped", [40845]], [[63941, 63941], "mapped", [26248]], [[63942, 63942], "mapped", [38446]], [[63943, 63943], "mapped", [21129]], [[63944, 63944], "mapped", [26491]], [[63945, 63945], "mapped", [26611]], [[63946, 63946], "mapped", [27969]], [[63947, 63947], "mapped", [28316]], [[63948, 63948], "mapped", [29705]], [[63949, 63949], "mapped", [30041]], [[63950, 63950], "mapped", [30827]], [[63951, 63951], "mapped", [32016]], [[63952, 63952], "mapped", [39006]], [[63953, 63953], "mapped", [20845]], [[63954, 63954], "mapped", [25134]], [[63955, 63955], "mapped", [38520]], [[63956, 63956], "mapped", [20523]], [[63957, 63957], "mapped", [23833]], [[63958, 63958], "mapped", [28138]], [[63959, 63959], "mapped", [36650]], [[63960, 63960], "mapped", [24459]], [[63961, 63961], "mapped", [24900]], [[63962, 63962], "mapped", [26647]], [[63963, 63963], "mapped", [29575]], [[63964, 63964], "mapped", [38534]], [[63965, 63965], "mapped", [21033]], [[63966, 63966], "mapped", [21519]], [[63967, 63967], "mapped", [23653]], [[63968, 63968], "mapped", [26131]], [[63969, 63969], "mapped", [26446]], [[63970, 63970], "mapped", [26792]], [[63971, 63971], "mapped", [27877]], [[63972, 63972], "mapped", [29702]], [[63973, 63973], "mapped", [30178]], [[63974, 63974], "mapped", [32633]], [[63975, 63975], "mapped", [35023]], [[63976, 63976], "mapped", [35041]], [[63977, 63977], "mapped", [37324]], [[63978, 63978], "mapped", [38626]], [[63979, 63979], "mapped", [21311]], [[63980, 63980], "mapped", [28346]], [[63981, 63981], "mapped", [21533]], [[63982, 63982], "mapped", [29136]], [[63983, 63983], "mapped", [29848]], [[63984, 63984], "mapped", [34298]], [[63985, 63985], "mapped", [38563]], [[63986, 63986], "mapped", [40023]], [[63987, 63987], "mapped", [40607]], [[63988, 63988], "mapped", [26519]], [[63989, 63989], "mapped", [28107]], [[63990, 63990], "mapped", [33256]], [[63991, 63991], "mapped", [31435]], [[63992, 63992], "mapped", [31520]], [[63993, 63993], "mapped", [31890]], [[63994, 63994], "mapped", [29376]], [[63995, 63995], "mapped", [28825]], [[63996, 63996], "mapped", [35672]], [[63997, 63997], "mapped", [20160]], [[63998, 63998], "mapped", [33590]], [[63999, 63999], "mapped", [21050]], [[64e3, 64e3], "mapped", [20999]], [[64001, 64001], "mapped", [24230]], [[64002, 64002], "mapped", [25299]], [[64003, 64003], "mapped", [31958]], [[64004, 64004], "mapped", [23429]], [[64005, 64005], "mapped", [27934]], [[64006, 64006], "mapped", [26292]], [[64007, 64007], "mapped", [36667]], [[64008, 64008], "mapped", [34892]], [[64009, 64009], "mapped", [38477]], [[64010, 64010], "mapped", [35211]], [[64011, 64011], "mapped", [24275]], [[64012, 64012], "mapped", [20800]], [[64013, 64013], "mapped", [21952]], [[64014, 64015], "valid"], [[64016, 64016], "mapped", [22618]], [[64017, 64017], "valid"], [[64018, 64018], "mapped", [26228]], [[64019, 64020], "valid"], [[64021, 64021], "mapped", [20958]], [[64022, 64022], "mapped", [29482]], [[64023, 64023], "mapped", [30410]], [[64024, 64024], "mapped", [31036]], [[64025, 64025], "mapped", [31070]], [[64026, 64026], "mapped", [31077]], [[64027, 64027], "mapped", [31119]], [[64028, 64028], "mapped", [38742]], [[64029, 64029], "mapped", [31934]], [[64030, 64030], "mapped", [32701]], [[64031, 64031], "valid"], [[64032, 64032], "mapped", [34322]], [[64033, 64033], "valid"], [[64034, 64034], "mapped", [35576]], [[64035, 64036], "valid"], [[64037, 64037], "mapped", [36920]], [[64038, 64038], "mapped", [37117]], [[64039, 64041], "valid"], [[64042, 64042], "mapped", [39151]], [[64043, 64043], "mapped", [39164]], [[64044, 64044], "mapped", [39208]], [[64045, 64045], "mapped", [40372]], [[64046, 64046], "mapped", [37086]], [[64047, 64047], "mapped", [38583]], [[64048, 64048], "mapped", [20398]], [[64049, 64049], "mapped", [20711]], [[64050, 64050], "mapped", [20813]], [[64051, 64051], "mapped", [21193]], [[64052, 64052], "mapped", [21220]], [[64053, 64053], "mapped", [21329]], [[64054, 64054], "mapped", [21917]], [[64055, 64055], "mapped", [22022]], [[64056, 64056], "mapped", [22120]], [[64057, 64057], "mapped", [22592]], [[64058, 64058], "mapped", [22696]], [[64059, 64059], "mapped", [23652]], [[64060, 64060], "mapped", [23662]], [[64061, 64061], "mapped", [24724]], [[64062, 64062], "mapped", [24936]], [[64063, 64063], "mapped", [24974]], [[64064, 64064], "mapped", [25074]], [[64065, 64065], "mapped", [25935]], [[64066, 64066], "mapped", [26082]], [[64067, 64067], "mapped", [26257]], [[64068, 64068], "mapped", [26757]], [[64069, 64069], "mapped", [28023]], [[64070, 64070], "mapped", [28186]], [[64071, 64071], "mapped", [28450]], [[64072, 64072], "mapped", [29038]], [[64073, 64073], "mapped", [29227]], [[64074, 64074], "mapped", [29730]], [[64075, 64075], "mapped", [30865]], [[64076, 64076], "mapped", [31038]], [[64077, 64077], "mapped", [31049]], [[64078, 64078], "mapped", [31048]], [[64079, 64079], "mapped", [31056]], [[64080, 64080], "mapped", [31062]], [[64081, 64081], "mapped", [31069]], [[64082, 64082], "mapped", [31117]], [[64083, 64083], "mapped", [31118]], [[64084, 64084], "mapped", [31296]], [[64085, 64085], "mapped", [31361]], [[64086, 64086], "mapped", [31680]], [[64087, 64087], "mapped", [32244]], [[64088, 64088], "mapped", [32265]], [[64089, 64089], "mapped", [32321]], [[64090, 64090], "mapped", [32626]], [[64091, 64091], "mapped", [32773]], [[64092, 64092], "mapped", [33261]], [[64093, 64094], "mapped", [33401]], [[64095, 64095], "mapped", [33879]], [[64096, 64096], "mapped", [35088]], [[64097, 64097], "mapped", [35222]], [[64098, 64098], "mapped", [35585]], [[64099, 64099], "mapped", [35641]], [[64100, 64100], "mapped", [36051]], [[64101, 64101], "mapped", [36104]], [[64102, 64102], "mapped", [36790]], [[64103, 64103], "mapped", [36920]], [[64104, 64104], "mapped", [38627]], [[64105, 64105], "mapped", [38911]], [[64106, 64106], "mapped", [38971]], [[64107, 64107], "mapped", [24693]], [[64108, 64108], "mapped", [148206]], [[64109, 64109], "mapped", [33304]], [[64110, 64111], "disallowed"], [[64112, 64112], "mapped", [20006]], [[64113, 64113], "mapped", [20917]], [[64114, 64114], "mapped", [20840]], [[64115, 64115], "mapped", [20352]], [[64116, 64116], "mapped", [20805]], [[64117, 64117], "mapped", [20864]], [[64118, 64118], "mapped", [21191]], [[64119, 64119], "mapped", [21242]], [[64120, 64120], "mapped", [21917]], [[64121, 64121], "mapped", [21845]], [[64122, 64122], "mapped", [21913]], [[64123, 64123], "mapped", [21986]], [[64124, 64124], "mapped", [22618]], [[64125, 64125], "mapped", [22707]], [[64126, 64126], "mapped", [22852]], [[64127, 64127], "mapped", [22868]], [[64128, 64128], "mapped", [23138]], [[64129, 64129], "mapped", [23336]], [[64130, 64130], "mapped", [24274]], [[64131, 64131], "mapped", [24281]], [[64132, 64132], "mapped", [24425]], [[64133, 64133], "mapped", [24493]], [[64134, 64134], "mapped", [24792]], [[64135, 64135], "mapped", [24910]], [[64136, 64136], "mapped", [24840]], [[64137, 64137], "mapped", [24974]], [[64138, 64138], "mapped", [24928]], [[64139, 64139], "mapped", [25074]], [[64140, 64140], "mapped", [25140]], [[64141, 64141], "mapped", [25540]], [[64142, 64142], "mapped", [25628]], [[64143, 64143], "mapped", [25682]], [[64144, 64144], "mapped", [25942]], [[64145, 64145], "mapped", [26228]], [[64146, 64146], "mapped", [26391]], [[64147, 64147], "mapped", [26395]], [[64148, 64148], "mapped", [26454]], [[64149, 64149], "mapped", [27513]], [[64150, 64150], "mapped", [27578]], [[64151, 64151], "mapped", [27969]], [[64152, 64152], "mapped", [28379]], [[64153, 64153], "mapped", [28363]], [[64154, 64154], "mapped", [28450]], [[64155, 64155], "mapped", [28702]], [[64156, 64156], "mapped", [29038]], [[64157, 64157], "mapped", [30631]], [[64158, 64158], "mapped", [29237]], [[64159, 64159], "mapped", [29359]], [[64160, 64160], "mapped", [29482]], [[64161, 64161], "mapped", [29809]], [[64162, 64162], "mapped", [29958]], [[64163, 64163], "mapped", [30011]], [[64164, 64164], "mapped", [30237]], [[64165, 64165], "mapped", [30239]], [[64166, 64166], "mapped", [30410]], [[64167, 64167], "mapped", [30427]], [[64168, 64168], "mapped", [30452]], [[64169, 64169], "mapped", [30538]], [[64170, 64170], "mapped", [30528]], [[64171, 64171], "mapped", [30924]], [[64172, 64172], "mapped", [31409]], [[64173, 64173], "mapped", [31680]], [[64174, 64174], "mapped", [31867]], [[64175, 64175], "mapped", [32091]], [[64176, 64176], "mapped", [32244]], [[64177, 64177], "mapped", [32574]], [[64178, 64178], "mapped", [32773]], [[64179, 64179], "mapped", [33618]], [[64180, 64180], "mapped", [33775]], [[64181, 64181], "mapped", [34681]], [[64182, 64182], "mapped", [35137]], [[64183, 64183], "mapped", [35206]], [[64184, 64184], "mapped", [35222]], [[64185, 64185], "mapped", [35519]], [[64186, 64186], "mapped", [35576]], [[64187, 64187], "mapped", [35531]], [[64188, 64188], "mapped", [35585]], [[64189, 64189], "mapped", [35582]], [[64190, 64190], "mapped", [35565]], [[64191, 64191], "mapped", [35641]], [[64192, 64192], "mapped", [35722]], [[64193, 64193], "mapped", [36104]], [[64194, 64194], "mapped", [36664]], [[64195, 64195], "mapped", [36978]], [[64196, 64196], "mapped", [37273]], [[64197, 64197], "mapped", [37494]], [[64198, 64198], "mapped", [38524]], [[64199, 64199], "mapped", [38627]], [[64200, 64200], "mapped", [38742]], [[64201, 64201], "mapped", [38875]], [[64202, 64202], "mapped", [38911]], [[64203, 64203], "mapped", [38923]], [[64204, 64204], "mapped", [38971]], [[64205, 64205], "mapped", [39698]], [[64206, 64206], "mapped", [40860]], [[64207, 64207], "mapped", [141386]], [[64208, 64208], "mapped", [141380]], [[64209, 64209], "mapped", [144341]], [[64210, 64210], "mapped", [15261]], [[64211, 64211], "mapped", [16408]], [[64212, 64212], "mapped", [16441]], [[64213, 64213], "mapped", [152137]], [[64214, 64214], "mapped", [154832]], [[64215, 64215], "mapped", [163539]], [[64216, 64216], "mapped", [40771]], [[64217, 64217], "mapped", [40846]], [[64218, 64255], "disallowed"], [[64256, 64256], "mapped", [102, 102]], [[64257, 64257], "mapped", [102, 105]], [[64258, 64258], "mapped", [102, 108]], [[64259, 64259], "mapped", [102, 102, 105]], [[64260, 64260], "mapped", [102, 102, 108]], [[64261, 64262], "mapped", [115, 116]], [[64263, 64274], "disallowed"], [[64275, 64275], "mapped", [1396, 1398]], [[64276, 64276], "mapped", [1396, 1381]], [[64277, 64277], "mapped", [1396, 1387]], [[64278, 64278], "mapped", [1406, 1398]], [[64279, 64279], "mapped", [1396, 1389]], [[64280, 64284], "disallowed"], [[64285, 64285], "mapped", [1497, 1460]], [[64286, 64286], "valid"], [[64287, 64287], "mapped", [1522, 1463]], [[64288, 64288], "mapped", [1506]], [[64289, 64289], "mapped", [1488]], [[64290, 64290], "mapped", [1491]], [[64291, 64291], "mapped", [1492]], [[64292, 64292], "mapped", [1499]], [[64293, 64293], "mapped", [1500]], [[64294, 64294], "mapped", [1501]], [[64295, 64295], "mapped", [1512]], [[64296, 64296], "mapped", [1514]], [[64297, 64297], "disallowed_STD3_mapped", [43]], [[64298, 64298], "mapped", [1513, 1473]], [[64299, 64299], "mapped", [1513, 1474]], [[64300, 64300], "mapped", [1513, 1468, 1473]], [[64301, 64301], "mapped", [1513, 1468, 1474]], [[64302, 64302], "mapped", [1488, 1463]], [[64303, 64303], "mapped", [1488, 1464]], [[64304, 64304], "mapped", [1488, 1468]], [[64305, 64305], "mapped", [1489, 1468]], [[64306, 64306], "mapped", [1490, 1468]], [[64307, 64307], "mapped", [1491, 1468]], [[64308, 64308], "mapped", [1492, 1468]], [[64309, 64309], "mapped", [1493, 1468]], [[64310, 64310], "mapped", [1494, 1468]], [[64311, 64311], "disallowed"], [[64312, 64312], "mapped", [1496, 1468]], [[64313, 64313], "mapped", [1497, 1468]], [[64314, 64314], "mapped", [1498, 1468]], [[64315, 64315], "mapped", [1499, 1468]], [[64316, 64316], "mapped", [1500, 1468]], [[64317, 64317], "disallowed"], [[64318, 64318], "mapped", [1502, 1468]], [[64319, 64319], "disallowed"], [[64320, 64320], "mapped", [1504, 1468]], [[64321, 64321], "mapped", [1505, 1468]], [[64322, 64322], "disallowed"], [[64323, 64323], "mapped", [1507, 1468]], [[64324, 64324], "mapped", [1508, 1468]], [[64325, 64325], "disallowed"], [[64326, 64326], "mapped", [1510, 1468]], [[64327, 64327], "mapped", [1511, 1468]], [[64328, 64328], "mapped", [1512, 1468]], [[64329, 64329], "mapped", [1513, 1468]], [[64330, 64330], "mapped", [1514, 1468]], [[64331, 64331], "mapped", [1493, 1465]], [[64332, 64332], "mapped", [1489, 1471]], [[64333, 64333], "mapped", [1499, 1471]], [[64334, 64334], "mapped", [1508, 1471]], [[64335, 64335], "mapped", [1488, 1500]], [[64336, 64337], "mapped", [1649]], [[64338, 64341], "mapped", [1659]], [[64342, 64345], "mapped", [1662]], [[64346, 64349], "mapped", [1664]], [[64350, 64353], "mapped", [1658]], [[64354, 64357], "mapped", [1663]], [[64358, 64361], "mapped", [1657]], [[64362, 64365], "mapped", [1700]], [[64366, 64369], "mapped", [1702]], [[64370, 64373], "mapped", [1668]], [[64374, 64377], "mapped", [1667]], [[64378, 64381], "mapped", [1670]], [[64382, 64385], "mapped", [1671]], [[64386, 64387], "mapped", [1677]], [[64388, 64389], "mapped", [1676]], [[64390, 64391], "mapped", [1678]], [[64392, 64393], "mapped", [1672]], [[64394, 64395], "mapped", [1688]], [[64396, 64397], "mapped", [1681]], [[64398, 64401], "mapped", [1705]], [[64402, 64405], "mapped", [1711]], [[64406, 64409], "mapped", [1715]], [[64410, 64413], "mapped", [1713]], [[64414, 64415], "mapped", [1722]], [[64416, 64419], "mapped", [1723]], [[64420, 64421], "mapped", [1728]], [[64422, 64425], "mapped", [1729]], [[64426, 64429], "mapped", [1726]], [[64430, 64431], "mapped", [1746]], [[64432, 64433], "mapped", [1747]], [[64434, 64449], "valid", [], "NV8"], [[64450, 64466], "disallowed"], [[64467, 64470], "mapped", [1709]], [[64471, 64472], "mapped", [1735]], [[64473, 64474], "mapped", [1734]], [[64475, 64476], "mapped", [1736]], [[64477, 64477], "mapped", [1735, 1652]], [[64478, 64479], "mapped", [1739]], [[64480, 64481], "mapped", [1733]], [[64482, 64483], "mapped", [1737]], [[64484, 64487], "mapped", [1744]], [[64488, 64489], "mapped", [1609]], [[64490, 64491], "mapped", [1574, 1575]], [[64492, 64493], "mapped", [1574, 1749]], [[64494, 64495], "mapped", [1574, 1608]], [[64496, 64497], "mapped", [1574, 1735]], [[64498, 64499], "mapped", [1574, 1734]], [[64500, 64501], "mapped", [1574, 1736]], [[64502, 64504], "mapped", [1574, 1744]], [[64505, 64507], "mapped", [1574, 1609]], [[64508, 64511], "mapped", [1740]], [[64512, 64512], "mapped", [1574, 1580]], [[64513, 64513], "mapped", [1574, 1581]], [[64514, 64514], "mapped", [1574, 1605]], [[64515, 64515], "mapped", [1574, 1609]], [[64516, 64516], "mapped", [1574, 1610]], [[64517, 64517], "mapped", [1576, 1580]], [[64518, 64518], "mapped", [1576, 1581]], [[64519, 64519], "mapped", [1576, 1582]], [[64520, 64520], "mapped", [1576, 1605]], [[64521, 64521], "mapped", [1576, 1609]], [[64522, 64522], "mapped", [1576, 1610]], [[64523, 64523], "mapped", [1578, 1580]], [[64524, 64524], "mapped", [1578, 1581]], [[64525, 64525], "mapped", [1578, 1582]], [[64526, 64526], "mapped", [1578, 1605]], [[64527, 64527], "mapped", [1578, 1609]], [[64528, 64528], "mapped", [1578, 1610]], [[64529, 64529], "mapped", [1579, 1580]], [[64530, 64530], "mapped", [1579, 1605]], [[64531, 64531], "mapped", [1579, 1609]], [[64532, 64532], "mapped", [1579, 1610]], [[64533, 64533], "mapped", [1580, 1581]], [[64534, 64534], "mapped", [1580, 1605]], [[64535, 64535], "mapped", [1581, 1580]], [[64536, 64536], "mapped", [1581, 1605]], [[64537, 64537], "mapped", [1582, 1580]], [[64538, 64538], "mapped", [1582, 1581]], [[64539, 64539], "mapped", [1582, 1605]], [[64540, 64540], "mapped", [1587, 1580]], [[64541, 64541], "mapped", [1587, 1581]], [[64542, 64542], "mapped", [1587, 1582]], [[64543, 64543], "mapped", [1587, 1605]], [[64544, 64544], "mapped", [1589, 1581]], [[64545, 64545], "mapped", [1589, 1605]], [[64546, 64546], "mapped", [1590, 1580]], [[64547, 64547], "mapped", [1590, 1581]], [[64548, 64548], "mapped", [1590, 1582]], [[64549, 64549], "mapped", [1590, 1605]], [[64550, 64550], "mapped", [1591, 1581]], [[64551, 64551], "mapped", [1591, 1605]], [[64552, 64552], "mapped", [1592, 1605]], [[64553, 64553], "mapped", [1593, 1580]], [[64554, 64554], "mapped", [1593, 1605]], [[64555, 64555], "mapped", [1594, 1580]], [[64556, 64556], "mapped", [1594, 1605]], [[64557, 64557], "mapped", [1601, 1580]], [[64558, 64558], "mapped", [1601, 1581]], [[64559, 64559], "mapped", [1601, 1582]], [[64560, 64560], "mapped", [1601, 1605]], [[64561, 64561], "mapped", [1601, 1609]], [[64562, 64562], "mapped", [1601, 1610]], [[64563, 64563], "mapped", [1602, 1581]], [[64564, 64564], "mapped", [1602, 1605]], [[64565, 64565], "mapped", [1602, 1609]], [[64566, 64566], "mapped", [1602, 1610]], [[64567, 64567], "mapped", [1603, 1575]], [[64568, 64568], "mapped", [1603, 1580]], [[64569, 64569], "mapped", [1603, 1581]], [[64570, 64570], "mapped", [1603, 1582]], [[64571, 64571], "mapped", [1603, 1604]], [[64572, 64572], "mapped", [1603, 1605]], [[64573, 64573], "mapped", [1603, 1609]], [[64574, 64574], "mapped", [1603, 1610]], [[64575, 64575], "mapped", [1604, 1580]], [[64576, 64576], "mapped", [1604, 1581]], [[64577, 64577], "mapped", [1604, 1582]], [[64578, 64578], "mapped", [1604, 1605]], [[64579, 64579], "mapped", [1604, 1609]], [[64580, 64580], "mapped", [1604, 1610]], [[64581, 64581], "mapped", [1605, 1580]], [[64582, 64582], "mapped", [1605, 1581]], [[64583, 64583], "mapped", [1605, 1582]], [[64584, 64584], "mapped", [1605, 1605]], [[64585, 64585], "mapped", [1605, 1609]], [[64586, 64586], "mapped", [1605, 1610]], [[64587, 64587], "mapped", [1606, 1580]], [[64588, 64588], "mapped", [1606, 1581]], [[64589, 64589], "mapped", [1606, 1582]], [[64590, 64590], "mapped", [1606, 1605]], [[64591, 64591], "mapped", [1606, 1609]], [[64592, 64592], "mapped", [1606, 1610]], [[64593, 64593], "mapped", [1607, 1580]], [[64594, 64594], "mapped", [1607, 1605]], [[64595, 64595], "mapped", [1607, 1609]], [[64596, 64596], "mapped", [1607, 1610]], [[64597, 64597], "mapped", [1610, 1580]], [[64598, 64598], "mapped", [1610, 1581]], [[64599, 64599], "mapped", [1610, 1582]], [[64600, 64600], "mapped", [1610, 1605]], [[64601, 64601], "mapped", [1610, 1609]], [[64602, 64602], "mapped", [1610, 1610]], [[64603, 64603], "mapped", [1584, 1648]], [[64604, 64604], "mapped", [1585, 1648]], [[64605, 64605], "mapped", [1609, 1648]], [[64606, 64606], "disallowed_STD3_mapped", [32, 1612, 1617]], [[64607, 64607], "disallowed_STD3_mapped", [32, 1613, 1617]], [[64608, 64608], "disallowed_STD3_mapped", [32, 1614, 1617]], [[64609, 64609], "disallowed_STD3_mapped", [32, 1615, 1617]], [[64610, 64610], "disallowed_STD3_mapped", [32, 1616, 1617]], [[64611, 64611], "disallowed_STD3_mapped", [32, 1617, 1648]], [[64612, 64612], "mapped", [1574, 1585]], [[64613, 64613], "mapped", [1574, 1586]], [[64614, 64614], "mapped", [1574, 1605]], [[64615, 64615], "mapped", [1574, 1606]], [[64616, 64616], "mapped", [1574, 1609]], [[64617, 64617], "mapped", [1574, 1610]], [[64618, 64618], "mapped", [1576, 1585]], [[64619, 64619], "mapped", [1576, 1586]], [[64620, 64620], "mapped", [1576, 1605]], [[64621, 64621], "mapped", [1576, 1606]], [[64622, 64622], "mapped", [1576, 1609]], [[64623, 64623], "mapped", [1576, 1610]], [[64624, 64624], "mapped", [1578, 1585]], [[64625, 64625], "mapped", [1578, 1586]], [[64626, 64626], "mapped", [1578, 1605]], [[64627, 64627], "mapped", [1578, 1606]], [[64628, 64628], "mapped", [1578, 1609]], [[64629, 64629], "mapped", [1578, 1610]], [[64630, 64630], "mapped", [1579, 1585]], [[64631, 64631], "mapped", [1579, 1586]], [[64632, 64632], "mapped", [1579, 1605]], [[64633, 64633], "mapped", [1579, 1606]], [[64634, 64634], "mapped", [1579, 1609]], [[64635, 64635], "mapped", [1579, 1610]], [[64636, 64636], "mapped", [1601, 1609]], [[64637, 64637], "mapped", [1601, 1610]], [[64638, 64638], "mapped", [1602, 1609]], [[64639, 64639], "mapped", [1602, 1610]], [[64640, 64640], "mapped", [1603, 1575]], [[64641, 64641], "mapped", [1603, 1604]], [[64642, 64642], "mapped", [1603, 1605]], [[64643, 64643], "mapped", [1603, 1609]], [[64644, 64644], "mapped", [1603, 1610]], [[64645, 64645], "mapped", [1604, 1605]], [[64646, 64646], "mapped", [1604, 1609]], [[64647, 64647], "mapped", [1604, 1610]], [[64648, 64648], "mapped", [1605, 1575]], [[64649, 64649], "mapped", [1605, 1605]], [[64650, 64650], "mapped", [1606, 1585]], [[64651, 64651], "mapped", [1606, 1586]], [[64652, 64652], "mapped", [1606, 1605]], [[64653, 64653], "mapped", [1606, 1606]], [[64654, 64654], "mapped", [1606, 1609]], [[64655, 64655], "mapped", [1606, 1610]], [[64656, 64656], "mapped", [1609, 1648]], [[64657, 64657], "mapped", [1610, 1585]], [[64658, 64658], "mapped", [1610, 1586]], [[64659, 64659], "mapped", [1610, 1605]], [[64660, 64660], "mapped", [1610, 1606]], [[64661, 64661], "mapped", [1610, 1609]], [[64662, 64662], "mapped", [1610, 1610]], [[64663, 64663], "mapped", [1574, 1580]], [[64664, 64664], "mapped", [1574, 1581]], [[64665, 64665], "mapped", [1574, 1582]], [[64666, 64666], "mapped", [1574, 1605]], [[64667, 64667], "mapped", [1574, 1607]], [[64668, 64668], "mapped", [1576, 1580]], [[64669, 64669], "mapped", [1576, 1581]], [[64670, 64670], "mapped", [1576, 1582]], [[64671, 64671], "mapped", [1576, 1605]], [[64672, 64672], "mapped", [1576, 1607]], [[64673, 64673], "mapped", [1578, 1580]], [[64674, 64674], "mapped", [1578, 1581]], [[64675, 64675], "mapped", [1578, 1582]], [[64676, 64676], "mapped", [1578, 1605]], [[64677, 64677], "mapped", [1578, 1607]], [[64678, 64678], "mapped", [1579, 1605]], [[64679, 64679], "mapped", [1580, 1581]], [[64680, 64680], "mapped", [1580, 1605]], [[64681, 64681], "mapped", [1581, 1580]], [[64682, 64682], "mapped", [1581, 1605]], [[64683, 64683], "mapped", [1582, 1580]], [[64684, 64684], "mapped", [1582, 1605]], [[64685, 64685], "mapped", [1587, 1580]], [[64686, 64686], "mapped", [1587, 1581]], [[64687, 64687], "mapped", [1587, 1582]], [[64688, 64688], "mapped", [1587, 1605]], [[64689, 64689], "mapped", [1589, 1581]], [[64690, 64690], "mapped", [1589, 1582]], [[64691, 64691], "mapped", [1589, 1605]], [[64692, 64692], "mapped", [1590, 1580]], [[64693, 64693], "mapped", [1590, 1581]], [[64694, 64694], "mapped", [1590, 1582]], [[64695, 64695], "mapped", [1590, 1605]], [[64696, 64696], "mapped", [1591, 1581]], [[64697, 64697], "mapped", [1592, 1605]], [[64698, 64698], "mapped", [1593, 1580]], [[64699, 64699], "mapped", [1593, 1605]], [[64700, 64700], "mapped", [1594, 1580]], [[64701, 64701], "mapped", [1594, 1605]], [[64702, 64702], "mapped", [1601, 1580]], [[64703, 64703], "mapped", [1601, 1581]], [[64704, 64704], "mapped", [1601, 1582]], [[64705, 64705], "mapped", [1601, 1605]], [[64706, 64706], "mapped", [1602, 1581]], [[64707, 64707], "mapped", [1602, 1605]], [[64708, 64708], "mapped", [1603, 1580]], [[64709, 64709], "mapped", [1603, 1581]], [[64710, 64710], "mapped", [1603, 1582]], [[64711, 64711], "mapped", [1603, 1604]], [[64712, 64712], "mapped", [1603, 1605]], [[64713, 64713], "mapped", [1604, 1580]], [[64714, 64714], "mapped", [1604, 1581]], [[64715, 64715], "mapped", [1604, 1582]], [[64716, 64716], "mapped", [1604, 1605]], [[64717, 64717], "mapped", [1604, 1607]], [[64718, 64718], "mapped", [1605, 1580]], [[64719, 64719], "mapped", [1605, 1581]], [[64720, 64720], "mapped", [1605, 1582]], [[64721, 64721], "mapped", [1605, 1605]], [[64722, 64722], "mapped", [1606, 1580]], [[64723, 64723], "mapped", [1606, 1581]], [[64724, 64724], "mapped", [1606, 1582]], [[64725, 64725], "mapped", [1606, 1605]], [[64726, 64726], "mapped", [1606, 1607]], [[64727, 64727], "mapped", [1607, 1580]], [[64728, 64728], "mapped", [1607, 1605]], [[64729, 64729], "mapped", [1607, 1648]], [[64730, 64730], "mapped", [1610, 1580]], [[64731, 64731], "mapped", [1610, 1581]], [[64732, 64732], "mapped", [1610, 1582]], [[64733, 64733], "mapped", [1610, 1605]], [[64734, 64734], "mapped", [1610, 1607]], [[64735, 64735], "mapped", [1574, 1605]], [[64736, 64736], "mapped", [1574, 1607]], [[64737, 64737], "mapped", [1576, 1605]], [[64738, 64738], "mapped", [1576, 1607]], [[64739, 64739], "mapped", [1578, 1605]], [[64740, 64740], "mapped", [1578, 1607]], [[64741, 64741], "mapped", [1579, 1605]], [[64742, 64742], "mapped", [1579, 1607]], [[64743, 64743], "mapped", [1587, 1605]], [[64744, 64744], "mapped", [1587, 1607]], [[64745, 64745], "mapped", [1588, 1605]], [[64746, 64746], "mapped", [1588, 1607]], [[64747, 64747], "mapped", [1603, 1604]], [[64748, 64748], "mapped", [1603, 1605]], [[64749, 64749], "mapped", [1604, 1605]], [[64750, 64750], "mapped", [1606, 1605]], [[64751, 64751], "mapped", [1606, 1607]], [[64752, 64752], "mapped", [1610, 1605]], [[64753, 64753], "mapped", [1610, 1607]], [[64754, 64754], "mapped", [1600, 1614, 1617]], [[64755, 64755], "mapped", [1600, 1615, 1617]], [[64756, 64756], "mapped", [1600, 1616, 1617]], [[64757, 64757], "mapped", [1591, 1609]], [[64758, 64758], "mapped", [1591, 1610]], [[64759, 64759], "mapped", [1593, 1609]], [[64760, 64760], "mapped", [1593, 1610]], [[64761, 64761], "mapped", [1594, 1609]], [[64762, 64762], "mapped", [1594, 1610]], [[64763, 64763], "mapped", [1587, 1609]], [[64764, 64764], "mapped", [1587, 1610]], [[64765, 64765], "mapped", [1588, 1609]], [[64766, 64766], "mapped", [1588, 1610]], [[64767, 64767], "mapped", [1581, 1609]], [[64768, 64768], "mapped", [1581, 1610]], [[64769, 64769], "mapped", [1580, 1609]], [[64770, 64770], "mapped", [1580, 1610]], [[64771, 64771], "mapped", [1582, 1609]], [[64772, 64772], "mapped", [1582, 1610]], [[64773, 64773], "mapped", [1589, 1609]], [[64774, 64774], "mapped", [1589, 1610]], [[64775, 64775], "mapped", [1590, 1609]], [[64776, 64776], "mapped", [1590, 1610]], [[64777, 64777], "mapped", [1588, 1580]], [[64778, 64778], "mapped", [1588, 1581]], [[64779, 64779], "mapped", [1588, 1582]], [[64780, 64780], "mapped", [1588, 1605]], [[64781, 64781], "mapped", [1588, 1585]], [[64782, 64782], "mapped", [1587, 1585]], [[64783, 64783], "mapped", [1589, 1585]], [[64784, 64784], "mapped", [1590, 1585]], [[64785, 64785], "mapped", [1591, 1609]], [[64786, 64786], "mapped", [1591, 1610]], [[64787, 64787], "mapped", [1593, 1609]], [[64788, 64788], "mapped", [1593, 1610]], [[64789, 64789], "mapped", [1594, 1609]], [[64790, 64790], "mapped", [1594, 1610]], [[64791, 64791], "mapped", [1587, 1609]], [[64792, 64792], "mapped", [1587, 1610]], [[64793, 64793], "mapped", [1588, 1609]], [[64794, 64794], "mapped", [1588, 1610]], [[64795, 64795], "mapped", [1581, 1609]], [[64796, 64796], "mapped", [1581, 1610]], [[64797, 64797], "mapped", [1580, 1609]], [[64798, 64798], "mapped", [1580, 1610]], [[64799, 64799], "mapped", [1582, 1609]], [[64800, 64800], "mapped", [1582, 1610]], [[64801, 64801], "mapped", [1589, 1609]], [[64802, 64802], "mapped", [1589, 1610]], [[64803, 64803], "mapped", [1590, 1609]], [[64804, 64804], "mapped", [1590, 1610]], [[64805, 64805], "mapped", [1588, 1580]], [[64806, 64806], "mapped", [1588, 1581]], [[64807, 64807], "mapped", [1588, 1582]], [[64808, 64808], "mapped", [1588, 1605]], [[64809, 64809], "mapped", [1588, 1585]], [[64810, 64810], "mapped", [1587, 1585]], [[64811, 64811], "mapped", [1589, 1585]], [[64812, 64812], "mapped", [1590, 1585]], [[64813, 64813], "mapped", [1588, 1580]], [[64814, 64814], "mapped", [1588, 1581]], [[64815, 64815], "mapped", [1588, 1582]], [[64816, 64816], "mapped", [1588, 1605]], [[64817, 64817], "mapped", [1587, 1607]], [[64818, 64818], "mapped", [1588, 1607]], [[64819, 64819], "mapped", [1591, 1605]], [[64820, 64820], "mapped", [1587, 1580]], [[64821, 64821], "mapped", [1587, 1581]], [[64822, 64822], "mapped", [1587, 1582]], [[64823, 64823], "mapped", [1588, 1580]], [[64824, 64824], "mapped", [1588, 1581]], [[64825, 64825], "mapped", [1588, 1582]], [[64826, 64826], "mapped", [1591, 1605]], [[64827, 64827], "mapped", [1592, 1605]], [[64828, 64829], "mapped", [1575, 1611]], [[64830, 64831], "valid", [], "NV8"], [[64832, 64847], "disallowed"], [[64848, 64848], "mapped", [1578, 1580, 1605]], [[64849, 64850], "mapped", [1578, 1581, 1580]], [[64851, 64851], "mapped", [1578, 1581, 1605]], [[64852, 64852], "mapped", [1578, 1582, 1605]], [[64853, 64853], "mapped", [1578, 1605, 1580]], [[64854, 64854], "mapped", [1578, 1605, 1581]], [[64855, 64855], "mapped", [1578, 1605, 1582]], [[64856, 64857], "mapped", [1580, 1605, 1581]], [[64858, 64858], "mapped", [1581, 1605, 1610]], [[64859, 64859], "mapped", [1581, 1605, 1609]], [[64860, 64860], "mapped", [1587, 1581, 1580]], [[64861, 64861], "mapped", [1587, 1580, 1581]], [[64862, 64862], "mapped", [1587, 1580, 1609]], [[64863, 64864], "mapped", [1587, 1605, 1581]], [[64865, 64865], "mapped", [1587, 1605, 1580]], [[64866, 64867], "mapped", [1587, 1605, 1605]], [[64868, 64869], "mapped", [1589, 1581, 1581]], [[64870, 64870], "mapped", [1589, 1605, 1605]], [[64871, 64872], "mapped", [1588, 1581, 1605]], [[64873, 64873], "mapped", [1588, 1580, 1610]], [[64874, 64875], "mapped", [1588, 1605, 1582]], [[64876, 64877], "mapped", [1588, 1605, 1605]], [[64878, 64878], "mapped", [1590, 1581, 1609]], [[64879, 64880], "mapped", [1590, 1582, 1605]], [[64881, 64882], "mapped", [1591, 1605, 1581]], [[64883, 64883], "mapped", [1591, 1605, 1605]], [[64884, 64884], "mapped", [1591, 1605, 1610]], [[64885, 64885], "mapped", [1593, 1580, 1605]], [[64886, 64887], "mapped", [1593, 1605, 1605]], [[64888, 64888], "mapped", [1593, 1605, 1609]], [[64889, 64889], "mapped", [1594, 1605, 1605]], [[64890, 64890], "mapped", [1594, 1605, 1610]], [[64891, 64891], "mapped", [1594, 1605, 1609]], [[64892, 64893], "mapped", [1601, 1582, 1605]], [[64894, 64894], "mapped", [1602, 1605, 1581]], [[64895, 64895], "mapped", [1602, 1605, 1605]], [[64896, 64896], "mapped", [1604, 1581, 1605]], [[64897, 64897], "mapped", [1604, 1581, 1610]], [[64898, 64898], "mapped", [1604, 1581, 1609]], [[64899, 64900], "mapped", [1604, 1580, 1580]], [[64901, 64902], "mapped", [1604, 1582, 1605]], [[64903, 64904], "mapped", [1604, 1605, 1581]], [[64905, 64905], "mapped", [1605, 1581, 1580]], [[64906, 64906], "mapped", [1605, 1581, 1605]], [[64907, 64907], "mapped", [1605, 1581, 1610]], [[64908, 64908], "mapped", [1605, 1580, 1581]], [[64909, 64909], "mapped", [1605, 1580, 1605]], [[64910, 64910], "mapped", [1605, 1582, 1580]], [[64911, 64911], "mapped", [1605, 1582, 1605]], [[64912, 64913], "disallowed"], [[64914, 64914], "mapped", [1605, 1580, 1582]], [[64915, 64915], "mapped", [1607, 1605, 1580]], [[64916, 64916], "mapped", [1607, 1605, 1605]], [[64917, 64917], "mapped", [1606, 1581, 1605]], [[64918, 64918], "mapped", [1606, 1581, 1609]], [[64919, 64920], "mapped", [1606, 1580, 1605]], [[64921, 64921], "mapped", [1606, 1580, 1609]], [[64922, 64922], "mapped", [1606, 1605, 1610]], [[64923, 64923], "mapped", [1606, 1605, 1609]], [[64924, 64925], "mapped", [1610, 1605, 1605]], [[64926, 64926], "mapped", [1576, 1582, 1610]], [[64927, 64927], "mapped", [1578, 1580, 1610]], [[64928, 64928], "mapped", [1578, 1580, 1609]], [[64929, 64929], "mapped", [1578, 1582, 1610]], [[64930, 64930], "mapped", [1578, 1582, 1609]], [[64931, 64931], "mapped", [1578, 1605, 1610]], [[64932, 64932], "mapped", [1578, 1605, 1609]], [[64933, 64933], "mapped", [1580, 1605, 1610]], [[64934, 64934], "mapped", [1580, 1581, 1609]], [[64935, 64935], "mapped", [1580, 1605, 1609]], [[64936, 64936], "mapped", [1587, 1582, 1609]], [[64937, 64937], "mapped", [1589, 1581, 1610]], [[64938, 64938], "mapped", [1588, 1581, 1610]], [[64939, 64939], "mapped", [1590, 1581, 1610]], [[64940, 64940], "mapped", [1604, 1580, 1610]], [[64941, 64941], "mapped", [1604, 1605, 1610]], [[64942, 64942], "mapped", [1610, 1581, 1610]], [[64943, 64943], "mapped", [1610, 1580, 1610]], [[64944, 64944], "mapped", [1610, 1605, 1610]], [[64945, 64945], "mapped", [1605, 1605, 1610]], [[64946, 64946], "mapped", [1602, 1605, 1610]], [[64947, 64947], "mapped", [1606, 1581, 1610]], [[64948, 64948], "mapped", [1602, 1605, 1581]], [[64949, 64949], "mapped", [1604, 1581, 1605]], [[64950, 64950], "mapped", [1593, 1605, 1610]], [[64951, 64951], "mapped", [1603, 1605, 1610]], [[64952, 64952], "mapped", [1606, 1580, 1581]], [[64953, 64953], "mapped", [1605, 1582, 1610]], [[64954, 64954], "mapped", [1604, 1580, 1605]], [[64955, 64955], "mapped", [1603, 1605, 1605]], [[64956, 64956], "mapped", [1604, 1580, 1605]], [[64957, 64957], "mapped", [1606, 1580, 1581]], [[64958, 64958], "mapped", [1580, 1581, 1610]], [[64959, 64959], "mapped", [1581, 1580, 1610]], [[64960, 64960], "mapped", [1605, 1580, 1610]], [[64961, 64961], "mapped", [1601, 1605, 1610]], [[64962, 64962], "mapped", [1576, 1581, 1610]], [[64963, 64963], "mapped", [1603, 1605, 1605]], [[64964, 64964], "mapped", [1593, 1580, 1605]], [[64965, 64965], "mapped", [1589, 1605, 1605]], [[64966, 64966], "mapped", [1587, 1582, 1610]], [[64967, 64967], "mapped", [1606, 1580, 1610]], [[64968, 64975], "disallowed"], [[64976, 65007], "disallowed"], [[65008, 65008], "mapped", [1589, 1604, 1746]], [[65009, 65009], "mapped", [1602, 1604, 1746]], [[65010, 65010], "mapped", [1575, 1604, 1604, 1607]], [[65011, 65011], "mapped", [1575, 1603, 1576, 1585]], [[65012, 65012], "mapped", [1605, 1581, 1605, 1583]], [[65013, 65013], "mapped", [1589, 1604, 1593, 1605]], [[65014, 65014], "mapped", [1585, 1587, 1608, 1604]], [[65015, 65015], "mapped", [1593, 1604, 1610, 1607]], [[65016, 65016], "mapped", [1608, 1587, 1604, 1605]], [[65017, 65017], "mapped", [1589, 1604, 1609]], [[65018, 65018], "disallowed_STD3_mapped", [1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593, 1604, 1610, 1607, 32, 1608, 1587, 1604, 1605]], [[65019, 65019], "disallowed_STD3_mapped", [1580, 1604, 32, 1580, 1604, 1575, 1604, 1607]], [[65020, 65020], "mapped", [1585, 1740, 1575, 1604]], [[65021, 65021], "valid", [], "NV8"], [[65022, 65023], "disallowed"], [[65024, 65039], "ignored"], [[65040, 65040], "disallowed_STD3_mapped", [44]], [[65041, 65041], "mapped", [12289]], [[65042, 65042], "disallowed"], [[65043, 65043], "disallowed_STD3_mapped", [58]], [[65044, 65044], "disallowed_STD3_mapped", [59]], [[65045, 65045], "disallowed_STD3_mapped", [33]], [[65046, 65046], "disallowed_STD3_mapped", [63]], [[65047, 65047], "mapped", [12310]], [[65048, 65048], "mapped", [12311]], [[65049, 65049], "disallowed"], [[65050, 65055], "disallowed"], [[65056, 65059], "valid"], [[65060, 65062], "valid"], [[65063, 65069], "valid"], [[65070, 65071], "valid"], [[65072, 65072], "disallowed"], [[65073, 65073], "mapped", [8212]], [[65074, 65074], "mapped", [8211]], [[65075, 65076], "disallowed_STD3_mapped", [95]], [[65077, 65077], "disallowed_STD3_mapped", [40]], [[65078, 65078], "disallowed_STD3_mapped", [41]], [[65079, 65079], "disallowed_STD3_mapped", [123]], [[65080, 65080], "disallowed_STD3_mapped", [125]], [[65081, 65081], "mapped", [12308]], [[65082, 65082], "mapped", [12309]], [[65083, 65083], "mapped", [12304]], [[65084, 65084], "mapped", [12305]], [[65085, 65085], "mapped", [12298]], [[65086, 65086], "mapped", [12299]], [[65087, 65087], "mapped", [12296]], [[65088, 65088], "mapped", [12297]], [[65089, 65089], "mapped", [12300]], [[65090, 65090], "mapped", [12301]], [[65091, 65091], "mapped", [12302]], [[65092, 65092], "mapped", [12303]], [[65093, 65094], "valid", [], "NV8"], [[65095, 65095], "disallowed_STD3_mapped", [91]], [[65096, 65096], "disallowed_STD3_mapped", [93]], [[65097, 65100], "disallowed_STD3_mapped", [32, 773]], [[65101, 65103], "disallowed_STD3_mapped", [95]], [[65104, 65104], "disallowed_STD3_mapped", [44]], [[65105, 65105], "mapped", [12289]], [[65106, 65106], "disallowed"], [[65107, 65107], "disallowed"], [[65108, 65108], "disallowed_STD3_mapped", [59]], [[65109, 65109], "disallowed_STD3_mapped", [58]], [[65110, 65110], "disallowed_STD3_mapped", [63]], [[65111, 65111], "disallowed_STD3_mapped", [33]], [[65112, 65112], "mapped", [8212]], [[65113, 65113], "disallowed_STD3_mapped", [40]], [[65114, 65114], "disallowed_STD3_mapped", [41]], [[65115, 65115], "disallowed_STD3_mapped", [123]], [[65116, 65116], "disallowed_STD3_mapped", [125]], [[65117, 65117], "mapped", [12308]], [[65118, 65118], "mapped", [12309]], [[65119, 65119], "disallowed_STD3_mapped", [35]], [[65120, 65120], "disallowed_STD3_mapped", [38]], [[65121, 65121], "disallowed_STD3_mapped", [42]], [[65122, 65122], "disallowed_STD3_mapped", [43]], [[65123, 65123], "mapped", [45]], [[65124, 65124], "disallowed_STD3_mapped", [60]], [[65125, 65125], "disallowed_STD3_mapped", [62]], [[65126, 65126], "disallowed_STD3_mapped", [61]], [[65127, 65127], "disallowed"], [[65128, 65128], "disallowed_STD3_mapped", [92]], [[65129, 65129], "disallowed_STD3_mapped", [36]], [[65130, 65130], "disallowed_STD3_mapped", [37]], [[65131, 65131], "disallowed_STD3_mapped", [64]], [[65132, 65135], "disallowed"], [[65136, 65136], "disallowed_STD3_mapped", [32, 1611]], [[65137, 65137], "mapped", [1600, 1611]], [[65138, 65138], "disallowed_STD3_mapped", [32, 1612]], [[65139, 65139], "valid"], [[65140, 65140], "disallowed_STD3_mapped", [32, 1613]], [[65141, 65141], "disallowed"], [[65142, 65142], "disallowed_STD3_mapped", [32, 1614]], [[65143, 65143], "mapped", [1600, 1614]], [[65144, 65144], "disallowed_STD3_mapped", [32, 1615]], [[65145, 65145], "mapped", [1600, 1615]], [[65146, 65146], "disallowed_STD3_mapped", [32, 1616]], [[65147, 65147], "mapped", [1600, 1616]], [[65148, 65148], "disallowed_STD3_mapped", [32, 1617]], [[65149, 65149], "mapped", [1600, 1617]], [[65150, 65150], "disallowed_STD3_mapped", [32, 1618]], [[65151, 65151], "mapped", [1600, 1618]], [[65152, 65152], "mapped", [1569]], [[65153, 65154], "mapped", [1570]], [[65155, 65156], "mapped", [1571]], [[65157, 65158], "mapped", [1572]], [[65159, 65160], "mapped", [1573]], [[65161, 65164], "mapped", [1574]], [[65165, 65166], "mapped", [1575]], [[65167, 65170], "mapped", [1576]], [[65171, 65172], "mapped", [1577]], [[65173, 65176], "mapped", [1578]], [[65177, 65180], "mapped", [1579]], [[65181, 65184], "mapped", [1580]], [[65185, 65188], "mapped", [1581]], [[65189, 65192], "mapped", [1582]], [[65193, 65194], "mapped", [1583]], [[65195, 65196], "mapped", [1584]], [[65197, 65198], "mapped", [1585]], [[65199, 65200], "mapped", [1586]], [[65201, 65204], "mapped", [1587]], [[65205, 65208], "mapped", [1588]], [[65209, 65212], "mapped", [1589]], [[65213, 65216], "mapped", [1590]], [[65217, 65220], "mapped", [1591]], [[65221, 65224], "mapped", [1592]], [[65225, 65228], "mapped", [1593]], [[65229, 65232], "mapped", [1594]], [[65233, 65236], "mapped", [1601]], [[65237, 65240], "mapped", [1602]], [[65241, 65244], "mapped", [1603]], [[65245, 65248], "mapped", [1604]], [[65249, 65252], "mapped", [1605]], [[65253, 65256], "mapped", [1606]], [[65257, 65260], "mapped", [1607]], [[65261, 65262], "mapped", [1608]], [[65263, 65264], "mapped", [1609]], [[65265, 65268], "mapped", [1610]], [[65269, 65270], "mapped", [1604, 1570]], [[65271, 65272], "mapped", [1604, 1571]], [[65273, 65274], "mapped", [1604, 1573]], [[65275, 65276], "mapped", [1604, 1575]], [[65277, 65278], "disallowed"], [[65279, 65279], "ignored"], [[65280, 65280], "disallowed"], [[65281, 65281], "disallowed_STD3_mapped", [33]], [[65282, 65282], "disallowed_STD3_mapped", [34]], [[65283, 65283], "disallowed_STD3_mapped", [35]], [[65284, 65284], "disallowed_STD3_mapped", [36]], [[65285, 65285], "disallowed_STD3_mapped", [37]], [[65286, 65286], "disallowed_STD3_mapped", [38]], [[65287, 65287], "disallowed_STD3_mapped", [39]], [[65288, 65288], "disallowed_STD3_mapped", [40]], [[65289, 65289], "disallowed_STD3_mapped", [41]], [[65290, 65290], "disallowed_STD3_mapped", [42]], [[65291, 65291], "disallowed_STD3_mapped", [43]], [[65292, 65292], "disallowed_STD3_mapped", [44]], [[65293, 65293], "mapped", [45]], [[65294, 65294], "mapped", [46]], [[65295, 65295], "disallowed_STD3_mapped", [47]], [[65296, 65296], "mapped", [48]], [[65297, 65297], "mapped", [49]], [[65298, 65298], "mapped", [50]], [[65299, 65299], "mapped", [51]], [[65300, 65300], "mapped", [52]], [[65301, 65301], "mapped", [53]], [[65302, 65302], "mapped", [54]], [[65303, 65303], "mapped", [55]], [[65304, 65304], "mapped", [56]], [[65305, 65305], "mapped", [57]], [[65306, 65306], "disallowed_STD3_mapped", [58]], [[65307, 65307], "disallowed_STD3_mapped", [59]], [[65308, 65308], "disallowed_STD3_mapped", [60]], [[65309, 65309], "disallowed_STD3_mapped", [61]], [[65310, 65310], "disallowed_STD3_mapped", [62]], [[65311, 65311], "disallowed_STD3_mapped", [63]], [[65312, 65312], "disallowed_STD3_mapped", [64]], [[65313, 65313], "mapped", [97]], [[65314, 65314], "mapped", [98]], [[65315, 65315], "mapped", [99]], [[65316, 65316], "mapped", [100]], [[65317, 65317], "mapped", [101]], [[65318, 65318], "mapped", [102]], [[65319, 65319], "mapped", [103]], [[65320, 65320], "mapped", [104]], [[65321, 65321], "mapped", [105]], [[65322, 65322], "mapped", [106]], [[65323, 65323], "mapped", [107]], [[65324, 65324], "mapped", [108]], [[65325, 65325], "mapped", [109]], [[65326, 65326], "mapped", [110]], [[65327, 65327], "mapped", [111]], [[65328, 65328], "mapped", [112]], [[65329, 65329], "mapped", [113]], [[65330, 65330], "mapped", [114]], [[65331, 65331], "mapped", [115]], [[65332, 65332], "mapped", [116]], [[65333, 65333], "mapped", [117]], [[65334, 65334], "mapped", [118]], [[65335, 65335], "mapped", [119]], [[65336, 65336], "mapped", [120]], [[65337, 65337], "mapped", [121]], [[65338, 65338], "mapped", [122]], [[65339, 65339], "disallowed_STD3_mapped", [91]], [[65340, 65340], "disallowed_STD3_mapped", [92]], [[65341, 65341], "disallowed_STD3_mapped", [93]], [[65342, 65342], "disallowed_STD3_mapped", [94]], [[65343, 65343], "disallowed_STD3_mapped", [95]], [[65344, 65344], "disallowed_STD3_mapped", [96]], [[65345, 65345], "mapped", [97]], [[65346, 65346], "mapped", [98]], [[65347, 65347], "mapped", [99]], [[65348, 65348], "mapped", [100]], [[65349, 65349], "mapped", [101]], [[65350, 65350], "mapped", [102]], [[65351, 65351], "mapped", [103]], [[65352, 65352], "mapped", [104]], [[65353, 65353], "mapped", [105]], [[65354, 65354], "mapped", [106]], [[65355, 65355], "mapped", [107]], [[65356, 65356], "mapped", [108]], [[65357, 65357], "mapped", [109]], [[65358, 65358], "mapped", [110]], [[65359, 65359], "mapped", [111]], [[65360, 65360], "mapped", [112]], [[65361, 65361], "mapped", [113]], [[65362, 65362], "mapped", [114]], [[65363, 65363], "mapped", [115]], [[65364, 65364], "mapped", [116]], [[65365, 65365], "mapped", [117]], [[65366, 65366], "mapped", [118]], [[65367, 65367], "mapped", [119]], [[65368, 65368], "mapped", [120]], [[65369, 65369], "mapped", [121]], [[65370, 65370], "mapped", [122]], [[65371, 65371], "disallowed_STD3_mapped", [123]], [[65372, 65372], "disallowed_STD3_mapped", [124]], [[65373, 65373], "disallowed_STD3_mapped", [125]], [[65374, 65374], "disallowed_STD3_mapped", [126]], [[65375, 65375], "mapped", [10629]], [[65376, 65376], "mapped", [10630]], [[65377, 65377], "mapped", [46]], [[65378, 65378], "mapped", [12300]], [[65379, 65379], "mapped", [12301]], [[65380, 65380], "mapped", [12289]], [[65381, 65381], "mapped", [12539]], [[65382, 65382], "mapped", [12530]], [[65383, 65383], "mapped", [12449]], [[65384, 65384], "mapped", [12451]], [[65385, 65385], "mapped", [12453]], [[65386, 65386], "mapped", [12455]], [[65387, 65387], "mapped", [12457]], [[65388, 65388], "mapped", [12515]], [[65389, 65389], "mapped", [12517]], [[65390, 65390], "mapped", [12519]], [[65391, 65391], "mapped", [12483]], [[65392, 65392], "mapped", [12540]], [[65393, 65393], "mapped", [12450]], [[65394, 65394], "mapped", [12452]], [[65395, 65395], "mapped", [12454]], [[65396, 65396], "mapped", [12456]], [[65397, 65397], "mapped", [12458]], [[65398, 65398], "mapped", [12459]], [[65399, 65399], "mapped", [12461]], [[65400, 65400], "mapped", [12463]], [[65401, 65401], "mapped", [12465]], [[65402, 65402], "mapped", [12467]], [[65403, 65403], "mapped", [12469]], [[65404, 65404], "mapped", [12471]], [[65405, 65405], "mapped", [12473]], [[65406, 65406], "mapped", [12475]], [[65407, 65407], "mapped", [12477]], [[65408, 65408], "mapped", [12479]], [[65409, 65409], "mapped", [12481]], [[65410, 65410], "mapped", [12484]], [[65411, 65411], "mapped", [12486]], [[65412, 65412], "mapped", [12488]], [[65413, 65413], "mapped", [12490]], [[65414, 65414], "mapped", [12491]], [[65415, 65415], "mapped", [12492]], [[65416, 65416], "mapped", [12493]], [[65417, 65417], "mapped", [12494]], [[65418, 65418], "mapped", [12495]], [[65419, 65419], "mapped", [12498]], [[65420, 65420], "mapped", [12501]], [[65421, 65421], "mapped", [12504]], [[65422, 65422], "mapped", [12507]], [[65423, 65423], "mapped", [12510]], [[65424, 65424], "mapped", [12511]], [[65425, 65425], "mapped", [12512]], [[65426, 65426], "mapped", [12513]], [[65427, 65427], "mapped", [12514]], [[65428, 65428], "mapped", [12516]], [[65429, 65429], "mapped", [12518]], [[65430, 65430], "mapped", [12520]], [[65431, 65431], "mapped", [12521]], [[65432, 65432], "mapped", [12522]], [[65433, 65433], "mapped", [12523]], [[65434, 65434], "mapped", [12524]], [[65435, 65435], "mapped", [12525]], [[65436, 65436], "mapped", [12527]], [[65437, 65437], "mapped", [12531]], [[65438, 65438], "mapped", [12441]], [[65439, 65439], "mapped", [12442]], [[65440, 65440], "disallowed"], [[65441, 65441], "mapped", [4352]], [[65442, 65442], "mapped", [4353]], [[65443, 65443], "mapped", [4522]], [[65444, 65444], "mapped", [4354]], [[65445, 65445], "mapped", [4524]], [[65446, 65446], "mapped", [4525]], [[65447, 65447], "mapped", [4355]], [[65448, 65448], "mapped", [4356]], [[65449, 65449], "mapped", [4357]], [[65450, 65450], "mapped", [4528]], [[65451, 65451], "mapped", [4529]], [[65452, 65452], "mapped", [4530]], [[65453, 65453], "mapped", [4531]], [[65454, 65454], "mapped", [4532]], [[65455, 65455], "mapped", [4533]], [[65456, 65456], "mapped", [4378]], [[65457, 65457], "mapped", [4358]], [[65458, 65458], "mapped", [4359]], [[65459, 65459], "mapped", [4360]], [[65460, 65460], "mapped", [4385]], [[65461, 65461], "mapped", [4361]], [[65462, 65462], "mapped", [4362]], [[65463, 65463], "mapped", [4363]], [[65464, 65464], "mapped", [4364]], [[65465, 65465], "mapped", [4365]], [[65466, 65466], "mapped", [4366]], [[65467, 65467], "mapped", [4367]], [[65468, 65468], "mapped", [4368]], [[65469, 65469], "mapped", [4369]], [[65470, 65470], "mapped", [4370]], [[65471, 65473], "disallowed"], [[65474, 65474], "mapped", [4449]], [[65475, 65475], "mapped", [4450]], [[65476, 65476], "mapped", [4451]], [[65477, 65477], "mapped", [4452]], [[65478, 65478], "mapped", [4453]], [[65479, 65479], "mapped", [4454]], [[65480, 65481], "disallowed"], [[65482, 65482], "mapped", [4455]], [[65483, 65483], "mapped", [4456]], [[65484, 65484], "mapped", [4457]], [[65485, 65485], "mapped", [4458]], [[65486, 65486], "mapped", [4459]], [[65487, 65487], "mapped", [4460]], [[65488, 65489], "disallowed"], [[65490, 65490], "mapped", [4461]], [[65491, 65491], "mapped", [4462]], [[65492, 65492], "mapped", [4463]], [[65493, 65493], "mapped", [4464]], [[65494, 65494], "mapped", [4465]], [[65495, 65495], "mapped", [4466]], [[65496, 65497], "disallowed"], [[65498, 65498], "mapped", [4467]], [[65499, 65499], "mapped", [4468]], [[65500, 65500], "mapped", [4469]], [[65501, 65503], "disallowed"], [[65504, 65504], "mapped", [162]], [[65505, 65505], "mapped", [163]], [[65506, 65506], "mapped", [172]], [[65507, 65507], "disallowed_STD3_mapped", [32, 772]], [[65508, 65508], "mapped", [166]], [[65509, 65509], "mapped", [165]], [[65510, 65510], "mapped", [8361]], [[65511, 65511], "disallowed"], [[65512, 65512], "mapped", [9474]], [[65513, 65513], "mapped", [8592]], [[65514, 65514], "mapped", [8593]], [[65515, 65515], "mapped", [8594]], [[65516, 65516], "mapped", [8595]], [[65517, 65517], "mapped", [9632]], [[65518, 65518], "mapped", [9675]], [[65519, 65528], "disallowed"], [[65529, 65531], "disallowed"], [[65532, 65532], "disallowed"], [[65533, 65533], "disallowed"], [[65534, 65535], "disallowed"], [[65536, 65547], "valid"], [[65548, 65548], "disallowed"], [[65549, 65574], "valid"], [[65575, 65575], "disallowed"], [[65576, 65594], "valid"], [[65595, 65595], "disallowed"], [[65596, 65597], "valid"], [[65598, 65598], "disallowed"], [[65599, 65613], "valid"], [[65614, 65615], "disallowed"], [[65616, 65629], "valid"], [[65630, 65663], "disallowed"], [[65664, 65786], "valid"], [[65787, 65791], "disallowed"], [[65792, 65794], "valid", [], "NV8"], [[65795, 65798], "disallowed"], [[65799, 65843], "valid", [], "NV8"], [[65844, 65846], "disallowed"], [[65847, 65855], "valid", [], "NV8"], [[65856, 65930], "valid", [], "NV8"], [[65931, 65932], "valid", [], "NV8"], [[65933, 65935], "disallowed"], [[65936, 65947], "valid", [], "NV8"], [[65948, 65951], "disallowed"], [[65952, 65952], "valid", [], "NV8"], [[65953, 65999], "disallowed"], [[66e3, 66044], "valid", [], "NV8"], [[66045, 66045], "valid"], [[66046, 66175], "disallowed"], [[66176, 66204], "valid"], [[66205, 66207], "disallowed"], [[66208, 66256], "valid"], [[66257, 66271], "disallowed"], [[66272, 66272], "valid"], [[66273, 66299], "valid", [], "NV8"], [[66300, 66303], "disallowed"], [[66304, 66334], "valid"], [[66335, 66335], "valid"], [[66336, 66339], "valid", [], "NV8"], [[66340, 66351], "disallowed"], [[66352, 66368], "valid"], [[66369, 66369], "valid", [], "NV8"], [[66370, 66377], "valid"], [[66378, 66378], "valid", [], "NV8"], [[66379, 66383], "disallowed"], [[66384, 66426], "valid"], [[66427, 66431], "disallowed"], [[66432, 66461], "valid"], [[66462, 66462], "disallowed"], [[66463, 66463], "valid", [], "NV8"], [[66464, 66499], "valid"], [[66500, 66503], "disallowed"], [[66504, 66511], "valid"], [[66512, 66517], "valid", [], "NV8"], [[66518, 66559], "disallowed"], [[66560, 66560], "mapped", [66600]], [[66561, 66561], "mapped", [66601]], [[66562, 66562], "mapped", [66602]], [[66563, 66563], "mapped", [66603]], [[66564, 66564], "mapped", [66604]], [[66565, 66565], "mapped", [66605]], [[66566, 66566], "mapped", [66606]], [[66567, 66567], "mapped", [66607]], [[66568, 66568], "mapped", [66608]], [[66569, 66569], "mapped", [66609]], [[66570, 66570], "mapped", [66610]], [[66571, 66571], "mapped", [66611]], [[66572, 66572], "mapped", [66612]], [[66573, 66573], "mapped", [66613]], [[66574, 66574], "mapped", [66614]], [[66575, 66575], "mapped", [66615]], [[66576, 66576], "mapped", [66616]], [[66577, 66577], "mapped", [66617]], [[66578, 66578], "mapped", [66618]], [[66579, 66579], "mapped", [66619]], [[66580, 66580], "mapped", [66620]], [[66581, 66581], "mapped", [66621]], [[66582, 66582], "mapped", [66622]], [[66583, 66583], "mapped", [66623]], [[66584, 66584], "mapped", [66624]], [[66585, 66585], "mapped", [66625]], [[66586, 66586], "mapped", [66626]], [[66587, 66587], "mapped", [66627]], [[66588, 66588], "mapped", [66628]], [[66589, 66589], "mapped", [66629]], [[66590, 66590], "mapped", [66630]], [[66591, 66591], "mapped", [66631]], [[66592, 66592], "mapped", [66632]], [[66593, 66593], "mapped", [66633]], [[66594, 66594], "mapped", [66634]], [[66595, 66595], "mapped", [66635]], [[66596, 66596], "mapped", [66636]], [[66597, 66597], "mapped", [66637]], [[66598, 66598], "mapped", [66638]], [[66599, 66599], "mapped", [66639]], [[66600, 66637], "valid"], [[66638, 66717], "valid"], [[66718, 66719], "disallowed"], [[66720, 66729], "valid"], [[66730, 66815], "disallowed"], [[66816, 66855], "valid"], [[66856, 66863], "disallowed"], [[66864, 66915], "valid"], [[66916, 66926], "disallowed"], [[66927, 66927], "valid", [], "NV8"], [[66928, 67071], "disallowed"], [[67072, 67382], "valid"], [[67383, 67391], "disallowed"], [[67392, 67413], "valid"], [[67414, 67423], "disallowed"], [[67424, 67431], "valid"], [[67432, 67583], "disallowed"], [[67584, 67589], "valid"], [[67590, 67591], "disallowed"], [[67592, 67592], "valid"], [[67593, 67593], "disallowed"], [[67594, 67637], "valid"], [[67638, 67638], "disallowed"], [[67639, 67640], "valid"], [[67641, 67643], "disallowed"], [[67644, 67644], "valid"], [[67645, 67646], "disallowed"], [[67647, 67647], "valid"], [[67648, 67669], "valid"], [[67670, 67670], "disallowed"], [[67671, 67679], "valid", [], "NV8"], [[67680, 67702], "valid"], [[67703, 67711], "valid", [], "NV8"], [[67712, 67742], "valid"], [[67743, 67750], "disallowed"], [[67751, 67759], "valid", [], "NV8"], [[67760, 67807], "disallowed"], [[67808, 67826], "valid"], [[67827, 67827], "disallowed"], [[67828, 67829], "valid"], [[67830, 67834], "disallowed"], [[67835, 67839], "valid", [], "NV8"], [[67840, 67861], "valid"], [[67862, 67865], "valid", [], "NV8"], [[67866, 67867], "valid", [], "NV8"], [[67868, 67870], "disallowed"], [[67871, 67871], "valid", [], "NV8"], [[67872, 67897], "valid"], [[67898, 67902], "disallowed"], [[67903, 67903], "valid", [], "NV8"], [[67904, 67967], "disallowed"], [[67968, 68023], "valid"], [[68024, 68027], "disallowed"], [[68028, 68029], "valid", [], "NV8"], [[68030, 68031], "valid"], [[68032, 68047], "valid", [], "NV8"], [[68048, 68049], "disallowed"], [[68050, 68095], "valid", [], "NV8"], [[68096, 68099], "valid"], [[68100, 68100], "disallowed"], [[68101, 68102], "valid"], [[68103, 68107], "disallowed"], [[68108, 68115], "valid"], [[68116, 68116], "disallowed"], [[68117, 68119], "valid"], [[68120, 68120], "disallowed"], [[68121, 68147], "valid"], [[68148, 68151], "disallowed"], [[68152, 68154], "valid"], [[68155, 68158], "disallowed"], [[68159, 68159], "valid"], [[68160, 68167], "valid", [], "NV8"], [[68168, 68175], "disallowed"], [[68176, 68184], "valid", [], "NV8"], [[68185, 68191], "disallowed"], [[68192, 68220], "valid"], [[68221, 68223], "valid", [], "NV8"], [[68224, 68252], "valid"], [[68253, 68255], "valid", [], "NV8"], [[68256, 68287], "disallowed"], [[68288, 68295], "valid"], [[68296, 68296], "valid", [], "NV8"], [[68297, 68326], "valid"], [[68327, 68330], "disallowed"], [[68331, 68342], "valid", [], "NV8"], [[68343, 68351], "disallowed"], [[68352, 68405], "valid"], [[68406, 68408], "disallowed"], [[68409, 68415], "valid", [], "NV8"], [[68416, 68437], "valid"], [[68438, 68439], "disallowed"], [[68440, 68447], "valid", [], "NV8"], [[68448, 68466], "valid"], [[68467, 68471], "disallowed"], [[68472, 68479], "valid", [], "NV8"], [[68480, 68497], "valid"], [[68498, 68504], "disallowed"], [[68505, 68508], "valid", [], "NV8"], [[68509, 68520], "disallowed"], [[68521, 68527], "valid", [], "NV8"], [[68528, 68607], "disallowed"], [[68608, 68680], "valid"], [[68681, 68735], "disallowed"], [[68736, 68736], "mapped", [68800]], [[68737, 68737], "mapped", [68801]], [[68738, 68738], "mapped", [68802]], [[68739, 68739], "mapped", [68803]], [[68740, 68740], "mapped", [68804]], [[68741, 68741], "mapped", [68805]], [[68742, 68742], "mapped", [68806]], [[68743, 68743], "mapped", [68807]], [[68744, 68744], "mapped", [68808]], [[68745, 68745], "mapped", [68809]], [[68746, 68746], "mapped", [68810]], [[68747, 68747], "mapped", [68811]], [[68748, 68748], "mapped", [68812]], [[68749, 68749], "mapped", [68813]], [[68750, 68750], "mapped", [68814]], [[68751, 68751], "mapped", [68815]], [[68752, 68752], "mapped", [68816]], [[68753, 68753], "mapped", [68817]], [[68754, 68754], "mapped", [68818]], [[68755, 68755], "mapped", [68819]], [[68756, 68756], "mapped", [68820]], [[68757, 68757], "mapped", [68821]], [[68758, 68758], "mapped", [68822]], [[68759, 68759], "mapped", [68823]], [[68760, 68760], "mapped", [68824]], [[68761, 68761], "mapped", [68825]], [[68762, 68762], "mapped", [68826]], [[68763, 68763], "mapped", [68827]], [[68764, 68764], "mapped", [68828]], [[68765, 68765], "mapped", [68829]], [[68766, 68766], "mapped", [68830]], [[68767, 68767], "mapped", [68831]], [[68768, 68768], "mapped", [68832]], [[68769, 68769], "mapped", [68833]], [[68770, 68770], "mapped", [68834]], [[68771, 68771], "mapped", [68835]], [[68772, 68772], "mapped", [68836]], [[68773, 68773], "mapped", [68837]], [[68774, 68774], "mapped", [68838]], [[68775, 68775], "mapped", [68839]], [[68776, 68776], "mapped", [68840]], [[68777, 68777], "mapped", [68841]], [[68778, 68778], "mapped", [68842]], [[68779, 68779], "mapped", [68843]], [[68780, 68780], "mapped", [68844]], [[68781, 68781], "mapped", [68845]], [[68782, 68782], "mapped", [68846]], [[68783, 68783], "mapped", [68847]], [[68784, 68784], "mapped", [68848]], [[68785, 68785], "mapped", [68849]], [[68786, 68786], "mapped", [68850]], [[68787, 68799], "disallowed"], [[68800, 68850], "valid"], [[68851, 68857], "disallowed"], [[68858, 68863], "valid", [], "NV8"], [[68864, 69215], "disallowed"], [[69216, 69246], "valid", [], "NV8"], [[69247, 69631], "disallowed"], [[69632, 69702], "valid"], [[69703, 69709], "valid", [], "NV8"], [[69710, 69713], "disallowed"], [[69714, 69733], "valid", [], "NV8"], [[69734, 69743], "valid"], [[69744, 69758], "disallowed"], [[69759, 69759], "valid"], [[69760, 69818], "valid"], [[69819, 69820], "valid", [], "NV8"], [[69821, 69821], "disallowed"], [[69822, 69825], "valid", [], "NV8"], [[69826, 69839], "disallowed"], [[69840, 69864], "valid"], [[69865, 69871], "disallowed"], [[69872, 69881], "valid"], [[69882, 69887], "disallowed"], [[69888, 69940], "valid"], [[69941, 69941], "disallowed"], [[69942, 69951], "valid"], [[69952, 69955], "valid", [], "NV8"], [[69956, 69967], "disallowed"], [[69968, 70003], "valid"], [[70004, 70005], "valid", [], "NV8"], [[70006, 70006], "valid"], [[70007, 70015], "disallowed"], [[70016, 70084], "valid"], [[70085, 70088], "valid", [], "NV8"], [[70089, 70089], "valid", [], "NV8"], [[70090, 70092], "valid"], [[70093, 70093], "valid", [], "NV8"], [[70094, 70095], "disallowed"], [[70096, 70105], "valid"], [[70106, 70106], "valid"], [[70107, 70107], "valid", [], "NV8"], [[70108, 70108], "valid"], [[70109, 70111], "valid", [], "NV8"], [[70112, 70112], "disallowed"], [[70113, 70132], "valid", [], "NV8"], [[70133, 70143], "disallowed"], [[70144, 70161], "valid"], [[70162, 70162], "disallowed"], [[70163, 70199], "valid"], [[70200, 70205], "valid", [], "NV8"], [[70206, 70271], "disallowed"], [[70272, 70278], "valid"], [[70279, 70279], "disallowed"], [[70280, 70280], "valid"], [[70281, 70281], "disallowed"], [[70282, 70285], "valid"], [[70286, 70286], "disallowed"], [[70287, 70301], "valid"], [[70302, 70302], "disallowed"], [[70303, 70312], "valid"], [[70313, 70313], "valid", [], "NV8"], [[70314, 70319], "disallowed"], [[70320, 70378], "valid"], [[70379, 70383], "disallowed"], [[70384, 70393], "valid"], [[70394, 70399], "disallowed"], [[70400, 70400], "valid"], [[70401, 70403], "valid"], [[70404, 70404], "disallowed"], [[70405, 70412], "valid"], [[70413, 70414], "disallowed"], [[70415, 70416], "valid"], [[70417, 70418], "disallowed"], [[70419, 70440], "valid"], [[70441, 70441], "disallowed"], [[70442, 70448], "valid"], [[70449, 70449], "disallowed"], [[70450, 70451], "valid"], [[70452, 70452], "disallowed"], [[70453, 70457], "valid"], [[70458, 70459], "disallowed"], [[70460, 70468], "valid"], [[70469, 70470], "disallowed"], [[70471, 70472], "valid"], [[70473, 70474], "disallowed"], [[70475, 70477], "valid"], [[70478, 70479], "disallowed"], [[70480, 70480], "valid"], [[70481, 70486], "disallowed"], [[70487, 70487], "valid"], [[70488, 70492], "disallowed"], [[70493, 70499], "valid"], [[70500, 70501], "disallowed"], [[70502, 70508], "valid"], [[70509, 70511], "disallowed"], [[70512, 70516], "valid"], [[70517, 70783], "disallowed"], [[70784, 70853], "valid"], [[70854, 70854], "valid", [], "NV8"], [[70855, 70855], "valid"], [[70856, 70863], "disallowed"], [[70864, 70873], "valid"], [[70874, 71039], "disallowed"], [[71040, 71093], "valid"], [[71094, 71095], "disallowed"], [[71096, 71104], "valid"], [[71105, 71113], "valid", [], "NV8"], [[71114, 71127], "valid", [], "NV8"], [[71128, 71133], "valid"], [[71134, 71167], "disallowed"], [[71168, 71232], "valid"], [[71233, 71235], "valid", [], "NV8"], [[71236, 71236], "valid"], [[71237, 71247], "disallowed"], [[71248, 71257], "valid"], [[71258, 71295], "disallowed"], [[71296, 71351], "valid"], [[71352, 71359], "disallowed"], [[71360, 71369], "valid"], [[71370, 71423], "disallowed"], [[71424, 71449], "valid"], [[71450, 71452], "disallowed"], [[71453, 71467], "valid"], [[71468, 71471], "disallowed"], [[71472, 71481], "valid"], [[71482, 71487], "valid", [], "NV8"], [[71488, 71839], "disallowed"], [[71840, 71840], "mapped", [71872]], [[71841, 71841], "mapped", [71873]], [[71842, 71842], "mapped", [71874]], [[71843, 71843], "mapped", [71875]], [[71844, 71844], "mapped", [71876]], [[71845, 71845], "mapped", [71877]], [[71846, 71846], "mapped", [71878]], [[71847, 71847], "mapped", [71879]], [[71848, 71848], "mapped", [71880]], [[71849, 71849], "mapped", [71881]], [[71850, 71850], "mapped", [71882]], [[71851, 71851], "mapped", [71883]], [[71852, 71852], "mapped", [71884]], [[71853, 71853], "mapped", [71885]], [[71854, 71854], "mapped", [71886]], [[71855, 71855], "mapped", [71887]], [[71856, 71856], "mapped", [71888]], [[71857, 71857], "mapped", [71889]], [[71858, 71858], "mapped", [71890]], [[71859, 71859], "mapped", [71891]], [[71860, 71860], "mapped", [71892]], [[71861, 71861], "mapped", [71893]], [[71862, 71862], "mapped", [71894]], [[71863, 71863], "mapped", [71895]], [[71864, 71864], "mapped", [71896]], [[71865, 71865], "mapped", [71897]], [[71866, 71866], "mapped", [71898]], [[71867, 71867], "mapped", [71899]], [[71868, 71868], "mapped", [71900]], [[71869, 71869], "mapped", [71901]], [[71870, 71870], "mapped", [71902]], [[71871, 71871], "mapped", [71903]], [[71872, 71913], "valid"], [[71914, 71922], "valid", [], "NV8"], [[71923, 71934], "disallowed"], [[71935, 71935], "valid"], [[71936, 72383], "disallowed"], [[72384, 72440], "valid"], [[72441, 73727], "disallowed"], [[73728, 74606], "valid"], [[74607, 74648], "valid"], [[74649, 74649], "valid"], [[74650, 74751], "disallowed"], [[74752, 74850], "valid", [], "NV8"], [[74851, 74862], "valid", [], "NV8"], [[74863, 74863], "disallowed"], [[74864, 74867], "valid", [], "NV8"], [[74868, 74868], "valid", [], "NV8"], [[74869, 74879], "disallowed"], [[74880, 75075], "valid"], [[75076, 77823], "disallowed"], [[77824, 78894], "valid"], [[78895, 82943], "disallowed"], [[82944, 83526], "valid"], [[83527, 92159], "disallowed"], [[92160, 92728], "valid"], [[92729, 92735], "disallowed"], [[92736, 92766], "valid"], [[92767, 92767], "disallowed"], [[92768, 92777], "valid"], [[92778, 92781], "disallowed"], [[92782, 92783], "valid", [], "NV8"], [[92784, 92879], "disallowed"], [[92880, 92909], "valid"], [[92910, 92911], "disallowed"], [[92912, 92916], "valid"], [[92917, 92917], "valid", [], "NV8"], [[92918, 92927], "disallowed"], [[92928, 92982], "valid"], [[92983, 92991], "valid", [], "NV8"], [[92992, 92995], "valid"], [[92996, 92997], "valid", [], "NV8"], [[92998, 93007], "disallowed"], [[93008, 93017], "valid"], [[93018, 93018], "disallowed"], [[93019, 93025], "valid", [], "NV8"], [[93026, 93026], "disallowed"], [[93027, 93047], "valid"], [[93048, 93052], "disallowed"], [[93053, 93071], "valid"], [[93072, 93951], "disallowed"], [[93952, 94020], "valid"], [[94021, 94031], "disallowed"], [[94032, 94078], "valid"], [[94079, 94094], "disallowed"], [[94095, 94111], "valid"], [[94112, 110591], "disallowed"], [[110592, 110593], "valid"], [[110594, 113663], "disallowed"], [[113664, 113770], "valid"], [[113771, 113775], "disallowed"], [[113776, 113788], "valid"], [[113789, 113791], "disallowed"], [[113792, 113800], "valid"], [[113801, 113807], "disallowed"], [[113808, 113817], "valid"], [[113818, 113819], "disallowed"], [[113820, 113820], "valid", [], "NV8"], [[113821, 113822], "valid"], [[113823, 113823], "valid", [], "NV8"], [[113824, 113827], "ignored"], [[113828, 118783], "disallowed"], [[118784, 119029], "valid", [], "NV8"], [[119030, 119039], "disallowed"], [[119040, 119078], "valid", [], "NV8"], [[119079, 119080], "disallowed"], [[119081, 119081], "valid", [], "NV8"], [[119082, 119133], "valid", [], "NV8"], [[119134, 119134], "mapped", [119127, 119141]], [[119135, 119135], "mapped", [119128, 119141]], [[119136, 119136], "mapped", [119128, 119141, 119150]], [[119137, 119137], "mapped", [119128, 119141, 119151]], [[119138, 119138], "mapped", [119128, 119141, 119152]], [[119139, 119139], "mapped", [119128, 119141, 119153]], [[119140, 119140], "mapped", [119128, 119141, 119154]], [[119141, 119154], "valid", [], "NV8"], [[119155, 119162], "disallowed"], [[119163, 119226], "valid", [], "NV8"], [[119227, 119227], "mapped", [119225, 119141]], [[119228, 119228], "mapped", [119226, 119141]], [[119229, 119229], "mapped", [119225, 119141, 119150]], [[119230, 119230], "mapped", [119226, 119141, 119150]], [[119231, 119231], "mapped", [119225, 119141, 119151]], [[119232, 119232], "mapped", [119226, 119141, 119151]], [[119233, 119261], "valid", [], "NV8"], [[119262, 119272], "valid", [], "NV8"], [[119273, 119295], "disallowed"], [[119296, 119365], "valid", [], "NV8"], [[119366, 119551], "disallowed"], [[119552, 119638], "valid", [], "NV8"], [[119639, 119647], "disallowed"], [[119648, 119665], "valid", [], "NV8"], [[119666, 119807], "disallowed"], [[119808, 119808], "mapped", [97]], [[119809, 119809], "mapped", [98]], [[119810, 119810], "mapped", [99]], [[119811, 119811], "mapped", [100]], [[119812, 119812], "mapped", [101]], [[119813, 119813], "mapped", [102]], [[119814, 119814], "mapped", [103]], [[119815, 119815], "mapped", [104]], [[119816, 119816], "mapped", [105]], [[119817, 119817], "mapped", [106]], [[119818, 119818], "mapped", [107]], [[119819, 119819], "mapped", [108]], [[119820, 119820], "mapped", [109]], [[119821, 119821], "mapped", [110]], [[119822, 119822], "mapped", [111]], [[119823, 119823], "mapped", [112]], [[119824, 119824], "mapped", [113]], [[119825, 119825], "mapped", [114]], [[119826, 119826], "mapped", [115]], [[119827, 119827], "mapped", [116]], [[119828, 119828], "mapped", [117]], [[119829, 119829], "mapped", [118]], [[119830, 119830], "mapped", [119]], [[119831, 119831], "mapped", [120]], [[119832, 119832], "mapped", [121]], [[119833, 119833], "mapped", [122]], [[119834, 119834], "mapped", [97]], [[119835, 119835], "mapped", [98]], [[119836, 119836], "mapped", [99]], [[119837, 119837], "mapped", [100]], [[119838, 119838], "mapped", [101]], [[119839, 119839], "mapped", [102]], [[119840, 119840], "mapped", [103]], [[119841, 119841], "mapped", [104]], [[119842, 119842], "mapped", [105]], [[119843, 119843], "mapped", [106]], [[119844, 119844], "mapped", [107]], [[119845, 119845], "mapped", [108]], [[119846, 119846], "mapped", [109]], [[119847, 119847], "mapped", [110]], [[119848, 119848], "mapped", [111]], [[119849, 119849], "mapped", [112]], [[119850, 119850], "mapped", [113]], [[119851, 119851], "mapped", [114]], [[119852, 119852], "mapped", [115]], [[119853, 119853], "mapped", [116]], [[119854, 119854], "mapped", [117]], [[119855, 119855], "mapped", [118]], [[119856, 119856], "mapped", [119]], [[119857, 119857], "mapped", [120]], [[119858, 119858], "mapped", [121]], [[119859, 119859], "mapped", [122]], [[119860, 119860], "mapped", [97]], [[119861, 119861], "mapped", [98]], [[119862, 119862], "mapped", [99]], [[119863, 119863], "mapped", [100]], [[119864, 119864], "mapped", [101]], [[119865, 119865], "mapped", [102]], [[119866, 119866], "mapped", [103]], [[119867, 119867], "mapped", [104]], [[119868, 119868], "mapped", [105]], [[119869, 119869], "mapped", [106]], [[119870, 119870], "mapped", [107]], [[119871, 119871], "mapped", [108]], [[119872, 119872], "mapped", [109]], [[119873, 119873], "mapped", [110]], [[119874, 119874], "mapped", [111]], [[119875, 119875], "mapped", [112]], [[119876, 119876], "mapped", [113]], [[119877, 119877], "mapped", [114]], [[119878, 119878], "mapped", [115]], [[119879, 119879], "mapped", [116]], [[119880, 119880], "mapped", [117]], [[119881, 119881], "mapped", [118]], [[119882, 119882], "mapped", [119]], [[119883, 119883], "mapped", [120]], [[119884, 119884], "mapped", [121]], [[119885, 119885], "mapped", [122]], [[119886, 119886], "mapped", [97]], [[119887, 119887], "mapped", [98]], [[119888, 119888], "mapped", [99]], [[119889, 119889], "mapped", [100]], [[119890, 119890], "mapped", [101]], [[119891, 119891], "mapped", [102]], [[119892, 119892], "mapped", [103]], [[119893, 119893], "disallowed"], [[119894, 119894], "mapped", [105]], [[119895, 119895], "mapped", [106]], [[119896, 119896], "mapped", [107]], [[119897, 119897], "mapped", [108]], [[119898, 119898], "mapped", [109]], [[119899, 119899], "mapped", [110]], [[119900, 119900], "mapped", [111]], [[119901, 119901], "mapped", [112]], [[119902, 119902], "mapped", [113]], [[119903, 119903], "mapped", [114]], [[119904, 119904], "mapped", [115]], [[119905, 119905], "mapped", [116]], [[119906, 119906], "mapped", [117]], [[119907, 119907], "mapped", [118]], [[119908, 119908], "mapped", [119]], [[119909, 119909], "mapped", [120]], [[119910, 119910], "mapped", [121]], [[119911, 119911], "mapped", [122]], [[119912, 119912], "mapped", [97]], [[119913, 119913], "mapped", [98]], [[119914, 119914], "mapped", [99]], [[119915, 119915], "mapped", [100]], [[119916, 119916], "mapped", [101]], [[119917, 119917], "mapped", [102]], [[119918, 119918], "mapped", [103]], [[119919, 119919], "mapped", [104]], [[119920, 119920], "mapped", [105]], [[119921, 119921], "mapped", [106]], [[119922, 119922], "mapped", [107]], [[119923, 119923], "mapped", [108]], [[119924, 119924], "mapped", [109]], [[119925, 119925], "mapped", [110]], [[119926, 119926], "mapped", [111]], [[119927, 119927], "mapped", [112]], [[119928, 119928], "mapped", [113]], [[119929, 119929], "mapped", [114]], [[119930, 119930], "mapped", [115]], [[119931, 119931], "mapped", [116]], [[119932, 119932], "mapped", [117]], [[119933, 119933], "mapped", [118]], [[119934, 119934], "mapped", [119]], [[119935, 119935], "mapped", [120]], [[119936, 119936], "mapped", [121]], [[119937, 119937], "mapped", [122]], [[119938, 119938], "mapped", [97]], [[119939, 119939], "mapped", [98]], [[119940, 119940], "mapped", [99]], [[119941, 119941], "mapped", [100]], [[119942, 119942], "mapped", [101]], [[119943, 119943], "mapped", [102]], [[119944, 119944], "mapped", [103]], [[119945, 119945], "mapped", [104]], [[119946, 119946], "mapped", [105]], [[119947, 119947], "mapped", [106]], [[119948, 119948], "mapped", [107]], [[119949, 119949], "mapped", [108]], [[119950, 119950], "mapped", [109]], [[119951, 119951], "mapped", [110]], [[119952, 119952], "mapped", [111]], [[119953, 119953], "mapped", [112]], [[119954, 119954], "mapped", [113]], [[119955, 119955], "mapped", [114]], [[119956, 119956], "mapped", [115]], [[119957, 119957], "mapped", [116]], [[119958, 119958], "mapped", [117]], [[119959, 119959], "mapped", [118]], [[119960, 119960], "mapped", [119]], [[119961, 119961], "mapped", [120]], [[119962, 119962], "mapped", [121]], [[119963, 119963], "mapped", [122]], [[119964, 119964], "mapped", [97]], [[119965, 119965], "disallowed"], [[119966, 119966], "mapped", [99]], [[119967, 119967], "mapped", [100]], [[119968, 119969], "disallowed"], [[119970, 119970], "mapped", [103]], [[119971, 119972], "disallowed"], [[119973, 119973], "mapped", [106]], [[119974, 119974], "mapped", [107]], [[119975, 119976], "disallowed"], [[119977, 119977], "mapped", [110]], [[119978, 119978], "mapped", [111]], [[119979, 119979], "mapped", [112]], [[119980, 119980], "mapped", [113]], [[119981, 119981], "disallowed"], [[119982, 119982], "mapped", [115]], [[119983, 119983], "mapped", [116]], [[119984, 119984], "mapped", [117]], [[119985, 119985], "mapped", [118]], [[119986, 119986], "mapped", [119]], [[119987, 119987], "mapped", [120]], [[119988, 119988], "mapped", [121]], [[119989, 119989], "mapped", [122]], [[119990, 119990], "mapped", [97]], [[119991, 119991], "mapped", [98]], [[119992, 119992], "mapped", [99]], [[119993, 119993], "mapped", [100]], [[119994, 119994], "disallowed"], [[119995, 119995], "mapped", [102]], [[119996, 119996], "disallowed"], [[119997, 119997], "mapped", [104]], [[119998, 119998], "mapped", [105]], [[119999, 119999], "mapped", [106]], [[12e4, 12e4], "mapped", [107]], [[120001, 120001], "mapped", [108]], [[120002, 120002], "mapped", [109]], [[120003, 120003], "mapped", [110]], [[120004, 120004], "disallowed"], [[120005, 120005], "mapped", [112]], [[120006, 120006], "mapped", [113]], [[120007, 120007], "mapped", [114]], [[120008, 120008], "mapped", [115]], [[120009, 120009], "mapped", [116]], [[120010, 120010], "mapped", [117]], [[120011, 120011], "mapped", [118]], [[120012, 120012], "mapped", [119]], [[120013, 120013], "mapped", [120]], [[120014, 120014], "mapped", [121]], [[120015, 120015], "mapped", [122]], [[120016, 120016], "mapped", [97]], [[120017, 120017], "mapped", [98]], [[120018, 120018], "mapped", [99]], [[120019, 120019], "mapped", [100]], [[120020, 120020], "mapped", [101]], [[120021, 120021], "mapped", [102]], [[120022, 120022], "mapped", [103]], [[120023, 120023], "mapped", [104]], [[120024, 120024], "mapped", [105]], [[120025, 120025], "mapped", [106]], [[120026, 120026], "mapped", [107]], [[120027, 120027], "mapped", [108]], [[120028, 120028], "mapped", [109]], [[120029, 120029], "mapped", [110]], [[120030, 120030], "mapped", [111]], [[120031, 120031], "mapped", [112]], [[120032, 120032], "mapped", [113]], [[120033, 120033], "mapped", [114]], [[120034, 120034], "mapped", [115]], [[120035, 120035], "mapped", [116]], [[120036, 120036], "mapped", [117]], [[120037, 120037], "mapped", [118]], [[120038, 120038], "mapped", [119]], [[120039, 120039], "mapped", [120]], [[120040, 120040], "mapped", [121]], [[120041, 120041], "mapped", [122]], [[120042, 120042], "mapped", [97]], [[120043, 120043], "mapped", [98]], [[120044, 120044], "mapped", [99]], [[120045, 120045], "mapped", [100]], [[120046, 120046], "mapped", [101]], [[120047, 120047], "mapped", [102]], [[120048, 120048], "mapped", [103]], [[120049, 120049], "mapped", [104]], [[120050, 120050], "mapped", [105]], [[120051, 120051], "mapped", [106]], [[120052, 120052], "mapped", [107]], [[120053, 120053], "mapped", [108]], [[120054, 120054], "mapped", [109]], [[120055, 120055], "mapped", [110]], [[120056, 120056], "mapped", [111]], [[120057, 120057], "mapped", [112]], [[120058, 120058], "mapped", [113]], [[120059, 120059], "mapped", [114]], [[120060, 120060], "mapped", [115]], [[120061, 120061], "mapped", [116]], [[120062, 120062], "mapped", [117]], [[120063, 120063], "mapped", [118]], [[120064, 120064], "mapped", [119]], [[120065, 120065], "mapped", [120]], [[120066, 120066], "mapped", [121]], [[120067, 120067], "mapped", [122]], [[120068, 120068], "mapped", [97]], [[120069, 120069], "mapped", [98]], [[120070, 120070], "disallowed"], [[120071, 120071], "mapped", [100]], [[120072, 120072], "mapped", [101]], [[120073, 120073], "mapped", [102]], [[120074, 120074], "mapped", [103]], [[120075, 120076], "disallowed"], [[120077, 120077], "mapped", [106]], [[120078, 120078], "mapped", [107]], [[120079, 120079], "mapped", [108]], [[120080, 120080], "mapped", [109]], [[120081, 120081], "mapped", [110]], [[120082, 120082], "mapped", [111]], [[120083, 120083], "mapped", [112]], [[120084, 120084], "mapped", [113]], [[120085, 120085], "disallowed"], [[120086, 120086], "mapped", [115]], [[120087, 120087], "mapped", [116]], [[120088, 120088], "mapped", [117]], [[120089, 120089], "mapped", [118]], [[120090, 120090], "mapped", [119]], [[120091, 120091], "mapped", [120]], [[120092, 120092], "mapped", [121]], [[120093, 120093], "disallowed"], [[120094, 120094], "mapped", [97]], [[120095, 120095], "mapped", [98]], [[120096, 120096], "mapped", [99]], [[120097, 120097], "mapped", [100]], [[120098, 120098], "mapped", [101]], [[120099, 120099], "mapped", [102]], [[120100, 120100], "mapped", [103]], [[120101, 120101], "mapped", [104]], [[120102, 120102], "mapped", [105]], [[120103, 120103], "mapped", [106]], [[120104, 120104], "mapped", [107]], [[120105, 120105], "mapped", [108]], [[120106, 120106], "mapped", [109]], [[120107, 120107], "mapped", [110]], [[120108, 120108], "mapped", [111]], [[120109, 120109], "mapped", [112]], [[120110, 120110], "mapped", [113]], [[120111, 120111], "mapped", [114]], [[120112, 120112], "mapped", [115]], [[120113, 120113], "mapped", [116]], [[120114, 120114], "mapped", [117]], [[120115, 120115], "mapped", [118]], [[120116, 120116], "mapped", [119]], [[120117, 120117], "mapped", [120]], [[120118, 120118], "mapped", [121]], [[120119, 120119], "mapped", [122]], [[120120, 120120], "mapped", [97]], [[120121, 120121], "mapped", [98]], [[120122, 120122], "disallowed"], [[120123, 120123], "mapped", [100]], [[120124, 120124], "mapped", [101]], [[120125, 120125], "mapped", [102]], [[120126, 120126], "mapped", [103]], [[120127, 120127], "disallowed"], [[120128, 120128], "mapped", [105]], [[120129, 120129], "mapped", [106]], [[120130, 120130], "mapped", [107]], [[120131, 120131], "mapped", [108]], [[120132, 120132], "mapped", [109]], [[120133, 120133], "disallowed"], [[120134, 120134], "mapped", [111]], [[120135, 120137], "disallowed"], [[120138, 120138], "mapped", [115]], [[120139, 120139], "mapped", [116]], [[120140, 120140], "mapped", [117]], [[120141, 120141], "mapped", [118]], [[120142, 120142], "mapped", [119]], [[120143, 120143], "mapped", [120]], [[120144, 120144], "mapped", [121]], [[120145, 120145], "disallowed"], [[120146, 120146], "mapped", [97]], [[120147, 120147], "mapped", [98]], [[120148, 120148], "mapped", [99]], [[120149, 120149], "mapped", [100]], [[120150, 120150], "mapped", [101]], [[120151, 120151], "mapped", [102]], [[120152, 120152], "mapped", [103]], [[120153, 120153], "mapped", [104]], [[120154, 120154], "mapped", [105]], [[120155, 120155], "mapped", [106]], [[120156, 120156], "mapped", [107]], [[120157, 120157], "mapped", [108]], [[120158, 120158], "mapped", [109]], [[120159, 120159], "mapped", [110]], [[120160, 120160], "mapped", [111]], [[120161, 120161], "mapped", [112]], [[120162, 120162], "mapped", [113]], [[120163, 120163], "mapped", [114]], [[120164, 120164], "mapped", [115]], [[120165, 120165], "mapped", [116]], [[120166, 120166], "mapped", [117]], [[120167, 120167], "mapped", [118]], [[120168, 120168], "mapped", [119]], [[120169, 120169], "mapped", [120]], [[120170, 120170], "mapped", [121]], [[120171, 120171], "mapped", [122]], [[120172, 120172], "mapped", [97]], [[120173, 120173], "mapped", [98]], [[120174, 120174], "mapped", [99]], [[120175, 120175], "mapped", [100]], [[120176, 120176], "mapped", [101]], [[120177, 120177], "mapped", [102]], [[120178, 120178], "mapped", [103]], [[120179, 120179], "mapped", [104]], [[120180, 120180], "mapped", [105]], [[120181, 120181], "mapped", [106]], [[120182, 120182], "mapped", [107]], [[120183, 120183], "mapped", [108]], [[120184, 120184], "mapped", [109]], [[120185, 120185], "mapped", [110]], [[120186, 120186], "mapped", [111]], [[120187, 120187], "mapped", [112]], [[120188, 120188], "mapped", [113]], [[120189, 120189], "mapped", [114]], [[120190, 120190], "mapped", [115]], [[120191, 120191], "mapped", [116]], [[120192, 120192], "mapped", [117]], [[120193, 120193], "mapped", [118]], [[120194, 120194], "mapped", [119]], [[120195, 120195], "mapped", [120]], [[120196, 120196], "mapped", [121]], [[120197, 120197], "mapped", [122]], [[120198, 120198], "mapped", [97]], [[120199, 120199], "mapped", [98]], [[120200, 120200], "mapped", [99]], [[120201, 120201], "mapped", [100]], [[120202, 120202], "mapped", [101]], [[120203, 120203], "mapped", [102]], [[120204, 120204], "mapped", [103]], [[120205, 120205], "mapped", [104]], [[120206, 120206], "mapped", [105]], [[120207, 120207], "mapped", [106]], [[120208, 120208], "mapped", [107]], [[120209, 120209], "mapped", [108]], [[120210, 120210], "mapped", [109]], [[120211, 120211], "mapped", [110]], [[120212, 120212], "mapped", [111]], [[120213, 120213], "mapped", [112]], [[120214, 120214], "mapped", [113]], [[120215, 120215], "mapped", [114]], [[120216, 120216], "mapped", [115]], [[120217, 120217], "mapped", [116]], [[120218, 120218], "mapped", [117]], [[120219, 120219], "mapped", [118]], [[120220, 120220], "mapped", [119]], [[120221, 120221], "mapped", [120]], [[120222, 120222], "mapped", [121]], [[120223, 120223], "mapped", [122]], [[120224, 120224], "mapped", [97]], [[120225, 120225], "mapped", [98]], [[120226, 120226], "mapped", [99]], [[120227, 120227], "mapped", [100]], [[120228, 120228], "mapped", [101]], [[120229, 120229], "mapped", [102]], [[120230, 120230], "mapped", [103]], [[120231, 120231], "mapped", [104]], [[120232, 120232], "mapped", [105]], [[120233, 120233], "mapped", [106]], [[120234, 120234], "mapped", [107]], [[120235, 120235], "mapped", [108]], [[120236, 120236], "mapped", [109]], [[120237, 120237], "mapped", [110]], [[120238, 120238], "mapped", [111]], [[120239, 120239], "mapped", [112]], [[120240, 120240], "mapped", [113]], [[120241, 120241], "mapped", [114]], [[120242, 120242], "mapped", [115]], [[120243, 120243], "mapped", [116]], [[120244, 120244], "mapped", [117]], [[120245, 120245], "mapped", [118]], [[120246, 120246], "mapped", [119]], [[120247, 120247], "mapped", [120]], [[120248, 120248], "mapped", [121]], [[120249, 120249], "mapped", [122]], [[120250, 120250], "mapped", [97]], [[120251, 120251], "mapped", [98]], [[120252, 120252], "mapped", [99]], [[120253, 120253], "mapped", [100]], [[120254, 120254], "mapped", [101]], [[120255, 120255], "mapped", [102]], [[120256, 120256], "mapped", [103]], [[120257, 120257], "mapped", [104]], [[120258, 120258], "mapped", [105]], [[120259, 120259], "mapped", [106]], [[120260, 120260], "mapped", [107]], [[120261, 120261], "mapped", [108]], [[120262, 120262], "mapped", [109]], [[120263, 120263], "mapped", [110]], [[120264, 120264], "mapped", [111]], [[120265, 120265], "mapped", [112]], [[120266, 120266], "mapped", [113]], [[120267, 120267], "mapped", [114]], [[120268, 120268], "mapped", [115]], [[120269, 120269], "mapped", [116]], [[120270, 120270], "mapped", [117]], [[120271, 120271], "mapped", [118]], [[120272, 120272], "mapped", [119]], [[120273, 120273], "mapped", [120]], [[120274, 120274], "mapped", [121]], [[120275, 120275], "mapped", [122]], [[120276, 120276], "mapped", [97]], [[120277, 120277], "mapped", [98]], [[120278, 120278], "mapped", [99]], [[120279, 120279], "mapped", [100]], [[120280, 120280], "mapped", [101]], [[120281, 120281], "mapped", [102]], [[120282, 120282], "mapped", [103]], [[120283, 120283], "mapped", [104]], [[120284, 120284], "mapped", [105]], [[120285, 120285], "mapped", [106]], [[120286, 120286], "mapped", [107]], [[120287, 120287], "mapped", [108]], [[120288, 120288], "mapped", [109]], [[120289, 120289], "mapped", [110]], [[120290, 120290], "mapped", [111]], [[120291, 120291], "mapped", [112]], [[120292, 120292], "mapped", [113]], [[120293, 120293], "mapped", [114]], [[120294, 120294], "mapped", [115]], [[120295, 120295], "mapped", [116]], [[120296, 120296], "mapped", [117]], [[120297, 120297], "mapped", [118]], [[120298, 120298], "mapped", [119]], [[120299, 120299], "mapped", [120]], [[120300, 120300], "mapped", [121]], [[120301, 120301], "mapped", [122]], [[120302, 120302], "mapped", [97]], [[120303, 120303], "mapped", [98]], [[120304, 120304], "mapped", [99]], [[120305, 120305], "mapped", [100]], [[120306, 120306], "mapped", [101]], [[120307, 120307], "mapped", [102]], [[120308, 120308], "mapped", [103]], [[120309, 120309], "mapped", [104]], [[120310, 120310], "mapped", [105]], [[120311, 120311], "mapped", [106]], [[120312, 120312], "mapped", [107]], [[120313, 120313], "mapped", [108]], [[120314, 120314], "mapped", [109]], [[120315, 120315], "mapped", [110]], [[120316, 120316], "mapped", [111]], [[120317, 120317], "mapped", [112]], [[120318, 120318], "mapped", [113]], [[120319, 120319], "mapped", [114]], [[120320, 120320], "mapped", [115]], [[120321, 120321], "mapped", [116]], [[120322, 120322], "mapped", [117]], [[120323, 120323], "mapped", [118]], [[120324, 120324], "mapped", [119]], [[120325, 120325], "mapped", [120]], [[120326, 120326], "mapped", [121]], [[120327, 120327], "mapped", [122]], [[120328, 120328], "mapped", [97]], [[120329, 120329], "mapped", [98]], [[120330, 120330], "mapped", [99]], [[120331, 120331], "mapped", [100]], [[120332, 120332], "mapped", [101]], [[120333, 120333], "mapped", [102]], [[120334, 120334], "mapped", [103]], [[120335, 120335], "mapped", [104]], [[120336, 120336], "mapped", [105]], [[120337, 120337], "mapped", [106]], [[120338, 120338], "mapped", [107]], [[120339, 120339], "mapped", [108]], [[120340, 120340], "mapped", [109]], [[120341, 120341], "mapped", [110]], [[120342, 120342], "mapped", [111]], [[120343, 120343], "mapped", [112]], [[120344, 120344], "mapped", [113]], [[120345, 120345], "mapped", [114]], [[120346, 120346], "mapped", [115]], [[120347, 120347], "mapped", [116]], [[120348, 120348], "mapped", [117]], [[120349, 120349], "mapped", [118]], [[120350, 120350], "mapped", [119]], [[120351, 120351], "mapped", [120]], [[120352, 120352], "mapped", [121]], [[120353, 120353], "mapped", [122]], [[120354, 120354], "mapped", [97]], [[120355, 120355], "mapped", [98]], [[120356, 120356], "mapped", [99]], [[120357, 120357], "mapped", [100]], [[120358, 120358], "mapped", [101]], [[120359, 120359], "mapped", [102]], [[120360, 120360], "mapped", [103]], [[120361, 120361], "mapped", [104]], [[120362, 120362], "mapped", [105]], [[120363, 120363], "mapped", [106]], [[120364, 120364], "mapped", [107]], [[120365, 120365], "mapped", [108]], [[120366, 120366], "mapped", [109]], [[120367, 120367], "mapped", [110]], [[120368, 120368], "mapped", [111]], [[120369, 120369], "mapped", [112]], [[120370, 120370], "mapped", [113]], [[120371, 120371], "mapped", [114]], [[120372, 120372], "mapped", [115]], [[120373, 120373], "mapped", [116]], [[120374, 120374], "mapped", [117]], [[120375, 120375], "mapped", [118]], [[120376, 120376], "mapped", [119]], [[120377, 120377], "mapped", [120]], [[120378, 120378], "mapped", [121]], [[120379, 120379], "mapped", [122]], [[120380, 120380], "mapped", [97]], [[120381, 120381], "mapped", [98]], [[120382, 120382], "mapped", [99]], [[120383, 120383], "mapped", [100]], [[120384, 120384], "mapped", [101]], [[120385, 120385], "mapped", [102]], [[120386, 120386], "mapped", [103]], [[120387, 120387], "mapped", [104]], [[120388, 120388], "mapped", [105]], [[120389, 120389], "mapped", [106]], [[120390, 120390], "mapped", [107]], [[120391, 120391], "mapped", [108]], [[120392, 120392], "mapped", [109]], [[120393, 120393], "mapped", [110]], [[120394, 120394], "mapped", [111]], [[120395, 120395], "mapped", [112]], [[120396, 120396], "mapped", [113]], [[120397, 120397], "mapped", [114]], [[120398, 120398], "mapped", [115]], [[120399, 120399], "mapped", [116]], [[120400, 120400], "mapped", [117]], [[120401, 120401], "mapped", [118]], [[120402, 120402], "mapped", [119]], [[120403, 120403], "mapped", [120]], [[120404, 120404], "mapped", [121]], [[120405, 120405], "mapped", [122]], [[120406, 120406], "mapped", [97]], [[120407, 120407], "mapped", [98]], [[120408, 120408], "mapped", [99]], [[120409, 120409], "mapped", [100]], [[120410, 120410], "mapped", [101]], [[120411, 120411], "mapped", [102]], [[120412, 120412], "mapped", [103]], [[120413, 120413], "mapped", [104]], [[120414, 120414], "mapped", [105]], [[120415, 120415], "mapped", [106]], [[120416, 120416], "mapped", [107]], [[120417, 120417], "mapped", [108]], [[120418, 120418], "mapped", [109]], [[120419, 120419], "mapped", [110]], [[120420, 120420], "mapped", [111]], [[120421, 120421], "mapped", [112]], [[120422, 120422], "mapped", [113]], [[120423, 120423], "mapped", [114]], [[120424, 120424], "mapped", [115]], [[120425, 120425], "mapped", [116]], [[120426, 120426], "mapped", [117]], [[120427, 120427], "mapped", [118]], [[120428, 120428], "mapped", [119]], [[120429, 120429], "mapped", [120]], [[120430, 120430], "mapped", [121]], [[120431, 120431], "mapped", [122]], [[120432, 120432], "mapped", [97]], [[120433, 120433], "mapped", [98]], [[120434, 120434], "mapped", [99]], [[120435, 120435], "mapped", [100]], [[120436, 120436], "mapped", [101]], [[120437, 120437], "mapped", [102]], [[120438, 120438], "mapped", [103]], [[120439, 120439], "mapped", [104]], [[120440, 120440], "mapped", [105]], [[120441, 120441], "mapped", [106]], [[120442, 120442], "mapped", [107]], [[120443, 120443], "mapped", [108]], [[120444, 120444], "mapped", [109]], [[120445, 120445], "mapped", [110]], [[120446, 120446], "mapped", [111]], [[120447, 120447], "mapped", [112]], [[120448, 120448], "mapped", [113]], [[120449, 120449], "mapped", [114]], [[120450, 120450], "mapped", [115]], [[120451, 120451], "mapped", [116]], [[120452, 120452], "mapped", [117]], [[120453, 120453], "mapped", [118]], [[120454, 120454], "mapped", [119]], [[120455, 120455], "mapped", [120]], [[120456, 120456], "mapped", [121]], [[120457, 120457], "mapped", [122]], [[120458, 120458], "mapped", [97]], [[120459, 120459], "mapped", [98]], [[120460, 120460], "mapped", [99]], [[120461, 120461], "mapped", [100]], [[120462, 120462], "mapped", [101]], [[120463, 120463], "mapped", [102]], [[120464, 120464], "mapped", [103]], [[120465, 120465], "mapped", [104]], [[120466, 120466], "mapped", [105]], [[120467, 120467], "mapped", [106]], [[120468, 120468], "mapped", [107]], [[120469, 120469], "mapped", [108]], [[120470, 120470], "mapped", [109]], [[120471, 120471], "mapped", [110]], [[120472, 120472], "mapped", [111]], [[120473, 120473], "mapped", [112]], [[120474, 120474], "mapped", [113]], [[120475, 120475], "mapped", [114]], [[120476, 120476], "mapped", [115]], [[120477, 120477], "mapped", [116]], [[120478, 120478], "mapped", [117]], [[120479, 120479], "mapped", [118]], [[120480, 120480], "mapped", [119]], [[120481, 120481], "mapped", [120]], [[120482, 120482], "mapped", [121]], [[120483, 120483], "mapped", [122]], [[120484, 120484], "mapped", [305]], [[120485, 120485], "mapped", [567]], [[120486, 120487], "disallowed"], [[120488, 120488], "mapped", [945]], [[120489, 120489], "mapped", [946]], [[120490, 120490], "mapped", [947]], [[120491, 120491], "mapped", [948]], [[120492, 120492], "mapped", [949]], [[120493, 120493], "mapped", [950]], [[120494, 120494], "mapped", [951]], [[120495, 120495], "mapped", [952]], [[120496, 120496], "mapped", [953]], [[120497, 120497], "mapped", [954]], [[120498, 120498], "mapped", [955]], [[120499, 120499], "mapped", [956]], [[120500, 120500], "mapped", [957]], [[120501, 120501], "mapped", [958]], [[120502, 120502], "mapped", [959]], [[120503, 120503], "mapped", [960]], [[120504, 120504], "mapped", [961]], [[120505, 120505], "mapped", [952]], [[120506, 120506], "mapped", [963]], [[120507, 120507], "mapped", [964]], [[120508, 120508], "mapped", [965]], [[120509, 120509], "mapped", [966]], [[120510, 120510], "mapped", [967]], [[120511, 120511], "mapped", [968]], [[120512, 120512], "mapped", [969]], [[120513, 120513], "mapped", [8711]], [[120514, 120514], "mapped", [945]], [[120515, 120515], "mapped", [946]], [[120516, 120516], "mapped", [947]], [[120517, 120517], "mapped", [948]], [[120518, 120518], "mapped", [949]], [[120519, 120519], "mapped", [950]], [[120520, 120520], "mapped", [951]], [[120521, 120521], "mapped", [952]], [[120522, 120522], "mapped", [953]], [[120523, 120523], "mapped", [954]], [[120524, 120524], "mapped", [955]], [[120525, 120525], "mapped", [956]], [[120526, 120526], "mapped", [957]], [[120527, 120527], "mapped", [958]], [[120528, 120528], "mapped", [959]], [[120529, 120529], "mapped", [960]], [[120530, 120530], "mapped", [961]], [[120531, 120532], "mapped", [963]], [[120533, 120533], "mapped", [964]], [[120534, 120534], "mapped", [965]], [[120535, 120535], "mapped", [966]], [[120536, 120536], "mapped", [967]], [[120537, 120537], "mapped", [968]], [[120538, 120538], "mapped", [969]], [[120539, 120539], "mapped", [8706]], [[120540, 120540], "mapped", [949]], [[120541, 120541], "mapped", [952]], [[120542, 120542], "mapped", [954]], [[120543, 120543], "mapped", [966]], [[120544, 120544], "mapped", [961]], [[120545, 120545], "mapped", [960]], [[120546, 120546], "mapped", [945]], [[120547, 120547], "mapped", [946]], [[120548, 120548], "mapped", [947]], [[120549, 120549], "mapped", [948]], [[120550, 120550], "mapped", [949]], [[120551, 120551], "mapped", [950]], [[120552, 120552], "mapped", [951]], [[120553, 120553], "mapped", [952]], [[120554, 120554], "mapped", [953]], [[120555, 120555], "mapped", [954]], [[120556, 120556], "mapped", [955]], [[120557, 120557], "mapped", [956]], [[120558, 120558], "mapped", [957]], [[120559, 120559], "mapped", [958]], [[120560, 120560], "mapped", [959]], [[120561, 120561], "mapped", [960]], [[120562, 120562], "mapped", [961]], [[120563, 120563], "mapped", [952]], [[120564, 120564], "mapped", [963]], [[120565, 120565], "mapped", [964]], [[120566, 120566], "mapped", [965]], [[120567, 120567], "mapped", [966]], [[120568, 120568], "mapped", [967]], [[120569, 120569], "mapped", [968]], [[120570, 120570], "mapped", [969]], [[120571, 120571], "mapped", [8711]], [[120572, 120572], "mapped", [945]], [[120573, 120573], "mapped", [946]], [[120574, 120574], "mapped", [947]], [[120575, 120575], "mapped", [948]], [[120576, 120576], "mapped", [949]], [[120577, 120577], "mapped", [950]], [[120578, 120578], "mapped", [951]], [[120579, 120579], "mapped", [952]], [[120580, 120580], "mapped", [953]], [[120581, 120581], "mapped", [954]], [[120582, 120582], "mapped", [955]], [[120583, 120583], "mapped", [956]], [[120584, 120584], "mapped", [957]], [[120585, 120585], "mapped", [958]], [[120586, 120586], "mapped", [959]], [[120587, 120587], "mapped", [960]], [[120588, 120588], "mapped", [961]], [[120589, 120590], "mapped", [963]], [[120591, 120591], "mapped", [964]], [[120592, 120592], "mapped", [965]], [[120593, 120593], "mapped", [966]], [[120594, 120594], "mapped", [967]], [[120595, 120595], "mapped", [968]], [[120596, 120596], "mapped", [969]], [[120597, 120597], "mapped", [8706]], [[120598, 120598], "mapped", [949]], [[120599, 120599], "mapped", [952]], [[120600, 120600], "mapped", [954]], [[120601, 120601], "mapped", [966]], [[120602, 120602], "mapped", [961]], [[120603, 120603], "mapped", [960]], [[120604, 120604], "mapped", [945]], [[120605, 120605], "mapped", [946]], [[120606, 120606], "mapped", [947]], [[120607, 120607], "mapped", [948]], [[120608, 120608], "mapped", [949]], [[120609, 120609], "mapped", [950]], [[120610, 120610], "mapped", [951]], [[120611, 120611], "mapped", [952]], [[120612, 120612], "mapped", [953]], [[120613, 120613], "mapped", [954]], [[120614, 120614], "mapped", [955]], [[120615, 120615], "mapped", [956]], [[120616, 120616], "mapped", [957]], [[120617, 120617], "mapped", [958]], [[120618, 120618], "mapped", [959]], [[120619, 120619], "mapped", [960]], [[120620, 120620], "mapped", [961]], [[120621, 120621], "mapped", [952]], [[120622, 120622], "mapped", [963]], [[120623, 120623], "mapped", [964]], [[120624, 120624], "mapped", [965]], [[120625, 120625], "mapped", [966]], [[120626, 120626], "mapped", [967]], [[120627, 120627], "mapped", [968]], [[120628, 120628], "mapped", [969]], [[120629, 120629], "mapped", [8711]], [[120630, 120630], "mapped", [945]], [[120631, 120631], "mapped", [946]], [[120632, 120632], "mapped", [947]], [[120633, 120633], "mapped", [948]], [[120634, 120634], "mapped", [949]], [[120635, 120635], "mapped", [950]], [[120636, 120636], "mapped", [951]], [[120637, 120637], "mapped", [952]], [[120638, 120638], "mapped", [953]], [[120639, 120639], "mapped", [954]], [[120640, 120640], "mapped", [955]], [[120641, 120641], "mapped", [956]], [[120642, 120642], "mapped", [957]], [[120643, 120643], "mapped", [958]], [[120644, 120644], "mapped", [959]], [[120645, 120645], "mapped", [960]], [[120646, 120646], "mapped", [961]], [[120647, 120648], "mapped", [963]], [[120649, 120649], "mapped", [964]], [[120650, 120650], "mapped", [965]], [[120651, 120651], "mapped", [966]], [[120652, 120652], "mapped", [967]], [[120653, 120653], "mapped", [968]], [[120654, 120654], "mapped", [969]], [[120655, 120655], "mapped", [8706]], [[120656, 120656], "mapped", [949]], [[120657, 120657], "mapped", [952]], [[120658, 120658], "mapped", [954]], [[120659, 120659], "mapped", [966]], [[120660, 120660], "mapped", [961]], [[120661, 120661], "mapped", [960]], [[120662, 120662], "mapped", [945]], [[120663, 120663], "mapped", [946]], [[120664, 120664], "mapped", [947]], [[120665, 120665], "mapped", [948]], [[120666, 120666], "mapped", [949]], [[120667, 120667], "mapped", [950]], [[120668, 120668], "mapped", [951]], [[120669, 120669], "mapped", [952]], [[120670, 120670], "mapped", [953]], [[120671, 120671], "mapped", [954]], [[120672, 120672], "mapped", [955]], [[120673, 120673], "mapped", [956]], [[120674, 120674], "mapped", [957]], [[120675, 120675], "mapped", [958]], [[120676, 120676], "mapped", [959]], [[120677, 120677], "mapped", [960]], [[120678, 120678], "mapped", [961]], [[120679, 120679], "mapped", [952]], [[120680, 120680], "mapped", [963]], [[120681, 120681], "mapped", [964]], [[120682, 120682], "mapped", [965]], [[120683, 120683], "mapped", [966]], [[120684, 120684], "mapped", [967]], [[120685, 120685], "mapped", [968]], [[120686, 120686], "mapped", [969]], [[120687, 120687], "mapped", [8711]], [[120688, 120688], "mapped", [945]], [[120689, 120689], "mapped", [946]], [[120690, 120690], "mapped", [947]], [[120691, 120691], "mapped", [948]], [[120692, 120692], "mapped", [949]], [[120693, 120693], "mapped", [950]], [[120694, 120694], "mapped", [951]], [[120695, 120695], "mapped", [952]], [[120696, 120696], "mapped", [953]], [[120697, 120697], "mapped", [954]], [[120698, 120698], "mapped", [955]], [[120699, 120699], "mapped", [956]], [[120700, 120700], "mapped", [957]], [[120701, 120701], "mapped", [958]], [[120702, 120702], "mapped", [959]], [[120703, 120703], "mapped", [960]], [[120704, 120704], "mapped", [961]], [[120705, 120706], "mapped", [963]], [[120707, 120707], "mapped", [964]], [[120708, 120708], "mapped", [965]], [[120709, 120709], "mapped", [966]], [[120710, 120710], "mapped", [967]], [[120711, 120711], "mapped", [968]], [[120712, 120712], "mapped", [969]], [[120713, 120713], "mapped", [8706]], [[120714, 120714], "mapped", [949]], [[120715, 120715], "mapped", [952]], [[120716, 120716], "mapped", [954]], [[120717, 120717], "mapped", [966]], [[120718, 120718], "mapped", [961]], [[120719, 120719], "mapped", [960]], [[120720, 120720], "mapped", [945]], [[120721, 120721], "mapped", [946]], [[120722, 120722], "mapped", [947]], [[120723, 120723], "mapped", [948]], [[120724, 120724], "mapped", [949]], [[120725, 120725], "mapped", [950]], [[120726, 120726], "mapped", [951]], [[120727, 120727], "mapped", [952]], [[120728, 120728], "mapped", [953]], [[120729, 120729], "mapped", [954]], [[120730, 120730], "mapped", [955]], [[120731, 120731], "mapped", [956]], [[120732, 120732], "mapped", [957]], [[120733, 120733], "mapped", [958]], [[120734, 120734], "mapped", [959]], [[120735, 120735], "mapped", [960]], [[120736, 120736], "mapped", [961]], [[120737, 120737], "mapped", [952]], [[120738, 120738], "mapped", [963]], [[120739, 120739], "mapped", [964]], [[120740, 120740], "mapped", [965]], [[120741, 120741], "mapped", [966]], [[120742, 120742], "mapped", [967]], [[120743, 120743], "mapped", [968]], [[120744, 120744], "mapped", [969]], [[120745, 120745], "mapped", [8711]], [[120746, 120746], "mapped", [945]], [[120747, 120747], "mapped", [946]], [[120748, 120748], "mapped", [947]], [[120749, 120749], "mapped", [948]], [[120750, 120750], "mapped", [949]], [[120751, 120751], "mapped", [950]], [[120752, 120752], "mapped", [951]], [[120753, 120753], "mapped", [952]], [[120754, 120754], "mapped", [953]], [[120755, 120755], "mapped", [954]], [[120756, 120756], "mapped", [955]], [[120757, 120757], "mapped", [956]], [[120758, 120758], "mapped", [957]], [[120759, 120759], "mapped", [958]], [[120760, 120760], "mapped", [959]], [[120761, 120761], "mapped", [960]], [[120762, 120762], "mapped", [961]], [[120763, 120764], "mapped", [963]], [[120765, 120765], "mapped", [964]], [[120766, 120766], "mapped", [965]], [[120767, 120767], "mapped", [966]], [[120768, 120768], "mapped", [967]], [[120769, 120769], "mapped", [968]], [[120770, 120770], "mapped", [969]], [[120771, 120771], "mapped", [8706]], [[120772, 120772], "mapped", [949]], [[120773, 120773], "mapped", [952]], [[120774, 120774], "mapped", [954]], [[120775, 120775], "mapped", [966]], [[120776, 120776], "mapped", [961]], [[120777, 120777], "mapped", [960]], [[120778, 120779], "mapped", [989]], [[120780, 120781], "disallowed"], [[120782, 120782], "mapped", [48]], [[120783, 120783], "mapped", [49]], [[120784, 120784], "mapped", [50]], [[120785, 120785], "mapped", [51]], [[120786, 120786], "mapped", [52]], [[120787, 120787], "mapped", [53]], [[120788, 120788], "mapped", [54]], [[120789, 120789], "mapped", [55]], [[120790, 120790], "mapped", [56]], [[120791, 120791], "mapped", [57]], [[120792, 120792], "mapped", [48]], [[120793, 120793], "mapped", [49]], [[120794, 120794], "mapped", [50]], [[120795, 120795], "mapped", [51]], [[120796, 120796], "mapped", [52]], [[120797, 120797], "mapped", [53]], [[120798, 120798], "mapped", [54]], [[120799, 120799], "mapped", [55]], [[120800, 120800], "mapped", [56]], [[120801, 120801], "mapped", [57]], [[120802, 120802], "mapped", [48]], [[120803, 120803], "mapped", [49]], [[120804, 120804], "mapped", [50]], [[120805, 120805], "mapped", [51]], [[120806, 120806], "mapped", [52]], [[120807, 120807], "mapped", [53]], [[120808, 120808], "mapped", [54]], [[120809, 120809], "mapped", [55]], [[120810, 120810], "mapped", [56]], [[120811, 120811], "mapped", [57]], [[120812, 120812], "mapped", [48]], [[120813, 120813], "mapped", [49]], [[120814, 120814], "mapped", [50]], [[120815, 120815], "mapped", [51]], [[120816, 120816], "mapped", [52]], [[120817, 120817], "mapped", [53]], [[120818, 120818], "mapped", [54]], [[120819, 120819], "mapped", [55]], [[120820, 120820], "mapped", [56]], [[120821, 120821], "mapped", [57]], [[120822, 120822], "mapped", [48]], [[120823, 120823], "mapped", [49]], [[120824, 120824], "mapped", [50]], [[120825, 120825], "mapped", [51]], [[120826, 120826], "mapped", [52]], [[120827, 120827], "mapped", [53]], [[120828, 120828], "mapped", [54]], [[120829, 120829], "mapped", [55]], [[120830, 120830], "mapped", [56]], [[120831, 120831], "mapped", [57]], [[120832, 121343], "valid", [], "NV8"], [[121344, 121398], "valid"], [[121399, 121402], "valid", [], "NV8"], [[121403, 121452], "valid"], [[121453, 121460], "valid", [], "NV8"], [[121461, 121461], "valid"], [[121462, 121475], "valid", [], "NV8"], [[121476, 121476], "valid"], [[121477, 121483], "valid", [], "NV8"], [[121484, 121498], "disallowed"], [[121499, 121503], "valid"], [[121504, 121504], "disallowed"], [[121505, 121519], "valid"], [[121520, 124927], "disallowed"], [[124928, 125124], "valid"], [[125125, 125126], "disallowed"], [[125127, 125135], "valid", [], "NV8"], [[125136, 125142], "valid"], [[125143, 126463], "disallowed"], [[126464, 126464], "mapped", [1575]], [[126465, 126465], "mapped", [1576]], [[126466, 126466], "mapped", [1580]], [[126467, 126467], "mapped", [1583]], [[126468, 126468], "disallowed"], [[126469, 126469], "mapped", [1608]], [[126470, 126470], "mapped", [1586]], [[126471, 126471], "mapped", [1581]], [[126472, 126472], "mapped", [1591]], [[126473, 126473], "mapped", [1610]], [[126474, 126474], "mapped", [1603]], [[126475, 126475], "mapped", [1604]], [[126476, 126476], "mapped", [1605]], [[126477, 126477], "mapped", [1606]], [[126478, 126478], "mapped", [1587]], [[126479, 126479], "mapped", [1593]], [[126480, 126480], "mapped", [1601]], [[126481, 126481], "mapped", [1589]], [[126482, 126482], "mapped", [1602]], [[126483, 126483], "mapped", [1585]], [[126484, 126484], "mapped", [1588]], [[126485, 126485], "mapped", [1578]], [[126486, 126486], "mapped", [1579]], [[126487, 126487], "mapped", [1582]], [[126488, 126488], "mapped", [1584]], [[126489, 126489], "mapped", [1590]], [[126490, 126490], "mapped", [1592]], [[126491, 126491], "mapped", [1594]], [[126492, 126492], "mapped", [1646]], [[126493, 126493], "mapped", [1722]], [[126494, 126494], "mapped", [1697]], [[126495, 126495], "mapped", [1647]], [[126496, 126496], "disallowed"], [[126497, 126497], "mapped", [1576]], [[126498, 126498], "mapped", [1580]], [[126499, 126499], "disallowed"], [[126500, 126500], "mapped", [1607]], [[126501, 126502], "disallowed"], [[126503, 126503], "mapped", [1581]], [[126504, 126504], "disallowed"], [[126505, 126505], "mapped", [1610]], [[126506, 126506], "mapped", [1603]], [[126507, 126507], "mapped", [1604]], [[126508, 126508], "mapped", [1605]], [[126509, 126509], "mapped", [1606]], [[126510, 126510], "mapped", [1587]], [[126511, 126511], "mapped", [1593]], [[126512, 126512], "mapped", [1601]], [[126513, 126513], "mapped", [1589]], [[126514, 126514], "mapped", [1602]], [[126515, 126515], "disallowed"], [[126516, 126516], "mapped", [1588]], [[126517, 126517], "mapped", [1578]], [[126518, 126518], "mapped", [1579]], [[126519, 126519], "mapped", [1582]], [[126520, 126520], "disallowed"], [[126521, 126521], "mapped", [1590]], [[126522, 126522], "disallowed"], [[126523, 126523], "mapped", [1594]], [[126524, 126529], "disallowed"], [[126530, 126530], "mapped", [1580]], [[126531, 126534], "disallowed"], [[126535, 126535], "mapped", [1581]], [[126536, 126536], "disallowed"], [[126537, 126537], "mapped", [1610]], [[126538, 126538], "disallowed"], [[126539, 126539], "mapped", [1604]], [[126540, 126540], "disallowed"], [[126541, 126541], "mapped", [1606]], [[126542, 126542], "mapped", [1587]], [[126543, 126543], "mapped", [1593]], [[126544, 126544], "disallowed"], [[126545, 126545], "mapped", [1589]], [[126546, 126546], "mapped", [1602]], [[126547, 126547], "disallowed"], [[126548, 126548], "mapped", [1588]], [[126549, 126550], "disallowed"], [[126551, 126551], "mapped", [1582]], [[126552, 126552], "disallowed"], [[126553, 126553], "mapped", [1590]], [[126554, 126554], "disallowed"], [[126555, 126555], "mapped", [1594]], [[126556, 126556], "disallowed"], [[126557, 126557], "mapped", [1722]], [[126558, 126558], "disallowed"], [[126559, 126559], "mapped", [1647]], [[126560, 126560], "disallowed"], [[126561, 126561], "mapped", [1576]], [[126562, 126562], "mapped", [1580]], [[126563, 126563], "disallowed"], [[126564, 126564], "mapped", [1607]], [[126565, 126566], "disallowed"], [[126567, 126567], "mapped", [1581]], [[126568, 126568], "mapped", [1591]], [[126569, 126569], "mapped", [1610]], [[126570, 126570], "mapped", [1603]], [[126571, 126571], "disallowed"], [[126572, 126572], "mapped", [1605]], [[126573, 126573], "mapped", [1606]], [[126574, 126574], "mapped", [1587]], [[126575, 126575], "mapped", [1593]], [[126576, 126576], "mapped", [1601]], [[126577, 126577], "mapped", [1589]], [[126578, 126578], "mapped", [1602]], [[126579, 126579], "disallowed"], [[126580, 126580], "mapped", [1588]], [[126581, 126581], "mapped", [1578]], [[126582, 126582], "mapped", [1579]], [[126583, 126583], "mapped", [1582]], [[126584, 126584], "disallowed"], [[126585, 126585], "mapped", [1590]], [[126586, 126586], "mapped", [1592]], [[126587, 126587], "mapped", [1594]], [[126588, 126588], "mapped", [1646]], [[126589, 126589], "disallowed"], [[126590, 126590], "mapped", [1697]], [[126591, 126591], "disallowed"], [[126592, 126592], "mapped", [1575]], [[126593, 126593], "mapped", [1576]], [[126594, 126594], "mapped", [1580]], [[126595, 126595], "mapped", [1583]], [[126596, 126596], "mapped", [1607]], [[126597, 126597], "mapped", [1608]], [[126598, 126598], "mapped", [1586]], [[126599, 126599], "mapped", [1581]], [[126600, 126600], "mapped", [1591]], [[126601, 126601], "mapped", [1610]], [[126602, 126602], "disallowed"], [[126603, 126603], "mapped", [1604]], [[126604, 126604], "mapped", [1605]], [[126605, 126605], "mapped", [1606]], [[126606, 126606], "mapped", [1587]], [[126607, 126607], "mapped", [1593]], [[126608, 126608], "mapped", [1601]], [[126609, 126609], "mapped", [1589]], [[126610, 126610], "mapped", [1602]], [[126611, 126611], "mapped", [1585]], [[126612, 126612], "mapped", [1588]], [[126613, 126613], "mapped", [1578]], [[126614, 126614], "mapped", [1579]], [[126615, 126615], "mapped", [1582]], [[126616, 126616], "mapped", [1584]], [[126617, 126617], "mapped", [1590]], [[126618, 126618], "mapped", [1592]], [[126619, 126619], "mapped", [1594]], [[126620, 126624], "disallowed"], [[126625, 126625], "mapped", [1576]], [[126626, 126626], "mapped", [1580]], [[126627, 126627], "mapped", [1583]], [[126628, 126628], "disallowed"], [[126629, 126629], "mapped", [1608]], [[126630, 126630], "mapped", [1586]], [[126631, 126631], "mapped", [1581]], [[126632, 126632], "mapped", [1591]], [[126633, 126633], "mapped", [1610]], [[126634, 126634], "disallowed"], [[126635, 126635], "mapped", [1604]], [[126636, 126636], "mapped", [1605]], [[126637, 126637], "mapped", [1606]], [[126638, 126638], "mapped", [1587]], [[126639, 126639], "mapped", [1593]], [[126640, 126640], "mapped", [1601]], [[126641, 126641], "mapped", [1589]], [[126642, 126642], "mapped", [1602]], [[126643, 126643], "mapped", [1585]], [[126644, 126644], "mapped", [1588]], [[126645, 126645], "mapped", [1578]], [[126646, 126646], "mapped", [1579]], [[126647, 126647], "mapped", [1582]], [[126648, 126648], "mapped", [1584]], [[126649, 126649], "mapped", [1590]], [[126650, 126650], "mapped", [1592]], [[126651, 126651], "mapped", [1594]], [[126652, 126703], "disallowed"], [[126704, 126705], "valid", [], "NV8"], [[126706, 126975], "disallowed"], [[126976, 127019], "valid", [], "NV8"], [[127020, 127023], "disallowed"], [[127024, 127123], "valid", [], "NV8"], [[127124, 127135], "disallowed"], [[127136, 127150], "valid", [], "NV8"], [[127151, 127152], "disallowed"], [[127153, 127166], "valid", [], "NV8"], [[127167, 127167], "valid", [], "NV8"], [[127168, 127168], "disallowed"], [[127169, 127183], "valid", [], "NV8"], [[127184, 127184], "disallowed"], [[127185, 127199], "valid", [], "NV8"], [[127200, 127221], "valid", [], "NV8"], [[127222, 127231], "disallowed"], [[127232, 127232], "disallowed"], [[127233, 127233], "disallowed_STD3_mapped", [48, 44]], [[127234, 127234], "disallowed_STD3_mapped", [49, 44]], [[127235, 127235], "disallowed_STD3_mapped", [50, 44]], [[127236, 127236], "disallowed_STD3_mapped", [51, 44]], [[127237, 127237], "disallowed_STD3_mapped", [52, 44]], [[127238, 127238], "disallowed_STD3_mapped", [53, 44]], [[127239, 127239], "disallowed_STD3_mapped", [54, 44]], [[127240, 127240], "disallowed_STD3_mapped", [55, 44]], [[127241, 127241], "disallowed_STD3_mapped", [56, 44]], [[127242, 127242], "disallowed_STD3_mapped", [57, 44]], [[127243, 127244], "valid", [], "NV8"], [[127245, 127247], "disallowed"], [[127248, 127248], "disallowed_STD3_mapped", [40, 97, 41]], [[127249, 127249], "disallowed_STD3_mapped", [40, 98, 41]], [[127250, 127250], "disallowed_STD3_mapped", [40, 99, 41]], [[127251, 127251], "disallowed_STD3_mapped", [40, 100, 41]], [[127252, 127252], "disallowed_STD3_mapped", [40, 101, 41]], [[127253, 127253], "disallowed_STD3_mapped", [40, 102, 41]], [[127254, 127254], "disallowed_STD3_mapped", [40, 103, 41]], [[127255, 127255], "disallowed_STD3_mapped", [40, 104, 41]], [[127256, 127256], "disallowed_STD3_mapped", [40, 105, 41]], [[127257, 127257], "disallowed_STD3_mapped", [40, 106, 41]], [[127258, 127258], "disallowed_STD3_mapped", [40, 107, 41]], [[127259, 127259], "disallowed_STD3_mapped", [40, 108, 41]], [[127260, 127260], "disallowed_STD3_mapped", [40, 109, 41]], [[127261, 127261], "disallowed_STD3_mapped", [40, 110, 41]], [[127262, 127262], "disallowed_STD3_mapped", [40, 111, 41]], [[127263, 127263], "disallowed_STD3_mapped", [40, 112, 41]], [[127264, 127264], "disallowed_STD3_mapped", [40, 113, 41]], [[127265, 127265], "disallowed_STD3_mapped", [40, 114, 41]], [[127266, 127266], "disallowed_STD3_mapped", [40, 115, 41]], [[127267, 127267], "disallowed_STD3_mapped", [40, 116, 41]], [[127268, 127268], "disallowed_STD3_mapped", [40, 117, 41]], [[127269, 127269], "disallowed_STD3_mapped", [40, 118, 41]], [[127270, 127270], "disallowed_STD3_mapped", [40, 119, 41]], [[127271, 127271], "disallowed_STD3_mapped", [40, 120, 41]], [[127272, 127272], "disallowed_STD3_mapped", [40, 121, 41]], [[127273, 127273], "disallowed_STD3_mapped", [40, 122, 41]], [[127274, 127274], "mapped", [12308, 115, 12309]], [[127275, 127275], "mapped", [99]], [[127276, 127276], "mapped", [114]], [[127277, 127277], "mapped", [99, 100]], [[127278, 127278], "mapped", [119, 122]], [[127279, 127279], "disallowed"], [[127280, 127280], "mapped", [97]], [[127281, 127281], "mapped", [98]], [[127282, 127282], "mapped", [99]], [[127283, 127283], "mapped", [100]], [[127284, 127284], "mapped", [101]], [[127285, 127285], "mapped", [102]], [[127286, 127286], "mapped", [103]], [[127287, 127287], "mapped", [104]], [[127288, 127288], "mapped", [105]], [[127289, 127289], "mapped", [106]], [[127290, 127290], "mapped", [107]], [[127291, 127291], "mapped", [108]], [[127292, 127292], "mapped", [109]], [[127293, 127293], "mapped", [110]], [[127294, 127294], "mapped", [111]], [[127295, 127295], "mapped", [112]], [[127296, 127296], "mapped", [113]], [[127297, 127297], "mapped", [114]], [[127298, 127298], "mapped", [115]], [[127299, 127299], "mapped", [116]], [[127300, 127300], "mapped", [117]], [[127301, 127301], "mapped", [118]], [[127302, 127302], "mapped", [119]], [[127303, 127303], "mapped", [120]], [[127304, 127304], "mapped", [121]], [[127305, 127305], "mapped", [122]], [[127306, 127306], "mapped", [104, 118]], [[127307, 127307], "mapped", [109, 118]], [[127308, 127308], "mapped", [115, 100]], [[127309, 127309], "mapped", [115, 115]], [[127310, 127310], "mapped", [112, 112, 118]], [[127311, 127311], "mapped", [119, 99]], [[127312, 127318], "valid", [], "NV8"], [[127319, 127319], "valid", [], "NV8"], [[127320, 127326], "valid", [], "NV8"], [[127327, 127327], "valid", [], "NV8"], [[127328, 127337], "valid", [], "NV8"], [[127338, 127338], "mapped", [109, 99]], [[127339, 127339], "mapped", [109, 100]], [[127340, 127343], "disallowed"], [[127344, 127352], "valid", [], "NV8"], [[127353, 127353], "valid", [], "NV8"], [[127354, 127354], "valid", [], "NV8"], [[127355, 127356], "valid", [], "NV8"], [[127357, 127358], "valid", [], "NV8"], [[127359, 127359], "valid", [], "NV8"], [[127360, 127369], "valid", [], "NV8"], [[127370, 127373], "valid", [], "NV8"], [[127374, 127375], "valid", [], "NV8"], [[127376, 127376], "mapped", [100, 106]], [[127377, 127386], "valid", [], "NV8"], [[127387, 127461], "disallowed"], [[127462, 127487], "valid", [], "NV8"], [[127488, 127488], "mapped", [12411, 12363]], [[127489, 127489], "mapped", [12467, 12467]], [[127490, 127490], "mapped", [12469]], [[127491, 127503], "disallowed"], [[127504, 127504], "mapped", [25163]], [[127505, 127505], "mapped", [23383]], [[127506, 127506], "mapped", [21452]], [[127507, 127507], "mapped", [12487]], [[127508, 127508], "mapped", [20108]], [[127509, 127509], "mapped", [22810]], [[127510, 127510], "mapped", [35299]], [[127511, 127511], "mapped", [22825]], [[127512, 127512], "mapped", [20132]], [[127513, 127513], "mapped", [26144]], [[127514, 127514], "mapped", [28961]], [[127515, 127515], "mapped", [26009]], [[127516, 127516], "mapped", [21069]], [[127517, 127517], "mapped", [24460]], [[127518, 127518], "mapped", [20877]], [[127519, 127519], "mapped", [26032]], [[127520, 127520], "mapped", [21021]], [[127521, 127521], "mapped", [32066]], [[127522, 127522], "mapped", [29983]], [[127523, 127523], "mapped", [36009]], [[127524, 127524], "mapped", [22768]], [[127525, 127525], "mapped", [21561]], [[127526, 127526], "mapped", [28436]], [[127527, 127527], "mapped", [25237]], [[127528, 127528], "mapped", [25429]], [[127529, 127529], "mapped", [19968]], [[127530, 127530], "mapped", [19977]], [[127531, 127531], "mapped", [36938]], [[127532, 127532], "mapped", [24038]], [[127533, 127533], "mapped", [20013]], [[127534, 127534], "mapped", [21491]], [[127535, 127535], "mapped", [25351]], [[127536, 127536], "mapped", [36208]], [[127537, 127537], "mapped", [25171]], [[127538, 127538], "mapped", [31105]], [[127539, 127539], "mapped", [31354]], [[127540, 127540], "mapped", [21512]], [[127541, 127541], "mapped", [28288]], [[127542, 127542], "mapped", [26377]], [[127543, 127543], "mapped", [26376]], [[127544, 127544], "mapped", [30003]], [[127545, 127545], "mapped", [21106]], [[127546, 127546], "mapped", [21942]], [[127547, 127551], "disallowed"], [[127552, 127552], "mapped", [12308, 26412, 12309]], [[127553, 127553], "mapped", [12308, 19977, 12309]], [[127554, 127554], "mapped", [12308, 20108, 12309]], [[127555, 127555], "mapped", [12308, 23433, 12309]], [[127556, 127556], "mapped", [12308, 28857, 12309]], [[127557, 127557], "mapped", [12308, 25171, 12309]], [[127558, 127558], "mapped", [12308, 30423, 12309]], [[127559, 127559], "mapped", [12308, 21213, 12309]], [[127560, 127560], "mapped", [12308, 25943, 12309]], [[127561, 127567], "disallowed"], [[127568, 127568], "mapped", [24471]], [[127569, 127569], "mapped", [21487]], [[127570, 127743], "disallowed"], [[127744, 127776], "valid", [], "NV8"], [[127777, 127788], "valid", [], "NV8"], [[127789, 127791], "valid", [], "NV8"], [[127792, 127797], "valid", [], "NV8"], [[127798, 127798], "valid", [], "NV8"], [[127799, 127868], "valid", [], "NV8"], [[127869, 127869], "valid", [], "NV8"], [[127870, 127871], "valid", [], "NV8"], [[127872, 127891], "valid", [], "NV8"], [[127892, 127903], "valid", [], "NV8"], [[127904, 127940], "valid", [], "NV8"], [[127941, 127941], "valid", [], "NV8"], [[127942, 127946], "valid", [], "NV8"], [[127947, 127950], "valid", [], "NV8"], [[127951, 127955], "valid", [], "NV8"], [[127956, 127967], "valid", [], "NV8"], [[127968, 127984], "valid", [], "NV8"], [[127985, 127991], "valid", [], "NV8"], [[127992, 127999], "valid", [], "NV8"], [[128e3, 128062], "valid", [], "NV8"], [[128063, 128063], "valid", [], "NV8"], [[128064, 128064], "valid", [], "NV8"], [[128065, 128065], "valid", [], "NV8"], [[128066, 128247], "valid", [], "NV8"], [[128248, 128248], "valid", [], "NV8"], [[128249, 128252], "valid", [], "NV8"], [[128253, 128254], "valid", [], "NV8"], [[128255, 128255], "valid", [], "NV8"], [[128256, 128317], "valid", [], "NV8"], [[128318, 128319], "valid", [], "NV8"], [[128320, 128323], "valid", [], "NV8"], [[128324, 128330], "valid", [], "NV8"], [[128331, 128335], "valid", [], "NV8"], [[128336, 128359], "valid", [], "NV8"], [[128360, 128377], "valid", [], "NV8"], [[128378, 128378], "disallowed"], [[128379, 128419], "valid", [], "NV8"], [[128420, 128420], "disallowed"], [[128421, 128506], "valid", [], "NV8"], [[128507, 128511], "valid", [], "NV8"], [[128512, 128512], "valid", [], "NV8"], [[128513, 128528], "valid", [], "NV8"], [[128529, 128529], "valid", [], "NV8"], [[128530, 128532], "valid", [], "NV8"], [[128533, 128533], "valid", [], "NV8"], [[128534, 128534], "valid", [], "NV8"], [[128535, 128535], "valid", [], "NV8"], [[128536, 128536], "valid", [], "NV8"], [[128537, 128537], "valid", [], "NV8"], [[128538, 128538], "valid", [], "NV8"], [[128539, 128539], "valid", [], "NV8"], [[128540, 128542], "valid", [], "NV8"], [[128543, 128543], "valid", [], "NV8"], [[128544, 128549], "valid", [], "NV8"], [[128550, 128551], "valid", [], "NV8"], [[128552, 128555], "valid", [], "NV8"], [[128556, 128556], "valid", [], "NV8"], [[128557, 128557], "valid", [], "NV8"], [[128558, 128559], "valid", [], "NV8"], [[128560, 128563], "valid", [], "NV8"], [[128564, 128564], "valid", [], "NV8"], [[128565, 128576], "valid", [], "NV8"], [[128577, 128578], "valid", [], "NV8"], [[128579, 128580], "valid", [], "NV8"], [[128581, 128591], "valid", [], "NV8"], [[128592, 128639], "valid", [], "NV8"], [[128640, 128709], "valid", [], "NV8"], [[128710, 128719], "valid", [], "NV8"], [[128720, 128720], "valid", [], "NV8"], [[128721, 128735], "disallowed"], [[128736, 128748], "valid", [], "NV8"], [[128749, 128751], "disallowed"], [[128752, 128755], "valid", [], "NV8"], [[128756, 128767], "disallowed"], [[128768, 128883], "valid", [], "NV8"], [[128884, 128895], "disallowed"], [[128896, 128980], "valid", [], "NV8"], [[128981, 129023], "disallowed"], [[129024, 129035], "valid", [], "NV8"], [[129036, 129039], "disallowed"], [[129040, 129095], "valid", [], "NV8"], [[129096, 129103], "disallowed"], [[129104, 129113], "valid", [], "NV8"], [[129114, 129119], "disallowed"], [[129120, 129159], "valid", [], "NV8"], [[129160, 129167], "disallowed"], [[129168, 129197], "valid", [], "NV8"], [[129198, 129295], "disallowed"], [[129296, 129304], "valid", [], "NV8"], [[129305, 129407], "disallowed"], [[129408, 129412], "valid", [], "NV8"], [[129413, 129471], "disallowed"], [[129472, 129472], "valid", [], "NV8"], [[129473, 131069], "disallowed"], [[131070, 131071], "disallowed"], [[131072, 173782], "valid"], [[173783, 173823], "disallowed"], [[173824, 177972], "valid"], [[177973, 177983], "disallowed"], [[177984, 178205], "valid"], [[178206, 178207], "disallowed"], [[178208, 183969], "valid"], [[183970, 194559], "disallowed"], [[194560, 194560], "mapped", [20029]], [[194561, 194561], "mapped", [20024]], [[194562, 194562], "mapped", [20033]], [[194563, 194563], "mapped", [131362]], [[194564, 194564], "mapped", [20320]], [[194565, 194565], "mapped", [20398]], [[194566, 194566], "mapped", [20411]], [[194567, 194567], "mapped", [20482]], [[194568, 194568], "mapped", [20602]], [[194569, 194569], "mapped", [20633]], [[194570, 194570], "mapped", [20711]], [[194571, 194571], "mapped", [20687]], [[194572, 194572], "mapped", [13470]], [[194573, 194573], "mapped", [132666]], [[194574, 194574], "mapped", [20813]], [[194575, 194575], "mapped", [20820]], [[194576, 194576], "mapped", [20836]], [[194577, 194577], "mapped", [20855]], [[194578, 194578], "mapped", [132380]], [[194579, 194579], "mapped", [13497]], [[194580, 194580], "mapped", [20839]], [[194581, 194581], "mapped", [20877]], [[194582, 194582], "mapped", [132427]], [[194583, 194583], "mapped", [20887]], [[194584, 194584], "mapped", [20900]], [[194585, 194585], "mapped", [20172]], [[194586, 194586], "mapped", [20908]], [[194587, 194587], "mapped", [20917]], [[194588, 194588], "mapped", [168415]], [[194589, 194589], "mapped", [20981]], [[194590, 194590], "mapped", [20995]], [[194591, 194591], "mapped", [13535]], [[194592, 194592], "mapped", [21051]], [[194593, 194593], "mapped", [21062]], [[194594, 194594], "mapped", [21106]], [[194595, 194595], "mapped", [21111]], [[194596, 194596], "mapped", [13589]], [[194597, 194597], "mapped", [21191]], [[194598, 194598], "mapped", [21193]], [[194599, 194599], "mapped", [21220]], [[194600, 194600], "mapped", [21242]], [[194601, 194601], "mapped", [21253]], [[194602, 194602], "mapped", [21254]], [[194603, 194603], "mapped", [21271]], [[194604, 194604], "mapped", [21321]], [[194605, 194605], "mapped", [21329]], [[194606, 194606], "mapped", [21338]], [[194607, 194607], "mapped", [21363]], [[194608, 194608], "mapped", [21373]], [[194609, 194611], "mapped", [21375]], [[194612, 194612], "mapped", [133676]], [[194613, 194613], "mapped", [28784]], [[194614, 194614], "mapped", [21450]], [[194615, 194615], "mapped", [21471]], [[194616, 194616], "mapped", [133987]], [[194617, 194617], "mapped", [21483]], [[194618, 194618], "mapped", [21489]], [[194619, 194619], "mapped", [21510]], [[194620, 194620], "mapped", [21662]], [[194621, 194621], "mapped", [21560]], [[194622, 194622], "mapped", [21576]], [[194623, 194623], "mapped", [21608]], [[194624, 194624], "mapped", [21666]], [[194625, 194625], "mapped", [21750]], [[194626, 194626], "mapped", [21776]], [[194627, 194627], "mapped", [21843]], [[194628, 194628], "mapped", [21859]], [[194629, 194630], "mapped", [21892]], [[194631, 194631], "mapped", [21913]], [[194632, 194632], "mapped", [21931]], [[194633, 194633], "mapped", [21939]], [[194634, 194634], "mapped", [21954]], [[194635, 194635], "mapped", [22294]], [[194636, 194636], "mapped", [22022]], [[194637, 194637], "mapped", [22295]], [[194638, 194638], "mapped", [22097]], [[194639, 194639], "mapped", [22132]], [[194640, 194640], "mapped", [20999]], [[194641, 194641], "mapped", [22766]], [[194642, 194642], "mapped", [22478]], [[194643, 194643], "mapped", [22516]], [[194644, 194644], "mapped", [22541]], [[194645, 194645], "mapped", [22411]], [[194646, 194646], "mapped", [22578]], [[194647, 194647], "mapped", [22577]], [[194648, 194648], "mapped", [22700]], [[194649, 194649], "mapped", [136420]], [[194650, 194650], "mapped", [22770]], [[194651, 194651], "mapped", [22775]], [[194652, 194652], "mapped", [22790]], [[194653, 194653], "mapped", [22810]], [[194654, 194654], "mapped", [22818]], [[194655, 194655], "mapped", [22882]], [[194656, 194656], "mapped", [136872]], [[194657, 194657], "mapped", [136938]], [[194658, 194658], "mapped", [23020]], [[194659, 194659], "mapped", [23067]], [[194660, 194660], "mapped", [23079]], [[194661, 194661], "mapped", [23e3]], [[194662, 194662], "mapped", [23142]], [[194663, 194663], "mapped", [14062]], [[194664, 194664], "disallowed"], [[194665, 194665], "mapped", [23304]], [[194666, 194667], "mapped", [23358]], [[194668, 194668], "mapped", [137672]], [[194669, 194669], "mapped", [23491]], [[194670, 194670], "mapped", [23512]], [[194671, 194671], "mapped", [23527]], [[194672, 194672], "mapped", [23539]], [[194673, 194673], "mapped", [138008]], [[194674, 194674], "mapped", [23551]], [[194675, 194675], "mapped", [23558]], [[194676, 194676], "disallowed"], [[194677, 194677], "mapped", [23586]], [[194678, 194678], "mapped", [14209]], [[194679, 194679], "mapped", [23648]], [[194680, 194680], "mapped", [23662]], [[194681, 194681], "mapped", [23744]], [[194682, 194682], "mapped", [23693]], [[194683, 194683], "mapped", [138724]], [[194684, 194684], "mapped", [23875]], [[194685, 194685], "mapped", [138726]], [[194686, 194686], "mapped", [23918]], [[194687, 194687], "mapped", [23915]], [[194688, 194688], "mapped", [23932]], [[194689, 194689], "mapped", [24033]], [[194690, 194690], "mapped", [24034]], [[194691, 194691], "mapped", [14383]], [[194692, 194692], "mapped", [24061]], [[194693, 194693], "mapped", [24104]], [[194694, 194694], "mapped", [24125]], [[194695, 194695], "mapped", [24169]], [[194696, 194696], "mapped", [14434]], [[194697, 194697], "mapped", [139651]], [[194698, 194698], "mapped", [14460]], [[194699, 194699], "mapped", [24240]], [[194700, 194700], "mapped", [24243]], [[194701, 194701], "mapped", [24246]], [[194702, 194702], "mapped", [24266]], [[194703, 194703], "mapped", [172946]], [[194704, 194704], "mapped", [24318]], [[194705, 194706], "mapped", [140081]], [[194707, 194707], "mapped", [33281]], [[194708, 194709], "mapped", [24354]], [[194710, 194710], "mapped", [14535]], [[194711, 194711], "mapped", [144056]], [[194712, 194712], "mapped", [156122]], [[194713, 194713], "mapped", [24418]], [[194714, 194714], "mapped", [24427]], [[194715, 194715], "mapped", [14563]], [[194716, 194716], "mapped", [24474]], [[194717, 194717], "mapped", [24525]], [[194718, 194718], "mapped", [24535]], [[194719, 194719], "mapped", [24569]], [[194720, 194720], "mapped", [24705]], [[194721, 194721], "mapped", [14650]], [[194722, 194722], "mapped", [14620]], [[194723, 194723], "mapped", [24724]], [[194724, 194724], "mapped", [141012]], [[194725, 194725], "mapped", [24775]], [[194726, 194726], "mapped", [24904]], [[194727, 194727], "mapped", [24908]], [[194728, 194728], "mapped", [24910]], [[194729, 194729], "mapped", [24908]], [[194730, 194730], "mapped", [24954]], [[194731, 194731], "mapped", [24974]], [[194732, 194732], "mapped", [25010]], [[194733, 194733], "mapped", [24996]], [[194734, 194734], "mapped", [25007]], [[194735, 194735], "mapped", [25054]], [[194736, 194736], "mapped", [25074]], [[194737, 194737], "mapped", [25078]], [[194738, 194738], "mapped", [25104]], [[194739, 194739], "mapped", [25115]], [[194740, 194740], "mapped", [25181]], [[194741, 194741], "mapped", [25265]], [[194742, 194742], "mapped", [25300]], [[194743, 194743], "mapped", [25424]], [[194744, 194744], "mapped", [142092]], [[194745, 194745], "mapped", [25405]], [[194746, 194746], "mapped", [25340]], [[194747, 194747], "mapped", [25448]], [[194748, 194748], "mapped", [25475]], [[194749, 194749], "mapped", [25572]], [[194750, 194750], "mapped", [142321]], [[194751, 194751], "mapped", [25634]], [[194752, 194752], "mapped", [25541]], [[194753, 194753], "mapped", [25513]], [[194754, 194754], "mapped", [14894]], [[194755, 194755], "mapped", [25705]], [[194756, 194756], "mapped", [25726]], [[194757, 194757], "mapped", [25757]], [[194758, 194758], "mapped", [25719]], [[194759, 194759], "mapped", [14956]], [[194760, 194760], "mapped", [25935]], [[194761, 194761], "mapped", [25964]], [[194762, 194762], "mapped", [143370]], [[194763, 194763], "mapped", [26083]], [[194764, 194764], "mapped", [26360]], [[194765, 194765], "mapped", [26185]], [[194766, 194766], "mapped", [15129]], [[194767, 194767], "mapped", [26257]], [[194768, 194768], "mapped", [15112]], [[194769, 194769], "mapped", [15076]], [[194770, 194770], "mapped", [20882]], [[194771, 194771], "mapped", [20885]], [[194772, 194772], "mapped", [26368]], [[194773, 194773], "mapped", [26268]], [[194774, 194774], "mapped", [32941]], [[194775, 194775], "mapped", [17369]], [[194776, 194776], "mapped", [26391]], [[194777, 194777], "mapped", [26395]], [[194778, 194778], "mapped", [26401]], [[194779, 194779], "mapped", [26462]], [[194780, 194780], "mapped", [26451]], [[194781, 194781], "mapped", [144323]], [[194782, 194782], "mapped", [15177]], [[194783, 194783], "mapped", [26618]], [[194784, 194784], "mapped", [26501]], [[194785, 194785], "mapped", [26706]], [[194786, 194786], "mapped", [26757]], [[194787, 194787], "mapped", [144493]], [[194788, 194788], "mapped", [26766]], [[194789, 194789], "mapped", [26655]], [[194790, 194790], "mapped", [26900]], [[194791, 194791], "mapped", [15261]], [[194792, 194792], "mapped", [26946]], [[194793, 194793], "mapped", [27043]], [[194794, 194794], "mapped", [27114]], [[194795, 194795], "mapped", [27304]], [[194796, 194796], "mapped", [145059]], [[194797, 194797], "mapped", [27355]], [[194798, 194798], "mapped", [15384]], [[194799, 194799], "mapped", [27425]], [[194800, 194800], "mapped", [145575]], [[194801, 194801], "mapped", [27476]], [[194802, 194802], "mapped", [15438]], [[194803, 194803], "mapped", [27506]], [[194804, 194804], "mapped", [27551]], [[194805, 194805], "mapped", [27578]], [[194806, 194806], "mapped", [27579]], [[194807, 194807], "mapped", [146061]], [[194808, 194808], "mapped", [138507]], [[194809, 194809], "mapped", [146170]], [[194810, 194810], "mapped", [27726]], [[194811, 194811], "mapped", [146620]], [[194812, 194812], "mapped", [27839]], [[194813, 194813], "mapped", [27853]], [[194814, 194814], "mapped", [27751]], [[194815, 194815], "mapped", [27926]], [[194816, 194816], "mapped", [27966]], [[194817, 194817], "mapped", [28023]], [[194818, 194818], "mapped", [27969]], [[194819, 194819], "mapped", [28009]], [[194820, 194820], "mapped", [28024]], [[194821, 194821], "mapped", [28037]], [[194822, 194822], "mapped", [146718]], [[194823, 194823], "mapped", [27956]], [[194824, 194824], "mapped", [28207]], [[194825, 194825], "mapped", [28270]], [[194826, 194826], "mapped", [15667]], [[194827, 194827], "mapped", [28363]], [[194828, 194828], "mapped", [28359]], [[194829, 194829], "mapped", [147153]], [[194830, 194830], "mapped", [28153]], [[194831, 194831], "mapped", [28526]], [[194832, 194832], "mapped", [147294]], [[194833, 194833], "mapped", [147342]], [[194834, 194834], "mapped", [28614]], [[194835, 194835], "mapped", [28729]], [[194836, 194836], "mapped", [28702]], [[194837, 194837], "mapped", [28699]], [[194838, 194838], "mapped", [15766]], [[194839, 194839], "mapped", [28746]], [[194840, 194840], "mapped", [28797]], [[194841, 194841], "mapped", [28791]], [[194842, 194842], "mapped", [28845]], [[194843, 194843], "mapped", [132389]], [[194844, 194844], "mapped", [28997]], [[194845, 194845], "mapped", [148067]], [[194846, 194846], "mapped", [29084]], [[194847, 194847], "disallowed"], [[194848, 194848], "mapped", [29224]], [[194849, 194849], "mapped", [29237]], [[194850, 194850], "mapped", [29264]], [[194851, 194851], "mapped", [149e3]], [[194852, 194852], "mapped", [29312]], [[194853, 194853], "mapped", [29333]], [[194854, 194854], "mapped", [149301]], [[194855, 194855], "mapped", [149524]], [[194856, 194856], "mapped", [29562]], [[194857, 194857], "mapped", [29579]], [[194858, 194858], "mapped", [16044]], [[194859, 194859], "mapped", [29605]], [[194860, 194861], "mapped", [16056]], [[194862, 194862], "mapped", [29767]], [[194863, 194863], "mapped", [29788]], [[194864, 194864], "mapped", [29809]], [[194865, 194865], "mapped", [29829]], [[194866, 194866], "mapped", [29898]], [[194867, 194867], "mapped", [16155]], [[194868, 194868], "mapped", [29988]], [[194869, 194869], "mapped", [150582]], [[194870, 194870], "mapped", [30014]], [[194871, 194871], "mapped", [150674]], [[194872, 194872], "mapped", [30064]], [[194873, 194873], "mapped", [139679]], [[194874, 194874], "mapped", [30224]], [[194875, 194875], "mapped", [151457]], [[194876, 194876], "mapped", [151480]], [[194877, 194877], "mapped", [151620]], [[194878, 194878], "mapped", [16380]], [[194879, 194879], "mapped", [16392]], [[194880, 194880], "mapped", [30452]], [[194881, 194881], "mapped", [151795]], [[194882, 194882], "mapped", [151794]], [[194883, 194883], "mapped", [151833]], [[194884, 194884], "mapped", [151859]], [[194885, 194885], "mapped", [30494]], [[194886, 194887], "mapped", [30495]], [[194888, 194888], "mapped", [30538]], [[194889, 194889], "mapped", [16441]], [[194890, 194890], "mapped", [30603]], [[194891, 194891], "mapped", [16454]], [[194892, 194892], "mapped", [16534]], [[194893, 194893], "mapped", [152605]], [[194894, 194894], "mapped", [30798]], [[194895, 194895], "mapped", [30860]], [[194896, 194896], "mapped", [30924]], [[194897, 194897], "mapped", [16611]], [[194898, 194898], "mapped", [153126]], [[194899, 194899], "mapped", [31062]], [[194900, 194900], "mapped", [153242]], [[194901, 194901], "mapped", [153285]], [[194902, 194902], "mapped", [31119]], [[194903, 194903], "mapped", [31211]], [[194904, 194904], "mapped", [16687]], [[194905, 194905], "mapped", [31296]], [[194906, 194906], "mapped", [31306]], [[194907, 194907], "mapped", [31311]], [[194908, 194908], "mapped", [153980]], [[194909, 194910], "mapped", [154279]], [[194911, 194911], "disallowed"], [[194912, 194912], "mapped", [16898]], [[194913, 194913], "mapped", [154539]], [[194914, 194914], "mapped", [31686]], [[194915, 194915], "mapped", [31689]], [[194916, 194916], "mapped", [16935]], [[194917, 194917], "mapped", [154752]], [[194918, 194918], "mapped", [31954]], [[194919, 194919], "mapped", [17056]], [[194920, 194920], "mapped", [31976]], [[194921, 194921], "mapped", [31971]], [[194922, 194922], "mapped", [32e3]], [[194923, 194923], "mapped", [155526]], [[194924, 194924], "mapped", [32099]], [[194925, 194925], "mapped", [17153]], [[194926, 194926], "mapped", [32199]], [[194927, 194927], "mapped", [32258]], [[194928, 194928], "mapped", [32325]], [[194929, 194929], "mapped", [17204]], [[194930, 194930], "mapped", [156200]], [[194931, 194931], "mapped", [156231]], [[194932, 194932], "mapped", [17241]], [[194933, 194933], "mapped", [156377]], [[194934, 194934], "mapped", [32634]], [[194935, 194935], "mapped", [156478]], [[194936, 194936], "mapped", [32661]], [[194937, 194937], "mapped", [32762]], [[194938, 194938], "mapped", [32773]], [[194939, 194939], "mapped", [156890]], [[194940, 194940], "mapped", [156963]], [[194941, 194941], "mapped", [32864]], [[194942, 194942], "mapped", [157096]], [[194943, 194943], "mapped", [32880]], [[194944, 194944], "mapped", [144223]], [[194945, 194945], "mapped", [17365]], [[194946, 194946], "mapped", [32946]], [[194947, 194947], "mapped", [33027]], [[194948, 194948], "mapped", [17419]], [[194949, 194949], "mapped", [33086]], [[194950, 194950], "mapped", [23221]], [[194951, 194951], "mapped", [157607]], [[194952, 194952], "mapped", [157621]], [[194953, 194953], "mapped", [144275]], [[194954, 194954], "mapped", [144284]], [[194955, 194955], "mapped", [33281]], [[194956, 194956], "mapped", [33284]], [[194957, 194957], "mapped", [36766]], [[194958, 194958], "mapped", [17515]], [[194959, 194959], "mapped", [33425]], [[194960, 194960], "mapped", [33419]], [[194961, 194961], "mapped", [33437]], [[194962, 194962], "mapped", [21171]], [[194963, 194963], "mapped", [33457]], [[194964, 194964], "mapped", [33459]], [[194965, 194965], "mapped", [33469]], [[194966, 194966], "mapped", [33510]], [[194967, 194967], "mapped", [158524]], [[194968, 194968], "mapped", [33509]], [[194969, 194969], "mapped", [33565]], [[194970, 194970], "mapped", [33635]], [[194971, 194971], "mapped", [33709]], [[194972, 194972], "mapped", [33571]], [[194973, 194973], "mapped", [33725]], [[194974, 194974], "mapped", [33767]], [[194975, 194975], "mapped", [33879]], [[194976, 194976], "mapped", [33619]], [[194977, 194977], "mapped", [33738]], [[194978, 194978], "mapped", [33740]], [[194979, 194979], "mapped", [33756]], [[194980, 194980], "mapped", [158774]], [[194981, 194981], "mapped", [159083]], [[194982, 194982], "mapped", [158933]], [[194983, 194983], "mapped", [17707]], [[194984, 194984], "mapped", [34033]], [[194985, 194985], "mapped", [34035]], [[194986, 194986], "mapped", [34070]], [[194987, 194987], "mapped", [160714]], [[194988, 194988], "mapped", [34148]], [[194989, 194989], "mapped", [159532]], [[194990, 194990], "mapped", [17757]], [[194991, 194991], "mapped", [17761]], [[194992, 194992], "mapped", [159665]], [[194993, 194993], "mapped", [159954]], [[194994, 194994], "mapped", [17771]], [[194995, 194995], "mapped", [34384]], [[194996, 194996], "mapped", [34396]], [[194997, 194997], "mapped", [34407]], [[194998, 194998], "mapped", [34409]], [[194999, 194999], "mapped", [34473]], [[195e3, 195e3], "mapped", [34440]], [[195001, 195001], "mapped", [34574]], [[195002, 195002], "mapped", [34530]], [[195003, 195003], "mapped", [34681]], [[195004, 195004], "mapped", [34600]], [[195005, 195005], "mapped", [34667]], [[195006, 195006], "mapped", [34694]], [[195007, 195007], "disallowed"], [[195008, 195008], "mapped", [34785]], [[195009, 195009], "mapped", [34817]], [[195010, 195010], "mapped", [17913]], [[195011, 195011], "mapped", [34912]], [[195012, 195012], "mapped", [34915]], [[195013, 195013], "mapped", [161383]], [[195014, 195014], "mapped", [35031]], [[195015, 195015], "mapped", [35038]], [[195016, 195016], "mapped", [17973]], [[195017, 195017], "mapped", [35066]], [[195018, 195018], "mapped", [13499]], [[195019, 195019], "mapped", [161966]], [[195020, 195020], "mapped", [162150]], [[195021, 195021], "mapped", [18110]], [[195022, 195022], "mapped", [18119]], [[195023, 195023], "mapped", [35488]], [[195024, 195024], "mapped", [35565]], [[195025, 195025], "mapped", [35722]], [[195026, 195026], "mapped", [35925]], [[195027, 195027], "mapped", [162984]], [[195028, 195028], "mapped", [36011]], [[195029, 195029], "mapped", [36033]], [[195030, 195030], "mapped", [36123]], [[195031, 195031], "mapped", [36215]], [[195032, 195032], "mapped", [163631]], [[195033, 195033], "mapped", [133124]], [[195034, 195034], "mapped", [36299]], [[195035, 195035], "mapped", [36284]], [[195036, 195036], "mapped", [36336]], [[195037, 195037], "mapped", [133342]], [[195038, 195038], "mapped", [36564]], [[195039, 195039], "mapped", [36664]], [[195040, 195040], "mapped", [165330]], [[195041, 195041], "mapped", [165357]], [[195042, 195042], "mapped", [37012]], [[195043, 195043], "mapped", [37105]], [[195044, 195044], "mapped", [37137]], [[195045, 195045], "mapped", [165678]], [[195046, 195046], "mapped", [37147]], [[195047, 195047], "mapped", [37432]], [[195048, 195048], "mapped", [37591]], [[195049, 195049], "mapped", [37592]], [[195050, 195050], "mapped", [37500]], [[195051, 195051], "mapped", [37881]], [[195052, 195052], "mapped", [37909]], [[195053, 195053], "mapped", [166906]], [[195054, 195054], "mapped", [38283]], [[195055, 195055], "mapped", [18837]], [[195056, 195056], "mapped", [38327]], [[195057, 195057], "mapped", [167287]], [[195058, 195058], "mapped", [18918]], [[195059, 195059], "mapped", [38595]], [[195060, 195060], "mapped", [23986]], [[195061, 195061], "mapped", [38691]], [[195062, 195062], "mapped", [168261]], [[195063, 195063], "mapped", [168474]], [[195064, 195064], "mapped", [19054]], [[195065, 195065], "mapped", [19062]], [[195066, 195066], "mapped", [38880]], [[195067, 195067], "mapped", [168970]], [[195068, 195068], "mapped", [19122]], [[195069, 195069], "mapped", [169110]], [[195070, 195071], "mapped", [38923]], [[195072, 195072], "mapped", [38953]], [[195073, 195073], "mapped", [169398]], [[195074, 195074], "mapped", [39138]], [[195075, 195075], "mapped", [19251]], [[195076, 195076], "mapped", [39209]], [[195077, 195077], "mapped", [39335]], [[195078, 195078], "mapped", [39362]], [[195079, 195079], "mapped", [39422]], [[195080, 195080], "mapped", [19406]], [[195081, 195081], "mapped", [170800]], [[195082, 195082], "mapped", [39698]], [[195083, 195083], "mapped", [4e4]], [[195084, 195084], "mapped", [40189]], [[195085, 195085], "mapped", [19662]], [[195086, 195086], "mapped", [19693]], [[195087, 195087], "mapped", [40295]], [[195088, 195088], "mapped", [172238]], [[195089, 195089], "mapped", [19704]], [[195090, 195090], "mapped", [172293]], [[195091, 195091], "mapped", [172558]], [[195092, 195092], "mapped", [172689]], [[195093, 195093], "mapped", [40635]], [[195094, 195094], "mapped", [19798]], [[195095, 195095], "mapped", [40697]], [[195096, 195096], "mapped", [40702]], [[195097, 195097], "mapped", [40709]], [[195098, 195098], "mapped", [40719]], [[195099, 195099], "mapped", [40726]], [[195100, 195100], "mapped", [40763]], [[195101, 195101], "mapped", [173568]], [[195102, 196605], "disallowed"], [[196606, 196607], "disallowed"], [[196608, 262141], "disallowed"], [[262142, 262143], "disallowed"], [[262144, 327677], "disallowed"], [[327678, 327679], "disallowed"], [[327680, 393213], "disallowed"], [[393214, 393215], "disallowed"], [[393216, 458749], "disallowed"], [[458750, 458751], "disallowed"], [[458752, 524285], "disallowed"], [[524286, 524287], "disallowed"], [[524288, 589821], "disallowed"], [[589822, 589823], "disallowed"], [[589824, 655357], "disallowed"], [[655358, 655359], "disallowed"], [[655360, 720893], "disallowed"], [[720894, 720895], "disallowed"], [[720896, 786429], "disallowed"], [[786430, 786431], "disallowed"], [[786432, 851965], "disallowed"], [[851966, 851967], "disallowed"], [[851968, 917501], "disallowed"], [[917502, 917503], "disallowed"], [[917504, 917504], "disallowed"], [[917505, 917505], "disallowed"], [[917506, 917535], "disallowed"], [[917536, 917631], "disallowed"], [[917632, 917759], "disallowed"], [[917760, 917999], "ignored"], [[918e3, 983037], "disallowed"], [[983038, 983039], "disallowed"], [[983040, 1048573], "disallowed"], [[1048574, 1048575], "disallowed"], [[1048576, 1114109], "disallowed"], [[1114110, 1114111], "disallowed"]];
    }
  });

  // ../../node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/index.js
  var require_tr46 = __commonJS({
    "../../node_modules/.pnpm/tr46@0.0.3/node_modules/tr46/index.js"(exports, module2) {
      "use strict";
      var punycode = __require2("punycode");
      var mappingTable = require_mappingTable();
      var PROCESSING_OPTIONS = {
        TRANSITIONAL: 0,
        NONTRANSITIONAL: 1
      };
      function normalize4(str) {
        return str.split("\0").map(function(s) {
          return s.normalize("NFC");
        }).join("\0");
      }
      function findStatus(val) {
        var start = 0;
        var end = mappingTable.length - 1;
        while (start <= end) {
          var mid = Math.floor((start + end) / 2);
          var target = mappingTable[mid];
          if (target[0][0] <= val && target[0][1] >= val) {
            return target;
          } else if (target[0][0] > val) {
            end = mid - 1;
          } else {
            start = mid + 1;
          }
        }
        return null;
      }
      var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      function countSymbols(string2) {
        return string2.replace(regexAstralSymbols, "_").length;
      }
      function mapChars(domain_name, useSTD3, processing_option) {
        var hasError = false;
        var processed = "";
        var len = countSymbols(domain_name);
        for (var i = 0; i < len; ++i) {
          var codePoint = domain_name.codePointAt(i);
          var status = findStatus(codePoint);
          switch (status[1]) {
            case "disallowed":
              hasError = true;
              processed += String.fromCodePoint(codePoint);
              break;
            case "ignored":
              break;
            case "mapped":
              processed += String.fromCodePoint.apply(String, status[2]);
              break;
            case "deviation":
              if (processing_option === PROCESSING_OPTIONS.TRANSITIONAL) {
                processed += String.fromCodePoint.apply(String, status[2]);
              } else {
                processed += String.fromCodePoint(codePoint);
              }
              break;
            case "valid":
              processed += String.fromCodePoint(codePoint);
              break;
            case "disallowed_STD3_mapped":
              if (useSTD3) {
                hasError = true;
                processed += String.fromCodePoint(codePoint);
              } else {
                processed += String.fromCodePoint.apply(String, status[2]);
              }
              break;
            case "disallowed_STD3_valid":
              if (useSTD3) {
                hasError = true;
              }
              processed += String.fromCodePoint(codePoint);
              break;
          }
        }
        return {
          string: processed,
          error: hasError
        };
      }
      var combiningMarksRegex = /[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08E4-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u18A9\u1920-\u192B\u1930-\u193B\u19B0-\u19C0\u19C8\u19C9\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFC-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C4\uA8E0-\uA8F1\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2D]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD804[\uDC00-\uDC02\uDC38-\uDC46\uDC7F-\uDC82\uDCB0-\uDCBA\uDD00-\uDD02\uDD27-\uDD34\uDD73\uDD80-\uDD82\uDDB3-\uDDC0\uDE2C-\uDE37\uDEDF-\uDEEA\uDF01-\uDF03\uDF3C\uDF3E-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF62\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDCB0-\uDCC3\uDDAF-\uDDB5\uDDB8-\uDDC0\uDE30-\uDE40\uDEAB-\uDEB7]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF51-\uDF7E\uDF8F-\uDF92]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD83A[\uDCD0-\uDCD6]|\uDB40[\uDD00-\uDDEF]/;
      function validateLabel(label, processing_option) {
        if (label.substr(0, 4) === "xn--") {
          label = punycode.toUnicode(label);
          processing_option = PROCESSING_OPTIONS.NONTRANSITIONAL;
        }
        var error2 = false;
        if (normalize4(label) !== label || label[3] === "-" && label[4] === "-" || label[0] === "-" || label[label.length - 1] === "-" || label.indexOf(".") !== -1 || label.search(combiningMarksRegex) === 0) {
          error2 = true;
        }
        var len = countSymbols(label);
        for (var i = 0; i < len; ++i) {
          var status = findStatus(label.codePointAt(i));
          if (processing === PROCESSING_OPTIONS.TRANSITIONAL && status[1] !== "valid" || processing === PROCESSING_OPTIONS.NONTRANSITIONAL && status[1] !== "valid" && status[1] !== "deviation") {
            error2 = true;
            break;
          }
        }
        return {
          label,
          error: error2
        };
      }
      function processing(domain_name, useSTD3, processing_option) {
        var result = mapChars(domain_name, useSTD3, processing_option);
        result.string = normalize4(result.string);
        var labels = result.string.split(".");
        for (var i = 0; i < labels.length; ++i) {
          try {
            var validation = validateLabel(labels[i]);
            labels[i] = validation.label;
            result.error = result.error || validation.error;
          } catch (e) {
            result.error = true;
          }
        }
        return {
          string: labels.join("."),
          error: result.error
        };
      }
      module2.exports.toASCII = function(domain_name, useSTD3, processing_option, verifyDnsLength) {
        var result = processing(domain_name, useSTD3, processing_option);
        var labels = result.string.split(".");
        labels = labels.map(function(l) {
          try {
            return punycode.toASCII(l);
          } catch (e) {
            result.error = true;
            return l;
          }
        });
        if (verifyDnsLength) {
          var total = labels.slice(0, labels.length - 1).join(".").length;
          if (total.length > 253 || total.length === 0) {
            result.error = true;
          }
          for (var i = 0; i < labels.length; ++i) {
            if (labels.length > 63 || labels.length === 0) {
              result.error = true;
              break;
            }
          }
        }
        if (result.error)
          return null;
        return labels.join(".");
      };
      module2.exports.toUnicode = function(domain_name, useSTD3) {
        var result = processing(domain_name, useSTD3, PROCESSING_OPTIONS.NONTRANSITIONAL);
        return {
          domain: result.string,
          error: result.error
        };
      };
      module2.exports.PROCESSING_OPTIONS = PROCESSING_OPTIONS;
    }
  });

  // ../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js
  var require_url_state_machine = __commonJS({
    "../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/url-state-machine.js"(exports, module2) {
      "use strict";
      var punycode = __require2("punycode");
      var tr46 = require_tr46();
      var specialSchemes = {
        ftp: 21,
        file: null,
        gopher: 70,
        http: 80,
        https: 443,
        ws: 80,
        wss: 443
      };
      var failure = Symbol("failure");
      function countSymbols(str) {
        return punycode.ucs2.decode(str).length;
      }
      function at(input, idx) {
        const c = input[idx];
        return isNaN(c) ? void 0 : String.fromCodePoint(c);
      }
      function isASCIIDigit(c) {
        return c >= 48 && c <= 57;
      }
      function isASCIIAlpha(c) {
        return c >= 65 && c <= 90 || c >= 97 && c <= 122;
      }
      function isASCIIAlphanumeric(c) {
        return isASCIIAlpha(c) || isASCIIDigit(c);
      }
      function isASCIIHex(c) {
        return isASCIIDigit(c) || c >= 65 && c <= 70 || c >= 97 && c <= 102;
      }
      function isSingleDot(buffer) {
        return buffer === "." || buffer.toLowerCase() === "%2e";
      }
      function isDoubleDot(buffer) {
        buffer = buffer.toLowerCase();
        return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
      }
      function isWindowsDriveLetterCodePoints(cp1, cp2) {
        return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
      }
      function isWindowsDriveLetterString(string2) {
        return string2.length === 2 && isASCIIAlpha(string2.codePointAt(0)) && (string2[1] === ":" || string2[1] === "|");
      }
      function isNormalizedWindowsDriveLetterString(string2) {
        return string2.length === 2 && isASCIIAlpha(string2.codePointAt(0)) && string2[1] === ":";
      }
      function containsForbiddenHostCodePoint(string2) {
        return string2.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
      }
      function containsForbiddenHostCodePointExcludingPercent(string2) {
        return string2.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
      }
      function isSpecialScheme(scheme) {
        return specialSchemes[scheme] !== void 0;
      }
      function isSpecial(url) {
        return isSpecialScheme(url.scheme);
      }
      function defaultPort(scheme) {
        return specialSchemes[scheme];
      }
      function percentEncode(c) {
        let hex = c.toString(16).toUpperCase();
        if (hex.length === 1) {
          hex = "0" + hex;
        }
        return "%" + hex;
      }
      function utf8PercentEncode(c) {
        const buf = new Buffer(c);
        let str = "";
        for (let i = 0; i < buf.length; ++i) {
          str += percentEncode(buf[i]);
        }
        return str;
      }
      function utf8PercentDecode(str) {
        const input = new Buffer(str);
        const output3 = [];
        for (let i = 0; i < input.length; ++i) {
          if (input[i] !== 37) {
            output3.push(input[i]);
          } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
            output3.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
            i += 2;
          } else {
            output3.push(input[i]);
          }
        }
        return new Buffer(output3).toString();
      }
      function isC0ControlPercentEncode(c) {
        return c <= 31 || c > 126;
      }
      var extraPathPercentEncodeSet = /* @__PURE__ */ new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
      function isPathPercentEncode(c) {
        return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
      }
      var extraUserinfoPercentEncodeSet = /* @__PURE__ */ new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
      function isUserinfoPercentEncode(c) {
        return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
      }
      function percentEncodeChar(c, encodeSetPredicate) {
        const cStr = String.fromCodePoint(c);
        if (encodeSetPredicate(c)) {
          return utf8PercentEncode(cStr);
        }
        return cStr;
      }
      function parseIPv4Number(input) {
        let R = 10;
        if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
          input = input.substring(2);
          R = 16;
        } else if (input.length >= 2 && input.charAt(0) === "0") {
          input = input.substring(1);
          R = 8;
        }
        if (input === "") {
          return 0;
        }
        const regex = R === 10 ? /[^0-9]/ : R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/;
        if (regex.test(input)) {
          return failure;
        }
        return parseInt(input, R);
      }
      function parseIPv4(input) {
        const parts = input.split(".");
        if (parts[parts.length - 1] === "") {
          if (parts.length > 1) {
            parts.pop();
          }
        }
        if (parts.length > 4) {
          return input;
        }
        const numbers = [];
        for (const part of parts) {
          if (part === "") {
            return input;
          }
          const n = parseIPv4Number(part);
          if (n === failure) {
            return input;
          }
          numbers.push(n);
        }
        for (let i = 0; i < numbers.length - 1; ++i) {
          if (numbers[i] > 255) {
            return failure;
          }
        }
        if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
          return failure;
        }
        let ipv4 = numbers.pop();
        let counter = 0;
        for (const n of numbers) {
          ipv4 += n * Math.pow(256, 3 - counter);
          ++counter;
        }
        return ipv4;
      }
      function serializeIPv4(address) {
        let output3 = "";
        let n = address;
        for (let i = 1; i <= 4; ++i) {
          output3 = String(n % 256) + output3;
          if (i !== 4) {
            output3 = "." + output3;
          }
          n = Math.floor(n / 256);
        }
        return output3;
      }
      function parseIPv6(input) {
        const address = [0, 0, 0, 0, 0, 0, 0, 0];
        let pieceIndex = 0;
        let compress = null;
        let pointer = 0;
        input = punycode.ucs2.decode(input);
        if (input[pointer] === 58) {
          if (input[pointer + 1] !== 58) {
            return failure;
          }
          pointer += 2;
          ++pieceIndex;
          compress = pieceIndex;
        }
        while (pointer < input.length) {
          if (pieceIndex === 8) {
            return failure;
          }
          if (input[pointer] === 58) {
            if (compress !== null) {
              return failure;
            }
            ++pointer;
            ++pieceIndex;
            compress = pieceIndex;
            continue;
          }
          let value = 0;
          let length = 0;
          while (length < 4 && isASCIIHex(input[pointer])) {
            value = value * 16 + parseInt(at(input, pointer), 16);
            ++pointer;
            ++length;
          }
          if (input[pointer] === 46) {
            if (length === 0) {
              return failure;
            }
            pointer -= length;
            if (pieceIndex > 6) {
              return failure;
            }
            let numbersSeen = 0;
            while (input[pointer] !== void 0) {
              let ipv4Piece = null;
              if (numbersSeen > 0) {
                if (input[pointer] === 46 && numbersSeen < 4) {
                  ++pointer;
                } else {
                  return failure;
                }
              }
              if (!isASCIIDigit(input[pointer])) {
                return failure;
              }
              while (isASCIIDigit(input[pointer])) {
                const number4 = parseInt(at(input, pointer));
                if (ipv4Piece === null) {
                  ipv4Piece = number4;
                } else if (ipv4Piece === 0) {
                  return failure;
                } else {
                  ipv4Piece = ipv4Piece * 10 + number4;
                }
                if (ipv4Piece > 255) {
                  return failure;
                }
                ++pointer;
              }
              address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
              ++numbersSeen;
              if (numbersSeen === 2 || numbersSeen === 4) {
                ++pieceIndex;
              }
            }
            if (numbersSeen !== 4) {
              return failure;
            }
            break;
          } else if (input[pointer] === 58) {
            ++pointer;
            if (input[pointer] === void 0) {
              return failure;
            }
          } else if (input[pointer] !== void 0) {
            return failure;
          }
          address[pieceIndex] = value;
          ++pieceIndex;
        }
        if (compress !== null) {
          let swaps = pieceIndex - compress;
          pieceIndex = 7;
          while (pieceIndex !== 0 && swaps > 0) {
            const temp = address[compress + swaps - 1];
            address[compress + swaps - 1] = address[pieceIndex];
            address[pieceIndex] = temp;
            --pieceIndex;
            --swaps;
          }
        } else if (compress === null && pieceIndex !== 8) {
          return failure;
        }
        return address;
      }
      function serializeIPv6(address) {
        let output3 = "";
        const seqResult = findLongestZeroSequence(address);
        const compress = seqResult.idx;
        let ignore0 = false;
        for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
          if (ignore0 && address[pieceIndex] === 0) {
            continue;
          } else if (ignore0) {
            ignore0 = false;
          }
          if (compress === pieceIndex) {
            const separator = pieceIndex === 0 ? "::" : ":";
            output3 += separator;
            ignore0 = true;
            continue;
          }
          output3 += address[pieceIndex].toString(16);
          if (pieceIndex !== 7) {
            output3 += ":";
          }
        }
        return output3;
      }
      function parseHost(input, isSpecialArg) {
        if (input[0] === "[") {
          if (input[input.length - 1] !== "]") {
            return failure;
          }
          return parseIPv6(input.substring(1, input.length - 1));
        }
        if (!isSpecialArg) {
          return parseOpaqueHost(input);
        }
        const domain = utf8PercentDecode(input);
        const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
        if (asciiDomain === null) {
          return failure;
        }
        if (containsForbiddenHostCodePoint(asciiDomain)) {
          return failure;
        }
        const ipv4Host = parseIPv4(asciiDomain);
        if (typeof ipv4Host === "number" || ipv4Host === failure) {
          return ipv4Host;
        }
        return asciiDomain;
      }
      function parseOpaqueHost(input) {
        if (containsForbiddenHostCodePointExcludingPercent(input)) {
          return failure;
        }
        let output3 = "";
        const decoded = punycode.ucs2.decode(input);
        for (let i = 0; i < decoded.length; ++i) {
          output3 += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
        }
        return output3;
      }
      function findLongestZeroSequence(arr) {
        let maxIdx = null;
        let maxLen = 1;
        let currStart = null;
        let currLen = 0;
        for (let i = 0; i < arr.length; ++i) {
          if (arr[i] !== 0) {
            if (currLen > maxLen) {
              maxIdx = currStart;
              maxLen = currLen;
            }
            currStart = null;
            currLen = 0;
          } else {
            if (currStart === null) {
              currStart = i;
            }
            ++currLen;
          }
        }
        if (currLen > maxLen) {
          maxIdx = currStart;
          maxLen = currLen;
        }
        return {
          idx: maxIdx,
          len: maxLen
        };
      }
      function serializeHost(host) {
        if (typeof host === "number") {
          return serializeIPv4(host);
        }
        if (host instanceof Array) {
          return "[" + serializeIPv6(host) + "]";
        }
        return host;
      }
      function trimControlChars(url) {
        return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
      }
      function trimTabAndNewline(url) {
        return url.replace(/\u0009|\u000A|\u000D/g, "");
      }
      function shortenPath(url) {
        const path4 = url.path;
        if (path4.length === 0) {
          return;
        }
        if (url.scheme === "file" && path4.length === 1 && isNormalizedWindowsDriveLetter(path4[0])) {
          return;
        }
        path4.pop();
      }
      function includesCredentials(url) {
        return url.username !== "" || url.password !== "";
      }
      function cannotHaveAUsernamePasswordPort(url) {
        return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
      }
      function isNormalizedWindowsDriveLetter(string2) {
        return /^[A-Za-z]:$/.test(string2);
      }
      function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
        this.pointer = 0;
        this.input = input;
        this.base = base || null;
        this.encodingOverride = encodingOverride || "utf-8";
        this.stateOverride = stateOverride;
        this.url = url;
        this.failure = false;
        this.parseError = false;
        if (!this.url) {
          this.url = {
            scheme: "",
            username: "",
            password: "",
            host: null,
            port: null,
            path: [],
            query: null,
            fragment: null,
            cannotBeABaseURL: false
          };
          const res2 = trimControlChars(this.input);
          if (res2 !== this.input) {
            this.parseError = true;
          }
          this.input = res2;
        }
        const res = trimTabAndNewline(this.input);
        if (res !== this.input) {
          this.parseError = true;
        }
        this.input = res;
        this.state = stateOverride || "scheme start";
        this.buffer = "";
        this.atFlag = false;
        this.arrFlag = false;
        this.passwordTokenSeenFlag = false;
        this.input = punycode.ucs2.decode(this.input);
        for (; this.pointer <= this.input.length; ++this.pointer) {
          const c = this.input[this.pointer];
          const cStr = isNaN(c) ? void 0 : String.fromCodePoint(c);
          const ret3 = this["parse " + this.state](c, cStr);
          if (!ret3) {
            break;
          } else if (ret3 === failure) {
            this.failure = true;
            break;
          }
        }
      }
      URLStateMachine.prototype["parse scheme start"] = function parseSchemeStart(c, cStr) {
        if (isASCIIAlpha(c)) {
          this.buffer += cStr.toLowerCase();
          this.state = "scheme";
        } else if (!this.stateOverride) {
          this.state = "no scheme";
          --this.pointer;
        } else {
          this.parseError = true;
          return failure;
        }
        return true;
      };
      URLStateMachine.prototype["parse scheme"] = function parseScheme(c, cStr) {
        if (isASCIIAlphanumeric(c) || c === 43 || c === 45 || c === 46) {
          this.buffer += cStr.toLowerCase();
        } else if (c === 58) {
          if (this.stateOverride) {
            if (isSpecial(this.url) && !isSpecialScheme(this.buffer)) {
              return false;
            }
            if (!isSpecial(this.url) && isSpecialScheme(this.buffer)) {
              return false;
            }
            if ((includesCredentials(this.url) || this.url.port !== null) && this.buffer === "file") {
              return false;
            }
            if (this.url.scheme === "file" && (this.url.host === "" || this.url.host === null)) {
              return false;
            }
          }
          this.url.scheme = this.buffer;
          this.buffer = "";
          if (this.stateOverride) {
            return false;
          }
          if (this.url.scheme === "file") {
            if (this.input[this.pointer + 1] !== 47 || this.input[this.pointer + 2] !== 47) {
              this.parseError = true;
            }
            this.state = "file";
          } else if (isSpecial(this.url) && this.base !== null && this.base.scheme === this.url.scheme) {
            this.state = "special relative or authority";
          } else if (isSpecial(this.url)) {
            this.state = "special authority slashes";
          } else if (this.input[this.pointer + 1] === 47) {
            this.state = "path or authority";
            ++this.pointer;
          } else {
            this.url.cannotBeABaseURL = true;
            this.url.path.push("");
            this.state = "cannot-be-a-base-URL path";
          }
        } else if (!this.stateOverride) {
          this.buffer = "";
          this.state = "no scheme";
          this.pointer = -1;
        } else {
          this.parseError = true;
          return failure;
        }
        return true;
      };
      URLStateMachine.prototype["parse no scheme"] = function parseNoScheme(c) {
        if (this.base === null || this.base.cannotBeABaseURL && c !== 35) {
          return failure;
        } else if (this.base.cannotBeABaseURL && c === 35) {
          this.url.scheme = this.base.scheme;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.url.cannotBeABaseURL = true;
          this.state = "fragment";
        } else if (this.base.scheme === "file") {
          this.state = "file";
          --this.pointer;
        } else {
          this.state = "relative";
          --this.pointer;
        }
        return true;
      };
      URLStateMachine.prototype["parse special relative or authority"] = function parseSpecialRelativeOrAuthority(c) {
        if (c === 47 && this.input[this.pointer + 1] === 47) {
          this.state = "special authority ignore slashes";
          ++this.pointer;
        } else {
          this.parseError = true;
          this.state = "relative";
          --this.pointer;
        }
        return true;
      };
      URLStateMachine.prototype["parse path or authority"] = function parsePathOrAuthority(c) {
        if (c === 47) {
          this.state = "authority";
        } else {
          this.state = "path";
          --this.pointer;
        }
        return true;
      };
      URLStateMachine.prototype["parse relative"] = function parseRelative(c) {
        this.url.scheme = this.base.scheme;
        if (isNaN(c)) {
          this.url.username = this.base.username;
          this.url.password = this.base.password;
          this.url.host = this.base.host;
          this.url.port = this.base.port;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
        } else if (c === 47) {
          this.state = "relative slash";
        } else if (c === 63) {
          this.url.username = this.base.username;
          this.url.password = this.base.password;
          this.url.host = this.base.host;
          this.url.port = this.base.port;
          this.url.path = this.base.path.slice();
          this.url.query = "";
          this.state = "query";
        } else if (c === 35) {
          this.url.username = this.base.username;
          this.url.password = this.base.password;
          this.url.host = this.base.host;
          this.url.port = this.base.port;
          this.url.path = this.base.path.slice();
          this.url.query = this.base.query;
          this.url.fragment = "";
          this.state = "fragment";
        } else if (isSpecial(this.url) && c === 92) {
          this.parseError = true;
          this.state = "relative slash";
        } else {
          this.url.username = this.base.username;
          this.url.password = this.base.password;
          this.url.host = this.base.host;
          this.url.port = this.base.port;
          this.url.path = this.base.path.slice(0, this.base.path.length - 1);
          this.state = "path";
          --this.pointer;
        }
        return true;
      };
      URLStateMachine.prototype["parse relative slash"] = function parseRelativeSlash(c) {
        if (isSpecial(this.url) && (c === 47 || c === 92)) {
          if (c === 92) {
            this.parseError = true;
          }
          this.state = "special authority ignore slashes";
        } else if (c === 47) {
          this.state = "authority";
        } else {
          this.url.username = this.base.username;
          this.url.password = this.base.password;
          this.url.host = this.base.host;
          this.url.port = this.base.port;
          this.state = "path";
          --this.pointer;
        }
        return true;
      };
      URLStateMachine.prototype["parse special authority slashes"] = function parseSpecialAuthoritySlashes(c) {
        if (c === 47 && this.input[this.pointer + 1] === 47) {
          this.state = "special authority ignore slashes";
          ++this.pointer;
        } else {
          this.parseError = true;
          this.state = "special authority ignore slashes";
          --this.pointer;
        }
        return true;
      };
      URLStateMachine.prototype["parse special authority ignore slashes"] = function parseSpecialAuthorityIgnoreSlashes(c) {
        if (c !== 47 && c !== 92) {
          this.state = "authority";
          --this.pointer;
        } else {
          this.parseError = true;
        }
        return true;
      };
      URLStateMachine.prototype["parse authority"] = function parseAuthority(c, cStr) {
        if (c === 64) {
          this.parseError = true;
          if (this.atFlag) {
            this.buffer = "%40" + this.buffer;
          }
          this.atFlag = true;
          const len = countSymbols(this.buffer);
          for (let pointer = 0; pointer < len; ++pointer) {
            const codePoint = this.buffer.codePointAt(pointer);
            if (codePoint === 58 && !this.passwordTokenSeenFlag) {
              this.passwordTokenSeenFlag = true;
              continue;
            }
            const encodedCodePoints = percentEncodeChar(codePoint, isUserinfoPercentEncode);
            if (this.passwordTokenSeenFlag) {
              this.url.password += encodedCodePoints;
            } else {
              this.url.username += encodedCodePoints;
            }
          }
          this.buffer = "";
        } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
          if (this.atFlag && this.buffer === "") {
            this.parseError = true;
            return failure;
          }
          this.pointer -= countSymbols(this.buffer) + 1;
          this.buffer = "";
          this.state = "host";
        } else {
          this.buffer += cStr;
        }
        return true;
      };
      URLStateMachine.prototype["parse hostname"] = URLStateMachine.prototype["parse host"] = function parseHostName(c, cStr) {
        if (this.stateOverride && this.url.scheme === "file") {
          --this.pointer;
          this.state = "file host";
        } else if (c === 58 && !this.arrFlag) {
          if (this.buffer === "") {
            this.parseError = true;
            return failure;
          }
          const host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          this.url.host = host;
          this.buffer = "";
          this.state = "port";
          if (this.stateOverride === "hostname") {
            return false;
          }
        } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92) {
          --this.pointer;
          if (isSpecial(this.url) && this.buffer === "") {
            this.parseError = true;
            return failure;
          } else if (this.stateOverride && this.buffer === "" && (includesCredentials(this.url) || this.url.port !== null)) {
            this.parseError = true;
            return false;
          }
          const host = parseHost(this.buffer, isSpecial(this.url));
          if (host === failure) {
            return failure;
          }
          this.url.host = host;
          this.buffer = "";
          this.state = "path start";
          if (this.stateOverride) {
            return false;
          }
        } else {
          if (c === 91) {
            this.arrFlag = true;
          } else if (c === 93) {
            this.arrFlag = false;
          }
          this.buffer += cStr;
        }
        return true;
      };
      URLStateMachine.prototype["parse port"] = function parsePort(c, cStr) {
        if (isASCIIDigit(c)) {
          this.buffer += cStr;
        } else if (isNaN(c) || c === 47 || c === 63 || c === 35 || isSpecial(this.url) && c === 92 || this.stateOverride) {
          if (this.buffer !== "") {
            const port = parseInt(this.buffer);
            if (port > Math.pow(2, 16) - 1) {
              this.parseError = true;
              return failure;
            }
            this.url.port = port === defaultPort(this.url.scheme) ? null : port;
            this.buffer = "";
          }
          if (this.stateOverride) {
            return false;
          }
          this.state = "path start";
          --this.pointer;
        } else {
          this.parseError = true;
          return failure;
        }
        return true;
      };
      var fileOtherwiseCodePoints = /* @__PURE__ */ new Set([47, 92, 63, 35]);
      URLStateMachine.prototype["parse file"] = function parseFile(c) {
        this.url.scheme = "file";
        if (c === 47 || c === 92) {
          if (c === 92) {
            this.parseError = true;
          }
          this.state = "file slash";
        } else if (this.base !== null && this.base.scheme === "file") {
          if (isNaN(c)) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            this.url.query = this.base.query;
          } else if (c === 63) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            this.url.query = "";
            this.state = "query";
          } else if (c === 35) {
            this.url.host = this.base.host;
            this.url.path = this.base.path.slice();
            this.url.query = this.base.query;
            this.url.fragment = "";
            this.state = "fragment";
          } else {
            if (this.input.length - this.pointer - 1 === 0 || // remaining consists of 0 code points
            !isWindowsDriveLetterCodePoints(c, this.input[this.pointer + 1]) || this.input.length - this.pointer - 1 >= 2 && // remaining has at least 2 code points
            !fileOtherwiseCodePoints.has(this.input[this.pointer + 2])) {
              this.url.host = this.base.host;
              this.url.path = this.base.path.slice();
              shortenPath(this.url);
            } else {
              this.parseError = true;
            }
            this.state = "path";
            --this.pointer;
          }
        } else {
          this.state = "path";
          --this.pointer;
        }
        return true;
      };
      URLStateMachine.prototype["parse file slash"] = function parseFileSlash(c) {
        if (c === 47 || c === 92) {
          if (c === 92) {
            this.parseError = true;
          }
          this.state = "file host";
        } else {
          if (this.base !== null && this.base.scheme === "file") {
            if (isNormalizedWindowsDriveLetterString(this.base.path[0])) {
              this.url.path.push(this.base.path[0]);
            } else {
              this.url.host = this.base.host;
            }
          }
          this.state = "path";
          --this.pointer;
        }
        return true;
      };
      URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
        if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
          --this.pointer;
          if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
            this.parseError = true;
            this.state = "path";
          } else if (this.buffer === "") {
            this.url.host = "";
            if (this.stateOverride) {
              return false;
            }
            this.state = "path start";
          } else {
            let host = parseHost(this.buffer, isSpecial(this.url));
            if (host === failure) {
              return failure;
            }
            if (host === "localhost") {
              host = "";
            }
            this.url.host = host;
            if (this.stateOverride) {
              return false;
            }
            this.buffer = "";
            this.state = "path start";
          }
        } else {
          this.buffer += cStr;
        }
        return true;
      };
      URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
        if (isSpecial(this.url)) {
          if (c === 92) {
            this.parseError = true;
          }
          this.state = "path";
          if (c !== 47 && c !== 92) {
            --this.pointer;
          }
        } else if (!this.stateOverride && c === 63) {
          this.url.query = "";
          this.state = "query";
        } else if (!this.stateOverride && c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        } else if (c !== void 0) {
          this.state = "path";
          if (c !== 47) {
            --this.pointer;
          }
        }
        return true;
      };
      URLStateMachine.prototype["parse path"] = function parsePath2(c) {
        if (isNaN(c) || c === 47 || isSpecial(this.url) && c === 92 || !this.stateOverride && (c === 63 || c === 35)) {
          if (isSpecial(this.url) && c === 92) {
            this.parseError = true;
          }
          if (isDoubleDot(this.buffer)) {
            shortenPath(this.url);
            if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
              this.url.path.push("");
            }
          } else if (isSingleDot(this.buffer) && c !== 47 && !(isSpecial(this.url) && c === 92)) {
            this.url.path.push("");
          } else if (!isSingleDot(this.buffer)) {
            if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
              if (this.url.host !== "" && this.url.host !== null) {
                this.parseError = true;
                this.url.host = "";
              }
              this.buffer = this.buffer[0] + ":";
            }
            this.url.path.push(this.buffer);
          }
          this.buffer = "";
          if (this.url.scheme === "file" && (c === void 0 || c === 63 || c === 35)) {
            while (this.url.path.length > 1 && this.url.path[0] === "") {
              this.parseError = true;
              this.url.path.shift();
            }
          }
          if (c === 63) {
            this.url.query = "";
            this.state = "query";
          }
          if (c === 35) {
            this.url.fragment = "";
            this.state = "fragment";
          }
        } else {
          if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
          }
          this.buffer += percentEncodeChar(c, isPathPercentEncode);
        }
        return true;
      };
      URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
        if (c === 63) {
          this.url.query = "";
          this.state = "query";
        } else if (c === 35) {
          this.url.fragment = "";
          this.state = "fragment";
        } else {
          if (!isNaN(c) && c !== 37) {
            this.parseError = true;
          }
          if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
          }
          if (!isNaN(c)) {
            this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
          }
        }
        return true;
      };
      URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
        if (isNaN(c) || !this.stateOverride && c === 35) {
          if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
            this.encodingOverride = "utf-8";
          }
          const buffer = new Buffer(this.buffer);
          for (let i = 0; i < buffer.length; ++i) {
            if (buffer[i] < 33 || buffer[i] > 126 || buffer[i] === 34 || buffer[i] === 35 || buffer[i] === 60 || buffer[i] === 62) {
              this.url.query += percentEncode(buffer[i]);
            } else {
              this.url.query += String.fromCodePoint(buffer[i]);
            }
          }
          this.buffer = "";
          if (c === 35) {
            this.url.fragment = "";
            this.state = "fragment";
          }
        } else {
          if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
          }
          this.buffer += cStr;
        }
        return true;
      };
      URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
        if (isNaN(c)) {
        } else if (c === 0) {
          this.parseError = true;
        } else {
          if (c === 37 && (!isASCIIHex(this.input[this.pointer + 1]) || !isASCIIHex(this.input[this.pointer + 2]))) {
            this.parseError = true;
          }
          this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
        }
        return true;
      };
      function serializeURL(url, excludeFragment) {
        let output3 = url.scheme + ":";
        if (url.host !== null) {
          output3 += "//";
          if (url.username !== "" || url.password !== "") {
            output3 += url.username;
            if (url.password !== "") {
              output3 += ":" + url.password;
            }
            output3 += "@";
          }
          output3 += serializeHost(url.host);
          if (url.port !== null) {
            output3 += ":" + url.port;
          }
        } else if (url.host === null && url.scheme === "file") {
          output3 += "//";
        }
        if (url.cannotBeABaseURL) {
          output3 += url.path[0];
        } else {
          for (const string2 of url.path) {
            output3 += "/" + string2;
          }
        }
        if (url.query !== null) {
          output3 += "?" + url.query;
        }
        if (!excludeFragment && url.fragment !== null) {
          output3 += "#" + url.fragment;
        }
        return output3;
      }
      function serializeOrigin(tuple) {
        let result = tuple.scheme + "://";
        result += serializeHost(tuple.host);
        if (tuple.port !== null) {
          result += ":" + tuple.port;
        }
        return result;
      }
      module2.exports.serializeURL = serializeURL;
      module2.exports.serializeURLOrigin = function(url) {
        switch (url.scheme) {
          case "blob":
            try {
              return module2.exports.serializeURLOrigin(module2.exports.parseURL(url.path[0]));
            } catch (e) {
              return "null";
            }
          case "ftp":
          case "gopher":
          case "http":
          case "https":
          case "ws":
          case "wss":
            return serializeOrigin({
              scheme: url.scheme,
              host: url.host,
              port: url.port
            });
          case "file":
            return "file://";
          default:
            return "null";
        }
      };
      module2.exports.basicURLParse = function(input, options) {
        if (options === void 0) {
          options = {};
        }
        const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
        if (usm.failure) {
          return "failure";
        }
        return usm.url;
      };
      module2.exports.setTheUsername = function(url, username) {
        url.username = "";
        const decoded = punycode.ucs2.decode(username);
        for (let i = 0; i < decoded.length; ++i) {
          url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
        }
      };
      module2.exports.setThePassword = function(url, password) {
        url.password = "";
        const decoded = punycode.ucs2.decode(password);
        for (let i = 0; i < decoded.length; ++i) {
          url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
        }
      };
      module2.exports.serializeHost = serializeHost;
      module2.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;
      module2.exports.serializeInteger = function(integer) {
        return String(integer);
      };
      module2.exports.parseURL = function(input, options) {
        if (options === void 0) {
          options = {};
        }
        return module2.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
      };
    }
  });

  // ../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL-impl.js
  var require_URL_impl = __commonJS({
    "../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL-impl.js"(exports) {
      "use strict";
      var usm = require_url_state_machine();
      exports.implementation = class URLImpl {
        constructor(constructorArgs) {
          const url = constructorArgs[0];
          const base = constructorArgs[1];
          let parsedBase = null;
          if (base !== void 0) {
            parsedBase = usm.basicURLParse(base);
            if (parsedBase === "failure") {
              throw new TypeError("Invalid base URL");
            }
          }
          const parsedURL = usm.basicURLParse(url, { baseURL: parsedBase });
          if (parsedURL === "failure") {
            throw new TypeError("Invalid URL");
          }
          this._url = parsedURL;
        }
        get href() {
          return usm.serializeURL(this._url);
        }
        set href(v) {
          const parsedURL = usm.basicURLParse(v);
          if (parsedURL === "failure") {
            throw new TypeError("Invalid URL");
          }
          this._url = parsedURL;
        }
        get origin() {
          return usm.serializeURLOrigin(this._url);
        }
        get protocol() {
          return this._url.scheme + ":";
        }
        set protocol(v) {
          usm.basicURLParse(v + ":", { url: this._url, stateOverride: "scheme start" });
        }
        get username() {
          return this._url.username;
        }
        set username(v) {
          if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
            return;
          }
          usm.setTheUsername(this._url, v);
        }
        get password() {
          return this._url.password;
        }
        set password(v) {
          if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
            return;
          }
          usm.setThePassword(this._url, v);
        }
        get host() {
          const url = this._url;
          if (url.host === null) {
            return "";
          }
          if (url.port === null) {
            return usm.serializeHost(url.host);
          }
          return usm.serializeHost(url.host) + ":" + usm.serializeInteger(url.port);
        }
        set host(v) {
          if (this._url.cannotBeABaseURL) {
            return;
          }
          usm.basicURLParse(v, { url: this._url, stateOverride: "host" });
        }
        get hostname() {
          if (this._url.host === null) {
            return "";
          }
          return usm.serializeHost(this._url.host);
        }
        set hostname(v) {
          if (this._url.cannotBeABaseURL) {
            return;
          }
          usm.basicURLParse(v, { url: this._url, stateOverride: "hostname" });
        }
        get port() {
          if (this._url.port === null) {
            return "";
          }
          return usm.serializeInteger(this._url.port);
        }
        set port(v) {
          if (usm.cannotHaveAUsernamePasswordPort(this._url)) {
            return;
          }
          if (v === "") {
            this._url.port = null;
          } else {
            usm.basicURLParse(v, { url: this._url, stateOverride: "port" });
          }
        }
        get pathname() {
          if (this._url.cannotBeABaseURL) {
            return this._url.path[0];
          }
          if (this._url.path.length === 0) {
            return "";
          }
          return "/" + this._url.path.join("/");
        }
        set pathname(v) {
          if (this._url.cannotBeABaseURL) {
            return;
          }
          this._url.path = [];
          usm.basicURLParse(v, { url: this._url, stateOverride: "path start" });
        }
        get search() {
          if (this._url.query === null || this._url.query === "") {
            return "";
          }
          return "?" + this._url.query;
        }
        set search(v) {
          const url = this._url;
          if (v === "") {
            url.query = null;
            return;
          }
          const input = v[0] === "?" ? v.substring(1) : v;
          url.query = "";
          usm.basicURLParse(input, { url, stateOverride: "query" });
        }
        get hash() {
          if (this._url.fragment === null || this._url.fragment === "") {
            return "";
          }
          return "#" + this._url.fragment;
        }
        set hash(v) {
          if (v === "") {
            this._url.fragment = null;
            return;
          }
          const input = v[0] === "#" ? v.substring(1) : v;
          this._url.fragment = "";
          usm.basicURLParse(input, { url: this._url, stateOverride: "fragment" });
        }
        toJSON() {
          return this.href;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL.js
  var require_URL = __commonJS({
    "../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/URL.js"(exports, module2) {
      "use strict";
      var conversions = require_lib3();
      var utils = require_utils3();
      var Impl = require_URL_impl();
      var impl = utils.implSymbol;
      function URL3(url) {
        if (!this || this[impl] || !(this instanceof URL3)) {
          throw new TypeError("Failed to construct 'URL': Please use the 'new' operator, this DOM object constructor cannot be called as a function.");
        }
        if (arguments.length < 1) {
          throw new TypeError("Failed to construct 'URL': 1 argument required, but only " + arguments.length + " present.");
        }
        const args = [];
        for (let i = 0; i < arguments.length && i < 2; ++i) {
          args[i] = arguments[i];
        }
        args[0] = conversions["USVString"](args[0]);
        if (args[1] !== void 0) {
          args[1] = conversions["USVString"](args[1]);
        }
        module2.exports.setup(this, args);
      }
      URL3.prototype.toJSON = function toJSON() {
        if (!this || !module2.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        const args = [];
        for (let i = 0; i < arguments.length && i < 0; ++i) {
          args[i] = arguments[i];
        }
        return this[impl].toJSON.apply(this[impl], args);
      };
      Object.defineProperty(URL3.prototype, "href", {
        get() {
          return this[impl].href;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].href = V;
        },
        enumerable: true,
        configurable: true
      });
      URL3.prototype.toString = function() {
        if (!this || !module2.exports.is(this)) {
          throw new TypeError("Illegal invocation");
        }
        return this.href;
      };
      Object.defineProperty(URL3.prototype, "origin", {
        get() {
          return this[impl].origin;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(URL3.prototype, "protocol", {
        get() {
          return this[impl].protocol;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].protocol = V;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(URL3.prototype, "username", {
        get() {
          return this[impl].username;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].username = V;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(URL3.prototype, "password", {
        get() {
          return this[impl].password;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].password = V;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(URL3.prototype, "host", {
        get() {
          return this[impl].host;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].host = V;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(URL3.prototype, "hostname", {
        get() {
          return this[impl].hostname;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].hostname = V;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(URL3.prototype, "port", {
        get() {
          return this[impl].port;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].port = V;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(URL3.prototype, "pathname", {
        get() {
          return this[impl].pathname;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].pathname = V;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(URL3.prototype, "search", {
        get() {
          return this[impl].search;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].search = V;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(URL3.prototype, "hash", {
        get() {
          return this[impl].hash;
        },
        set(V) {
          V = conversions["USVString"](V);
          this[impl].hash = V;
        },
        enumerable: true,
        configurable: true
      });
      module2.exports = {
        is(obj) {
          return !!obj && obj[impl] instanceof Impl.implementation;
        },
        create(constructorArgs, privateData) {
          let obj = Object.create(URL3.prototype);
          this.setup(obj, constructorArgs, privateData);
          return obj;
        },
        setup(obj, constructorArgs, privateData) {
          if (!privateData)
            privateData = {};
          privateData.wrapper = obj;
          obj[impl] = new Impl.implementation(constructorArgs, privateData);
          obj[impl][utils.wrapperSymbol] = obj;
        },
        interface: URL3,
        expose: {
          Window: { URL: URL3 },
          Worker: { URL: URL3 }
        }
      };
    }
  });

  // ../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/public-api.js
  var require_public_api = __commonJS({
    "../../node_modules/.pnpm/whatwg-url@5.0.0/node_modules/whatwg-url/lib/public-api.js"(exports) {
      "use strict";
      exports.URL = require_URL().interface;
      exports.serializeURL = require_url_state_machine().serializeURL;
      exports.serializeURLOrigin = require_url_state_machine().serializeURLOrigin;
      exports.basicURLParse = require_url_state_machine().basicURLParse;
      exports.setTheUsername = require_url_state_machine().setTheUsername;
      exports.setThePassword = require_url_state_machine().setThePassword;
      exports.serializeHost = require_url_state_machine().serializeHost;
      exports.serializeInteger = require_url_state_machine().serializeInteger;
      exports.parseURL = require_url_state_machine().parseURL;
    }
  });

  // ../../node_modules/.pnpm/node-fetch@2.6.12/node_modules/node-fetch/lib/index.mjs
  var lib_exports = {};
  __export(lib_exports, {
    FetchError: () => FetchError,
    Headers: () => Headers2,
    Request: () => Request,
    Response: () => Response2,
    default: () => lib_default
  });
  function FetchError(message, type3, systemError) {
    Error.call(this, message);
    this.message = message;
    this.type = type3;
    if (systemError) {
      this.code = this.errno = systemError.code;
    }
    Error.captureStackTrace(this, this.constructor);
  }
  function Body(body) {
    var _this = this;
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
    let size = _ref$size === void 0 ? 0 : _ref$size;
    var _ref$timeout = _ref.timeout;
    let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
    if (body == null) {
      body = null;
    } else if (isURLSearchParams(body)) {
      body = Buffer.from(body.toString());
    } else if (isBlob(body))
      ;
    else if (Buffer.isBuffer(body))
      ;
    else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      body = Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof import_stream2.default)
      ;
    else {
      body = Buffer.from(String(body));
    }
    this[INTERNALS] = {
      body,
      disturbed: false,
      error: null
    };
    this.size = size;
    this.timeout = timeout;
    if (body instanceof import_stream2.default) {
      body.on("error", function(err) {
        const error2 = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
        _this[INTERNALS].error = error2;
      });
    }
  }
  function consumeBody() {
    var _this4 = this;
    if (this[INTERNALS].disturbed) {
      return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
    }
    this[INTERNALS].disturbed = true;
    if (this[INTERNALS].error) {
      return Body.Promise.reject(this[INTERNALS].error);
    }
    let body = this.body;
    if (body === null) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    if (isBlob(body)) {
      body = body.stream();
    }
    if (Buffer.isBuffer(body)) {
      return Body.Promise.resolve(body);
    }
    if (!(body instanceof import_stream2.default)) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    let accum = [];
    let accumBytes = 0;
    let abort = false;
    return new Body.Promise(function(resolve4, reject) {
      let resTimeout;
      if (_this4.timeout) {
        resTimeout = setTimeout(function() {
          abort = true;
          reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
        }, _this4.timeout);
      }
      body.on("error", function(err) {
        if (err.name === "AbortError") {
          abort = true;
          reject(err);
        } else {
          reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
        }
      });
      body.on("data", function(chunk) {
        if (abort || chunk === null) {
          return;
        }
        if (_this4.size && accumBytes + chunk.length > _this4.size) {
          abort = true;
          reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
          return;
        }
        accumBytes += chunk.length;
        accum.push(chunk);
      });
      body.on("end", function() {
        if (abort) {
          return;
        }
        clearTimeout(resTimeout);
        try {
          resolve4(Buffer.concat(accum, accumBytes));
        } catch (err) {
          reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
        }
      });
    });
  }
  function convertBody(buffer, headers) {
    if (typeof convert !== "function") {
      throw new Error("The package `encoding` must be installed to use the textConverted() function");
    }
    const ct = headers.get("content-type");
    let charset = "utf-8";
    let res, str;
    if (ct) {
      res = /charset=([^;]*)/i.exec(ct);
    }
    str = buffer.slice(0, 1024).toString();
    if (!res && str) {
      res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
    }
    if (!res && str) {
      res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
      if (!res) {
        res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
        if (res) {
          res.pop();
        }
      }
      if (res) {
        res = /charset=(.*)/i.exec(res.pop());
      }
    }
    if (!res && str) {
      res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
    }
    if (res) {
      charset = res.pop();
      if (charset === "gb2312" || charset === "gbk") {
        charset = "gb18030";
      }
    }
    return convert(buffer, "UTF-8", charset).toString();
  }
  function isURLSearchParams(obj) {
    if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
      return false;
    }
    return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
  }
  function isBlob(obj) {
    return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
  }
  function clone3(instance) {
    let p1, p2;
    let body = instance.body;
    if (instance.bodyUsed) {
      throw new Error("cannot clone body after it is used");
    }
    if (body instanceof import_stream2.default && typeof body.getBoundary !== "function") {
      p1 = new PassThrough();
      p2 = new PassThrough();
      body.pipe(p1);
      body.pipe(p2);
      instance[INTERNALS].body = p1;
      body = p2;
    }
    return body;
  }
  function extractContentType(body) {
    if (body === null) {
      return null;
    } else if (typeof body === "string") {
      return "text/plain;charset=UTF-8";
    } else if (isURLSearchParams(body)) {
      return "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (isBlob(body)) {
      return body.type || null;
    } else if (Buffer.isBuffer(body)) {
      return null;
    } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      return null;
    } else if (ArrayBuffer.isView(body)) {
      return null;
    } else if (typeof body.getBoundary === "function") {
      return `multipart/form-data;boundary=${body.getBoundary()}`;
    } else if (body instanceof import_stream2.default) {
      return null;
    } else {
      return "text/plain;charset=UTF-8";
    }
  }
  function getTotalBytes(instance) {
    const body = instance.body;
    if (body === null) {
      return 0;
    } else if (isBlob(body)) {
      return body.size;
    } else if (Buffer.isBuffer(body)) {
      return body.length;
    } else if (body && typeof body.getLengthSync === "function") {
      if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || // 1.x
      body.hasKnownLength && body.hasKnownLength()) {
        return body.getLengthSync();
      }
      return null;
    } else {
      return null;
    }
  }
  function writeToStream(dest, instance) {
    const body = instance.body;
    if (body === null) {
      dest.end();
    } else if (isBlob(body)) {
      body.stream().pipe(dest);
    } else if (Buffer.isBuffer(body)) {
      dest.write(body);
      dest.end();
    } else {
      body.pipe(dest);
    }
  }
  function validateName(name) {
    name = `${name}`;
    if (invalidTokenRegex.test(name) || name === "") {
      throw new TypeError(`${name} is not a legal HTTP header name`);
    }
  }
  function validateValue(value) {
    value = `${value}`;
    if (invalidHeaderCharRegex.test(value)) {
      throw new TypeError(`${value} is not a legal HTTP header value`);
    }
  }
  function find(map2, name) {
    name = name.toLowerCase();
    for (const key in map2) {
      if (key.toLowerCase() === name) {
        return key;
      }
    }
    return void 0;
  }
  function getHeaders(headers) {
    let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
    const keys4 = Object.keys(headers[MAP]).sort();
    return keys4.map(kind === "key" ? function(k) {
      return k.toLowerCase();
    } : kind === "value" ? function(k) {
      return headers[MAP][k].join(", ");
    } : function(k) {
      return [k.toLowerCase(), headers[MAP][k].join(", ")];
    });
  }
  function createHeadersIterator(target, kind) {
    const iterator = Object.create(HeadersIteratorPrototype);
    iterator[INTERNAL] = {
      target,
      kind,
      index: 0
    };
    return iterator;
  }
  function exportNodeCompatibleHeaders(headers) {
    const obj = Object.assign({ __proto__: null }, headers[MAP]);
    const hostHeaderKey = find(headers[MAP], "Host");
    if (hostHeaderKey !== void 0) {
      obj[hostHeaderKey] = obj[hostHeaderKey][0];
    }
    return obj;
  }
  function createHeadersLenient(obj) {
    const headers = new Headers2();
    for (const name of Object.keys(obj)) {
      if (invalidTokenRegex.test(name)) {
        continue;
      }
      if (Array.isArray(obj[name])) {
        for (const val of obj[name]) {
          if (invalidHeaderCharRegex.test(val)) {
            continue;
          }
          if (headers[MAP][name] === void 0) {
            headers[MAP][name] = [val];
          } else {
            headers[MAP][name].push(val);
          }
        }
      } else if (!invalidHeaderCharRegex.test(obj[name])) {
        headers[MAP][name] = [obj[name]];
      }
    }
    return headers;
  }
  function parseURL(urlStr) {
    if (/^[a-zA-Z][a-zA-Z\d+\-.]*:/.exec(urlStr)) {
      urlStr = new URL2(urlStr).toString();
    }
    return parse_url(urlStr);
  }
  function isRequest(input) {
    return typeof input === "object" && typeof input[INTERNALS$2] === "object";
  }
  function isAbortSignal(signal) {
    const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
    return !!(proto && proto.constructor.name === "AbortSignal");
  }
  function getNodeRequestOptions(request) {
    const parsedURL = request[INTERNALS$2].parsedURL;
    const headers = new Headers2(request[INTERNALS$2].headers);
    if (!headers.has("Accept")) {
      headers.set("Accept", "*/*");
    }
    if (!parsedURL.protocol || !parsedURL.hostname) {
      throw new TypeError("Only absolute URLs are supported");
    }
    if (!/^https?:$/.test(parsedURL.protocol)) {
      throw new TypeError("Only HTTP(S) protocols are supported");
    }
    if (request.signal && request.body instanceof import_stream2.default.Readable && !streamDestructionSupported) {
      throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
    }
    let contentLengthValue = null;
    if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
      contentLengthValue = "0";
    }
    if (request.body != null) {
      const totalBytes = getTotalBytes(request);
      if (typeof totalBytes === "number") {
        contentLengthValue = String(totalBytes);
      }
    }
    if (contentLengthValue) {
      headers.set("Content-Length", contentLengthValue);
    }
    if (!headers.has("User-Agent")) {
      headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
    }
    if (request.compress && !headers.has("Accept-Encoding")) {
      headers.set("Accept-Encoding", "gzip,deflate");
    }
    let agent = request.agent;
    if (typeof agent === "function") {
      agent = agent(parsedURL);
    }
    if (!headers.has("Connection") && !agent) {
      headers.set("Connection", "close");
    }
    return Object.assign({}, parsedURL, {
      method: request.method,
      headers: exportNodeCompatibleHeaders(headers),
      agent
    });
  }
  function AbortError(message) {
    Error.call(this, message);
    this.type = "aborted";
    this.message = message;
    Error.captureStackTrace(this, this.constructor);
  }
  function fetch(url, opts) {
    if (!fetch.Promise) {
      throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
    }
    Body.Promise = fetch.Promise;
    return new fetch.Promise(function(resolve4, reject) {
      const request = new Request(url, opts);
      const options = getNodeRequestOptions(request);
      const send = (options.protocol === "https:" ? import_https.default : import_http.default).request;
      const signal = request.signal;
      let response = null;
      const abort = function abort2() {
        let error2 = new AbortError("The user aborted a request.");
        reject(error2);
        if (request.body && request.body instanceof import_stream2.default.Readable) {
          destroyStream(request.body, error2);
        }
        if (!response || !response.body)
          return;
        response.body.emit("error", error2);
      };
      if (signal && signal.aborted) {
        abort();
        return;
      }
      const abortAndFinalize = function abortAndFinalize2() {
        abort();
        finalize();
      };
      const req2 = send(options);
      let reqTimeout;
      if (signal) {
        signal.addEventListener("abort", abortAndFinalize);
      }
      function finalize() {
        req2.abort();
        if (signal)
          signal.removeEventListener("abort", abortAndFinalize);
        clearTimeout(reqTimeout);
      }
      if (request.timeout) {
        req2.once("socket", function(socket) {
          reqTimeout = setTimeout(function() {
            reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
            finalize();
          }, request.timeout);
        });
      }
      req2.on("error", function(err) {
        reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
        if (response && response.body) {
          destroyStream(response.body, err);
        }
        finalize();
      });
      fixResponseChunkedTransferBadEnding(req2, function(err) {
        if (signal && signal.aborted) {
          return;
        }
        if (response && response.body) {
          destroyStream(response.body, err);
        }
      });
      if (parseInt(process.version.substring(1)) < 14) {
        req2.on("socket", function(s) {
          s.addListener("close", function(hadError) {
            const hasDataListener = s.listenerCount("data") > 0;
            if (response && hasDataListener && !hadError && !(signal && signal.aborted)) {
              const err = new Error("Premature close");
              err.code = "ERR_STREAM_PREMATURE_CLOSE";
              response.body.emit("error", err);
            }
          });
        });
      }
      req2.on("response", function(res) {
        clearTimeout(reqTimeout);
        const headers = createHeadersLenient(res.headers);
        if (fetch.isRedirect(res.statusCode)) {
          const location = headers.get("Location");
          let locationURL = null;
          try {
            locationURL = location === null ? null : new URL$1(location, request.url).toString();
          } catch (err) {
            if (request.redirect !== "manual") {
              reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, "invalid-redirect"));
              finalize();
              return;
            }
          }
          switch (request.redirect) {
            case "error":
              reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
              finalize();
              return;
            case "manual":
              if (locationURL !== null) {
                try {
                  headers.set("Location", locationURL);
                } catch (err) {
                  reject(err);
                }
              }
              break;
            case "follow":
              if (locationURL === null) {
                break;
              }
              if (request.counter >= request.follow) {
                reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                finalize();
                return;
              }
              const requestOpts = {
                headers: new Headers2(request.headers),
                follow: request.follow,
                counter: request.counter + 1,
                agent: request.agent,
                compress: request.compress,
                method: request.method,
                body: request.body,
                signal: request.signal,
                timeout: request.timeout,
                size: request.size
              };
              if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
                for (const name of ["authorization", "www-authenticate", "cookie", "cookie2"]) {
                  requestOpts.headers.delete(name);
                }
              }
              if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                finalize();
                return;
              }
              if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                requestOpts.method = "GET";
                requestOpts.body = void 0;
                requestOpts.headers.delete("content-length");
              }
              resolve4(fetch(new Request(locationURL, requestOpts)));
              finalize();
              return;
          }
        }
        res.once("end", function() {
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
        });
        let body = res.pipe(new PassThrough$1());
        const response_options = {
          url: request.url,
          status: res.statusCode,
          statusText: res.statusMessage,
          headers,
          size: request.size,
          timeout: request.timeout,
          counter: request.counter
        };
        const codings = headers.get("Content-Encoding");
        if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
          response = new Response2(body, response_options);
          resolve4(response);
          return;
        }
        const zlibOptions = {
          flush: import_zlib.default.Z_SYNC_FLUSH,
          finishFlush: import_zlib.default.Z_SYNC_FLUSH
        };
        if (codings == "gzip" || codings == "x-gzip") {
          body = body.pipe(import_zlib.default.createGunzip(zlibOptions));
          response = new Response2(body, response_options);
          resolve4(response);
          return;
        }
        if (codings == "deflate" || codings == "x-deflate") {
          const raw = res.pipe(new PassThrough$1());
          raw.once("data", function(chunk) {
            if ((chunk[0] & 15) === 8) {
              body = body.pipe(import_zlib.default.createInflate());
            } else {
              body = body.pipe(import_zlib.default.createInflateRaw());
            }
            response = new Response2(body, response_options);
            resolve4(response);
          });
          raw.on("end", function() {
            if (!response) {
              response = new Response2(body, response_options);
              resolve4(response);
            }
          });
          return;
        }
        if (codings == "br" && typeof import_zlib.default.createBrotliDecompress === "function") {
          body = body.pipe(import_zlib.default.createBrotliDecompress());
          response = new Response2(body, response_options);
          resolve4(response);
          return;
        }
        response = new Response2(body, response_options);
        resolve4(response);
      });
      writeToStream(req2, request);
    });
  }
  function fixResponseChunkedTransferBadEnding(request, errorCallback) {
    let socket;
    request.on("socket", function(s) {
      socket = s;
    });
    request.on("response", function(response) {
      const headers = response.headers;
      if (headers["transfer-encoding"] === "chunked" && !headers["content-length"]) {
        response.once("close", function(hadError) {
          const hasDataListener = socket && socket.listenerCount("data") > 0;
          if (hasDataListener && !hadError) {
            const err = new Error("Premature close");
            err.code = "ERR_STREAM_PREMATURE_CLOSE";
            errorCallback(err);
          }
        });
      }
    });
  }
  function destroyStream(stream2, err) {
    if (stream2.destroy) {
      stream2.destroy(err);
    } else {
      stream2.emit("error", err);
      stream2.end();
    }
  }
  var import_stream2, import_http, import_url3, import_whatwg_url, import_https, import_zlib, Readable, BUFFER2, TYPE2, Blob2, convert, INTERNALS, PassThrough, invalidTokenRegex, invalidHeaderCharRegex, MAP, Headers2, INTERNAL, HeadersIteratorPrototype, INTERNALS$1, STATUS_CODES, Response2, INTERNALS$2, URL2, parse_url, format_url, streamDestructionSupported, Request, URL$1, PassThrough$1, isDomainOrSubdomain, isSameProtocol, lib_default;
  var init_lib = __esm({
    "../../node_modules/.pnpm/node-fetch@2.6.12/node_modules/node-fetch/lib/index.mjs"() {
      import_stream2 = __toESM(__require2("stream"), 1);
      import_http = __toESM(__require2("http"), 1);
      import_url3 = __toESM(__require2("url"), 1);
      import_whatwg_url = __toESM(require_public_api(), 1);
      import_https = __toESM(__require2("https"), 1);
      import_zlib = __toESM(__require2("zlib"), 1);
      Readable = import_stream2.default.Readable;
      BUFFER2 = Symbol("buffer");
      TYPE2 = Symbol("type");
      Blob2 = class {
        constructor() {
          this[TYPE2] = "";
          const blobParts = arguments[0];
          const options = arguments[1];
          const buffers = [];
          let size = 0;
          if (blobParts) {
            const a = blobParts;
            const length = Number(a.length);
            for (let i = 0; i < length; i++) {
              const element = a[i];
              let buffer;
              if (element instanceof Buffer) {
                buffer = element;
              } else if (ArrayBuffer.isView(element)) {
                buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
              } else if (element instanceof ArrayBuffer) {
                buffer = Buffer.from(element);
              } else if (element instanceof Blob2) {
                buffer = element[BUFFER2];
              } else {
                buffer = Buffer.from(typeof element === "string" ? element : String(element));
              }
              size += buffer.length;
              buffers.push(buffer);
            }
          }
          this[BUFFER2] = Buffer.concat(buffers);
          let type3 = options && options.type !== void 0 && String(options.type).toLowerCase();
          if (type3 && !/[^\u0020-\u007E]/.test(type3)) {
            this[TYPE2] = type3;
          }
        }
        get size() {
          return this[BUFFER2].length;
        }
        get type() {
          return this[TYPE2];
        }
        text() {
          return Promise.resolve(this[BUFFER2].toString());
        }
        arrayBuffer() {
          const buf = this[BUFFER2];
          const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
          return Promise.resolve(ab);
        }
        stream() {
          const readable = new Readable();
          readable._read = function() {
          };
          readable.push(this[BUFFER2]);
          readable.push(null);
          return readable;
        }
        toString() {
          return "[object Blob]";
        }
        slice() {
          const size = this.size;
          const start = arguments[0];
          const end = arguments[1];
          let relativeStart, relativeEnd;
          if (start === void 0) {
            relativeStart = 0;
          } else if (start < 0) {
            relativeStart = Math.max(size + start, 0);
          } else {
            relativeStart = Math.min(start, size);
          }
          if (end === void 0) {
            relativeEnd = size;
          } else if (end < 0) {
            relativeEnd = Math.max(size + end, 0);
          } else {
            relativeEnd = Math.min(end, size);
          }
          const span = Math.max(relativeEnd - relativeStart, 0);
          const buffer = this[BUFFER2];
          const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
          const blob = new Blob2([], { type: arguments[2] });
          blob[BUFFER2] = slicedBuffer;
          return blob;
        }
      };
      Object.defineProperties(Blob2.prototype, {
        size: { enumerable: true },
        type: { enumerable: true },
        slice: { enumerable: true }
      });
      Object.defineProperty(Blob2.prototype, Symbol.toStringTag, {
        value: "Blob",
        writable: false,
        enumerable: false,
        configurable: true
      });
      FetchError.prototype = Object.create(Error.prototype);
      FetchError.prototype.constructor = FetchError;
      FetchError.prototype.name = "FetchError";
      try {
        convert = __require2("encoding").convert;
      } catch (e) {
      }
      INTERNALS = Symbol("Body internals");
      PassThrough = import_stream2.default.PassThrough;
      Body.prototype = {
        get body() {
          return this[INTERNALS].body;
        },
        get bodyUsed() {
          return this[INTERNALS].disturbed;
        },
        /**
         * Decode response as ArrayBuffer
         *
         * @return  Promise
         */
        arrayBuffer() {
          return consumeBody.call(this).then(function(buf) {
            return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
          });
        },
        /**
         * Return raw response as Blob
         *
         * @return Promise
         */
        blob() {
          let ct = this.headers && this.headers.get("content-type") || "";
          return consumeBody.call(this).then(function(buf) {
            return Object.assign(
              // Prevent copying
              new Blob2([], {
                type: ct.toLowerCase()
              }),
              {
                [BUFFER2]: buf
              }
            );
          });
        },
        /**
         * Decode response as json
         *
         * @return  Promise
         */
        json() {
          var _this2 = this;
          return consumeBody.call(this).then(function(buffer) {
            try {
              return JSON.parse(buffer.toString());
            } catch (err) {
              return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
            }
          });
        },
        /**
         * Decode response as text
         *
         * @return  Promise
         */
        text() {
          return consumeBody.call(this).then(function(buffer) {
            return buffer.toString();
          });
        },
        /**
         * Decode response as buffer (non-spec api)
         *
         * @return  Promise
         */
        buffer() {
          return consumeBody.call(this);
        },
        /**
         * Decode response as text, while automatically detecting the encoding and
         * trying to decode to UTF-8 (non-spec api)
         *
         * @return  Promise
         */
        textConverted() {
          var _this3 = this;
          return consumeBody.call(this).then(function(buffer) {
            return convertBody(buffer, _this3.headers);
          });
        }
      };
      Object.defineProperties(Body.prototype, {
        body: { enumerable: true },
        bodyUsed: { enumerable: true },
        arrayBuffer: { enumerable: true },
        blob: { enumerable: true },
        json: { enumerable: true },
        text: { enumerable: true }
      });
      Body.mixIn = function(proto) {
        for (const name of Object.getOwnPropertyNames(Body.prototype)) {
          if (!(name in proto)) {
            const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
            Object.defineProperty(proto, name, desc);
          }
        }
      };
      Body.Promise = global.Promise;
      invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
      invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
      MAP = Symbol("map");
      Headers2 = class {
        /**
         * Headers class
         *
         * @param   Object  headers  Response headers
         * @return  Void
         */
        constructor() {
          let init2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
          this[MAP] = /* @__PURE__ */ Object.create(null);
          if (init2 instanceof Headers2) {
            const rawHeaders = init2.raw();
            const headerNames = Object.keys(rawHeaders);
            for (const headerName of headerNames) {
              for (const value of rawHeaders[headerName]) {
                this.append(headerName, value);
              }
            }
            return;
          }
          if (init2 == null)
            ;
          else if (typeof init2 === "object") {
            const method = init2[Symbol.iterator];
            if (method != null) {
              if (typeof method !== "function") {
                throw new TypeError("Header pairs must be iterable");
              }
              const pairs = [];
              for (const pair of init2) {
                if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
                  throw new TypeError("Each header pair must be iterable");
                }
                pairs.push(Array.from(pair));
              }
              for (const pair of pairs) {
                if (pair.length !== 2) {
                  throw new TypeError("Each header pair must be a name/value tuple");
                }
                this.append(pair[0], pair[1]);
              }
            } else {
              for (const key of Object.keys(init2)) {
                const value = init2[key];
                this.append(key, value);
              }
            }
          } else {
            throw new TypeError("Provided initializer must be an object");
          }
        }
        /**
         * Return combined header value given name
         *
         * @param   String  name  Header name
         * @return  Mixed
         */
        get(name) {
          name = `${name}`;
          validateName(name);
          const key = find(this[MAP], name);
          if (key === void 0) {
            return null;
          }
          return this[MAP][key].join(", ");
        }
        /**
         * Iterate over all headers
         *
         * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)
         * @param   Boolean   thisArg   `this` context for callback function
         * @return  Void
         */
        forEach(callback) {
          let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
          let pairs = getHeaders(this);
          let i = 0;
          while (i < pairs.length) {
            var _pairs$i = pairs[i];
            const name = _pairs$i[0], value = _pairs$i[1];
            callback.call(thisArg, value, name, this);
            pairs = getHeaders(this);
            i++;
          }
        }
        /**
         * Overwrite header values given name
         *
         * @param   String  name   Header name
         * @param   String  value  Header value
         * @return  Void
         */
        set(name, value) {
          name = `${name}`;
          value = `${value}`;
          validateName(name);
          validateValue(value);
          const key = find(this[MAP], name);
          this[MAP][key !== void 0 ? key : name] = [value];
        }
        /**
         * Append a value onto existing header
         *
         * @param   String  name   Header name
         * @param   String  value  Header value
         * @return  Void
         */
        append(name, value) {
          name = `${name}`;
          value = `${value}`;
          validateName(name);
          validateValue(value);
          const key = find(this[MAP], name);
          if (key !== void 0) {
            this[MAP][key].push(value);
          } else {
            this[MAP][name] = [value];
          }
        }
        /**
         * Check for header name existence
         *
         * @param   String   name  Header name
         * @return  Boolean
         */
        has(name) {
          name = `${name}`;
          validateName(name);
          return find(this[MAP], name) !== void 0;
        }
        /**
         * Delete all header values given name
         *
         * @param   String  name  Header name
         * @return  Void
         */
        delete(name) {
          name = `${name}`;
          validateName(name);
          const key = find(this[MAP], name);
          if (key !== void 0) {
            delete this[MAP][key];
          }
        }
        /**
         * Return raw headers (non-spec api)
         *
         * @return  Object
         */
        raw() {
          return this[MAP];
        }
        /**
         * Get an iterator on keys.
         *
         * @return  Iterator
         */
        keys() {
          return createHeadersIterator(this, "key");
        }
        /**
         * Get an iterator on values.
         *
         * @return  Iterator
         */
        values() {
          return createHeadersIterator(this, "value");
        }
        /**
         * Get an iterator on entries.
         *
         * This is the default iterator of the Headers object.
         *
         * @return  Iterator
         */
        [Symbol.iterator]() {
          return createHeadersIterator(this, "key+value");
        }
      };
      Headers2.prototype.entries = Headers2.prototype[Symbol.iterator];
      Object.defineProperty(Headers2.prototype, Symbol.toStringTag, {
        value: "Headers",
        writable: false,
        enumerable: false,
        configurable: true
      });
      Object.defineProperties(Headers2.prototype, {
        get: { enumerable: true },
        forEach: { enumerable: true },
        set: { enumerable: true },
        append: { enumerable: true },
        has: { enumerable: true },
        delete: { enumerable: true },
        keys: { enumerable: true },
        values: { enumerable: true },
        entries: { enumerable: true }
      });
      INTERNAL = Symbol("internal");
      HeadersIteratorPrototype = Object.setPrototypeOf({
        next() {
          if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
            throw new TypeError("Value of `this` is not a HeadersIterator");
          }
          var _INTERNAL = this[INTERNAL];
          const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
          const values = getHeaders(target, kind);
          const len = values.length;
          if (index >= len) {
            return {
              value: void 0,
              done: true
            };
          }
          this[INTERNAL].index = index + 1;
          return {
            value: values[index],
            done: false
          };
        }
      }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
      Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
        value: "HeadersIterator",
        writable: false,
        enumerable: false,
        configurable: true
      });
      INTERNALS$1 = Symbol("Response internals");
      STATUS_CODES = import_http.default.STATUS_CODES;
      Response2 = class {
        constructor() {
          let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
          let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          Body.call(this, body, opts);
          const status = opts.status || 200;
          const headers = new Headers2(opts.headers);
          if (body != null && !headers.has("Content-Type")) {
            const contentType = extractContentType(body);
            if (contentType) {
              headers.append("Content-Type", contentType);
            }
          }
          this[INTERNALS$1] = {
            url: opts.url,
            status,
            statusText: opts.statusText || STATUS_CODES[status],
            headers,
            counter: opts.counter
          };
        }
        get url() {
          return this[INTERNALS$1].url || "";
        }
        get status() {
          return this[INTERNALS$1].status;
        }
        /**
         * Convenience property representing if the request ended normally
         */
        get ok() {
          return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
        }
        get redirected() {
          return this[INTERNALS$1].counter > 0;
        }
        get statusText() {
          return this[INTERNALS$1].statusText;
        }
        get headers() {
          return this[INTERNALS$1].headers;
        }
        /**
         * Clone this response
         *
         * @return  Response
         */
        clone() {
          return new Response2(clone3(this), {
            url: this.url,
            status: this.status,
            statusText: this.statusText,
            headers: this.headers,
            ok: this.ok,
            redirected: this.redirected
          });
        }
      };
      Body.mixIn(Response2.prototype);
      Object.defineProperties(Response2.prototype, {
        url: { enumerable: true },
        status: { enumerable: true },
        ok: { enumerable: true },
        redirected: { enumerable: true },
        statusText: { enumerable: true },
        headers: { enumerable: true },
        clone: { enumerable: true }
      });
      Object.defineProperty(Response2.prototype, Symbol.toStringTag, {
        value: "Response",
        writable: false,
        enumerable: false,
        configurable: true
      });
      INTERNALS$2 = Symbol("Request internals");
      URL2 = import_url3.default.URL || import_whatwg_url.default.URL;
      parse_url = import_url3.default.parse;
      format_url = import_url3.default.format;
      streamDestructionSupported = "destroy" in import_stream2.default.Readable.prototype;
      Request = class {
        constructor(input) {
          let init2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          let parsedURL;
          if (!isRequest(input)) {
            if (input && input.href) {
              parsedURL = parseURL(input.href);
            } else {
              parsedURL = parseURL(`${input}`);
            }
            input = {};
          } else {
            parsedURL = parseURL(input.url);
          }
          let method = init2.method || input.method || "GET";
          method = method.toUpperCase();
          if ((init2.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
            throw new TypeError("Request with GET/HEAD method cannot have body");
          }
          let inputBody = init2.body != null ? init2.body : isRequest(input) && input.body !== null ? clone3(input) : null;
          Body.call(this, inputBody, {
            timeout: init2.timeout || input.timeout || 0,
            size: init2.size || input.size || 0
          });
          const headers = new Headers2(init2.headers || input.headers || {});
          if (inputBody != null && !headers.has("Content-Type")) {
            const contentType = extractContentType(inputBody);
            if (contentType) {
              headers.append("Content-Type", contentType);
            }
          }
          let signal = isRequest(input) ? input.signal : null;
          if ("signal" in init2)
            signal = init2.signal;
          if (signal != null && !isAbortSignal(signal)) {
            throw new TypeError("Expected signal to be an instanceof AbortSignal");
          }
          this[INTERNALS$2] = {
            method,
            redirect: init2.redirect || input.redirect || "follow",
            headers,
            parsedURL,
            signal
          };
          this.follow = init2.follow !== void 0 ? init2.follow : input.follow !== void 0 ? input.follow : 20;
          this.compress = init2.compress !== void 0 ? init2.compress : input.compress !== void 0 ? input.compress : true;
          this.counter = init2.counter || input.counter || 0;
          this.agent = init2.agent || input.agent;
        }
        get method() {
          return this[INTERNALS$2].method;
        }
        get url() {
          return format_url(this[INTERNALS$2].parsedURL);
        }
        get headers() {
          return this[INTERNALS$2].headers;
        }
        get redirect() {
          return this[INTERNALS$2].redirect;
        }
        get signal() {
          return this[INTERNALS$2].signal;
        }
        /**
         * Clone this request
         *
         * @return  Request
         */
        clone() {
          return new Request(this);
        }
      };
      Body.mixIn(Request.prototype);
      Object.defineProperty(Request.prototype, Symbol.toStringTag, {
        value: "Request",
        writable: false,
        enumerable: false,
        configurable: true
      });
      Object.defineProperties(Request.prototype, {
        method: { enumerable: true },
        url: { enumerable: true },
        headers: { enumerable: true },
        redirect: { enumerable: true },
        clone: { enumerable: true },
        signal: { enumerable: true }
      });
      AbortError.prototype = Object.create(Error.prototype);
      AbortError.prototype.constructor = AbortError;
      AbortError.prototype.name = "AbortError";
      URL$1 = import_url3.default.URL || import_whatwg_url.default.URL;
      PassThrough$1 = import_stream2.default.PassThrough;
      isDomainOrSubdomain = function isDomainOrSubdomain2(destination, original) {
        const orig = new URL$1(original).hostname;
        const dest = new URL$1(destination).hostname;
        return orig === dest || orig[orig.length - dest.length - 1] === "." && orig.endsWith(dest);
      };
      isSameProtocol = function isSameProtocol2(destination, original) {
        const orig = new URL$1(original).protocol;
        const dest = new URL$1(destination).protocol;
        return orig === dest;
      };
      fetch.isRedirect = function(code) {
        return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
      };
      fetch.Promise = global.Promise;
      lib_default = fetch;
    }
  });

  // ../../node_modules/.pnpm/cross-fetch@4.0.0/node_modules/cross-fetch/dist/node-ponyfill.js
  var require_node_ponyfill = __commonJS({
    "../../node_modules/.pnpm/cross-fetch@4.0.0/node_modules/cross-fetch/dist/node-ponyfill.js"(exports, module2) {
      var nodeFetch = (init_lib(), __toCommonJS(lib_exports));
      var realFetch = nodeFetch.default || nodeFetch;
      var fetch2 = function(url, options) {
        if (/^\/\//.test(url)) {
          url = "https:" + url;
        }
        return realFetch.call(this, url, options);
      };
      fetch2.ponyfill = true;
      module2.exports = exports = fetch2;
      exports.fetch = fetch2;
      exports.Headers = nodeFetch.Headers;
      exports.Request = nodeFetch.Request;
      exports.Response = nodeFetch.Response;
      exports.default = fetch2;
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/isObjectLike.js
  var require_isObjectLike = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/isObjectLike.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isObjectLike = isObjectLike2;
      function isObjectLike2(value) {
        return typeof value == "object" && value !== null;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/invariant.js
  var require_invariant = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/invariant.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.invariant = invariant2;
      function invariant2(condition, message) {
        const booleanCondition = Boolean(condition);
        if (!booleanCondition) {
          throw new Error(
            message != null ? message : "Unexpected invariant triggered."
          );
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/location.js
  var require_location = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/location.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.getLocation = getLocation2;
      var _invariant = require_invariant();
      var LineRegExp2 = /\r\n|[\n\r]/g;
      function getLocation2(source, position) {
        let lastLineStart = 0;
        let line = 1;
        for (const match3 of source.body.matchAll(LineRegExp2)) {
          typeof match3.index === "number" || (0, _invariant.invariant)(false);
          if (match3.index >= position) {
            break;
          }
          lastLineStart = match3.index + match3[0].length;
          line += 1;
        }
        return {
          line,
          column: position + 1 - lastLineStart
        };
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/printLocation.js
  var require_printLocation = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/printLocation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.printLocation = printLocation2;
      exports.printSourceLocation = printSourceLocation2;
      var _location = require_location();
      function printLocation2(location) {
        return printSourceLocation2(
          location.source,
          (0, _location.getLocation)(location.source, location.start)
        );
      }
      function printSourceLocation2(source, sourceLocation) {
        const firstLineColumnOffset = source.locationOffset.column - 1;
        const body = "".padStart(firstLineColumnOffset) + source.body;
        const lineIndex = sourceLocation.line - 1;
        const lineOffset = source.locationOffset.line - 1;
        const lineNum = sourceLocation.line + lineOffset;
        const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
        const columnNum = sourceLocation.column + columnOffset;
        const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
        const lines = body.split(/\r\n|[\n\r]/g);
        const locationLine = lines[lineIndex];
        if (locationLine.length > 120) {
          const subLineIndex = Math.floor(columnNum / 80);
          const subLineColumnNum = columnNum % 80;
          const subLines = [];
          for (let i = 0; i < locationLine.length; i += 80) {
            subLines.push(locationLine.slice(i, i + 80));
          }
          return locationStr + printPrefixedLines2([
            [`${lineNum} |`, subLines[0]],
            ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
            ["|", "^".padStart(subLineColumnNum)],
            ["|", subLines[subLineIndex + 1]]
          ]);
        }
        return locationStr + printPrefixedLines2([
          // Lines specified like this: ["prefix", "string"],
          [`${lineNum - 1} |`, lines[lineIndex - 1]],
          [`${lineNum} |`, locationLine],
          ["|", "^".padStart(columnNum)],
          [`${lineNum + 1} |`, lines[lineIndex + 1]]
        ]);
      }
      function printPrefixedLines2(lines) {
        const existingLines = lines.filter(([_, line]) => line !== void 0);
        const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
        return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/error/GraphQLError.js
  var require_GraphQLError = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/error/GraphQLError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.GraphQLError = void 0;
      exports.formatError = formatError;
      exports.printError = printError;
      var _isObjectLike = require_isObjectLike();
      var _location = require_location();
      var _printLocation = require_printLocation();
      function toNormalizedOptions2(args) {
        const firstArg = args[0];
        if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
          return {
            nodes: firstArg,
            source: args[1],
            positions: args[2],
            path: args[3],
            originalError: args[4],
            extensions: args[5]
          };
        }
        return firstArg;
      }
      var GraphQLError2 = class extends Error {
        /**
         * An array of `{ line, column }` locations within the source GraphQL document
         * which correspond to this error.
         *
         * Errors during validation often contain multiple locations, for example to
         * point out two things with the same name. Errors during execution include a
         * single location, the field which produced the error.
         *
         * Enumerable, and appears in the result of JSON.stringify().
         */
        /**
         * An array describing the JSON-path into the execution response which
         * corresponds to this error. Only included for errors during execution.
         *
         * Enumerable, and appears in the result of JSON.stringify().
         */
        /**
         * An array of GraphQL AST Nodes corresponding to this error.
         */
        /**
         * The source GraphQL document for the first location of this error.
         *
         * Note that if this Error represents more than one node, the source may not
         * represent nodes after the first node.
         */
        /**
         * An array of character offsets within the source GraphQL document
         * which correspond to this error.
         */
        /**
         * The original error thrown from a field resolver during execution.
         */
        /**
         * Extension fields to add to the formatted error.
         */
        /**
         * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
         */
        constructor(message, ...rawArgs) {
          var _this$nodes, _nodeLocations$, _ref;
          const { nodes, source, positions, path: path4, originalError, extensions } = toNormalizedOptions2(rawArgs);
          super(message);
          this.name = "GraphQLError";
          this.path = path4 !== null && path4 !== void 0 ? path4 : void 0;
          this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
          this.nodes = undefinedIfEmpty2(
            Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
          );
          const nodeLocations = undefinedIfEmpty2(
            (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
          );
          this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
          this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
          this.locations = positions && source ? positions.map((pos) => (0, _location.getLocation)(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map(
            (loc) => (0, _location.getLocation)(loc.source, loc.start)
          );
          const originalExtensions = (0, _isObjectLike.isObjectLike)(
            originalError === null || originalError === void 0 ? void 0 : originalError.extensions
          ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
          this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
          Object.defineProperties(this, {
            message: {
              writable: true,
              enumerable: true
            },
            name: {
              enumerable: false
            },
            nodes: {
              enumerable: false
            },
            source: {
              enumerable: false
            },
            positions: {
              enumerable: false
            },
            originalError: {
              enumerable: false
            }
          });
          if (originalError !== null && originalError !== void 0 && originalError.stack) {
            Object.defineProperty(this, "stack", {
              value: originalError.stack,
              writable: true,
              configurable: true
            });
          } else if (Error.captureStackTrace) {
            Error.captureStackTrace(this, GraphQLError2);
          } else {
            Object.defineProperty(this, "stack", {
              value: Error().stack,
              writable: true,
              configurable: true
            });
          }
        }
        get [Symbol.toStringTag]() {
          return "GraphQLError";
        }
        toString() {
          let output3 = this.message;
          if (this.nodes) {
            for (const node of this.nodes) {
              if (node.loc) {
                output3 += "\n\n" + (0, _printLocation.printLocation)(node.loc);
              }
            }
          } else if (this.source && this.locations) {
            for (const location of this.locations) {
              output3 += "\n\n" + (0, _printLocation.printSourceLocation)(this.source, location);
            }
          }
          return output3;
        }
        toJSON() {
          const formattedError = {
            message: this.message
          };
          if (this.locations != null) {
            formattedError.locations = this.locations;
          }
          if (this.path != null) {
            formattedError.path = this.path;
          }
          if (this.extensions != null && Object.keys(this.extensions).length > 0) {
            formattedError.extensions = this.extensions;
          }
          return formattedError;
        }
      };
      exports.GraphQLError = GraphQLError2;
      function undefinedIfEmpty2(array2) {
        return array2 === void 0 || array2.length === 0 ? void 0 : array2;
      }
      function printError(error2) {
        return error2.toString();
      }
      function formatError(error2) {
        return error2.toJSON();
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/error/syntaxError.js
  var require_syntaxError = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/error/syntaxError.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.syntaxError = syntaxError2;
      var _GraphQLError = require_GraphQLError();
      function syntaxError2(source, position, description) {
        return new _GraphQLError.GraphQLError(`Syntax Error: ${description}`, {
          source,
          positions: [position]
        });
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/ast.js
  var require_ast2 = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/ast.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Token = exports.QueryDocumentKeys = exports.OperationTypeNode = exports.Location = void 0;
      exports.isNode = isNode;
      var Location2 = class {
        /**
         * The character offset at which this Node begins.
         */
        /**
         * The character offset at which this Node ends.
         */
        /**
         * The Token at which this Node begins.
         */
        /**
         * The Token at which this Node ends.
         */
        /**
         * The Source document the AST represents.
         */
        constructor(startToken, endToken, source) {
          this.start = startToken.start;
          this.end = endToken.end;
          this.startToken = startToken;
          this.endToken = endToken;
          this.source = source;
        }
        get [Symbol.toStringTag]() {
          return "Location";
        }
        toJSON() {
          return {
            start: this.start,
            end: this.end
          };
        }
      };
      exports.Location = Location2;
      var Token2 = class {
        /**
         * The kind of Token.
         */
        /**
         * The character offset at which this Node begins.
         */
        /**
         * The character offset at which this Node ends.
         */
        /**
         * The 1-indexed line number on which this Token appears.
         */
        /**
         * The 1-indexed column number at which this Token begins.
         */
        /**
         * For non-punctuation tokens, represents the interpreted value of the token.
         *
         * Note: is undefined for punctuation tokens, but typed as string for
         * convenience in the parser.
         */
        /**
         * Tokens exist as nodes in a double-linked-list amongst all tokens
         * including ignored tokens. <SOF> is always the first node and <EOF>
         * the last.
         */
        constructor(kind, start, end, line, column, value) {
          this.kind = kind;
          this.start = start;
          this.end = end;
          this.line = line;
          this.column = column;
          this.value = value;
          this.prev = null;
          this.next = null;
        }
        get [Symbol.toStringTag]() {
          return "Token";
        }
        toJSON() {
          return {
            kind: this.kind,
            value: this.value,
            line: this.line,
            column: this.column
          };
        }
      };
      exports.Token = Token2;
      var QueryDocumentKeys2 = {
        Name: [],
        Document: ["definitions"],
        OperationDefinition: [
          "name",
          "variableDefinitions",
          "directives",
          "selectionSet"
        ],
        VariableDefinition: ["variable", "type", "defaultValue", "directives"],
        Variable: ["name"],
        SelectionSet: ["selections"],
        Field: ["alias", "name", "arguments", "directives", "selectionSet"],
        Argument: ["name", "value"],
        FragmentSpread: ["name", "directives"],
        InlineFragment: ["typeCondition", "directives", "selectionSet"],
        FragmentDefinition: [
          "name",
          // Note: fragment variable definitions are deprecated and will removed in v17.0.0
          "variableDefinitions",
          "typeCondition",
          "directives",
          "selectionSet"
        ],
        IntValue: [],
        FloatValue: [],
        StringValue: [],
        BooleanValue: [],
        NullValue: [],
        EnumValue: [],
        ListValue: ["values"],
        ObjectValue: ["fields"],
        ObjectField: ["name", "value"],
        Directive: ["name", "arguments"],
        NamedType: ["name"],
        ListType: ["type"],
        NonNullType: ["type"],
        SchemaDefinition: ["description", "directives", "operationTypes"],
        OperationTypeDefinition: ["type"],
        ScalarTypeDefinition: ["description", "name", "directives"],
        ObjectTypeDefinition: [
          "description",
          "name",
          "interfaces",
          "directives",
          "fields"
        ],
        FieldDefinition: ["description", "name", "arguments", "type", "directives"],
        InputValueDefinition: [
          "description",
          "name",
          "type",
          "defaultValue",
          "directives"
        ],
        InterfaceTypeDefinition: [
          "description",
          "name",
          "interfaces",
          "directives",
          "fields"
        ],
        UnionTypeDefinition: ["description", "name", "directives", "types"],
        EnumTypeDefinition: ["description", "name", "directives", "values"],
        EnumValueDefinition: ["description", "name", "directives"],
        InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
        DirectiveDefinition: ["description", "name", "arguments", "locations"],
        SchemaExtension: ["directives", "operationTypes"],
        ScalarTypeExtension: ["name", "directives"],
        ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
        InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
        UnionTypeExtension: ["name", "directives", "types"],
        EnumTypeExtension: ["name", "directives", "values"],
        InputObjectTypeExtension: ["name", "directives", "fields"]
      };
      exports.QueryDocumentKeys = QueryDocumentKeys2;
      var kindValues2 = new Set(Object.keys(QueryDocumentKeys2));
      function isNode(maybeNode) {
        const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
        return typeof maybeKind === "string" && kindValues2.has(maybeKind);
      }
      var OperationTypeNode2;
      exports.OperationTypeNode = OperationTypeNode2;
      (function(OperationTypeNode3) {
        OperationTypeNode3["QUERY"] = "query";
        OperationTypeNode3["MUTATION"] = "mutation";
        OperationTypeNode3["SUBSCRIPTION"] = "subscription";
      })(OperationTypeNode2 || (exports.OperationTypeNode = OperationTypeNode2 = {}));
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/directiveLocation.js
  var require_directiveLocation = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/directiveLocation.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.DirectiveLocation = void 0;
      var DirectiveLocation2;
      exports.DirectiveLocation = DirectiveLocation2;
      (function(DirectiveLocation3) {
        DirectiveLocation3["QUERY"] = "QUERY";
        DirectiveLocation3["MUTATION"] = "MUTATION";
        DirectiveLocation3["SUBSCRIPTION"] = "SUBSCRIPTION";
        DirectiveLocation3["FIELD"] = "FIELD";
        DirectiveLocation3["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
        DirectiveLocation3["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
        DirectiveLocation3["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
        DirectiveLocation3["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
        DirectiveLocation3["SCHEMA"] = "SCHEMA";
        DirectiveLocation3["SCALAR"] = "SCALAR";
        DirectiveLocation3["OBJECT"] = "OBJECT";
        DirectiveLocation3["FIELD_DEFINITION"] = "FIELD_DEFINITION";
        DirectiveLocation3["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
        DirectiveLocation3["INTERFACE"] = "INTERFACE";
        DirectiveLocation3["UNION"] = "UNION";
        DirectiveLocation3["ENUM"] = "ENUM";
        DirectiveLocation3["ENUM_VALUE"] = "ENUM_VALUE";
        DirectiveLocation3["INPUT_OBJECT"] = "INPUT_OBJECT";
        DirectiveLocation3["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
      })(DirectiveLocation2 || (exports.DirectiveLocation = DirectiveLocation2 = {}));
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/kinds.js
  var require_kinds = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/kinds.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Kind = void 0;
      var Kind2;
      exports.Kind = Kind2;
      (function(Kind3) {
        Kind3["NAME"] = "Name";
        Kind3["DOCUMENT"] = "Document";
        Kind3["OPERATION_DEFINITION"] = "OperationDefinition";
        Kind3["VARIABLE_DEFINITION"] = "VariableDefinition";
        Kind3["SELECTION_SET"] = "SelectionSet";
        Kind3["FIELD"] = "Field";
        Kind3["ARGUMENT"] = "Argument";
        Kind3["FRAGMENT_SPREAD"] = "FragmentSpread";
        Kind3["INLINE_FRAGMENT"] = "InlineFragment";
        Kind3["FRAGMENT_DEFINITION"] = "FragmentDefinition";
        Kind3["VARIABLE"] = "Variable";
        Kind3["INT"] = "IntValue";
        Kind3["FLOAT"] = "FloatValue";
        Kind3["STRING"] = "StringValue";
        Kind3["BOOLEAN"] = "BooleanValue";
        Kind3["NULL"] = "NullValue";
        Kind3["ENUM"] = "EnumValue";
        Kind3["LIST"] = "ListValue";
        Kind3["OBJECT"] = "ObjectValue";
        Kind3["OBJECT_FIELD"] = "ObjectField";
        Kind3["DIRECTIVE"] = "Directive";
        Kind3["NAMED_TYPE"] = "NamedType";
        Kind3["LIST_TYPE"] = "ListType";
        Kind3["NON_NULL_TYPE"] = "NonNullType";
        Kind3["SCHEMA_DEFINITION"] = "SchemaDefinition";
        Kind3["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
        Kind3["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
        Kind3["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
        Kind3["FIELD_DEFINITION"] = "FieldDefinition";
        Kind3["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
        Kind3["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
        Kind3["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
        Kind3["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
        Kind3["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
        Kind3["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
        Kind3["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
        Kind3["SCHEMA_EXTENSION"] = "SchemaExtension";
        Kind3["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
        Kind3["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
        Kind3["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
        Kind3["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
        Kind3["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
        Kind3["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
      })(Kind2 || (exports.Kind = Kind2 = {}));
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/characterClasses.js
  var require_characterClasses = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/characterClasses.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.isDigit = isDigit2;
      exports.isLetter = isLetter2;
      exports.isNameContinue = isNameContinue2;
      exports.isNameStart = isNameStart2;
      exports.isWhiteSpace = isWhiteSpace2;
      function isWhiteSpace2(code) {
        return code === 9 || code === 32;
      }
      function isDigit2(code) {
        return code >= 48 && code <= 57;
      }
      function isLetter2(code) {
        return code >= 97 && code <= 122 || // A-Z
        code >= 65 && code <= 90;
      }
      function isNameStart2(code) {
        return isLetter2(code) || code === 95;
      }
      function isNameContinue2(code) {
        return isLetter2(code) || isDigit2(code) || code === 95;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/blockString.js
  var require_blockString = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/blockString.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.dedentBlockStringLines = dedentBlockStringLines2;
      exports.isPrintableAsBlockString = isPrintableAsBlockString;
      exports.printBlockString = printBlockString;
      var _characterClasses = require_characterClasses();
      function dedentBlockStringLines2(lines) {
        var _firstNonEmptyLine2;
        let commonIndent = Number.MAX_SAFE_INTEGER;
        let firstNonEmptyLine = null;
        let lastNonEmptyLine = -1;
        for (let i = 0; i < lines.length; ++i) {
          var _firstNonEmptyLine;
          const line = lines[i];
          const indent = leadingWhitespace2(line);
          if (indent === line.length) {
            continue;
          }
          firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
          lastNonEmptyLine = i;
          if (i !== 0 && indent < commonIndent) {
            commonIndent = indent;
          }
        }
        return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice(
          (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
          lastNonEmptyLine + 1
        );
      }
      function leadingWhitespace2(str) {
        let i = 0;
        while (i < str.length && (0, _characterClasses.isWhiteSpace)(str.charCodeAt(i))) {
          ++i;
        }
        return i;
      }
      function isPrintableAsBlockString(value) {
        if (value === "") {
          return true;
        }
        let isEmptyLine = true;
        let hasIndent = false;
        let hasCommonIndent = true;
        let seenNonEmptyLine = false;
        for (let i = 0; i < value.length; ++i) {
          switch (value.codePointAt(i)) {
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 11:
            case 12:
            case 14:
            case 15:
              return false;
            case 13:
              return false;
            case 10:
              if (isEmptyLine && !seenNonEmptyLine) {
                return false;
              }
              seenNonEmptyLine = true;
              isEmptyLine = true;
              hasIndent = false;
              break;
            case 9:
            case 32:
              hasIndent || (hasIndent = isEmptyLine);
              break;
            default:
              hasCommonIndent && (hasCommonIndent = hasIndent);
              isEmptyLine = false;
          }
        }
        if (isEmptyLine) {
          return false;
        }
        if (hasCommonIndent && seenNonEmptyLine) {
          return false;
        }
        return true;
      }
      function printBlockString(value, options) {
        const escapedValue = value.replace(/"""/g, '\\"""');
        const lines = escapedValue.split(/\r\n|[\n\r]/g);
        const isSingleLine = lines.length === 1;
        const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every(
          (line) => line.length === 0 || (0, _characterClasses.isWhiteSpace)(line.charCodeAt(0))
        );
        const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
        const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
        const hasTrailingSlash = value.endsWith("\\");
        const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
        const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
        (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
        let result = "";
        const skipLeadingNewLine = isSingleLine && (0, _characterClasses.isWhiteSpace)(value.charCodeAt(0));
        if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
          result += "\n";
        }
        result += escapedValue;
        if (printAsMultipleLines || forceTrailingNewline) {
          result += "\n";
        }
        return '"""' + result + '"""';
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/tokenKind.js
  var require_tokenKind = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/tokenKind.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.TokenKind = void 0;
      var TokenKind2;
      exports.TokenKind = TokenKind2;
      (function(TokenKind3) {
        TokenKind3["SOF"] = "<SOF>";
        TokenKind3["EOF"] = "<EOF>";
        TokenKind3["BANG"] = "!";
        TokenKind3["DOLLAR"] = "$";
        TokenKind3["AMP"] = "&";
        TokenKind3["PAREN_L"] = "(";
        TokenKind3["PAREN_R"] = ")";
        TokenKind3["SPREAD"] = "...";
        TokenKind3["COLON"] = ":";
        TokenKind3["EQUALS"] = "=";
        TokenKind3["AT"] = "@";
        TokenKind3["BRACKET_L"] = "[";
        TokenKind3["BRACKET_R"] = "]";
        TokenKind3["BRACE_L"] = "{";
        TokenKind3["PIPE"] = "|";
        TokenKind3["BRACE_R"] = "}";
        TokenKind3["NAME"] = "Name";
        TokenKind3["INT"] = "Int";
        TokenKind3["FLOAT"] = "Float";
        TokenKind3["STRING"] = "String";
        TokenKind3["BLOCK_STRING"] = "BlockString";
        TokenKind3["COMMENT"] = "Comment";
      })(TokenKind2 || (exports.TokenKind = TokenKind2 = {}));
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/lexer.js
  var require_lexer = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/lexer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Lexer = void 0;
      exports.isPunctuatorTokenKind = isPunctuatorTokenKind2;
      var _syntaxError = require_syntaxError();
      var _ast = require_ast2();
      var _blockString = require_blockString();
      var _characterClasses = require_characterClasses();
      var _tokenKind = require_tokenKind();
      var Lexer2 = class {
        /**
         * The previously focused non-ignored token.
         */
        /**
         * The currently focused non-ignored token.
         */
        /**
         * The (1-indexed) line containing the current token.
         */
        /**
         * The character offset at which the current line begins.
         */
        constructor(source) {
          const startOfFileToken = new _ast.Token(
            _tokenKind.TokenKind.SOF,
            0,
            0,
            0,
            0
          );
          this.source = source;
          this.lastToken = startOfFileToken;
          this.token = startOfFileToken;
          this.line = 1;
          this.lineStart = 0;
        }
        get [Symbol.toStringTag]() {
          return "Lexer";
        }
        /**
         * Advances the token stream to the next non-ignored token.
         */
        advance() {
          this.lastToken = this.token;
          const token = this.token = this.lookahead();
          return token;
        }
        /**
         * Looks ahead and returns the next non-ignored token, but does not change
         * the state of Lexer.
         */
        lookahead() {
          let token = this.token;
          if (token.kind !== _tokenKind.TokenKind.EOF) {
            do {
              if (token.next) {
                token = token.next;
              } else {
                const nextToken = readNextToken2(this, token.end);
                token.next = nextToken;
                nextToken.prev = token;
                token = nextToken;
              }
            } while (token.kind === _tokenKind.TokenKind.COMMENT);
          }
          return token;
        }
      };
      exports.Lexer = Lexer2;
      function isPunctuatorTokenKind2(kind) {
        return kind === _tokenKind.TokenKind.BANG || kind === _tokenKind.TokenKind.DOLLAR || kind === _tokenKind.TokenKind.AMP || kind === _tokenKind.TokenKind.PAREN_L || kind === _tokenKind.TokenKind.PAREN_R || kind === _tokenKind.TokenKind.SPREAD || kind === _tokenKind.TokenKind.COLON || kind === _tokenKind.TokenKind.EQUALS || kind === _tokenKind.TokenKind.AT || kind === _tokenKind.TokenKind.BRACKET_L || kind === _tokenKind.TokenKind.BRACKET_R || kind === _tokenKind.TokenKind.BRACE_L || kind === _tokenKind.TokenKind.PIPE || kind === _tokenKind.TokenKind.BRACE_R;
      }
      function isUnicodeScalarValue2(code) {
        return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
      }
      function isSupplementaryCodePoint2(body, location) {
        return isLeadingSurrogate2(body.charCodeAt(location)) && isTrailingSurrogate2(body.charCodeAt(location + 1));
      }
      function isLeadingSurrogate2(code) {
        return code >= 55296 && code <= 56319;
      }
      function isTrailingSurrogate2(code) {
        return code >= 56320 && code <= 57343;
      }
      function printCodePointAt2(lexer, location) {
        const code = lexer.source.body.codePointAt(location);
        if (code === void 0) {
          return _tokenKind.TokenKind.EOF;
        } else if (code >= 32 && code <= 126) {
          const char = String.fromCodePoint(code);
          return char === '"' ? `'"'` : `"${char}"`;
        }
        return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
      }
      function createToken2(lexer, kind, start, end, value) {
        const line = lexer.line;
        const col = 1 + start - lexer.lineStart;
        return new _ast.Token(kind, start, end, line, col, value);
      }
      function readNextToken2(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start;
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          switch (code) {
            case 65279:
            case 9:
            case 32:
            case 44:
              ++position;
              continue;
            case 10:
              ++position;
              ++lexer.line;
              lexer.lineStart = position;
              continue;
            case 13:
              if (body.charCodeAt(position + 1) === 10) {
                position += 2;
              } else {
                ++position;
              }
              ++lexer.line;
              lexer.lineStart = position;
              continue;
            case 35:
              return readComment2(lexer, position);
            case 33:
              return createToken2(
                lexer,
                _tokenKind.TokenKind.BANG,
                position,
                position + 1
              );
            case 36:
              return createToken2(
                lexer,
                _tokenKind.TokenKind.DOLLAR,
                position,
                position + 1
              );
            case 38:
              return createToken2(
                lexer,
                _tokenKind.TokenKind.AMP,
                position,
                position + 1
              );
            case 40:
              return createToken2(
                lexer,
                _tokenKind.TokenKind.PAREN_L,
                position,
                position + 1
              );
            case 41:
              return createToken2(
                lexer,
                _tokenKind.TokenKind.PAREN_R,
                position,
                position + 1
              );
            case 46:
              if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
                return createToken2(
                  lexer,
                  _tokenKind.TokenKind.SPREAD,
                  position,
                  position + 3
                );
              }
              break;
            case 58:
              return createToken2(
                lexer,
                _tokenKind.TokenKind.COLON,
                position,
                position + 1
              );
            case 61:
              return createToken2(
                lexer,
                _tokenKind.TokenKind.EQUALS,
                position,
                position + 1
              );
            case 64:
              return createToken2(
                lexer,
                _tokenKind.TokenKind.AT,
                position,
                position + 1
              );
            case 91:
              return createToken2(
                lexer,
                _tokenKind.TokenKind.BRACKET_L,
                position,
                position + 1
              );
            case 93:
              return createToken2(
                lexer,
                _tokenKind.TokenKind.BRACKET_R,
                position,
                position + 1
              );
            case 123:
              return createToken2(
                lexer,
                _tokenKind.TokenKind.BRACE_L,
                position,
                position + 1
              );
            case 124:
              return createToken2(
                lexer,
                _tokenKind.TokenKind.PIPE,
                position,
                position + 1
              );
            case 125:
              return createToken2(
                lexer,
                _tokenKind.TokenKind.BRACE_R,
                position,
                position + 1
              );
            case 34:
              if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
                return readBlockString2(lexer, position);
              }
              return readString2(lexer, position);
          }
          if ((0, _characterClasses.isDigit)(code) || code === 45) {
            return readNumber2(lexer, position, code);
          }
          if ((0, _characterClasses.isNameStart)(code)) {
            return readName2(lexer, position);
          }
          throw (0, _syntaxError.syntaxError)(
            lexer.source,
            position,
            code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue2(code) || isSupplementaryCodePoint2(body, position) ? `Unexpected character: ${printCodePointAt2(lexer, position)}.` : `Invalid character: ${printCodePointAt2(lexer, position)}.`
          );
        }
        return createToken2(lexer, _tokenKind.TokenKind.EOF, bodyLength, bodyLength);
      }
      function readComment2(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start + 1;
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          if (code === 10 || code === 13) {
            break;
          }
          if (isUnicodeScalarValue2(code)) {
            ++position;
          } else if (isSupplementaryCodePoint2(body, position)) {
            position += 2;
          } else {
            break;
          }
        }
        return createToken2(
          lexer,
          _tokenKind.TokenKind.COMMENT,
          start,
          position,
          body.slice(start + 1, position)
        );
      }
      function readNumber2(lexer, start, firstCode) {
        const body = lexer.source.body;
        let position = start;
        let code = firstCode;
        let isFloat = false;
        if (code === 45) {
          code = body.charCodeAt(++position);
        }
        if (code === 48) {
          code = body.charCodeAt(++position);
          if ((0, _characterClasses.isDigit)(code)) {
            throw (0, _syntaxError.syntaxError)(
              lexer.source,
              position,
              `Invalid number, unexpected digit after 0: ${printCodePointAt2(
                lexer,
                position
              )}.`
            );
          }
        } else {
          position = readDigits2(lexer, position, code);
          code = body.charCodeAt(position);
        }
        if (code === 46) {
          isFloat = true;
          code = body.charCodeAt(++position);
          position = readDigits2(lexer, position, code);
          code = body.charCodeAt(position);
        }
        if (code === 69 || code === 101) {
          isFloat = true;
          code = body.charCodeAt(++position);
          if (code === 43 || code === 45) {
            code = body.charCodeAt(++position);
          }
          position = readDigits2(lexer, position, code);
          code = body.charCodeAt(position);
        }
        if (code === 46 || (0, _characterClasses.isNameStart)(code)) {
          throw (0, _syntaxError.syntaxError)(
            lexer.source,
            position,
            `Invalid number, expected digit but got: ${printCodePointAt2(
              lexer,
              position
            )}.`
          );
        }
        return createToken2(
          lexer,
          isFloat ? _tokenKind.TokenKind.FLOAT : _tokenKind.TokenKind.INT,
          start,
          position,
          body.slice(start, position)
        );
      }
      function readDigits2(lexer, start, firstCode) {
        if (!(0, _characterClasses.isDigit)(firstCode)) {
          throw (0, _syntaxError.syntaxError)(
            lexer.source,
            start,
            `Invalid number, expected digit but got: ${printCodePointAt2(
              lexer,
              start
            )}.`
          );
        }
        const body = lexer.source.body;
        let position = start + 1;
        while ((0, _characterClasses.isDigit)(body.charCodeAt(position))) {
          ++position;
        }
        return position;
      }
      function readString2(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start + 1;
        let chunkStart = position;
        let value = "";
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          if (code === 34) {
            value += body.slice(chunkStart, position);
            return createToken2(
              lexer,
              _tokenKind.TokenKind.STRING,
              start,
              position + 1,
              value
            );
          }
          if (code === 92) {
            value += body.slice(chunkStart, position);
            const escape2 = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth2(lexer, position) : readEscapedUnicodeFixedWidth2(lexer, position) : readEscapedCharacter2(lexer, position);
            value += escape2.value;
            position += escape2.size;
            chunkStart = position;
            continue;
          }
          if (code === 10 || code === 13) {
            break;
          }
          if (isUnicodeScalarValue2(code)) {
            ++position;
          } else if (isSupplementaryCodePoint2(body, position)) {
            position += 2;
          } else {
            throw (0, _syntaxError.syntaxError)(
              lexer.source,
              position,
              `Invalid character within String: ${printCodePointAt2(
                lexer,
                position
              )}.`
            );
          }
        }
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          "Unterminated string."
        );
      }
      function readEscapedUnicodeVariableWidth2(lexer, position) {
        const body = lexer.source.body;
        let point = 0;
        let size = 3;
        while (size < 12) {
          const code = body.charCodeAt(position + size++);
          if (code === 125) {
            if (size < 5 || !isUnicodeScalarValue2(point)) {
              break;
            }
            return {
              value: String.fromCodePoint(point),
              size
            };
          }
          point = point << 4 | readHexDigit2(code);
          if (point < 0) {
            break;
          }
        }
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          `Invalid Unicode escape sequence: "${body.slice(
            position,
            position + size
          )}".`
        );
      }
      function readEscapedUnicodeFixedWidth2(lexer, position) {
        const body = lexer.source.body;
        const code = read16BitHexCode2(body, position + 2);
        if (isUnicodeScalarValue2(code)) {
          return {
            value: String.fromCodePoint(code),
            size: 6
          };
        }
        if (isLeadingSurrogate2(code)) {
          if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
            const trailingCode = read16BitHexCode2(body, position + 8);
            if (isTrailingSurrogate2(trailingCode)) {
              return {
                value: String.fromCodePoint(code, trailingCode),
                size: 12
              };
            }
          }
        }
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
        );
      }
      function read16BitHexCode2(body, position) {
        return readHexDigit2(body.charCodeAt(position)) << 12 | readHexDigit2(body.charCodeAt(position + 1)) << 8 | readHexDigit2(body.charCodeAt(position + 2)) << 4 | readHexDigit2(body.charCodeAt(position + 3));
      }
      function readHexDigit2(code) {
        return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
      }
      function readEscapedCharacter2(lexer, position) {
        const body = lexer.source.body;
        const code = body.charCodeAt(position + 1);
        switch (code) {
          case 34:
            return {
              value: '"',
              size: 2
            };
          case 92:
            return {
              value: "\\",
              size: 2
            };
          case 47:
            return {
              value: "/",
              size: 2
            };
          case 98:
            return {
              value: "\b",
              size: 2
            };
          case 102:
            return {
              value: "\f",
              size: 2
            };
          case 110:
            return {
              value: "\n",
              size: 2
            };
          case 114:
            return {
              value: "\r",
              size: 2
            };
          case 116:
            return {
              value: "	",
              size: 2
            };
        }
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          `Invalid character escape sequence: "${body.slice(
            position,
            position + 2
          )}".`
        );
      }
      function readBlockString2(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let lineStart = lexer.lineStart;
        let position = start + 3;
        let chunkStart = position;
        let currentLine = "";
        const blockLines = [];
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
            currentLine += body.slice(chunkStart, position);
            blockLines.push(currentLine);
            const token = createToken2(
              lexer,
              _tokenKind.TokenKind.BLOCK_STRING,
              start,
              position + 3,
              // Return a string of the lines joined with U+000A.
              (0, _blockString.dedentBlockStringLines)(blockLines).join("\n")
            );
            lexer.line += blockLines.length - 1;
            lexer.lineStart = lineStart;
            return token;
          }
          if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
            currentLine += body.slice(chunkStart, position);
            chunkStart = position + 1;
            position += 4;
            continue;
          }
          if (code === 10 || code === 13) {
            currentLine += body.slice(chunkStart, position);
            blockLines.push(currentLine);
            if (code === 13 && body.charCodeAt(position + 1) === 10) {
              position += 2;
            } else {
              ++position;
            }
            currentLine = "";
            chunkStart = position;
            lineStart = position;
            continue;
          }
          if (isUnicodeScalarValue2(code)) {
            ++position;
          } else if (isSupplementaryCodePoint2(body, position)) {
            position += 2;
          } else {
            throw (0, _syntaxError.syntaxError)(
              lexer.source,
              position,
              `Invalid character within String: ${printCodePointAt2(
                lexer,
                position
              )}.`
            );
          }
        }
        throw (0, _syntaxError.syntaxError)(
          lexer.source,
          position,
          "Unterminated string."
        );
      }
      function readName2(lexer, start) {
        const body = lexer.source.body;
        const bodyLength = body.length;
        let position = start + 1;
        while (position < bodyLength) {
          const code = body.charCodeAt(position);
          if ((0, _characterClasses.isNameContinue)(code)) {
            ++position;
          } else {
            break;
          }
        }
        return createToken2(
          lexer,
          _tokenKind.TokenKind.NAME,
          start,
          position,
          body.slice(start, position)
        );
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/devAssert.js
  var require_devAssert = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/devAssert.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.devAssert = devAssert2;
      function devAssert2(condition, message) {
        const booleanCondition = Boolean(condition);
        if (!booleanCondition) {
          throw new Error(message);
        }
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/inspect.js
  var require_inspect = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/inspect.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.inspect = inspect2;
      var MAX_ARRAY_LENGTH2 = 10;
      var MAX_RECURSIVE_DEPTH2 = 2;
      function inspect2(value) {
        return formatValue2(value, []);
      }
      function formatValue2(value, seenValues) {
        switch (typeof value) {
          case "string":
            return JSON.stringify(value);
          case "function":
            return value.name ? `[function ${value.name}]` : "[function]";
          case "object":
            return formatObjectValue2(value, seenValues);
          default:
            return String(value);
        }
      }
      function formatObjectValue2(value, previouslySeenValues) {
        if (value === null) {
          return "null";
        }
        if (previouslySeenValues.includes(value)) {
          return "[Circular]";
        }
        const seenValues = [...previouslySeenValues, value];
        if (isJSONable2(value)) {
          const jsonValue = value.toJSON();
          if (jsonValue !== value) {
            return typeof jsonValue === "string" ? jsonValue : formatValue2(jsonValue, seenValues);
          }
        } else if (Array.isArray(value)) {
          return formatArray2(value, seenValues);
        }
        return formatObject2(value, seenValues);
      }
      function isJSONable2(value) {
        return typeof value.toJSON === "function";
      }
      function formatObject2(object2, seenValues) {
        const entries = Object.entries(object2);
        if (entries.length === 0) {
          return "{}";
        }
        if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
          return "[" + getObjectTag2(object2) + "]";
        }
        const properties = entries.map(
          ([key, value]) => key + ": " + formatValue2(value, seenValues)
        );
        return "{ " + properties.join(", ") + " }";
      }
      function formatArray2(array2, seenValues) {
        if (array2.length === 0) {
          return "[]";
        }
        if (seenValues.length > MAX_RECURSIVE_DEPTH2) {
          return "[Array]";
        }
        const len = Math.min(MAX_ARRAY_LENGTH2, array2.length);
        const remaining = array2.length - len;
        const items = [];
        for (let i = 0; i < len; ++i) {
          items.push(formatValue2(array2[i], seenValues));
        }
        if (remaining === 1) {
          items.push("... 1 more item");
        } else if (remaining > 1) {
          items.push(`... ${remaining} more items`);
        }
        return "[" + items.join(", ") + "]";
      }
      function getObjectTag2(object2) {
        const tag = Object.prototype.toString.call(object2).replace(/^\[object /, "").replace(/]$/, "");
        if (tag === "Object" && typeof object2.constructor === "function") {
          const name = object2.constructor.name;
          if (typeof name === "string" && name !== "") {
            return name;
          }
        }
        return tag;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/instanceOf.js
  var require_instanceOf = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/instanceOf.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.instanceOf = void 0;
      var _inspect = require_inspect();
      var instanceOf4 = (
        /* c8 ignore next 6 */
        // FIXME: https://github.com/graphql/graphql-js/issues/2317
        // eslint-disable-next-line no-undef
        process.env.NODE_ENV === "production" ? function instanceOf5(value, constructor) {
          return value instanceof constructor;
        } : function instanceOf5(value, constructor) {
          if (value instanceof constructor) {
            return true;
          }
          if (typeof value === "object" && value !== null) {
            var _value$constructor;
            const className = constructor.prototype[Symbol.toStringTag];
            const valueClassName = (
              // We still need to support constructor's name to detect conflicts with older versions of this library.
              Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
            );
            if (className === valueClassName) {
              const stringifiedValue = (0, _inspect.inspect)(value);
              throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
            }
          }
          return false;
        }
      );
      exports.instanceOf = instanceOf4;
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/source.js
  var require_source2 = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/source.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Source = void 0;
      exports.isSource = isSource2;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _instanceOf = require_instanceOf();
      var Source2 = class {
        constructor(body, name = "GraphQL request", locationOffset = {
          line: 1,
          column: 1
        }) {
          typeof body === "string" || (0, _devAssert.devAssert)(
            false,
            `Body must be a string. Received: ${(0, _inspect.inspect)(body)}.`
          );
          this.body = body;
          this.name = name;
          this.locationOffset = locationOffset;
          this.locationOffset.line > 0 || (0, _devAssert.devAssert)(
            false,
            "line in locationOffset is 1-indexed and must be positive."
          );
          this.locationOffset.column > 0 || (0, _devAssert.devAssert)(
            false,
            "column in locationOffset is 1-indexed and must be positive."
          );
        }
        get [Symbol.toStringTag]() {
          return "Source";
        }
      };
      exports.Source = Source2;
      function isSource2(source) {
        return (0, _instanceOf.instanceOf)(source, Source2);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/parser.js
  var require_parser3 = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/parser.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.Parser = void 0;
      exports.parse = parse3;
      exports.parseConstValue = parseConstValue2;
      exports.parseType = parseType2;
      exports.parseValue = parseValue2;
      var _syntaxError = require_syntaxError();
      var _ast = require_ast2();
      var _directiveLocation = require_directiveLocation();
      var _kinds = require_kinds();
      var _lexer = require_lexer();
      var _source = require_source2();
      var _tokenKind = require_tokenKind();
      function parse3(source, options) {
        const parser = new Parser2(source, options);
        return parser.parseDocument();
      }
      function parseValue2(source, options) {
        const parser = new Parser2(source, options);
        parser.expectToken(_tokenKind.TokenKind.SOF);
        const value = parser.parseValueLiteral(false);
        parser.expectToken(_tokenKind.TokenKind.EOF);
        return value;
      }
      function parseConstValue2(source, options) {
        const parser = new Parser2(source, options);
        parser.expectToken(_tokenKind.TokenKind.SOF);
        const value = parser.parseConstValueLiteral();
        parser.expectToken(_tokenKind.TokenKind.EOF);
        return value;
      }
      function parseType2(source, options) {
        const parser = new Parser2(source, options);
        parser.expectToken(_tokenKind.TokenKind.SOF);
        const type3 = parser.parseTypeReference();
        parser.expectToken(_tokenKind.TokenKind.EOF);
        return type3;
      }
      var Parser2 = class {
        constructor(source, options = {}) {
          const sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
          this._lexer = new _lexer.Lexer(sourceObj);
          this._options = options;
          this._tokenCounter = 0;
        }
        /**
         * Converts a name lex token into a name parse node.
         */
        parseName() {
          const token = this.expectToken(_tokenKind.TokenKind.NAME);
          return this.node(token, {
            kind: _kinds.Kind.NAME,
            value: token.value
          });
        }
        // Implements the parsing rules in the Document section.
        /**
         * Document : Definition+
         */
        parseDocument() {
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.DOCUMENT,
            definitions: this.many(
              _tokenKind.TokenKind.SOF,
              this.parseDefinition,
              _tokenKind.TokenKind.EOF
            )
          });
        }
        /**
         * Definition :
         *   - ExecutableDefinition
         *   - TypeSystemDefinition
         *   - TypeSystemExtension
         *
         * ExecutableDefinition :
         *   - OperationDefinition
         *   - FragmentDefinition
         *
         * TypeSystemDefinition :
         *   - SchemaDefinition
         *   - TypeDefinition
         *   - DirectiveDefinition
         *
         * TypeDefinition :
         *   - ScalarTypeDefinition
         *   - ObjectTypeDefinition
         *   - InterfaceTypeDefinition
         *   - UnionTypeDefinition
         *   - EnumTypeDefinition
         *   - InputObjectTypeDefinition
         */
        parseDefinition() {
          if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
            return this.parseOperationDefinition();
          }
          const hasDescription = this.peekDescription();
          const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
          if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
            switch (keywordToken.value) {
              case "schema":
                return this.parseSchemaDefinition();
              case "scalar":
                return this.parseScalarTypeDefinition();
              case "type":
                return this.parseObjectTypeDefinition();
              case "interface":
                return this.parseInterfaceTypeDefinition();
              case "union":
                return this.parseUnionTypeDefinition();
              case "enum":
                return this.parseEnumTypeDefinition();
              case "input":
                return this.parseInputObjectTypeDefinition();
              case "directive":
                return this.parseDirectiveDefinition();
            }
            if (hasDescription) {
              throw (0, _syntaxError.syntaxError)(
                this._lexer.source,
                this._lexer.token.start,
                "Unexpected description, descriptions are supported only on type definitions."
              );
            }
            switch (keywordToken.value) {
              case "query":
              case "mutation":
              case "subscription":
                return this.parseOperationDefinition();
              case "fragment":
                return this.parseFragmentDefinition();
              case "extend":
                return this.parseTypeSystemExtension();
            }
          }
          throw this.unexpected(keywordToken);
        }
        // Implements the parsing rules in the Operations section.
        /**
         * OperationDefinition :
         *  - SelectionSet
         *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
         */
        parseOperationDefinition() {
          const start = this._lexer.token;
          if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
            return this.node(start, {
              kind: _kinds.Kind.OPERATION_DEFINITION,
              operation: _ast.OperationTypeNode.QUERY,
              name: void 0,
              variableDefinitions: [],
              directives: [],
              selectionSet: this.parseSelectionSet()
            });
          }
          const operation = this.parseOperationType();
          let name;
          if (this.peek(_tokenKind.TokenKind.NAME)) {
            name = this.parseName();
          }
          return this.node(start, {
            kind: _kinds.Kind.OPERATION_DEFINITION,
            operation,
            name,
            variableDefinitions: this.parseVariableDefinitions(),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        /**
         * OperationType : one of query mutation subscription
         */
        parseOperationType() {
          const operationToken = this.expectToken(_tokenKind.TokenKind.NAME);
          switch (operationToken.value) {
            case "query":
              return _ast.OperationTypeNode.QUERY;
            case "mutation":
              return _ast.OperationTypeNode.MUTATION;
            case "subscription":
              return _ast.OperationTypeNode.SUBSCRIPTION;
          }
          throw this.unexpected(operationToken);
        }
        /**
         * VariableDefinitions : ( VariableDefinition+ )
         */
        parseVariableDefinitions() {
          return this.optionalMany(
            _tokenKind.TokenKind.PAREN_L,
            this.parseVariableDefinition,
            _tokenKind.TokenKind.PAREN_R
          );
        }
        /**
         * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
         */
        parseVariableDefinition() {
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.VARIABLE_DEFINITION,
            variable: this.parseVariable(),
            type: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseTypeReference()),
            defaultValue: this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
            directives: this.parseConstDirectives()
          });
        }
        /**
         * Variable : $ Name
         */
        parseVariable() {
          const start = this._lexer.token;
          this.expectToken(_tokenKind.TokenKind.DOLLAR);
          return this.node(start, {
            kind: _kinds.Kind.VARIABLE,
            name: this.parseName()
          });
        }
        /**
         * ```
         * SelectionSet : { Selection+ }
         * ```
         */
        parseSelectionSet() {
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.SELECTION_SET,
            selections: this.many(
              _tokenKind.TokenKind.BRACE_L,
              this.parseSelection,
              _tokenKind.TokenKind.BRACE_R
            )
          });
        }
        /**
         * Selection :
         *   - Field
         *   - FragmentSpread
         *   - InlineFragment
         */
        parseSelection() {
          return this.peek(_tokenKind.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
        }
        /**
         * Field : Alias? Name Arguments? Directives? SelectionSet?
         *
         * Alias : Name :
         */
        parseField() {
          const start = this._lexer.token;
          const nameOrAlias = this.parseName();
          let alias;
          let name;
          if (this.expectOptionalToken(_tokenKind.TokenKind.COLON)) {
            alias = nameOrAlias;
            name = this.parseName();
          } else {
            name = nameOrAlias;
          }
          return this.node(start, {
            kind: _kinds.Kind.FIELD,
            alias,
            name,
            arguments: this.parseArguments(false),
            directives: this.parseDirectives(false),
            selectionSet: this.peek(_tokenKind.TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
          });
        }
        /**
         * Arguments[Const] : ( Argument[?Const]+ )
         */
        parseArguments(isConst) {
          const item = isConst ? this.parseConstArgument : this.parseArgument;
          return this.optionalMany(
            _tokenKind.TokenKind.PAREN_L,
            item,
            _tokenKind.TokenKind.PAREN_R
          );
        }
        /**
         * Argument[Const] : Name : Value[?Const]
         */
        parseArgument(isConst = false) {
          const start = this._lexer.token;
          const name = this.parseName();
          this.expectToken(_tokenKind.TokenKind.COLON);
          return this.node(start, {
            kind: _kinds.Kind.ARGUMENT,
            name,
            value: this.parseValueLiteral(isConst)
          });
        }
        parseConstArgument() {
          return this.parseArgument(true);
        }
        // Implements the parsing rules in the Fragments section.
        /**
         * Corresponds to both FragmentSpread and InlineFragment in the spec.
         *
         * FragmentSpread : ... FragmentName Directives?
         *
         * InlineFragment : ... TypeCondition? Directives? SelectionSet
         */
        parseFragment() {
          const start = this._lexer.token;
          this.expectToken(_tokenKind.TokenKind.SPREAD);
          const hasTypeCondition = this.expectOptionalKeyword("on");
          if (!hasTypeCondition && this.peek(_tokenKind.TokenKind.NAME)) {
            return this.node(start, {
              kind: _kinds.Kind.FRAGMENT_SPREAD,
              name: this.parseFragmentName(),
              directives: this.parseDirectives(false)
            });
          }
          return this.node(start, {
            kind: _kinds.Kind.INLINE_FRAGMENT,
            typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        /**
         * FragmentDefinition :
         *   - fragment FragmentName on TypeCondition Directives? SelectionSet
         *
         * TypeCondition : NamedType
         */
        parseFragmentDefinition() {
          const start = this._lexer.token;
          this.expectKeyword("fragment");
          if (this._options.allowLegacyFragmentVariables === true) {
            return this.node(start, {
              kind: _kinds.Kind.FRAGMENT_DEFINITION,
              name: this.parseFragmentName(),
              variableDefinitions: this.parseVariableDefinitions(),
              typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
              directives: this.parseDirectives(false),
              selectionSet: this.parseSelectionSet()
            });
          }
          return this.node(start, {
            kind: _kinds.Kind.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet()
          });
        }
        /**
         * FragmentName : Name but not `on`
         */
        parseFragmentName() {
          if (this._lexer.token.value === "on") {
            throw this.unexpected();
          }
          return this.parseName();
        }
        // Implements the parsing rules in the Values section.
        /**
         * Value[Const] :
         *   - [~Const] Variable
         *   - IntValue
         *   - FloatValue
         *   - StringValue
         *   - BooleanValue
         *   - NullValue
         *   - EnumValue
         *   - ListValue[?Const]
         *   - ObjectValue[?Const]
         *
         * BooleanValue : one of `true` `false`
         *
         * NullValue : `null`
         *
         * EnumValue : Name but not `true`, `false` or `null`
         */
        parseValueLiteral(isConst) {
          const token = this._lexer.token;
          switch (token.kind) {
            case _tokenKind.TokenKind.BRACKET_L:
              return this.parseList(isConst);
            case _tokenKind.TokenKind.BRACE_L:
              return this.parseObject(isConst);
            case _tokenKind.TokenKind.INT:
              this.advanceLexer();
              return this.node(token, {
                kind: _kinds.Kind.INT,
                value: token.value
              });
            case _tokenKind.TokenKind.FLOAT:
              this.advanceLexer();
              return this.node(token, {
                kind: _kinds.Kind.FLOAT,
                value: token.value
              });
            case _tokenKind.TokenKind.STRING:
            case _tokenKind.TokenKind.BLOCK_STRING:
              return this.parseStringLiteral();
            case _tokenKind.TokenKind.NAME:
              this.advanceLexer();
              switch (token.value) {
                case "true":
                  return this.node(token, {
                    kind: _kinds.Kind.BOOLEAN,
                    value: true
                  });
                case "false":
                  return this.node(token, {
                    kind: _kinds.Kind.BOOLEAN,
                    value: false
                  });
                case "null":
                  return this.node(token, {
                    kind: _kinds.Kind.NULL
                  });
                default:
                  return this.node(token, {
                    kind: _kinds.Kind.ENUM,
                    value: token.value
                  });
              }
            case _tokenKind.TokenKind.DOLLAR:
              if (isConst) {
                this.expectToken(_tokenKind.TokenKind.DOLLAR);
                if (this._lexer.token.kind === _tokenKind.TokenKind.NAME) {
                  const varName = this._lexer.token.value;
                  throw (0, _syntaxError.syntaxError)(
                    this._lexer.source,
                    token.start,
                    `Unexpected variable "$${varName}" in constant value.`
                  );
                } else {
                  throw this.unexpected(token);
                }
              }
              return this.parseVariable();
            default:
              throw this.unexpected();
          }
        }
        parseConstValueLiteral() {
          return this.parseValueLiteral(true);
        }
        parseStringLiteral() {
          const token = this._lexer.token;
          this.advanceLexer();
          return this.node(token, {
            kind: _kinds.Kind.STRING,
            value: token.value,
            block: token.kind === _tokenKind.TokenKind.BLOCK_STRING
          });
        }
        /**
         * ListValue[Const] :
         *   - [ ]
         *   - [ Value[?Const]+ ]
         */
        parseList(isConst) {
          const item = () => this.parseValueLiteral(isConst);
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.LIST,
            values: this.any(
              _tokenKind.TokenKind.BRACKET_L,
              item,
              _tokenKind.TokenKind.BRACKET_R
            )
          });
        }
        /**
         * ```
         * ObjectValue[Const] :
         *   - { }
         *   - { ObjectField[?Const]+ }
         * ```
         */
        parseObject(isConst) {
          const item = () => this.parseObjectField(isConst);
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.OBJECT,
            fields: this.any(
              _tokenKind.TokenKind.BRACE_L,
              item,
              _tokenKind.TokenKind.BRACE_R
            )
          });
        }
        /**
         * ObjectField[Const] : Name : Value[?Const]
         */
        parseObjectField(isConst) {
          const start = this._lexer.token;
          const name = this.parseName();
          this.expectToken(_tokenKind.TokenKind.COLON);
          return this.node(start, {
            kind: _kinds.Kind.OBJECT_FIELD,
            name,
            value: this.parseValueLiteral(isConst)
          });
        }
        // Implements the parsing rules in the Directives section.
        /**
         * Directives[Const] : Directive[?Const]+
         */
        parseDirectives(isConst) {
          const directives = [];
          while (this.peek(_tokenKind.TokenKind.AT)) {
            directives.push(this.parseDirective(isConst));
          }
          return directives;
        }
        parseConstDirectives() {
          return this.parseDirectives(true);
        }
        /**
         * ```
         * Directive[Const] : @ Name Arguments[?Const]?
         * ```
         */
        parseDirective(isConst) {
          const start = this._lexer.token;
          this.expectToken(_tokenKind.TokenKind.AT);
          return this.node(start, {
            kind: _kinds.Kind.DIRECTIVE,
            name: this.parseName(),
            arguments: this.parseArguments(isConst)
          });
        }
        // Implements the parsing rules in the Types section.
        /**
         * Type :
         *   - NamedType
         *   - ListType
         *   - NonNullType
         */
        parseTypeReference() {
          const start = this._lexer.token;
          let type3;
          if (this.expectOptionalToken(_tokenKind.TokenKind.BRACKET_L)) {
            const innerType = this.parseTypeReference();
            this.expectToken(_tokenKind.TokenKind.BRACKET_R);
            type3 = this.node(start, {
              kind: _kinds.Kind.LIST_TYPE,
              type: innerType
            });
          } else {
            type3 = this.parseNamedType();
          }
          if (this.expectOptionalToken(_tokenKind.TokenKind.BANG)) {
            return this.node(start, {
              kind: _kinds.Kind.NON_NULL_TYPE,
              type: type3
            });
          }
          return type3;
        }
        /**
         * NamedType : Name
         */
        parseNamedType() {
          return this.node(this._lexer.token, {
            kind: _kinds.Kind.NAMED_TYPE,
            name: this.parseName()
          });
        }
        // Implements the parsing rules in the Type Definition section.
        peekDescription() {
          return this.peek(_tokenKind.TokenKind.STRING) || this.peek(_tokenKind.TokenKind.BLOCK_STRING);
        }
        /**
         * Description : StringValue
         */
        parseDescription() {
          if (this.peekDescription()) {
            return this.parseStringLiteral();
          }
        }
        /**
         * ```
         * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
         * ```
         */
        parseSchemaDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("schema");
          const directives = this.parseConstDirectives();
          const operationTypes = this.many(
            _tokenKind.TokenKind.BRACE_L,
            this.parseOperationTypeDefinition,
            _tokenKind.TokenKind.BRACE_R
          );
          return this.node(start, {
            kind: _kinds.Kind.SCHEMA_DEFINITION,
            description,
            directives,
            operationTypes
          });
        }
        /**
         * OperationTypeDefinition : OperationType : NamedType
         */
        parseOperationTypeDefinition() {
          const start = this._lexer.token;
          const operation = this.parseOperationType();
          this.expectToken(_tokenKind.TokenKind.COLON);
          const type3 = this.parseNamedType();
          return this.node(start, {
            kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,
            operation,
            type: type3
          });
        }
        /**
         * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
         */
        parseScalarTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("scalar");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,
            description,
            name,
            directives
          });
        }
        /**
         * ObjectTypeDefinition :
         *   Description?
         *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
         */
        parseObjectTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("type");
          const name = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          return this.node(start, {
            kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,
            description,
            name,
            interfaces,
            directives,
            fields
          });
        }
        /**
         * ImplementsInterfaces :
         *   - implements `&`? NamedType
         *   - ImplementsInterfaces & NamedType
         */
        parseImplementsInterfaces() {
          return this.expectOptionalKeyword("implements") ? this.delimitedMany(_tokenKind.TokenKind.AMP, this.parseNamedType) : [];
        }
        /**
         * ```
         * FieldsDefinition : { FieldDefinition+ }
         * ```
         */
        parseFieldsDefinition() {
          return this.optionalMany(
            _tokenKind.TokenKind.BRACE_L,
            this.parseFieldDefinition,
            _tokenKind.TokenKind.BRACE_R
          );
        }
        /**
         * FieldDefinition :
         *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
         */
        parseFieldDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          const name = this.parseName();
          const args = this.parseArgumentDefs();
          this.expectToken(_tokenKind.TokenKind.COLON);
          const type3 = this.parseTypeReference();
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: _kinds.Kind.FIELD_DEFINITION,
            description,
            name,
            arguments: args,
            type: type3,
            directives
          });
        }
        /**
         * ArgumentsDefinition : ( InputValueDefinition+ )
         */
        parseArgumentDefs() {
          return this.optionalMany(
            _tokenKind.TokenKind.PAREN_L,
            this.parseInputValueDef,
            _tokenKind.TokenKind.PAREN_R
          );
        }
        /**
         * InputValueDefinition :
         *   - Description? Name : Type DefaultValue? Directives[Const]?
         */
        parseInputValueDef() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          const name = this.parseName();
          this.expectToken(_tokenKind.TokenKind.COLON);
          const type3 = this.parseTypeReference();
          let defaultValue;
          if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {
            defaultValue = this.parseConstValueLiteral();
          }
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: _kinds.Kind.INPUT_VALUE_DEFINITION,
            description,
            name,
            type: type3,
            defaultValue,
            directives
          });
        }
        /**
         * InterfaceTypeDefinition :
         *   - Description? interface Name Directives[Const]? FieldsDefinition?
         */
        parseInterfaceTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("interface");
          const name = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          return this.node(start, {
            kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,
            description,
            name,
            interfaces,
            directives,
            fields
          });
        }
        /**
         * UnionTypeDefinition :
         *   - Description? union Name Directives[Const]? UnionMemberTypes?
         */
        parseUnionTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("union");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const types2 = this.parseUnionMemberTypes();
          return this.node(start, {
            kind: _kinds.Kind.UNION_TYPE_DEFINITION,
            description,
            name,
            directives,
            types: types2
          });
        }
        /**
         * UnionMemberTypes :
         *   - = `|`? NamedType
         *   - UnionMemberTypes | NamedType
         */
        parseUnionMemberTypes() {
          return this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseNamedType) : [];
        }
        /**
         * EnumTypeDefinition :
         *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
         */
        parseEnumTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("enum");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const values = this.parseEnumValuesDefinition();
          return this.node(start, {
            kind: _kinds.Kind.ENUM_TYPE_DEFINITION,
            description,
            name,
            directives,
            values
          });
        }
        /**
         * ```
         * EnumValuesDefinition : { EnumValueDefinition+ }
         * ```
         */
        parseEnumValuesDefinition() {
          return this.optionalMany(
            _tokenKind.TokenKind.BRACE_L,
            this.parseEnumValueDefinition,
            _tokenKind.TokenKind.BRACE_R
          );
        }
        /**
         * EnumValueDefinition : Description? EnumValue Directives[Const]?
         */
        parseEnumValueDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          const name = this.parseEnumValueName();
          const directives = this.parseConstDirectives();
          return this.node(start, {
            kind: _kinds.Kind.ENUM_VALUE_DEFINITION,
            description,
            name,
            directives
          });
        }
        /**
         * EnumValue : Name but not `true`, `false` or `null`
         */
        parseEnumValueName() {
          if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
            throw (0, _syntaxError.syntaxError)(
              this._lexer.source,
              this._lexer.token.start,
              `${getTokenDesc2(
                this._lexer.token
              )} is reserved and cannot be used for an enum value.`
            );
          }
          return this.parseName();
        }
        /**
         * InputObjectTypeDefinition :
         *   - Description? input Name Directives[Const]? InputFieldsDefinition?
         */
        parseInputObjectTypeDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("input");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const fields = this.parseInputFieldsDefinition();
          return this.node(start, {
            kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,
            description,
            name,
            directives,
            fields
          });
        }
        /**
         * ```
         * InputFieldsDefinition : { InputValueDefinition+ }
         * ```
         */
        parseInputFieldsDefinition() {
          return this.optionalMany(
            _tokenKind.TokenKind.BRACE_L,
            this.parseInputValueDef,
            _tokenKind.TokenKind.BRACE_R
          );
        }
        /**
         * TypeSystemExtension :
         *   - SchemaExtension
         *   - TypeExtension
         *
         * TypeExtension :
         *   - ScalarTypeExtension
         *   - ObjectTypeExtension
         *   - InterfaceTypeExtension
         *   - UnionTypeExtension
         *   - EnumTypeExtension
         *   - InputObjectTypeDefinition
         */
        parseTypeSystemExtension() {
          const keywordToken = this._lexer.lookahead();
          if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
            switch (keywordToken.value) {
              case "schema":
                return this.parseSchemaExtension();
              case "scalar":
                return this.parseScalarTypeExtension();
              case "type":
                return this.parseObjectTypeExtension();
              case "interface":
                return this.parseInterfaceTypeExtension();
              case "union":
                return this.parseUnionTypeExtension();
              case "enum":
                return this.parseEnumTypeExtension();
              case "input":
                return this.parseInputObjectTypeExtension();
            }
          }
          throw this.unexpected(keywordToken);
        }
        /**
         * ```
         * SchemaExtension :
         *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
         *  - extend schema Directives[Const]
         * ```
         */
        parseSchemaExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("schema");
          const directives = this.parseConstDirectives();
          const operationTypes = this.optionalMany(
            _tokenKind.TokenKind.BRACE_L,
            this.parseOperationTypeDefinition,
            _tokenKind.TokenKind.BRACE_R
          );
          if (directives.length === 0 && operationTypes.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.SCHEMA_EXTENSION,
            directives,
            operationTypes
          });
        }
        /**
         * ScalarTypeExtension :
         *   - extend scalar Name Directives[Const]
         */
        parseScalarTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("scalar");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          if (directives.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,
            name,
            directives
          });
        }
        /**
         * ObjectTypeExtension :
         *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
         *  - extend type Name ImplementsInterfaces? Directives[Const]
         *  - extend type Name ImplementsInterfaces
         */
        parseObjectTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("type");
          const name = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,
            name,
            interfaces,
            directives,
            fields
          });
        }
        /**
         * InterfaceTypeExtension :
         *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
         *  - extend interface Name ImplementsInterfaces? Directives[Const]
         *  - extend interface Name ImplementsInterfaces
         */
        parseInterfaceTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("interface");
          const name = this.parseName();
          const interfaces = this.parseImplementsInterfaces();
          const directives = this.parseConstDirectives();
          const fields = this.parseFieldsDefinition();
          if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
            name,
            interfaces,
            directives,
            fields
          });
        }
        /**
         * UnionTypeExtension :
         *   - extend union Name Directives[Const]? UnionMemberTypes
         *   - extend union Name Directives[Const]
         */
        parseUnionTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("union");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const types2 = this.parseUnionMemberTypes();
          if (directives.length === 0 && types2.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.UNION_TYPE_EXTENSION,
            name,
            directives,
            types: types2
          });
        }
        /**
         * EnumTypeExtension :
         *   - extend enum Name Directives[Const]? EnumValuesDefinition
         *   - extend enum Name Directives[Const]
         */
        parseEnumTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("enum");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const values = this.parseEnumValuesDefinition();
          if (directives.length === 0 && values.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.ENUM_TYPE_EXTENSION,
            name,
            directives,
            values
          });
        }
        /**
         * InputObjectTypeExtension :
         *   - extend input Name Directives[Const]? InputFieldsDefinition
         *   - extend input Name Directives[Const]
         */
        parseInputObjectTypeExtension() {
          const start = this._lexer.token;
          this.expectKeyword("extend");
          this.expectKeyword("input");
          const name = this.parseName();
          const directives = this.parseConstDirectives();
          const fields = this.parseInputFieldsDefinition();
          if (directives.length === 0 && fields.length === 0) {
            throw this.unexpected();
          }
          return this.node(start, {
            kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,
            name,
            directives,
            fields
          });
        }
        /**
         * ```
         * DirectiveDefinition :
         *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
         * ```
         */
        parseDirectiveDefinition() {
          const start = this._lexer.token;
          const description = this.parseDescription();
          this.expectKeyword("directive");
          this.expectToken(_tokenKind.TokenKind.AT);
          const name = this.parseName();
          const args = this.parseArgumentDefs();
          const repeatable = this.expectOptionalKeyword("repeatable");
          this.expectKeyword("on");
          const locations = this.parseDirectiveLocations();
          return this.node(start, {
            kind: _kinds.Kind.DIRECTIVE_DEFINITION,
            description,
            name,
            arguments: args,
            repeatable,
            locations
          });
        }
        /**
         * DirectiveLocations :
         *   - `|`? DirectiveLocation
         *   - DirectiveLocations | DirectiveLocation
         */
        parseDirectiveLocations() {
          return this.delimitedMany(
            _tokenKind.TokenKind.PIPE,
            this.parseDirectiveLocation
          );
        }
        /*
         * DirectiveLocation :
         *   - ExecutableDirectiveLocation
         *   - TypeSystemDirectiveLocation
         *
         * ExecutableDirectiveLocation : one of
         *   `QUERY`
         *   `MUTATION`
         *   `SUBSCRIPTION`
         *   `FIELD`
         *   `FRAGMENT_DEFINITION`
         *   `FRAGMENT_SPREAD`
         *   `INLINE_FRAGMENT`
         *
         * TypeSystemDirectiveLocation : one of
         *   `SCHEMA`
         *   `SCALAR`
         *   `OBJECT`
         *   `FIELD_DEFINITION`
         *   `ARGUMENT_DEFINITION`
         *   `INTERFACE`
         *   `UNION`
         *   `ENUM`
         *   `ENUM_VALUE`
         *   `INPUT_OBJECT`
         *   `INPUT_FIELD_DEFINITION`
         */
        parseDirectiveLocation() {
          const start = this._lexer.token;
          const name = this.parseName();
          if (Object.prototype.hasOwnProperty.call(
            _directiveLocation.DirectiveLocation,
            name.value
          )) {
            return name;
          }
          throw this.unexpected(start);
        }
        // Core parsing utility functions
        /**
         * Returns a node that, if configured to do so, sets a "loc" field as a
         * location object, used to identify the place in the source that created a
         * given parsed object.
         */
        node(startToken, node) {
          if (this._options.noLocation !== true) {
            node.loc = new _ast.Location(
              startToken,
              this._lexer.lastToken,
              this._lexer.source
            );
          }
          return node;
        }
        /**
         * Determines if the next token is of a given kind
         */
        peek(kind) {
          return this._lexer.token.kind === kind;
        }
        /**
         * If the next token is of the given kind, return that token after advancing the lexer.
         * Otherwise, do not change the parser state and throw an error.
         */
        expectToken(kind) {
          const token = this._lexer.token;
          if (token.kind === kind) {
            this.advanceLexer();
            return token;
          }
          throw (0, _syntaxError.syntaxError)(
            this._lexer.source,
            token.start,
            `Expected ${getTokenKindDesc2(kind)}, found ${getTokenDesc2(token)}.`
          );
        }
        /**
         * If the next token is of the given kind, return "true" after advancing the lexer.
         * Otherwise, do not change the parser state and return "false".
         */
        expectOptionalToken(kind) {
          const token = this._lexer.token;
          if (token.kind === kind) {
            this.advanceLexer();
            return true;
          }
          return false;
        }
        /**
         * If the next token is a given keyword, advance the lexer.
         * Otherwise, do not change the parser state and throw an error.
         */
        expectKeyword(value) {
          const token = this._lexer.token;
          if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
            this.advanceLexer();
          } else {
            throw (0, _syntaxError.syntaxError)(
              this._lexer.source,
              token.start,
              `Expected "${value}", found ${getTokenDesc2(token)}.`
            );
          }
        }
        /**
         * If the next token is a given keyword, return "true" after advancing the lexer.
         * Otherwise, do not change the parser state and return "false".
         */
        expectOptionalKeyword(value) {
          const token = this._lexer.token;
          if (token.kind === _tokenKind.TokenKind.NAME && token.value === value) {
            this.advanceLexer();
            return true;
          }
          return false;
        }
        /**
         * Helper function for creating an error when an unexpected lexed token is encountered.
         */
        unexpected(atToken) {
          const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
          return (0, _syntaxError.syntaxError)(
            this._lexer.source,
            token.start,
            `Unexpected ${getTokenDesc2(token)}.`
          );
        }
        /**
         * Returns a possibly empty list of parse nodes, determined by the parseFn.
         * This list begins with a lex token of openKind and ends with a lex token of closeKind.
         * Advances the parser to the next lex token after the closing token.
         */
        any(openKind, parseFn, closeKind) {
          this.expectToken(openKind);
          const nodes = [];
          while (!this.expectOptionalToken(closeKind)) {
            nodes.push(parseFn.call(this));
          }
          return nodes;
        }
        /**
         * Returns a list of parse nodes, determined by the parseFn.
         * It can be empty only if open token is missing otherwise it will always return non-empty list
         * that begins with a lex token of openKind and ends with a lex token of closeKind.
         * Advances the parser to the next lex token after the closing token.
         */
        optionalMany(openKind, parseFn, closeKind) {
          if (this.expectOptionalToken(openKind)) {
            const nodes = [];
            do {
              nodes.push(parseFn.call(this));
            } while (!this.expectOptionalToken(closeKind));
            return nodes;
          }
          return [];
        }
        /**
         * Returns a non-empty list of parse nodes, determined by the parseFn.
         * This list begins with a lex token of openKind and ends with a lex token of closeKind.
         * Advances the parser to the next lex token after the closing token.
         */
        many(openKind, parseFn, closeKind) {
          this.expectToken(openKind);
          const nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (!this.expectOptionalToken(closeKind));
          return nodes;
        }
        /**
         * Returns a non-empty list of parse nodes, determined by the parseFn.
         * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
         * Advances the parser to the next lex token after last item in the list.
         */
        delimitedMany(delimiterKind, parseFn) {
          this.expectOptionalToken(delimiterKind);
          const nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (this.expectOptionalToken(delimiterKind));
          return nodes;
        }
        advanceLexer() {
          const { maxTokens } = this._options;
          const token = this._lexer.advance();
          if (maxTokens !== void 0 && token.kind !== _tokenKind.TokenKind.EOF) {
            ++this._tokenCounter;
            if (this._tokenCounter > maxTokens) {
              throw (0, _syntaxError.syntaxError)(
                this._lexer.source,
                token.start,
                `Document contains more that ${maxTokens} tokens. Parsing aborted.`
              );
            }
          }
        }
      };
      exports.Parser = Parser2;
      function getTokenDesc2(token) {
        const value = token.value;
        return getTokenKindDesc2(token.kind) + (value != null ? ` "${value}"` : "");
      }
      function getTokenKindDesc2(kind) {
        return (0, _lexer.isPunctuatorTokenKind)(kind) ? `"${kind}"` : kind;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/printString.js
  var require_printString = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/printString.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.printString = printString;
      function printString(str) {
        return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
      }
      var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
      function escapedReplacer(str) {
        return escapeSequences[str.charCodeAt(0)];
      }
      var escapeSequences = [
        "\\u0000",
        "\\u0001",
        "\\u0002",
        "\\u0003",
        "\\u0004",
        "\\u0005",
        "\\u0006",
        "\\u0007",
        "\\b",
        "\\t",
        "\\n",
        "\\u000B",
        "\\f",
        "\\r",
        "\\u000E",
        "\\u000F",
        "\\u0010",
        "\\u0011",
        "\\u0012",
        "\\u0013",
        "\\u0014",
        "\\u0015",
        "\\u0016",
        "\\u0017",
        "\\u0018",
        "\\u0019",
        "\\u001A",
        "\\u001B",
        "\\u001C",
        "\\u001D",
        "\\u001E",
        "\\u001F",
        "",
        "",
        '\\"',
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        // 2F
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        // 3F
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        // 4F
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "\\\\",
        "",
        "",
        "",
        // 5F
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        // 6F
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "",
        "\\u007F",
        "\\u0080",
        "\\u0081",
        "\\u0082",
        "\\u0083",
        "\\u0084",
        "\\u0085",
        "\\u0086",
        "\\u0087",
        "\\u0088",
        "\\u0089",
        "\\u008A",
        "\\u008B",
        "\\u008C",
        "\\u008D",
        "\\u008E",
        "\\u008F",
        "\\u0090",
        "\\u0091",
        "\\u0092",
        "\\u0093",
        "\\u0094",
        "\\u0095",
        "\\u0096",
        "\\u0097",
        "\\u0098",
        "\\u0099",
        "\\u009A",
        "\\u009B",
        "\\u009C",
        "\\u009D",
        "\\u009E",
        "\\u009F"
      ];
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/visitor.js
  var require_visitor2 = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/visitor.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.BREAK = void 0;
      exports.getEnterLeaveForKind = getEnterLeaveForKind2;
      exports.getVisitFn = getVisitFn2;
      exports.visit = visit2;
      exports.visitInParallel = visitInParallel2;
      var _devAssert = require_devAssert();
      var _inspect = require_inspect();
      var _ast = require_ast2();
      var _kinds = require_kinds();
      var BREAK2 = Object.freeze({});
      exports.BREAK = BREAK2;
      function visit2(root, visitor, visitorKeys = _ast.QueryDocumentKeys) {
        const enterLeaveMap = /* @__PURE__ */ new Map();
        for (const kind of Object.values(_kinds.Kind)) {
          enterLeaveMap.set(kind, getEnterLeaveForKind2(visitor, kind));
        }
        let stack = void 0;
        let inArray = Array.isArray(root);
        let keys4 = [root];
        let index = -1;
        let edits = [];
        let node = root;
        let key = void 0;
        let parent = void 0;
        const path4 = [];
        const ancestors = [];
        do {
          index++;
          const isLeaving = index === keys4.length;
          const isEdited = isLeaving && edits.length !== 0;
          if (isLeaving) {
            key = ancestors.length === 0 ? void 0 : path4[path4.length - 1];
            node = parent;
            parent = ancestors.pop();
            if (isEdited) {
              if (inArray) {
                node = node.slice();
                let editOffset = 0;
                for (const [editKey, editValue] of edits) {
                  const arrayKey = editKey - editOffset;
                  if (editValue === null) {
                    node.splice(arrayKey, 1);
                    editOffset++;
                  } else {
                    node[arrayKey] = editValue;
                  }
                }
              } else {
                node = Object.defineProperties(
                  {},
                  Object.getOwnPropertyDescriptors(node)
                );
                for (const [editKey, editValue] of edits) {
                  node[editKey] = editValue;
                }
              }
            }
            index = stack.index;
            keys4 = stack.keys;
            edits = stack.edits;
            inArray = stack.inArray;
            stack = stack.prev;
          } else if (parent) {
            key = inArray ? index : keys4[index];
            node = parent[key];
            if (node === null || node === void 0) {
              continue;
            }
            path4.push(key);
          }
          let result;
          if (!Array.isArray(node)) {
            var _enterLeaveMap$get, _enterLeaveMap$get2;
            (0, _ast.isNode)(node) || (0, _devAssert.devAssert)(
              false,
              `Invalid AST Node: ${(0, _inspect.inspect)(node)}.`
            );
            const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
            result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path4, ancestors);
            if (result === BREAK2) {
              break;
            }
            if (result === false) {
              if (!isLeaving) {
                path4.pop();
                continue;
              }
            } else if (result !== void 0) {
              edits.push([key, result]);
              if (!isLeaving) {
                if ((0, _ast.isNode)(result)) {
                  node = result;
                } else {
                  path4.pop();
                  continue;
                }
              }
            }
          }
          if (result === void 0 && isEdited) {
            edits.push([key, node]);
          }
          if (isLeaving) {
            path4.pop();
          } else {
            var _node$kind;
            stack = {
              inArray,
              index,
              keys: keys4,
              edits,
              prev: stack
            };
            inArray = Array.isArray(node);
            keys4 = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
            index = -1;
            edits = [];
            if (parent) {
              ancestors.push(parent);
            }
            parent = node;
          }
        } while (stack !== void 0);
        if (edits.length !== 0) {
          return edits[edits.length - 1][1];
        }
        return root;
      }
      function visitInParallel2(visitors) {
        const skipping = new Array(visitors.length).fill(null);
        const mergedVisitor = /* @__PURE__ */ Object.create(null);
        for (const kind of Object.values(_kinds.Kind)) {
          let hasVisitor = false;
          const enterList = new Array(visitors.length).fill(void 0);
          const leaveList = new Array(visitors.length).fill(void 0);
          for (let i = 0; i < visitors.length; ++i) {
            const { enter, leave } = getEnterLeaveForKind2(visitors[i], kind);
            hasVisitor || (hasVisitor = enter != null || leave != null);
            enterList[i] = enter;
            leaveList[i] = leave;
          }
          if (!hasVisitor) {
            continue;
          }
          const mergedEnterLeave = {
            enter(...args) {
              const node = args[0];
              for (let i = 0; i < visitors.length; i++) {
                if (skipping[i] === null) {
                  var _enterList$i;
                  const result = (_enterList$i = enterList[i]) === null || _enterList$i === void 0 ? void 0 : _enterList$i.apply(visitors[i], args);
                  if (result === false) {
                    skipping[i] = node;
                  } else if (result === BREAK2) {
                    skipping[i] = BREAK2;
                  } else if (result !== void 0) {
                    return result;
                  }
                }
              }
            },
            leave(...args) {
              const node = args[0];
              for (let i = 0; i < visitors.length; i++) {
                if (skipping[i] === null) {
                  var _leaveList$i;
                  const result = (_leaveList$i = leaveList[i]) === null || _leaveList$i === void 0 ? void 0 : _leaveList$i.apply(visitors[i], args);
                  if (result === BREAK2) {
                    skipping[i] = BREAK2;
                  } else if (result !== void 0 && result !== false) {
                    return result;
                  }
                } else if (skipping[i] === node) {
                  skipping[i] = null;
                }
              }
            }
          };
          mergedVisitor[kind] = mergedEnterLeave;
        }
        return mergedVisitor;
      }
      function getEnterLeaveForKind2(visitor, kind) {
        const kindVisitor = visitor[kind];
        if (typeof kindVisitor === "object") {
          return kindVisitor;
        } else if (typeof kindVisitor === "function") {
          return {
            enter: kindVisitor,
            leave: void 0
          };
        }
        return {
          enter: visitor.enter,
          leave: visitor.leave
        };
      }
      function getVisitFn2(visitor, kind, isLeaving) {
        const { enter, leave } = getEnterLeaveForKind2(visitor, kind);
        return isLeaving ? leave : enter;
      }
    }
  });

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/printer.js
  var require_printer2 = __commonJS({
    "../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/printer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.print = print2;
      var _blockString = require_blockString();
      var _printString = require_printString();
      var _visitor = require_visitor2();
      function print2(ast) {
        return (0, _visitor.visit)(ast, printDocASTReducer);
      }
      var MAX_LINE_LENGTH = 80;
      var printDocASTReducer = {
        Name: {
          leave: (node) => node.value
        },
        Variable: {
          leave: (node) => "$" + node.name
        },
        // Document
        Document: {
          leave: (node) => join10(node.definitions, "\n\n")
        },
        OperationDefinition: {
          leave(node) {
            const varDefs = wrap("(", join10(node.variableDefinitions, ", "), ")");
            const prefix = join10(
              [
                node.operation,
                join10([node.name, varDefs]),
                join10(node.directives, " ")
              ],
              " "
            );
            return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
          }
        },
        VariableDefinition: {
          leave: ({ variable, type: type3, defaultValue, directives }) => variable + ": " + type3 + wrap(" = ", defaultValue) + wrap(" ", join10(directives, " "))
        },
        SelectionSet: {
          leave: ({ selections }) => block(selections)
        },
        Field: {
          leave({ alias, name, arguments: args, directives, selectionSet }) {
            const prefix = wrap("", alias, ": ") + name;
            let argsLine = prefix + wrap("(", join10(args, ", "), ")");
            if (argsLine.length > MAX_LINE_LENGTH) {
              argsLine = prefix + wrap("(\n", indent(join10(args, "\n")), "\n)");
            }
            return join10([argsLine, join10(directives, " "), selectionSet], " ");
          }
        },
        Argument: {
          leave: ({ name, value }) => name + ": " + value
        },
        // Fragments
        FragmentSpread: {
          leave: ({ name, directives }) => "..." + name + wrap(" ", join10(directives, " "))
        },
        InlineFragment: {
          leave: ({ typeCondition, directives, selectionSet }) => join10(
            [
              "...",
              wrap("on ", typeCondition),
              join10(directives, " "),
              selectionSet
            ],
            " "
          )
        },
        FragmentDefinition: {
          leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
            // or removed in the future.
            `fragment ${name}${wrap("(", join10(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join10(directives, " "), " ")}` + selectionSet
          )
        },
        // Value
        IntValue: {
          leave: ({ value }) => value
        },
        FloatValue: {
          leave: ({ value }) => value
        },
        StringValue: {
          leave: ({ value, block: isBlockString }) => isBlockString ? (0, _blockString.printBlockString)(value) : (0, _printString.printString)(value)
        },
        BooleanValue: {
          leave: ({ value }) => value ? "true" : "false"
        },
        NullValue: {
          leave: () => "null"
        },
        EnumValue: {
          leave: ({ value }) => value
        },
        ListValue: {
          leave: ({ values }) => "[" + join10(values, ", ") + "]"
        },
        ObjectValue: {
          leave: ({ fields }) => "{" + join10(fields, ", ") + "}"
        },
        ObjectField: {
          leave: ({ name, value }) => name + ": " + value
        },
        // Directive
        Directive: {
          leave: ({ name, arguments: args }) => "@" + name + wrap("(", join10(args, ", "), ")")
        },
        // Type
        NamedType: {
          leave: ({ name }) => name
        },
        ListType: {
          leave: ({ type: type3 }) => "[" + type3 + "]"
        },
        NonNullType: {
          leave: ({ type: type3 }) => type3 + "!"
        },
        // Type System Definitions
        SchemaDefinition: {
          leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join10(["schema", join10(directives, " "), block(operationTypes)], " ")
        },
        OperationTypeDefinition: {
          leave: ({ operation, type: type3 }) => operation + ": " + type3
        },
        ScalarTypeDefinition: {
          leave: ({ description, name, directives }) => wrap("", description, "\n") + join10(["scalar", name, join10(directives, " ")], " ")
        },
        ObjectTypeDefinition: {
          leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join10(
            [
              "type",
              name,
              wrap("implements ", join10(interfaces, " & ")),
              join10(directives, " "),
              block(fields)
            ],
            " "
          )
        },
        FieldDefinition: {
          leave: ({ description, name, arguments: args, type: type3, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join10(args, "\n")), "\n)") : wrap("(", join10(args, ", "), ")")) + ": " + type3 + wrap(" ", join10(directives, " "))
        },
        InputValueDefinition: {
          leave: ({ description, name, type: type3, defaultValue, directives }) => wrap("", description, "\n") + join10(
            [name + ": " + type3, wrap("= ", defaultValue), join10(directives, " ")],
            " "
          )
        },
        InterfaceTypeDefinition: {
          leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join10(
            [
              "interface",
              name,
              wrap("implements ", join10(interfaces, " & ")),
              join10(directives, " "),
              block(fields)
            ],
            " "
          )
        },
        UnionTypeDefinition: {
          leave: ({ description, name, directives, types: types2 }) => wrap("", description, "\n") + join10(
            ["union", name, join10(directives, " "), wrap("= ", join10(types2, " | "))],
            " "
          )
        },
        EnumTypeDefinition: {
          leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join10(["enum", name, join10(directives, " "), block(values)], " ")
        },
        EnumValueDefinition: {
          leave: ({ description, name, directives }) => wrap("", description, "\n") + join10([name, join10(directives, " ")], " ")
        },
        InputObjectTypeDefinition: {
          leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join10(["input", name, join10(directives, " "), block(fields)], " ")
        },
        DirectiveDefinition: {
          leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join10(args, "\n")), "\n)") : wrap("(", join10(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join10(locations, " | ")
        },
        SchemaExtension: {
          leave: ({ directives, operationTypes }) => join10(
            ["extend schema", join10(directives, " "), block(operationTypes)],
            " "
          )
        },
        ScalarTypeExtension: {
          leave: ({ name, directives }) => join10(["extend scalar", name, join10(directives, " ")], " ")
        },
        ObjectTypeExtension: {
          leave: ({ name, interfaces, directives, fields }) => join10(
            [
              "extend type",
              name,
              wrap("implements ", join10(interfaces, " & ")),
              join10(directives, " "),
              block(fields)
            ],
            " "
          )
        },
        InterfaceTypeExtension: {
          leave: ({ name, interfaces, directives, fields }) => join10(
            [
              "extend interface",
              name,
              wrap("implements ", join10(interfaces, " & ")),
              join10(directives, " "),
              block(fields)
            ],
            " "
          )
        },
        UnionTypeExtension: {
          leave: ({ name, directives, types: types2 }) => join10(
            [
              "extend union",
              name,
              join10(directives, " "),
              wrap("= ", join10(types2, " | "))
            ],
            " "
          )
        },
        EnumTypeExtension: {
          leave: ({ name, directives, values }) => join10(["extend enum", name, join10(directives, " "), block(values)], " ")
        },
        InputObjectTypeExtension: {
          leave: ({ name, directives, fields }) => join10(["extend input", name, join10(directives, " "), block(fields)], " ")
        }
      };
      function join10(maybeArray, separator = "") {
        var _maybeArray$filter$jo;
        return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x) => x).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
      }
      function block(array2) {
        return wrap("{\n", indent(join10(array2, "\n")), "\n}");
      }
      function wrap(start, maybeString, end = "") {
        return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
      }
      function indent(str) {
        return wrap("  ", str.replace(/\n/g, "\n  "));
      }
      function hasMultilineItems(maybeArray) {
        var _maybeArray$some;
        return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
      }
    }
  });

  // ../../node_modules/.pnpm/extract-files@9.0.0/node_modules/extract-files/public/ReactNativeFile.js
  var require_ReactNativeFile = __commonJS({
    "../../node_modules/.pnpm/extract-files@9.0.0/node_modules/extract-files/public/ReactNativeFile.js"(exports, module2) {
      "use strict";
      module2.exports = function ReactNativeFile(_ref) {
        var uri = _ref.uri, name = _ref.name, type3 = _ref.type;
        this.uri = uri;
        this.name = name;
        this.type = type3;
      };
    }
  });

  // ../../node_modules/.pnpm/extract-files@9.0.0/node_modules/extract-files/public/isExtractableFile.js
  var require_isExtractableFile = __commonJS({
    "../../node_modules/.pnpm/extract-files@9.0.0/node_modules/extract-files/public/isExtractableFile.js"(exports, module2) {
      "use strict";
      var ReactNativeFile = require_ReactNativeFile();
      module2.exports = function isExtractableFile(value) {
        return typeof File !== "undefined" && value instanceof File || typeof Blob !== "undefined" && value instanceof Blob || value instanceof ReactNativeFile;
      };
    }
  });

  // ../../node_modules/.pnpm/extract-files@9.0.0/node_modules/extract-files/public/extractFiles.js
  var require_extractFiles = __commonJS({
    "../../node_modules/.pnpm/extract-files@9.0.0/node_modules/extract-files/public/extractFiles.js"(exports, module2) {
      "use strict";
      var defaultIsExtractableFile = require_isExtractableFile();
      module2.exports = function extractFiles(value, path4, isExtractableFile) {
        if (path4 === void 0) {
          path4 = "";
        }
        if (isExtractableFile === void 0) {
          isExtractableFile = defaultIsExtractableFile;
        }
        var clone5;
        var files = /* @__PURE__ */ new Map();
        function addFile(paths, file) {
          var storedPaths = files.get(file);
          if (storedPaths)
            storedPaths.push.apply(storedPaths, paths);
          else
            files.set(file, paths);
        }
        if (isExtractableFile(value)) {
          clone5 = null;
          addFile([path4], value);
        } else {
          var prefix = path4 ? path4 + "." : "";
          if (typeof FileList !== "undefined" && value instanceof FileList)
            clone5 = Array.prototype.map.call(value, function(file, i2) {
              addFile(["" + prefix + i2], file);
              return null;
            });
          else if (Array.isArray(value))
            clone5 = value.map(function(child, i2) {
              var result2 = extractFiles(child, "" + prefix + i2, isExtractableFile);
              result2.files.forEach(addFile);
              return result2.clone;
            });
          else if (value && value.constructor === Object) {
            clone5 = {};
            for (var i in value) {
              var result = extractFiles(value[i], "" + prefix + i, isExtractableFile);
              result.files.forEach(addFile);
              clone5[i] = result.clone;
            }
          } else
            clone5 = value;
        }
        return {
          clone: clone5,
          files
        };
      };
    }
  });

  // ../../node_modules/.pnpm/extract-files@9.0.0/node_modules/extract-files/public/index.js
  var require_public = __commonJS({
    "../../node_modules/.pnpm/extract-files@9.0.0/node_modules/extract-files/public/index.js"(exports) {
      "use strict";
      exports.ReactNativeFile = require_ReactNativeFile();
      exports.extractFiles = require_extractFiles();
      exports.isExtractableFile = require_isExtractableFile();
    }
  });

  // ../../node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js
  var require_delayed_stream = __commonJS({
    "../../node_modules/.pnpm/delayed-stream@1.0.0/node_modules/delayed-stream/lib/delayed_stream.js"(exports, module2) {
      var Stream3 = __require2("stream").Stream;
      var util = __require2("util");
      module2.exports = DelayedStream;
      function DelayedStream() {
        this.source = null;
        this.dataSize = 0;
        this.maxDataSize = 1024 * 1024;
        this.pauseStream = true;
        this._maxDataSizeExceeded = false;
        this._released = false;
        this._bufferedEvents = [];
      }
      util.inherits(DelayedStream, Stream3);
      DelayedStream.create = function(source, options) {
        var delayedStream = new this();
        options = options || {};
        for (var option in options) {
          delayedStream[option] = options[option];
        }
        delayedStream.source = source;
        var realEmit = source.emit;
        source.emit = function() {
          delayedStream._handleEmit(arguments);
          return realEmit.apply(source, arguments);
        };
        source.on("error", function() {
        });
        if (delayedStream.pauseStream) {
          source.pause();
        }
        return delayedStream;
      };
      Object.defineProperty(DelayedStream.prototype, "readable", {
        configurable: true,
        enumerable: true,
        get: function() {
          return this.source.readable;
        }
      });
      DelayedStream.prototype.setEncoding = function() {
        return this.source.setEncoding.apply(this.source, arguments);
      };
      DelayedStream.prototype.resume = function() {
        if (!this._released) {
          this.release();
        }
        this.source.resume();
      };
      DelayedStream.prototype.pause = function() {
        this.source.pause();
      };
      DelayedStream.prototype.release = function() {
        this._released = true;
        this._bufferedEvents.forEach(function(args) {
          this.emit.apply(this, args);
        }.bind(this));
        this._bufferedEvents = [];
      };
      DelayedStream.prototype.pipe = function() {
        var r = Stream3.prototype.pipe.apply(this, arguments);
        this.resume();
        return r;
      };
      DelayedStream.prototype._handleEmit = function(args) {
        if (this._released) {
          this.emit.apply(this, args);
          return;
        }
        if (args[0] === "data") {
          this.dataSize += args[1].length;
          this._checkIfMaxDataSizeExceeded();
        }
        this._bufferedEvents.push(args);
      };
      DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
        if (this._maxDataSizeExceeded) {
          return;
        }
        if (this.dataSize <= this.maxDataSize) {
          return;
        }
        this._maxDataSizeExceeded = true;
        var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
        this.emit("error", new Error(message));
      };
    }
  });

  // ../../node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js
  var require_combined_stream = __commonJS({
    "../../node_modules/.pnpm/combined-stream@1.0.8/node_modules/combined-stream/lib/combined_stream.js"(exports, module2) {
      var util = __require2("util");
      var Stream3 = __require2("stream").Stream;
      var DelayedStream = require_delayed_stream();
      module2.exports = CombinedStream;
      function CombinedStream() {
        this.writable = false;
        this.readable = true;
        this.dataSize = 0;
        this.maxDataSize = 2 * 1024 * 1024;
        this.pauseStreams = true;
        this._released = false;
        this._streams = [];
        this._currentStream = null;
        this._insideLoop = false;
        this._pendingNext = false;
      }
      util.inherits(CombinedStream, Stream3);
      CombinedStream.create = function(options) {
        var combinedStream = new this();
        options = options || {};
        for (var option in options) {
          combinedStream[option] = options[option];
        }
        return combinedStream;
      };
      CombinedStream.isStreamLike = function(stream2) {
        return typeof stream2 !== "function" && typeof stream2 !== "string" && typeof stream2 !== "boolean" && typeof stream2 !== "number" && !Buffer.isBuffer(stream2);
      };
      CombinedStream.prototype.append = function(stream2) {
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          if (!(stream2 instanceof DelayedStream)) {
            var newStream = DelayedStream.create(stream2, {
              maxDataSize: Infinity,
              pauseStream: this.pauseStreams
            });
            stream2.on("data", this._checkDataSize.bind(this));
            stream2 = newStream;
          }
          this._handleErrors(stream2);
          if (this.pauseStreams) {
            stream2.pause();
          }
        }
        this._streams.push(stream2);
        return this;
      };
      CombinedStream.prototype.pipe = function(dest, options) {
        Stream3.prototype.pipe.call(this, dest, options);
        this.resume();
        return dest;
      };
      CombinedStream.prototype._getNext = function() {
        this._currentStream = null;
        if (this._insideLoop) {
          this._pendingNext = true;
          return;
        }
        this._insideLoop = true;
        try {
          do {
            this._pendingNext = false;
            this._realGetNext();
          } while (this._pendingNext);
        } finally {
          this._insideLoop = false;
        }
      };
      CombinedStream.prototype._realGetNext = function() {
        var stream2 = this._streams.shift();
        if (typeof stream2 == "undefined") {
          this.end();
          return;
        }
        if (typeof stream2 !== "function") {
          this._pipeNext(stream2);
          return;
        }
        var getStream = stream2;
        getStream(function(stream3) {
          var isStreamLike = CombinedStream.isStreamLike(stream3);
          if (isStreamLike) {
            stream3.on("data", this._checkDataSize.bind(this));
            this._handleErrors(stream3);
          }
          this._pipeNext(stream3);
        }.bind(this));
      };
      CombinedStream.prototype._pipeNext = function(stream2) {
        this._currentStream = stream2;
        var isStreamLike = CombinedStream.isStreamLike(stream2);
        if (isStreamLike) {
          stream2.on("end", this._getNext.bind(this));
          stream2.pipe(this, { end: false });
          return;
        }
        var value = stream2;
        this.write(value);
        this._getNext();
      };
      CombinedStream.prototype._handleErrors = function(stream2) {
        var self2 = this;
        stream2.on("error", function(err) {
          self2._emitError(err);
        });
      };
      CombinedStream.prototype.write = function(data) {
        this.emit("data", data);
      };
      CombinedStream.prototype.pause = function() {
        if (!this.pauseStreams) {
          return;
        }
        if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function")
          this._currentStream.pause();
        this.emit("pause");
      };
      CombinedStream.prototype.resume = function() {
        if (!this._released) {
          this._released = true;
          this.writable = true;
          this._getNext();
        }
        if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function")
          this._currentStream.resume();
        this.emit("resume");
      };
      CombinedStream.prototype.end = function() {
        this._reset();
        this.emit("end");
      };
      CombinedStream.prototype.destroy = function() {
        this._reset();
        this.emit("close");
      };
      CombinedStream.prototype._reset = function() {
        this.writable = false;
        this._streams = [];
        this._currentStream = null;
      };
      CombinedStream.prototype._checkDataSize = function() {
        this._updateDataSize();
        if (this.dataSize <= this.maxDataSize) {
          return;
        }
        var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
        this._emitError(new Error(message));
      };
      CombinedStream.prototype._updateDataSize = function() {
        this.dataSize = 0;
        var self2 = this;
        this._streams.forEach(function(stream2) {
          if (!stream2.dataSize) {
            return;
          }
          self2.dataSize += stream2.dataSize;
        });
        if (this._currentStream && this._currentStream.dataSize) {
          this.dataSize += this._currentStream.dataSize;
        }
      };
      CombinedStream.prototype._emitError = function(err) {
        this._reset();
        this.emit("error", err);
      };
    }
  });

  // ../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json
  var require_db = __commonJS({
    "../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/db.json"(exports, module2) {
      module2.exports = {
        "application/1d-interleaved-parityfec": {
          source: "iana"
        },
        "application/3gpdash-qoe-report+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/3gpp-ims+xml": {
          source: "iana",
          compressible: true
        },
        "application/3gpphal+json": {
          source: "iana",
          compressible: true
        },
        "application/3gpphalforms+json": {
          source: "iana",
          compressible: true
        },
        "application/a2l": {
          source: "iana"
        },
        "application/ace+cbor": {
          source: "iana"
        },
        "application/activemessage": {
          source: "iana"
        },
        "application/activity+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-costmap+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-costmapfilter+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-directory+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-endpointcost+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-endpointcostparams+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-endpointprop+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-endpointpropparams+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-error+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-networkmap+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-networkmapfilter+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-updatestreamcontrol+json": {
          source: "iana",
          compressible: true
        },
        "application/alto-updatestreamparams+json": {
          source: "iana",
          compressible: true
        },
        "application/aml": {
          source: "iana"
        },
        "application/andrew-inset": {
          source: "iana",
          extensions: ["ez"]
        },
        "application/applefile": {
          source: "iana"
        },
        "application/applixware": {
          source: "apache",
          extensions: ["aw"]
        },
        "application/at+jwt": {
          source: "iana"
        },
        "application/atf": {
          source: "iana"
        },
        "application/atfx": {
          source: "iana"
        },
        "application/atom+xml": {
          source: "iana",
          compressible: true,
          extensions: ["atom"]
        },
        "application/atomcat+xml": {
          source: "iana",
          compressible: true,
          extensions: ["atomcat"]
        },
        "application/atomdeleted+xml": {
          source: "iana",
          compressible: true,
          extensions: ["atomdeleted"]
        },
        "application/atomicmail": {
          source: "iana"
        },
        "application/atomsvc+xml": {
          source: "iana",
          compressible: true,
          extensions: ["atomsvc"]
        },
        "application/atsc-dwd+xml": {
          source: "iana",
          compressible: true,
          extensions: ["dwd"]
        },
        "application/atsc-dynamic-event-message": {
          source: "iana"
        },
        "application/atsc-held+xml": {
          source: "iana",
          compressible: true,
          extensions: ["held"]
        },
        "application/atsc-rdt+json": {
          source: "iana",
          compressible: true
        },
        "application/atsc-rsat+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rsat"]
        },
        "application/atxml": {
          source: "iana"
        },
        "application/auth-policy+xml": {
          source: "iana",
          compressible: true
        },
        "application/bacnet-xdd+zip": {
          source: "iana",
          compressible: false
        },
        "application/batch-smtp": {
          source: "iana"
        },
        "application/bdoc": {
          compressible: false,
          extensions: ["bdoc"]
        },
        "application/beep+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/calendar+json": {
          source: "iana",
          compressible: true
        },
        "application/calendar+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xcs"]
        },
        "application/call-completion": {
          source: "iana"
        },
        "application/cals-1840": {
          source: "iana"
        },
        "application/captive+json": {
          source: "iana",
          compressible: true
        },
        "application/cbor": {
          source: "iana"
        },
        "application/cbor-seq": {
          source: "iana"
        },
        "application/cccex": {
          source: "iana"
        },
        "application/ccmp+xml": {
          source: "iana",
          compressible: true
        },
        "application/ccxml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["ccxml"]
        },
        "application/cdfx+xml": {
          source: "iana",
          compressible: true,
          extensions: ["cdfx"]
        },
        "application/cdmi-capability": {
          source: "iana",
          extensions: ["cdmia"]
        },
        "application/cdmi-container": {
          source: "iana",
          extensions: ["cdmic"]
        },
        "application/cdmi-domain": {
          source: "iana",
          extensions: ["cdmid"]
        },
        "application/cdmi-object": {
          source: "iana",
          extensions: ["cdmio"]
        },
        "application/cdmi-queue": {
          source: "iana",
          extensions: ["cdmiq"]
        },
        "application/cdni": {
          source: "iana"
        },
        "application/cea": {
          source: "iana"
        },
        "application/cea-2018+xml": {
          source: "iana",
          compressible: true
        },
        "application/cellml+xml": {
          source: "iana",
          compressible: true
        },
        "application/cfw": {
          source: "iana"
        },
        "application/city+json": {
          source: "iana",
          compressible: true
        },
        "application/clr": {
          source: "iana"
        },
        "application/clue+xml": {
          source: "iana",
          compressible: true
        },
        "application/clue_info+xml": {
          source: "iana",
          compressible: true
        },
        "application/cms": {
          source: "iana"
        },
        "application/cnrp+xml": {
          source: "iana",
          compressible: true
        },
        "application/coap-group+json": {
          source: "iana",
          compressible: true
        },
        "application/coap-payload": {
          source: "iana"
        },
        "application/commonground": {
          source: "iana"
        },
        "application/conference-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/cose": {
          source: "iana"
        },
        "application/cose-key": {
          source: "iana"
        },
        "application/cose-key-set": {
          source: "iana"
        },
        "application/cpl+xml": {
          source: "iana",
          compressible: true,
          extensions: ["cpl"]
        },
        "application/csrattrs": {
          source: "iana"
        },
        "application/csta+xml": {
          source: "iana",
          compressible: true
        },
        "application/cstadata+xml": {
          source: "iana",
          compressible: true
        },
        "application/csvm+json": {
          source: "iana",
          compressible: true
        },
        "application/cu-seeme": {
          source: "apache",
          extensions: ["cu"]
        },
        "application/cwt": {
          source: "iana"
        },
        "application/cybercash": {
          source: "iana"
        },
        "application/dart": {
          compressible: true
        },
        "application/dash+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mpd"]
        },
        "application/dash-patch+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mpp"]
        },
        "application/dashdelta": {
          source: "iana"
        },
        "application/davmount+xml": {
          source: "iana",
          compressible: true,
          extensions: ["davmount"]
        },
        "application/dca-rft": {
          source: "iana"
        },
        "application/dcd": {
          source: "iana"
        },
        "application/dec-dx": {
          source: "iana"
        },
        "application/dialog-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/dicom": {
          source: "iana"
        },
        "application/dicom+json": {
          source: "iana",
          compressible: true
        },
        "application/dicom+xml": {
          source: "iana",
          compressible: true
        },
        "application/dii": {
          source: "iana"
        },
        "application/dit": {
          source: "iana"
        },
        "application/dns": {
          source: "iana"
        },
        "application/dns+json": {
          source: "iana",
          compressible: true
        },
        "application/dns-message": {
          source: "iana"
        },
        "application/docbook+xml": {
          source: "apache",
          compressible: true,
          extensions: ["dbk"]
        },
        "application/dots+cbor": {
          source: "iana"
        },
        "application/dskpp+xml": {
          source: "iana",
          compressible: true
        },
        "application/dssc+der": {
          source: "iana",
          extensions: ["dssc"]
        },
        "application/dssc+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xdssc"]
        },
        "application/dvcs": {
          source: "iana"
        },
        "application/ecmascript": {
          source: "iana",
          compressible: true,
          extensions: ["es", "ecma"]
        },
        "application/edi-consent": {
          source: "iana"
        },
        "application/edi-x12": {
          source: "iana",
          compressible: false
        },
        "application/edifact": {
          source: "iana",
          compressible: false
        },
        "application/efi": {
          source: "iana"
        },
        "application/elm+json": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/elm+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.cap+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/emergencycalldata.comment+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.control+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.deviceinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.ecall.msd": {
          source: "iana"
        },
        "application/emergencycalldata.providerinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.serviceinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.subscriberinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/emergencycalldata.veds+xml": {
          source: "iana",
          compressible: true
        },
        "application/emma+xml": {
          source: "iana",
          compressible: true,
          extensions: ["emma"]
        },
        "application/emotionml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["emotionml"]
        },
        "application/encaprtp": {
          source: "iana"
        },
        "application/epp+xml": {
          source: "iana",
          compressible: true
        },
        "application/epub+zip": {
          source: "iana",
          compressible: false,
          extensions: ["epub"]
        },
        "application/eshop": {
          source: "iana"
        },
        "application/exi": {
          source: "iana",
          extensions: ["exi"]
        },
        "application/expect-ct-report+json": {
          source: "iana",
          compressible: true
        },
        "application/express": {
          source: "iana",
          extensions: ["exp"]
        },
        "application/fastinfoset": {
          source: "iana"
        },
        "application/fastsoap": {
          source: "iana"
        },
        "application/fdt+xml": {
          source: "iana",
          compressible: true,
          extensions: ["fdt"]
        },
        "application/fhir+json": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/fhir+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/fido.trusted-apps+json": {
          compressible: true
        },
        "application/fits": {
          source: "iana"
        },
        "application/flexfec": {
          source: "iana"
        },
        "application/font-sfnt": {
          source: "iana"
        },
        "application/font-tdpfr": {
          source: "iana",
          extensions: ["pfr"]
        },
        "application/font-woff": {
          source: "iana",
          compressible: false
        },
        "application/framework-attributes+xml": {
          source: "iana",
          compressible: true
        },
        "application/geo+json": {
          source: "iana",
          compressible: true,
          extensions: ["geojson"]
        },
        "application/geo+json-seq": {
          source: "iana"
        },
        "application/geopackage+sqlite3": {
          source: "iana"
        },
        "application/geoxacml+xml": {
          source: "iana",
          compressible: true
        },
        "application/gltf-buffer": {
          source: "iana"
        },
        "application/gml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["gml"]
        },
        "application/gpx+xml": {
          source: "apache",
          compressible: true,
          extensions: ["gpx"]
        },
        "application/gxf": {
          source: "apache",
          extensions: ["gxf"]
        },
        "application/gzip": {
          source: "iana",
          compressible: false,
          extensions: ["gz"]
        },
        "application/h224": {
          source: "iana"
        },
        "application/held+xml": {
          source: "iana",
          compressible: true
        },
        "application/hjson": {
          extensions: ["hjson"]
        },
        "application/http": {
          source: "iana"
        },
        "application/hyperstudio": {
          source: "iana",
          extensions: ["stk"]
        },
        "application/ibe-key-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/ibe-pkg-reply+xml": {
          source: "iana",
          compressible: true
        },
        "application/ibe-pp-data": {
          source: "iana"
        },
        "application/iges": {
          source: "iana"
        },
        "application/im-iscomposing+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/index": {
          source: "iana"
        },
        "application/index.cmd": {
          source: "iana"
        },
        "application/index.obj": {
          source: "iana"
        },
        "application/index.response": {
          source: "iana"
        },
        "application/index.vnd": {
          source: "iana"
        },
        "application/inkml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["ink", "inkml"]
        },
        "application/iotp": {
          source: "iana"
        },
        "application/ipfix": {
          source: "iana",
          extensions: ["ipfix"]
        },
        "application/ipp": {
          source: "iana"
        },
        "application/isup": {
          source: "iana"
        },
        "application/its+xml": {
          source: "iana",
          compressible: true,
          extensions: ["its"]
        },
        "application/java-archive": {
          source: "apache",
          compressible: false,
          extensions: ["jar", "war", "ear"]
        },
        "application/java-serialized-object": {
          source: "apache",
          compressible: false,
          extensions: ["ser"]
        },
        "application/java-vm": {
          source: "apache",
          compressible: false,
          extensions: ["class"]
        },
        "application/javascript": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["js", "mjs"]
        },
        "application/jf2feed+json": {
          source: "iana",
          compressible: true
        },
        "application/jose": {
          source: "iana"
        },
        "application/jose+json": {
          source: "iana",
          compressible: true
        },
        "application/jrd+json": {
          source: "iana",
          compressible: true
        },
        "application/jscalendar+json": {
          source: "iana",
          compressible: true
        },
        "application/json": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["json", "map"]
        },
        "application/json-patch+json": {
          source: "iana",
          compressible: true
        },
        "application/json-seq": {
          source: "iana"
        },
        "application/json5": {
          extensions: ["json5"]
        },
        "application/jsonml+json": {
          source: "apache",
          compressible: true,
          extensions: ["jsonml"]
        },
        "application/jwk+json": {
          source: "iana",
          compressible: true
        },
        "application/jwk-set+json": {
          source: "iana",
          compressible: true
        },
        "application/jwt": {
          source: "iana"
        },
        "application/kpml-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/kpml-response+xml": {
          source: "iana",
          compressible: true
        },
        "application/ld+json": {
          source: "iana",
          compressible: true,
          extensions: ["jsonld"]
        },
        "application/lgr+xml": {
          source: "iana",
          compressible: true,
          extensions: ["lgr"]
        },
        "application/link-format": {
          source: "iana"
        },
        "application/load-control+xml": {
          source: "iana",
          compressible: true
        },
        "application/lost+xml": {
          source: "iana",
          compressible: true,
          extensions: ["lostxml"]
        },
        "application/lostsync+xml": {
          source: "iana",
          compressible: true
        },
        "application/lpf+zip": {
          source: "iana",
          compressible: false
        },
        "application/lxf": {
          source: "iana"
        },
        "application/mac-binhex40": {
          source: "iana",
          extensions: ["hqx"]
        },
        "application/mac-compactpro": {
          source: "apache",
          extensions: ["cpt"]
        },
        "application/macwriteii": {
          source: "iana"
        },
        "application/mads+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mads"]
        },
        "application/manifest+json": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["webmanifest"]
        },
        "application/marc": {
          source: "iana",
          extensions: ["mrc"]
        },
        "application/marcxml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mrcx"]
        },
        "application/mathematica": {
          source: "iana",
          extensions: ["ma", "nb", "mb"]
        },
        "application/mathml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mathml"]
        },
        "application/mathml-content+xml": {
          source: "iana",
          compressible: true
        },
        "application/mathml-presentation+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-associated-procedure-description+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-deregister+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-envelope+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-msk+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-msk-response+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-protection-description+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-reception-report+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-register+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-register-response+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-schedule+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbms-user-service-description+xml": {
          source: "iana",
          compressible: true
        },
        "application/mbox": {
          source: "iana",
          extensions: ["mbox"]
        },
        "application/media-policy-dataset+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mpf"]
        },
        "application/media_control+xml": {
          source: "iana",
          compressible: true
        },
        "application/mediaservercontrol+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mscml"]
        },
        "application/merge-patch+json": {
          source: "iana",
          compressible: true
        },
        "application/metalink+xml": {
          source: "apache",
          compressible: true,
          extensions: ["metalink"]
        },
        "application/metalink4+xml": {
          source: "iana",
          compressible: true,
          extensions: ["meta4"]
        },
        "application/mets+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mets"]
        },
        "application/mf4": {
          source: "iana"
        },
        "application/mikey": {
          source: "iana"
        },
        "application/mipc": {
          source: "iana"
        },
        "application/missing-blocks+cbor-seq": {
          source: "iana"
        },
        "application/mmt-aei+xml": {
          source: "iana",
          compressible: true,
          extensions: ["maei"]
        },
        "application/mmt-usd+xml": {
          source: "iana",
          compressible: true,
          extensions: ["musd"]
        },
        "application/mods+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mods"]
        },
        "application/moss-keys": {
          source: "iana"
        },
        "application/moss-signature": {
          source: "iana"
        },
        "application/mosskey-data": {
          source: "iana"
        },
        "application/mosskey-request": {
          source: "iana"
        },
        "application/mp21": {
          source: "iana",
          extensions: ["m21", "mp21"]
        },
        "application/mp4": {
          source: "iana",
          extensions: ["mp4s", "m4p"]
        },
        "application/mpeg4-generic": {
          source: "iana"
        },
        "application/mpeg4-iod": {
          source: "iana"
        },
        "application/mpeg4-iod-xmt": {
          source: "iana"
        },
        "application/mrb-consumer+xml": {
          source: "iana",
          compressible: true
        },
        "application/mrb-publish+xml": {
          source: "iana",
          compressible: true
        },
        "application/msc-ivr+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/msc-mixer+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/msword": {
          source: "iana",
          compressible: false,
          extensions: ["doc", "dot"]
        },
        "application/mud+json": {
          source: "iana",
          compressible: true
        },
        "application/multipart-core": {
          source: "iana"
        },
        "application/mxf": {
          source: "iana",
          extensions: ["mxf"]
        },
        "application/n-quads": {
          source: "iana",
          extensions: ["nq"]
        },
        "application/n-triples": {
          source: "iana",
          extensions: ["nt"]
        },
        "application/nasdata": {
          source: "iana"
        },
        "application/news-checkgroups": {
          source: "iana",
          charset: "US-ASCII"
        },
        "application/news-groupinfo": {
          source: "iana",
          charset: "US-ASCII"
        },
        "application/news-transmission": {
          source: "iana"
        },
        "application/nlsml+xml": {
          source: "iana",
          compressible: true
        },
        "application/node": {
          source: "iana",
          extensions: ["cjs"]
        },
        "application/nss": {
          source: "iana"
        },
        "application/oauth-authz-req+jwt": {
          source: "iana"
        },
        "application/oblivious-dns-message": {
          source: "iana"
        },
        "application/ocsp-request": {
          source: "iana"
        },
        "application/ocsp-response": {
          source: "iana"
        },
        "application/octet-stream": {
          source: "iana",
          compressible: false,
          extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
        },
        "application/oda": {
          source: "iana",
          extensions: ["oda"]
        },
        "application/odm+xml": {
          source: "iana",
          compressible: true
        },
        "application/odx": {
          source: "iana"
        },
        "application/oebps-package+xml": {
          source: "iana",
          compressible: true,
          extensions: ["opf"]
        },
        "application/ogg": {
          source: "iana",
          compressible: false,
          extensions: ["ogx"]
        },
        "application/omdoc+xml": {
          source: "apache",
          compressible: true,
          extensions: ["omdoc"]
        },
        "application/onenote": {
          source: "apache",
          extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
        },
        "application/opc-nodeset+xml": {
          source: "iana",
          compressible: true
        },
        "application/oscore": {
          source: "iana"
        },
        "application/oxps": {
          source: "iana",
          extensions: ["oxps"]
        },
        "application/p21": {
          source: "iana"
        },
        "application/p21+zip": {
          source: "iana",
          compressible: false
        },
        "application/p2p-overlay+xml": {
          source: "iana",
          compressible: true,
          extensions: ["relo"]
        },
        "application/parityfec": {
          source: "iana"
        },
        "application/passport": {
          source: "iana"
        },
        "application/patch-ops-error+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xer"]
        },
        "application/pdf": {
          source: "iana",
          compressible: false,
          extensions: ["pdf"]
        },
        "application/pdx": {
          source: "iana"
        },
        "application/pem-certificate-chain": {
          source: "iana"
        },
        "application/pgp-encrypted": {
          source: "iana",
          compressible: false,
          extensions: ["pgp"]
        },
        "application/pgp-keys": {
          source: "iana",
          extensions: ["asc"]
        },
        "application/pgp-signature": {
          source: "iana",
          extensions: ["asc", "sig"]
        },
        "application/pics-rules": {
          source: "apache",
          extensions: ["prf"]
        },
        "application/pidf+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/pidf-diff+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/pkcs10": {
          source: "iana",
          extensions: ["p10"]
        },
        "application/pkcs12": {
          source: "iana"
        },
        "application/pkcs7-mime": {
          source: "iana",
          extensions: ["p7m", "p7c"]
        },
        "application/pkcs7-signature": {
          source: "iana",
          extensions: ["p7s"]
        },
        "application/pkcs8": {
          source: "iana",
          extensions: ["p8"]
        },
        "application/pkcs8-encrypted": {
          source: "iana"
        },
        "application/pkix-attr-cert": {
          source: "iana",
          extensions: ["ac"]
        },
        "application/pkix-cert": {
          source: "iana",
          extensions: ["cer"]
        },
        "application/pkix-crl": {
          source: "iana",
          extensions: ["crl"]
        },
        "application/pkix-pkipath": {
          source: "iana",
          extensions: ["pkipath"]
        },
        "application/pkixcmp": {
          source: "iana",
          extensions: ["pki"]
        },
        "application/pls+xml": {
          source: "iana",
          compressible: true,
          extensions: ["pls"]
        },
        "application/poc-settings+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/postscript": {
          source: "iana",
          compressible: true,
          extensions: ["ai", "eps", "ps"]
        },
        "application/ppsp-tracker+json": {
          source: "iana",
          compressible: true
        },
        "application/problem+json": {
          source: "iana",
          compressible: true
        },
        "application/problem+xml": {
          source: "iana",
          compressible: true
        },
        "application/provenance+xml": {
          source: "iana",
          compressible: true,
          extensions: ["provx"]
        },
        "application/prs.alvestrand.titrax-sheet": {
          source: "iana"
        },
        "application/prs.cww": {
          source: "iana",
          extensions: ["cww"]
        },
        "application/prs.cyn": {
          source: "iana",
          charset: "7-BIT"
        },
        "application/prs.hpub+zip": {
          source: "iana",
          compressible: false
        },
        "application/prs.nprend": {
          source: "iana"
        },
        "application/prs.plucker": {
          source: "iana"
        },
        "application/prs.rdf-xml-crypt": {
          source: "iana"
        },
        "application/prs.xsf+xml": {
          source: "iana",
          compressible: true
        },
        "application/pskc+xml": {
          source: "iana",
          compressible: true,
          extensions: ["pskcxml"]
        },
        "application/pvd+json": {
          source: "iana",
          compressible: true
        },
        "application/qsig": {
          source: "iana"
        },
        "application/raml+yaml": {
          compressible: true,
          extensions: ["raml"]
        },
        "application/raptorfec": {
          source: "iana"
        },
        "application/rdap+json": {
          source: "iana",
          compressible: true
        },
        "application/rdf+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rdf", "owl"]
        },
        "application/reginfo+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rif"]
        },
        "application/relax-ng-compact-syntax": {
          source: "iana",
          extensions: ["rnc"]
        },
        "application/remote-printing": {
          source: "iana"
        },
        "application/reputon+json": {
          source: "iana",
          compressible: true
        },
        "application/resource-lists+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rl"]
        },
        "application/resource-lists-diff+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rld"]
        },
        "application/rfc+xml": {
          source: "iana",
          compressible: true
        },
        "application/riscos": {
          source: "iana"
        },
        "application/rlmi+xml": {
          source: "iana",
          compressible: true
        },
        "application/rls-services+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rs"]
        },
        "application/route-apd+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rapd"]
        },
        "application/route-s-tsid+xml": {
          source: "iana",
          compressible: true,
          extensions: ["sls"]
        },
        "application/route-usd+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rusd"]
        },
        "application/rpki-ghostbusters": {
          source: "iana",
          extensions: ["gbr"]
        },
        "application/rpki-manifest": {
          source: "iana",
          extensions: ["mft"]
        },
        "application/rpki-publication": {
          source: "iana"
        },
        "application/rpki-roa": {
          source: "iana",
          extensions: ["roa"]
        },
        "application/rpki-updown": {
          source: "iana"
        },
        "application/rsd+xml": {
          source: "apache",
          compressible: true,
          extensions: ["rsd"]
        },
        "application/rss+xml": {
          source: "apache",
          compressible: true,
          extensions: ["rss"]
        },
        "application/rtf": {
          source: "iana",
          compressible: true,
          extensions: ["rtf"]
        },
        "application/rtploopback": {
          source: "iana"
        },
        "application/rtx": {
          source: "iana"
        },
        "application/samlassertion+xml": {
          source: "iana",
          compressible: true
        },
        "application/samlmetadata+xml": {
          source: "iana",
          compressible: true
        },
        "application/sarif+json": {
          source: "iana",
          compressible: true
        },
        "application/sarif-external-properties+json": {
          source: "iana",
          compressible: true
        },
        "application/sbe": {
          source: "iana"
        },
        "application/sbml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["sbml"]
        },
        "application/scaip+xml": {
          source: "iana",
          compressible: true
        },
        "application/scim+json": {
          source: "iana",
          compressible: true
        },
        "application/scvp-cv-request": {
          source: "iana",
          extensions: ["scq"]
        },
        "application/scvp-cv-response": {
          source: "iana",
          extensions: ["scs"]
        },
        "application/scvp-vp-request": {
          source: "iana",
          extensions: ["spq"]
        },
        "application/scvp-vp-response": {
          source: "iana",
          extensions: ["spp"]
        },
        "application/sdp": {
          source: "iana",
          extensions: ["sdp"]
        },
        "application/secevent+jwt": {
          source: "iana"
        },
        "application/senml+cbor": {
          source: "iana"
        },
        "application/senml+json": {
          source: "iana",
          compressible: true
        },
        "application/senml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["senmlx"]
        },
        "application/senml-etch+cbor": {
          source: "iana"
        },
        "application/senml-etch+json": {
          source: "iana",
          compressible: true
        },
        "application/senml-exi": {
          source: "iana"
        },
        "application/sensml+cbor": {
          source: "iana"
        },
        "application/sensml+json": {
          source: "iana",
          compressible: true
        },
        "application/sensml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["sensmlx"]
        },
        "application/sensml-exi": {
          source: "iana"
        },
        "application/sep+xml": {
          source: "iana",
          compressible: true
        },
        "application/sep-exi": {
          source: "iana"
        },
        "application/session-info": {
          source: "iana"
        },
        "application/set-payment": {
          source: "iana"
        },
        "application/set-payment-initiation": {
          source: "iana",
          extensions: ["setpay"]
        },
        "application/set-registration": {
          source: "iana"
        },
        "application/set-registration-initiation": {
          source: "iana",
          extensions: ["setreg"]
        },
        "application/sgml": {
          source: "iana"
        },
        "application/sgml-open-catalog": {
          source: "iana"
        },
        "application/shf+xml": {
          source: "iana",
          compressible: true,
          extensions: ["shf"]
        },
        "application/sieve": {
          source: "iana",
          extensions: ["siv", "sieve"]
        },
        "application/simple-filter+xml": {
          source: "iana",
          compressible: true
        },
        "application/simple-message-summary": {
          source: "iana"
        },
        "application/simplesymbolcontainer": {
          source: "iana"
        },
        "application/sipc": {
          source: "iana"
        },
        "application/slate": {
          source: "iana"
        },
        "application/smil": {
          source: "iana"
        },
        "application/smil+xml": {
          source: "iana",
          compressible: true,
          extensions: ["smi", "smil"]
        },
        "application/smpte336m": {
          source: "iana"
        },
        "application/soap+fastinfoset": {
          source: "iana"
        },
        "application/soap+xml": {
          source: "iana",
          compressible: true
        },
        "application/sparql-query": {
          source: "iana",
          extensions: ["rq"]
        },
        "application/sparql-results+xml": {
          source: "iana",
          compressible: true,
          extensions: ["srx"]
        },
        "application/spdx+json": {
          source: "iana",
          compressible: true
        },
        "application/spirits-event+xml": {
          source: "iana",
          compressible: true
        },
        "application/sql": {
          source: "iana"
        },
        "application/srgs": {
          source: "iana",
          extensions: ["gram"]
        },
        "application/srgs+xml": {
          source: "iana",
          compressible: true,
          extensions: ["grxml"]
        },
        "application/sru+xml": {
          source: "iana",
          compressible: true,
          extensions: ["sru"]
        },
        "application/ssdl+xml": {
          source: "apache",
          compressible: true,
          extensions: ["ssdl"]
        },
        "application/ssml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["ssml"]
        },
        "application/stix+json": {
          source: "iana",
          compressible: true
        },
        "application/swid+xml": {
          source: "iana",
          compressible: true,
          extensions: ["swidtag"]
        },
        "application/tamp-apex-update": {
          source: "iana"
        },
        "application/tamp-apex-update-confirm": {
          source: "iana"
        },
        "application/tamp-community-update": {
          source: "iana"
        },
        "application/tamp-community-update-confirm": {
          source: "iana"
        },
        "application/tamp-error": {
          source: "iana"
        },
        "application/tamp-sequence-adjust": {
          source: "iana"
        },
        "application/tamp-sequence-adjust-confirm": {
          source: "iana"
        },
        "application/tamp-status-query": {
          source: "iana"
        },
        "application/tamp-status-response": {
          source: "iana"
        },
        "application/tamp-update": {
          source: "iana"
        },
        "application/tamp-update-confirm": {
          source: "iana"
        },
        "application/tar": {
          compressible: true
        },
        "application/taxii+json": {
          source: "iana",
          compressible: true
        },
        "application/td+json": {
          source: "iana",
          compressible: true
        },
        "application/tei+xml": {
          source: "iana",
          compressible: true,
          extensions: ["tei", "teicorpus"]
        },
        "application/tetra_isi": {
          source: "iana"
        },
        "application/thraud+xml": {
          source: "iana",
          compressible: true,
          extensions: ["tfi"]
        },
        "application/timestamp-query": {
          source: "iana"
        },
        "application/timestamp-reply": {
          source: "iana"
        },
        "application/timestamped-data": {
          source: "iana",
          extensions: ["tsd"]
        },
        "application/tlsrpt+gzip": {
          source: "iana"
        },
        "application/tlsrpt+json": {
          source: "iana",
          compressible: true
        },
        "application/tnauthlist": {
          source: "iana"
        },
        "application/token-introspection+jwt": {
          source: "iana"
        },
        "application/toml": {
          compressible: true,
          extensions: ["toml"]
        },
        "application/trickle-ice-sdpfrag": {
          source: "iana"
        },
        "application/trig": {
          source: "iana",
          extensions: ["trig"]
        },
        "application/ttml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["ttml"]
        },
        "application/tve-trigger": {
          source: "iana"
        },
        "application/tzif": {
          source: "iana"
        },
        "application/tzif-leap": {
          source: "iana"
        },
        "application/ubjson": {
          compressible: false,
          extensions: ["ubj"]
        },
        "application/ulpfec": {
          source: "iana"
        },
        "application/urc-grpsheet+xml": {
          source: "iana",
          compressible: true
        },
        "application/urc-ressheet+xml": {
          source: "iana",
          compressible: true,
          extensions: ["rsheet"]
        },
        "application/urc-targetdesc+xml": {
          source: "iana",
          compressible: true,
          extensions: ["td"]
        },
        "application/urc-uisocketdesc+xml": {
          source: "iana",
          compressible: true
        },
        "application/vcard+json": {
          source: "iana",
          compressible: true
        },
        "application/vcard+xml": {
          source: "iana",
          compressible: true
        },
        "application/vemmi": {
          source: "iana"
        },
        "application/vividence.scriptfile": {
          source: "apache"
        },
        "application/vnd.1000minds.decision-model+xml": {
          source: "iana",
          compressible: true,
          extensions: ["1km"]
        },
        "application/vnd.3gpp-prose+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp-prose-pc3ch+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp-v2x-local-service-information": {
          source: "iana"
        },
        "application/vnd.3gpp.5gnas": {
          source: "iana"
        },
        "application/vnd.3gpp.access-transfer-events+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.bsf+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.gmop+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.gtpc": {
          source: "iana"
        },
        "application/vnd.3gpp.interworking-data": {
          source: "iana"
        },
        "application/vnd.3gpp.lpp": {
          source: "iana"
        },
        "application/vnd.3gpp.mc-signalling-ear": {
          source: "iana"
        },
        "application/vnd.3gpp.mcdata-affiliation-command+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcdata-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcdata-payload": {
          source: "iana"
        },
        "application/vnd.3gpp.mcdata-service-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcdata-signalling": {
          source: "iana"
        },
        "application/vnd.3gpp.mcdata-ue-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcdata-user-profile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-affiliation-command+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-floor-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-location-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-service-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-signed+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-ue-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-ue-init-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcptt-user-profile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-location-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-service-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-transmission-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-ue-config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mcvideo-user-profile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.mid-call+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.ngap": {
          source: "iana"
        },
        "application/vnd.3gpp.pfcp": {
          source: "iana"
        },
        "application/vnd.3gpp.pic-bw-large": {
          source: "iana",
          extensions: ["plb"]
        },
        "application/vnd.3gpp.pic-bw-small": {
          source: "iana",
          extensions: ["psb"]
        },
        "application/vnd.3gpp.pic-bw-var": {
          source: "iana",
          extensions: ["pvb"]
        },
        "application/vnd.3gpp.s1ap": {
          source: "iana"
        },
        "application/vnd.3gpp.sms": {
          source: "iana"
        },
        "application/vnd.3gpp.sms+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.srvcc-ext+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.srvcc-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.state-and-event-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp.ussd+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp2.bcmcsinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.3gpp2.sms": {
          source: "iana"
        },
        "application/vnd.3gpp2.tcap": {
          source: "iana",
          extensions: ["tcap"]
        },
        "application/vnd.3lightssoftware.imagescal": {
          source: "iana"
        },
        "application/vnd.3m.post-it-notes": {
          source: "iana",
          extensions: ["pwn"]
        },
        "application/vnd.accpac.simply.aso": {
          source: "iana",
          extensions: ["aso"]
        },
        "application/vnd.accpac.simply.imp": {
          source: "iana",
          extensions: ["imp"]
        },
        "application/vnd.acucobol": {
          source: "iana",
          extensions: ["acu"]
        },
        "application/vnd.acucorp": {
          source: "iana",
          extensions: ["atc", "acutc"]
        },
        "application/vnd.adobe.air-application-installer-package+zip": {
          source: "apache",
          compressible: false,
          extensions: ["air"]
        },
        "application/vnd.adobe.flash.movie": {
          source: "iana"
        },
        "application/vnd.adobe.formscentral.fcdt": {
          source: "iana",
          extensions: ["fcdt"]
        },
        "application/vnd.adobe.fxp": {
          source: "iana",
          extensions: ["fxp", "fxpl"]
        },
        "application/vnd.adobe.partial-upload": {
          source: "iana"
        },
        "application/vnd.adobe.xdp+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xdp"]
        },
        "application/vnd.adobe.xfdf": {
          source: "iana",
          extensions: ["xfdf"]
        },
        "application/vnd.aether.imp": {
          source: "iana"
        },
        "application/vnd.afpc.afplinedata": {
          source: "iana"
        },
        "application/vnd.afpc.afplinedata-pagedef": {
          source: "iana"
        },
        "application/vnd.afpc.cmoca-cmresource": {
          source: "iana"
        },
        "application/vnd.afpc.foca-charset": {
          source: "iana"
        },
        "application/vnd.afpc.foca-codedfont": {
          source: "iana"
        },
        "application/vnd.afpc.foca-codepage": {
          source: "iana"
        },
        "application/vnd.afpc.modca": {
          source: "iana"
        },
        "application/vnd.afpc.modca-cmtable": {
          source: "iana"
        },
        "application/vnd.afpc.modca-formdef": {
          source: "iana"
        },
        "application/vnd.afpc.modca-mediummap": {
          source: "iana"
        },
        "application/vnd.afpc.modca-objectcontainer": {
          source: "iana"
        },
        "application/vnd.afpc.modca-overlay": {
          source: "iana"
        },
        "application/vnd.afpc.modca-pagesegment": {
          source: "iana"
        },
        "application/vnd.age": {
          source: "iana",
          extensions: ["age"]
        },
        "application/vnd.ah-barcode": {
          source: "iana"
        },
        "application/vnd.ahead.space": {
          source: "iana",
          extensions: ["ahead"]
        },
        "application/vnd.airzip.filesecure.azf": {
          source: "iana",
          extensions: ["azf"]
        },
        "application/vnd.airzip.filesecure.azs": {
          source: "iana",
          extensions: ["azs"]
        },
        "application/vnd.amadeus+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.amazon.ebook": {
          source: "apache",
          extensions: ["azw"]
        },
        "application/vnd.amazon.mobi8-ebook": {
          source: "iana"
        },
        "application/vnd.americandynamics.acc": {
          source: "iana",
          extensions: ["acc"]
        },
        "application/vnd.amiga.ami": {
          source: "iana",
          extensions: ["ami"]
        },
        "application/vnd.amundsen.maze+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.android.ota": {
          source: "iana"
        },
        "application/vnd.android.package-archive": {
          source: "apache",
          compressible: false,
          extensions: ["apk"]
        },
        "application/vnd.anki": {
          source: "iana"
        },
        "application/vnd.anser-web-certificate-issue-initiation": {
          source: "iana",
          extensions: ["cii"]
        },
        "application/vnd.anser-web-funds-transfer-initiation": {
          source: "apache",
          extensions: ["fti"]
        },
        "application/vnd.antix.game-component": {
          source: "iana",
          extensions: ["atx"]
        },
        "application/vnd.apache.arrow.file": {
          source: "iana"
        },
        "application/vnd.apache.arrow.stream": {
          source: "iana"
        },
        "application/vnd.apache.thrift.binary": {
          source: "iana"
        },
        "application/vnd.apache.thrift.compact": {
          source: "iana"
        },
        "application/vnd.apache.thrift.json": {
          source: "iana"
        },
        "application/vnd.api+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.aplextor.warrp+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.apothekende.reservation+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.apple.installer+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mpkg"]
        },
        "application/vnd.apple.keynote": {
          source: "iana",
          extensions: ["key"]
        },
        "application/vnd.apple.mpegurl": {
          source: "iana",
          extensions: ["m3u8"]
        },
        "application/vnd.apple.numbers": {
          source: "iana",
          extensions: ["numbers"]
        },
        "application/vnd.apple.pages": {
          source: "iana",
          extensions: ["pages"]
        },
        "application/vnd.apple.pkpass": {
          compressible: false,
          extensions: ["pkpass"]
        },
        "application/vnd.arastra.swi": {
          source: "iana"
        },
        "application/vnd.aristanetworks.swi": {
          source: "iana",
          extensions: ["swi"]
        },
        "application/vnd.artisan+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.artsquare": {
          source: "iana"
        },
        "application/vnd.astraea-software.iota": {
          source: "iana",
          extensions: ["iota"]
        },
        "application/vnd.audiograph": {
          source: "iana",
          extensions: ["aep"]
        },
        "application/vnd.autopackage": {
          source: "iana"
        },
        "application/vnd.avalon+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.avistar+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.balsamiq.bmml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["bmml"]
        },
        "application/vnd.balsamiq.bmpr": {
          source: "iana"
        },
        "application/vnd.banana-accounting": {
          source: "iana"
        },
        "application/vnd.bbf.usp.error": {
          source: "iana"
        },
        "application/vnd.bbf.usp.msg": {
          source: "iana"
        },
        "application/vnd.bbf.usp.msg+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.bekitzur-stech+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.bint.med-content": {
          source: "iana"
        },
        "application/vnd.biopax.rdf+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.blink-idb-value-wrapper": {
          source: "iana"
        },
        "application/vnd.blueice.multipass": {
          source: "iana",
          extensions: ["mpm"]
        },
        "application/vnd.bluetooth.ep.oob": {
          source: "iana"
        },
        "application/vnd.bluetooth.le.oob": {
          source: "iana"
        },
        "application/vnd.bmi": {
          source: "iana",
          extensions: ["bmi"]
        },
        "application/vnd.bpf": {
          source: "iana"
        },
        "application/vnd.bpf3": {
          source: "iana"
        },
        "application/vnd.businessobjects": {
          source: "iana",
          extensions: ["rep"]
        },
        "application/vnd.byu.uapi+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cab-jscript": {
          source: "iana"
        },
        "application/vnd.canon-cpdl": {
          source: "iana"
        },
        "application/vnd.canon-lips": {
          source: "iana"
        },
        "application/vnd.capasystems-pg+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cendio.thinlinc.clientconf": {
          source: "iana"
        },
        "application/vnd.century-systems.tcp_stream": {
          source: "iana"
        },
        "application/vnd.chemdraw+xml": {
          source: "iana",
          compressible: true,
          extensions: ["cdxml"]
        },
        "application/vnd.chess-pgn": {
          source: "iana"
        },
        "application/vnd.chipnuts.karaoke-mmd": {
          source: "iana",
          extensions: ["mmd"]
        },
        "application/vnd.ciedi": {
          source: "iana"
        },
        "application/vnd.cinderella": {
          source: "iana",
          extensions: ["cdy"]
        },
        "application/vnd.cirpack.isdn-ext": {
          source: "iana"
        },
        "application/vnd.citationstyles.style+xml": {
          source: "iana",
          compressible: true,
          extensions: ["csl"]
        },
        "application/vnd.claymore": {
          source: "iana",
          extensions: ["cla"]
        },
        "application/vnd.cloanto.rp9": {
          source: "iana",
          extensions: ["rp9"]
        },
        "application/vnd.clonk.c4group": {
          source: "iana",
          extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
        },
        "application/vnd.cluetrust.cartomobile-config": {
          source: "iana",
          extensions: ["c11amc"]
        },
        "application/vnd.cluetrust.cartomobile-config-pkg": {
          source: "iana",
          extensions: ["c11amz"]
        },
        "application/vnd.coffeescript": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.document": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.document-template": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.presentation": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.presentation-template": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.spreadsheet": {
          source: "iana"
        },
        "application/vnd.collabio.xodocuments.spreadsheet-template": {
          source: "iana"
        },
        "application/vnd.collection+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.collection.doc+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.collection.next+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.comicbook+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.comicbook-rar": {
          source: "iana"
        },
        "application/vnd.commerce-battelle": {
          source: "iana"
        },
        "application/vnd.commonspace": {
          source: "iana",
          extensions: ["csp"]
        },
        "application/vnd.contact.cmsg": {
          source: "iana",
          extensions: ["cdbcmsg"]
        },
        "application/vnd.coreos.ignition+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cosmocaller": {
          source: "iana",
          extensions: ["cmc"]
        },
        "application/vnd.crick.clicker": {
          source: "iana",
          extensions: ["clkx"]
        },
        "application/vnd.crick.clicker.keyboard": {
          source: "iana",
          extensions: ["clkk"]
        },
        "application/vnd.crick.clicker.palette": {
          source: "iana",
          extensions: ["clkp"]
        },
        "application/vnd.crick.clicker.template": {
          source: "iana",
          extensions: ["clkt"]
        },
        "application/vnd.crick.clicker.wordbank": {
          source: "iana",
          extensions: ["clkw"]
        },
        "application/vnd.criticaltools.wbs+xml": {
          source: "iana",
          compressible: true,
          extensions: ["wbs"]
        },
        "application/vnd.cryptii.pipe+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.crypto-shade-file": {
          source: "iana"
        },
        "application/vnd.cryptomator.encrypted": {
          source: "iana"
        },
        "application/vnd.cryptomator.vault": {
          source: "iana"
        },
        "application/vnd.ctc-posml": {
          source: "iana",
          extensions: ["pml"]
        },
        "application/vnd.ctct.ws+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cups-pdf": {
          source: "iana"
        },
        "application/vnd.cups-postscript": {
          source: "iana"
        },
        "application/vnd.cups-ppd": {
          source: "iana",
          extensions: ["ppd"]
        },
        "application/vnd.cups-raster": {
          source: "iana"
        },
        "application/vnd.cups-raw": {
          source: "iana"
        },
        "application/vnd.curl": {
          source: "iana"
        },
        "application/vnd.curl.car": {
          source: "apache",
          extensions: ["car"]
        },
        "application/vnd.curl.pcurl": {
          source: "apache",
          extensions: ["pcurl"]
        },
        "application/vnd.cyan.dean.root+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cybank": {
          source: "iana"
        },
        "application/vnd.cyclonedx+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.cyclonedx+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.d2l.coursepackage1p0+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.d3m-dataset": {
          source: "iana"
        },
        "application/vnd.d3m-problem": {
          source: "iana"
        },
        "application/vnd.dart": {
          source: "iana",
          compressible: true,
          extensions: ["dart"]
        },
        "application/vnd.data-vision.rdz": {
          source: "iana",
          extensions: ["rdz"]
        },
        "application/vnd.datapackage+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dataresource+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dbf": {
          source: "iana",
          extensions: ["dbf"]
        },
        "application/vnd.debian.binary-package": {
          source: "iana"
        },
        "application/vnd.dece.data": {
          source: "iana",
          extensions: ["uvf", "uvvf", "uvd", "uvvd"]
        },
        "application/vnd.dece.ttml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["uvt", "uvvt"]
        },
        "application/vnd.dece.unspecified": {
          source: "iana",
          extensions: ["uvx", "uvvx"]
        },
        "application/vnd.dece.zip": {
          source: "iana",
          extensions: ["uvz", "uvvz"]
        },
        "application/vnd.denovo.fcselayout-link": {
          source: "iana",
          extensions: ["fe_launch"]
        },
        "application/vnd.desmume.movie": {
          source: "iana"
        },
        "application/vnd.dir-bi.plate-dl-nosuffix": {
          source: "iana"
        },
        "application/vnd.dm.delegation+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dna": {
          source: "iana",
          extensions: ["dna"]
        },
        "application/vnd.document+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dolby.mlp": {
          source: "apache",
          extensions: ["mlp"]
        },
        "application/vnd.dolby.mobile.1": {
          source: "iana"
        },
        "application/vnd.dolby.mobile.2": {
          source: "iana"
        },
        "application/vnd.doremir.scorecloud-binary-document": {
          source: "iana"
        },
        "application/vnd.dpgraph": {
          source: "iana",
          extensions: ["dpg"]
        },
        "application/vnd.dreamfactory": {
          source: "iana",
          extensions: ["dfac"]
        },
        "application/vnd.drive+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ds-keypoint": {
          source: "apache",
          extensions: ["kpxx"]
        },
        "application/vnd.dtg.local": {
          source: "iana"
        },
        "application/vnd.dtg.local.flash": {
          source: "iana"
        },
        "application/vnd.dtg.local.html": {
          source: "iana"
        },
        "application/vnd.dvb.ait": {
          source: "iana",
          extensions: ["ait"]
        },
        "application/vnd.dvb.dvbisl+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.dvbj": {
          source: "iana"
        },
        "application/vnd.dvb.esgcontainer": {
          source: "iana"
        },
        "application/vnd.dvb.ipdcdftnotifaccess": {
          source: "iana"
        },
        "application/vnd.dvb.ipdcesgaccess": {
          source: "iana"
        },
        "application/vnd.dvb.ipdcesgaccess2": {
          source: "iana"
        },
        "application/vnd.dvb.ipdcesgpdd": {
          source: "iana"
        },
        "application/vnd.dvb.ipdcroaming": {
          source: "iana"
        },
        "application/vnd.dvb.iptv.alfec-base": {
          source: "iana"
        },
        "application/vnd.dvb.iptv.alfec-enhancement": {
          source: "iana"
        },
        "application/vnd.dvb.notif-aggregate-root+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-container+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-generic+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-ia-msglist+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-ia-registration-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-ia-registration-response+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.notif-init+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.dvb.pfr": {
          source: "iana"
        },
        "application/vnd.dvb.service": {
          source: "iana",
          extensions: ["svc"]
        },
        "application/vnd.dxr": {
          source: "iana"
        },
        "application/vnd.dynageo": {
          source: "iana",
          extensions: ["geo"]
        },
        "application/vnd.dzr": {
          source: "iana"
        },
        "application/vnd.easykaraoke.cdgdownload": {
          source: "iana"
        },
        "application/vnd.ecdis-update": {
          source: "iana"
        },
        "application/vnd.ecip.rlp": {
          source: "iana"
        },
        "application/vnd.eclipse.ditto+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ecowin.chart": {
          source: "iana",
          extensions: ["mag"]
        },
        "application/vnd.ecowin.filerequest": {
          source: "iana"
        },
        "application/vnd.ecowin.fileupdate": {
          source: "iana"
        },
        "application/vnd.ecowin.series": {
          source: "iana"
        },
        "application/vnd.ecowin.seriesrequest": {
          source: "iana"
        },
        "application/vnd.ecowin.seriesupdate": {
          source: "iana"
        },
        "application/vnd.efi.img": {
          source: "iana"
        },
        "application/vnd.efi.iso": {
          source: "iana"
        },
        "application/vnd.emclient.accessrequest+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.enliven": {
          source: "iana",
          extensions: ["nml"]
        },
        "application/vnd.enphase.envoy": {
          source: "iana"
        },
        "application/vnd.eprints.data+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.epson.esf": {
          source: "iana",
          extensions: ["esf"]
        },
        "application/vnd.epson.msf": {
          source: "iana",
          extensions: ["msf"]
        },
        "application/vnd.epson.quickanime": {
          source: "iana",
          extensions: ["qam"]
        },
        "application/vnd.epson.salt": {
          source: "iana",
          extensions: ["slt"]
        },
        "application/vnd.epson.ssf": {
          source: "iana",
          extensions: ["ssf"]
        },
        "application/vnd.ericsson.quickcall": {
          source: "iana"
        },
        "application/vnd.espass-espass+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.eszigno3+xml": {
          source: "iana",
          compressible: true,
          extensions: ["es3", "et3"]
        },
        "application/vnd.etsi.aoc+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.asic-e+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.etsi.asic-s+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.etsi.cug+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvcommand+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvdiscovery+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvprofile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvsad-bc+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvsad-cod+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvsad-npvr+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvservice+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvsync+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.iptvueprofile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.mcid+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.mheg5": {
          source: "iana"
        },
        "application/vnd.etsi.overload-control-policy-dataset+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.pstn+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.sci+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.simservs+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.timestamp-token": {
          source: "iana"
        },
        "application/vnd.etsi.tsl+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.etsi.tsl.der": {
          source: "iana"
        },
        "application/vnd.eu.kasparian.car+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.eudora.data": {
          source: "iana"
        },
        "application/vnd.evolv.ecig.profile": {
          source: "iana"
        },
        "application/vnd.evolv.ecig.settings": {
          source: "iana"
        },
        "application/vnd.evolv.ecig.theme": {
          source: "iana"
        },
        "application/vnd.exstream-empower+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.exstream-package": {
          source: "iana"
        },
        "application/vnd.ezpix-album": {
          source: "iana",
          extensions: ["ez2"]
        },
        "application/vnd.ezpix-package": {
          source: "iana",
          extensions: ["ez3"]
        },
        "application/vnd.f-secure.mobile": {
          source: "iana"
        },
        "application/vnd.familysearch.gedcom+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.fastcopy-disk-image": {
          source: "iana"
        },
        "application/vnd.fdf": {
          source: "iana",
          extensions: ["fdf"]
        },
        "application/vnd.fdsn.mseed": {
          source: "iana",
          extensions: ["mseed"]
        },
        "application/vnd.fdsn.seed": {
          source: "iana",
          extensions: ["seed", "dataless"]
        },
        "application/vnd.ffsns": {
          source: "iana"
        },
        "application/vnd.ficlab.flb+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.filmit.zfc": {
          source: "iana"
        },
        "application/vnd.fints": {
          source: "iana"
        },
        "application/vnd.firemonkeys.cloudcell": {
          source: "iana"
        },
        "application/vnd.flographit": {
          source: "iana",
          extensions: ["gph"]
        },
        "application/vnd.fluxtime.clip": {
          source: "iana",
          extensions: ["ftc"]
        },
        "application/vnd.font-fontforge-sfd": {
          source: "iana"
        },
        "application/vnd.framemaker": {
          source: "iana",
          extensions: ["fm", "frame", "maker", "book"]
        },
        "application/vnd.frogans.fnc": {
          source: "iana",
          extensions: ["fnc"]
        },
        "application/vnd.frogans.ltf": {
          source: "iana",
          extensions: ["ltf"]
        },
        "application/vnd.fsc.weblaunch": {
          source: "iana",
          extensions: ["fsc"]
        },
        "application/vnd.fujifilm.fb.docuworks": {
          source: "iana"
        },
        "application/vnd.fujifilm.fb.docuworks.binder": {
          source: "iana"
        },
        "application/vnd.fujifilm.fb.docuworks.container": {
          source: "iana"
        },
        "application/vnd.fujifilm.fb.jfi+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.fujitsu.oasys": {
          source: "iana",
          extensions: ["oas"]
        },
        "application/vnd.fujitsu.oasys2": {
          source: "iana",
          extensions: ["oa2"]
        },
        "application/vnd.fujitsu.oasys3": {
          source: "iana",
          extensions: ["oa3"]
        },
        "application/vnd.fujitsu.oasysgp": {
          source: "iana",
          extensions: ["fg5"]
        },
        "application/vnd.fujitsu.oasysprs": {
          source: "iana",
          extensions: ["bh2"]
        },
        "application/vnd.fujixerox.art-ex": {
          source: "iana"
        },
        "application/vnd.fujixerox.art4": {
          source: "iana"
        },
        "application/vnd.fujixerox.ddd": {
          source: "iana",
          extensions: ["ddd"]
        },
        "application/vnd.fujixerox.docuworks": {
          source: "iana",
          extensions: ["xdw"]
        },
        "application/vnd.fujixerox.docuworks.binder": {
          source: "iana",
          extensions: ["xbd"]
        },
        "application/vnd.fujixerox.docuworks.container": {
          source: "iana"
        },
        "application/vnd.fujixerox.hbpl": {
          source: "iana"
        },
        "application/vnd.fut-misnet": {
          source: "iana"
        },
        "application/vnd.futoin+cbor": {
          source: "iana"
        },
        "application/vnd.futoin+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.fuzzysheet": {
          source: "iana",
          extensions: ["fzs"]
        },
        "application/vnd.genomatix.tuxedo": {
          source: "iana",
          extensions: ["txd"]
        },
        "application/vnd.gentics.grd+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.geo+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.geocube+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.geogebra.file": {
          source: "iana",
          extensions: ["ggb"]
        },
        "application/vnd.geogebra.slides": {
          source: "iana"
        },
        "application/vnd.geogebra.tool": {
          source: "iana",
          extensions: ["ggt"]
        },
        "application/vnd.geometry-explorer": {
          source: "iana",
          extensions: ["gex", "gre"]
        },
        "application/vnd.geonext": {
          source: "iana",
          extensions: ["gxt"]
        },
        "application/vnd.geoplan": {
          source: "iana",
          extensions: ["g2w"]
        },
        "application/vnd.geospace": {
          source: "iana",
          extensions: ["g3w"]
        },
        "application/vnd.gerber": {
          source: "iana"
        },
        "application/vnd.globalplatform.card-content-mgt": {
          source: "iana"
        },
        "application/vnd.globalplatform.card-content-mgt-response": {
          source: "iana"
        },
        "application/vnd.gmx": {
          source: "iana",
          extensions: ["gmx"]
        },
        "application/vnd.google-apps.document": {
          compressible: false,
          extensions: ["gdoc"]
        },
        "application/vnd.google-apps.presentation": {
          compressible: false,
          extensions: ["gslides"]
        },
        "application/vnd.google-apps.spreadsheet": {
          compressible: false,
          extensions: ["gsheet"]
        },
        "application/vnd.google-earth.kml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["kml"]
        },
        "application/vnd.google-earth.kmz": {
          source: "iana",
          compressible: false,
          extensions: ["kmz"]
        },
        "application/vnd.gov.sk.e-form+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.gov.sk.e-form+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.gov.sk.xmldatacontainer+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.grafeq": {
          source: "iana",
          extensions: ["gqf", "gqs"]
        },
        "application/vnd.gridmp": {
          source: "iana"
        },
        "application/vnd.groove-account": {
          source: "iana",
          extensions: ["gac"]
        },
        "application/vnd.groove-help": {
          source: "iana",
          extensions: ["ghf"]
        },
        "application/vnd.groove-identity-message": {
          source: "iana",
          extensions: ["gim"]
        },
        "application/vnd.groove-injector": {
          source: "iana",
          extensions: ["grv"]
        },
        "application/vnd.groove-tool-message": {
          source: "iana",
          extensions: ["gtm"]
        },
        "application/vnd.groove-tool-template": {
          source: "iana",
          extensions: ["tpl"]
        },
        "application/vnd.groove-vcard": {
          source: "iana",
          extensions: ["vcg"]
        },
        "application/vnd.hal+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hal+xml": {
          source: "iana",
          compressible: true,
          extensions: ["hal"]
        },
        "application/vnd.handheld-entertainment+xml": {
          source: "iana",
          compressible: true,
          extensions: ["zmm"]
        },
        "application/vnd.hbci": {
          source: "iana",
          extensions: ["hbci"]
        },
        "application/vnd.hc+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hcl-bireports": {
          source: "iana"
        },
        "application/vnd.hdt": {
          source: "iana"
        },
        "application/vnd.heroku+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hhe.lesson-player": {
          source: "iana",
          extensions: ["les"]
        },
        "application/vnd.hl7cda+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.hl7v2+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.hp-hpgl": {
          source: "iana",
          extensions: ["hpgl"]
        },
        "application/vnd.hp-hpid": {
          source: "iana",
          extensions: ["hpid"]
        },
        "application/vnd.hp-hps": {
          source: "iana",
          extensions: ["hps"]
        },
        "application/vnd.hp-jlyt": {
          source: "iana",
          extensions: ["jlt"]
        },
        "application/vnd.hp-pcl": {
          source: "iana",
          extensions: ["pcl"]
        },
        "application/vnd.hp-pclxl": {
          source: "iana",
          extensions: ["pclxl"]
        },
        "application/vnd.httphone": {
          source: "iana"
        },
        "application/vnd.hydrostatix.sof-data": {
          source: "iana",
          extensions: ["sfd-hdstx"]
        },
        "application/vnd.hyper+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hyper-item+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hyperdrive+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.hzn-3d-crossword": {
          source: "iana"
        },
        "application/vnd.ibm.afplinedata": {
          source: "iana"
        },
        "application/vnd.ibm.electronic-media": {
          source: "iana"
        },
        "application/vnd.ibm.minipay": {
          source: "iana",
          extensions: ["mpy"]
        },
        "application/vnd.ibm.modcap": {
          source: "iana",
          extensions: ["afp", "listafp", "list3820"]
        },
        "application/vnd.ibm.rights-management": {
          source: "iana",
          extensions: ["irm"]
        },
        "application/vnd.ibm.secure-container": {
          source: "iana",
          extensions: ["sc"]
        },
        "application/vnd.iccprofile": {
          source: "iana",
          extensions: ["icc", "icm"]
        },
        "application/vnd.ieee.1905": {
          source: "iana"
        },
        "application/vnd.igloader": {
          source: "iana",
          extensions: ["igl"]
        },
        "application/vnd.imagemeter.folder+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.imagemeter.image+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.immervision-ivp": {
          source: "iana",
          extensions: ["ivp"]
        },
        "application/vnd.immervision-ivu": {
          source: "iana",
          extensions: ["ivu"]
        },
        "application/vnd.ims.imsccv1p1": {
          source: "iana"
        },
        "application/vnd.ims.imsccv1p2": {
          source: "iana"
        },
        "application/vnd.ims.imsccv1p3": {
          source: "iana"
        },
        "application/vnd.ims.lis.v2.result+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ims.lti.v2.toolproxy+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ims.lti.v2.toolproxy.id+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ims.lti.v2.toolsettings+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ims.lti.v2.toolsettings.simple+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.informedcontrol.rms+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.informix-visionary": {
          source: "iana"
        },
        "application/vnd.infotech.project": {
          source: "iana"
        },
        "application/vnd.infotech.project+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.innopath.wamp.notification": {
          source: "iana"
        },
        "application/vnd.insors.igm": {
          source: "iana",
          extensions: ["igm"]
        },
        "application/vnd.intercon.formnet": {
          source: "iana",
          extensions: ["xpw", "xpx"]
        },
        "application/vnd.intergeo": {
          source: "iana",
          extensions: ["i2g"]
        },
        "application/vnd.intertrust.digibox": {
          source: "iana"
        },
        "application/vnd.intertrust.nncp": {
          source: "iana"
        },
        "application/vnd.intu.qbo": {
          source: "iana",
          extensions: ["qbo"]
        },
        "application/vnd.intu.qfx": {
          source: "iana",
          extensions: ["qfx"]
        },
        "application/vnd.iptc.g2.catalogitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.conceptitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.knowledgeitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.newsitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.newsmessage+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.packageitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.iptc.g2.planningitem+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ipunplugged.rcprofile": {
          source: "iana",
          extensions: ["rcprofile"]
        },
        "application/vnd.irepository.package+xml": {
          source: "iana",
          compressible: true,
          extensions: ["irp"]
        },
        "application/vnd.is-xpr": {
          source: "iana",
          extensions: ["xpr"]
        },
        "application/vnd.isac.fcs": {
          source: "iana",
          extensions: ["fcs"]
        },
        "application/vnd.iso11783-10+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.jam": {
          source: "iana",
          extensions: ["jam"]
        },
        "application/vnd.japannet-directory-service": {
          source: "iana"
        },
        "application/vnd.japannet-jpnstore-wakeup": {
          source: "iana"
        },
        "application/vnd.japannet-payment-wakeup": {
          source: "iana"
        },
        "application/vnd.japannet-registration": {
          source: "iana"
        },
        "application/vnd.japannet-registration-wakeup": {
          source: "iana"
        },
        "application/vnd.japannet-setstore-wakeup": {
          source: "iana"
        },
        "application/vnd.japannet-verification": {
          source: "iana"
        },
        "application/vnd.japannet-verification-wakeup": {
          source: "iana"
        },
        "application/vnd.jcp.javame.midlet-rms": {
          source: "iana",
          extensions: ["rms"]
        },
        "application/vnd.jisp": {
          source: "iana",
          extensions: ["jisp"]
        },
        "application/vnd.joost.joda-archive": {
          source: "iana",
          extensions: ["joda"]
        },
        "application/vnd.jsk.isdn-ngn": {
          source: "iana"
        },
        "application/vnd.kahootz": {
          source: "iana",
          extensions: ["ktz", "ktr"]
        },
        "application/vnd.kde.karbon": {
          source: "iana",
          extensions: ["karbon"]
        },
        "application/vnd.kde.kchart": {
          source: "iana",
          extensions: ["chrt"]
        },
        "application/vnd.kde.kformula": {
          source: "iana",
          extensions: ["kfo"]
        },
        "application/vnd.kde.kivio": {
          source: "iana",
          extensions: ["flw"]
        },
        "application/vnd.kde.kontour": {
          source: "iana",
          extensions: ["kon"]
        },
        "application/vnd.kde.kpresenter": {
          source: "iana",
          extensions: ["kpr", "kpt"]
        },
        "application/vnd.kde.kspread": {
          source: "iana",
          extensions: ["ksp"]
        },
        "application/vnd.kde.kword": {
          source: "iana",
          extensions: ["kwd", "kwt"]
        },
        "application/vnd.kenameaapp": {
          source: "iana",
          extensions: ["htke"]
        },
        "application/vnd.kidspiration": {
          source: "iana",
          extensions: ["kia"]
        },
        "application/vnd.kinar": {
          source: "iana",
          extensions: ["kne", "knp"]
        },
        "application/vnd.koan": {
          source: "iana",
          extensions: ["skp", "skd", "skt", "skm"]
        },
        "application/vnd.kodak-descriptor": {
          source: "iana",
          extensions: ["sse"]
        },
        "application/vnd.las": {
          source: "iana"
        },
        "application/vnd.las.las+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.las.las+xml": {
          source: "iana",
          compressible: true,
          extensions: ["lasxml"]
        },
        "application/vnd.laszip": {
          source: "iana"
        },
        "application/vnd.leap+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.liberty-request+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.llamagraphics.life-balance.desktop": {
          source: "iana",
          extensions: ["lbd"]
        },
        "application/vnd.llamagraphics.life-balance.exchange+xml": {
          source: "iana",
          compressible: true,
          extensions: ["lbe"]
        },
        "application/vnd.logipipe.circuit+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.loom": {
          source: "iana"
        },
        "application/vnd.lotus-1-2-3": {
          source: "iana",
          extensions: ["123"]
        },
        "application/vnd.lotus-approach": {
          source: "iana",
          extensions: ["apr"]
        },
        "application/vnd.lotus-freelance": {
          source: "iana",
          extensions: ["pre"]
        },
        "application/vnd.lotus-notes": {
          source: "iana",
          extensions: ["nsf"]
        },
        "application/vnd.lotus-organizer": {
          source: "iana",
          extensions: ["org"]
        },
        "application/vnd.lotus-screencam": {
          source: "iana",
          extensions: ["scm"]
        },
        "application/vnd.lotus-wordpro": {
          source: "iana",
          extensions: ["lwp"]
        },
        "application/vnd.macports.portpkg": {
          source: "iana",
          extensions: ["portpkg"]
        },
        "application/vnd.mapbox-vector-tile": {
          source: "iana",
          extensions: ["mvt"]
        },
        "application/vnd.marlin.drm.actiontoken+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.marlin.drm.conftoken+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.marlin.drm.license+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.marlin.drm.mdcf": {
          source: "iana"
        },
        "application/vnd.mason+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.maxar.archive.3tz+zip": {
          source: "iana",
          compressible: false
        },
        "application/vnd.maxmind.maxmind-db": {
          source: "iana"
        },
        "application/vnd.mcd": {
          source: "iana",
          extensions: ["mcd"]
        },
        "application/vnd.medcalcdata": {
          source: "iana",
          extensions: ["mc1"]
        },
        "application/vnd.mediastation.cdkey": {
          source: "iana",
          extensions: ["cdkey"]
        },
        "application/vnd.meridian-slingshot": {
          source: "iana"
        },
        "application/vnd.mfer": {
          source: "iana",
          extensions: ["mwf"]
        },
        "application/vnd.mfmp": {
          source: "iana",
          extensions: ["mfm"]
        },
        "application/vnd.micro+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.micrografx.flo": {
          source: "iana",
          extensions: ["flo"]
        },
        "application/vnd.micrografx.igx": {
          source: "iana",
          extensions: ["igx"]
        },
        "application/vnd.microsoft.portable-executable": {
          source: "iana"
        },
        "application/vnd.microsoft.windows.thumbnail-cache": {
          source: "iana"
        },
        "application/vnd.miele+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.mif": {
          source: "iana",
          extensions: ["mif"]
        },
        "application/vnd.minisoft-hp3000-save": {
          source: "iana"
        },
        "application/vnd.mitsubishi.misty-guard.trustweb": {
          source: "iana"
        },
        "application/vnd.mobius.daf": {
          source: "iana",
          extensions: ["daf"]
        },
        "application/vnd.mobius.dis": {
          source: "iana",
          extensions: ["dis"]
        },
        "application/vnd.mobius.mbk": {
          source: "iana",
          extensions: ["mbk"]
        },
        "application/vnd.mobius.mqy": {
          source: "iana",
          extensions: ["mqy"]
        },
        "application/vnd.mobius.msl": {
          source: "iana",
          extensions: ["msl"]
        },
        "application/vnd.mobius.plc": {
          source: "iana",
          extensions: ["plc"]
        },
        "application/vnd.mobius.txf": {
          source: "iana",
          extensions: ["txf"]
        },
        "application/vnd.mophun.application": {
          source: "iana",
          extensions: ["mpn"]
        },
        "application/vnd.mophun.certificate": {
          source: "iana",
          extensions: ["mpc"]
        },
        "application/vnd.motorola.flexsuite": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.adsi": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.fis": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.gotap": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.kmr": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.ttc": {
          source: "iana"
        },
        "application/vnd.motorola.flexsuite.wem": {
          source: "iana"
        },
        "application/vnd.motorola.iprm": {
          source: "iana"
        },
        "application/vnd.mozilla.xul+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xul"]
        },
        "application/vnd.ms-3mfdocument": {
          source: "iana"
        },
        "application/vnd.ms-artgalry": {
          source: "iana",
          extensions: ["cil"]
        },
        "application/vnd.ms-asf": {
          source: "iana"
        },
        "application/vnd.ms-cab-compressed": {
          source: "iana",
          extensions: ["cab"]
        },
        "application/vnd.ms-color.iccprofile": {
          source: "apache"
        },
        "application/vnd.ms-excel": {
          source: "iana",
          compressible: false,
          extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
        },
        "application/vnd.ms-excel.addin.macroenabled.12": {
          source: "iana",
          extensions: ["xlam"]
        },
        "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
          source: "iana",
          extensions: ["xlsb"]
        },
        "application/vnd.ms-excel.sheet.macroenabled.12": {
          source: "iana",
          extensions: ["xlsm"]
        },
        "application/vnd.ms-excel.template.macroenabled.12": {
          source: "iana",
          extensions: ["xltm"]
        },
        "application/vnd.ms-fontobject": {
          source: "iana",
          compressible: true,
          extensions: ["eot"]
        },
        "application/vnd.ms-htmlhelp": {
          source: "iana",
          extensions: ["chm"]
        },
        "application/vnd.ms-ims": {
          source: "iana",
          extensions: ["ims"]
        },
        "application/vnd.ms-lrm": {
          source: "iana",
          extensions: ["lrm"]
        },
        "application/vnd.ms-office.activex+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ms-officetheme": {
          source: "iana",
          extensions: ["thmx"]
        },
        "application/vnd.ms-opentype": {
          source: "apache",
          compressible: true
        },
        "application/vnd.ms-outlook": {
          compressible: false,
          extensions: ["msg"]
        },
        "application/vnd.ms-package.obfuscated-opentype": {
          source: "apache"
        },
        "application/vnd.ms-pki.seccat": {
          source: "apache",
          extensions: ["cat"]
        },
        "application/vnd.ms-pki.stl": {
          source: "apache",
          extensions: ["stl"]
        },
        "application/vnd.ms-playready.initiator+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ms-powerpoint": {
          source: "iana",
          compressible: false,
          extensions: ["ppt", "pps", "pot"]
        },
        "application/vnd.ms-powerpoint.addin.macroenabled.12": {
          source: "iana",
          extensions: ["ppam"]
        },
        "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
          source: "iana",
          extensions: ["pptm"]
        },
        "application/vnd.ms-powerpoint.slide.macroenabled.12": {
          source: "iana",
          extensions: ["sldm"]
        },
        "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
          source: "iana",
          extensions: ["ppsm"]
        },
        "application/vnd.ms-powerpoint.template.macroenabled.12": {
          source: "iana",
          extensions: ["potm"]
        },
        "application/vnd.ms-printdevicecapabilities+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ms-printing.printticket+xml": {
          source: "apache",
          compressible: true
        },
        "application/vnd.ms-printschematicket+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ms-project": {
          source: "iana",
          extensions: ["mpp", "mpt"]
        },
        "application/vnd.ms-tnef": {
          source: "iana"
        },
        "application/vnd.ms-windows.devicepairing": {
          source: "iana"
        },
        "application/vnd.ms-windows.nwprinting.oob": {
          source: "iana"
        },
        "application/vnd.ms-windows.printerpairing": {
          source: "iana"
        },
        "application/vnd.ms-windows.wsd.oob": {
          source: "iana"
        },
        "application/vnd.ms-wmdrm.lic-chlg-req": {
          source: "iana"
        },
        "application/vnd.ms-wmdrm.lic-resp": {
          source: "iana"
        },
        "application/vnd.ms-wmdrm.meter-chlg-req": {
          source: "iana"
        },
        "application/vnd.ms-wmdrm.meter-resp": {
          source: "iana"
        },
        "application/vnd.ms-word.document.macroenabled.12": {
          source: "iana",
          extensions: ["docm"]
        },
        "application/vnd.ms-word.template.macroenabled.12": {
          source: "iana",
          extensions: ["dotm"]
        },
        "application/vnd.ms-works": {
          source: "iana",
          extensions: ["wps", "wks", "wcm", "wdb"]
        },
        "application/vnd.ms-wpl": {
          source: "iana",
          extensions: ["wpl"]
        },
        "application/vnd.ms-xpsdocument": {
          source: "iana",
          compressible: false,
          extensions: ["xps"]
        },
        "application/vnd.msa-disk-image": {
          source: "iana"
        },
        "application/vnd.mseq": {
          source: "iana",
          extensions: ["mseq"]
        },
        "application/vnd.msign": {
          source: "iana"
        },
        "application/vnd.multiad.creator": {
          source: "iana"
        },
        "application/vnd.multiad.creator.cif": {
          source: "iana"
        },
        "application/vnd.music-niff": {
          source: "iana"
        },
        "application/vnd.musician": {
          source: "iana",
          extensions: ["mus"]
        },
        "application/vnd.muvee.style": {
          source: "iana",
          extensions: ["msty"]
        },
        "application/vnd.mynfc": {
          source: "iana",
          extensions: ["taglet"]
        },
        "application/vnd.nacamar.ybrid+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.ncd.control": {
          source: "iana"
        },
        "application/vnd.ncd.reference": {
          source: "iana"
        },
        "application/vnd.nearst.inv+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nebumind.line": {
          source: "iana"
        },
        "application/vnd.nervana": {
          source: "iana"
        },
        "application/vnd.netfpx": {
          source: "iana"
        },
        "application/vnd.neurolanguage.nlu": {
          source: "iana",
          extensions: ["nlu"]
        },
        "application/vnd.nimn": {
          source: "iana"
        },
        "application/vnd.nintendo.nitro.rom": {
          source: "iana"
        },
        "application/vnd.nintendo.snes.rom": {
          source: "iana"
        },
        "application/vnd.nitf": {
          source: "iana",
          extensions: ["ntf", "nitf"]
        },
        "application/vnd.noblenet-directory": {
          source: "iana",
          extensions: ["nnd"]
        },
        "application/vnd.noblenet-sealer": {
          source: "iana",
          extensions: ["nns"]
        },
        "application/vnd.noblenet-web": {
          source: "iana",
          extensions: ["nnw"]
        },
        "application/vnd.nokia.catalogs": {
          source: "iana"
        },
        "application/vnd.nokia.conml+wbxml": {
          source: "iana"
        },
        "application/vnd.nokia.conml+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nokia.iptv.config+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nokia.isds-radio-presets": {
          source: "iana"
        },
        "application/vnd.nokia.landmark+wbxml": {
          source: "iana"
        },
        "application/vnd.nokia.landmark+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nokia.landmarkcollection+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nokia.n-gage.ac+xml": {
          source: "iana",
          compressible: true,
          extensions: ["ac"]
        },
        "application/vnd.nokia.n-gage.data": {
          source: "iana",
          extensions: ["ngdat"]
        },
        "application/vnd.nokia.n-gage.symbian.install": {
          source: "iana",
          extensions: ["n-gage"]
        },
        "application/vnd.nokia.ncd": {
          source: "iana"
        },
        "application/vnd.nokia.pcd+wbxml": {
          source: "iana"
        },
        "application/vnd.nokia.pcd+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.nokia.radio-preset": {
          source: "iana",
          extensions: ["rpst"]
        },
        "application/vnd.nokia.radio-presets": {
          source: "iana",
          extensions: ["rpss"]
        },
        "application/vnd.novadigm.edm": {
          source: "iana",
          extensions: ["edm"]
        },
        "application/vnd.novadigm.edx": {
          source: "iana",
          extensions: ["edx"]
        },
        "application/vnd.novadigm.ext": {
          source: "iana",
          extensions: ["ext"]
        },
        "application/vnd.ntt-local.content-share": {
          source: "iana"
        },
        "application/vnd.ntt-local.file-transfer": {
          source: "iana"
        },
        "application/vnd.ntt-local.ogw_remote-access": {
          source: "iana"
        },
        "application/vnd.ntt-local.sip-ta_remote": {
          source: "iana"
        },
        "application/vnd.ntt-local.sip-ta_tcp_stream": {
          source: "iana"
        },
        "application/vnd.oasis.opendocument.chart": {
          source: "iana",
          extensions: ["odc"]
        },
        "application/vnd.oasis.opendocument.chart-template": {
          source: "iana",
          extensions: ["otc"]
        },
        "application/vnd.oasis.opendocument.database": {
          source: "iana",
          extensions: ["odb"]
        },
        "application/vnd.oasis.opendocument.formula": {
          source: "iana",
          extensions: ["odf"]
        },
        "application/vnd.oasis.opendocument.formula-template": {
          source: "iana",
          extensions: ["odft"]
        },
        "application/vnd.oasis.opendocument.graphics": {
          source: "iana",
          compressible: false,
          extensions: ["odg"]
        },
        "application/vnd.oasis.opendocument.graphics-template": {
          source: "iana",
          extensions: ["otg"]
        },
        "application/vnd.oasis.opendocument.image": {
          source: "iana",
          extensions: ["odi"]
        },
        "application/vnd.oasis.opendocument.image-template": {
          source: "iana",
          extensions: ["oti"]
        },
        "application/vnd.oasis.opendocument.presentation": {
          source: "iana",
          compressible: false,
          extensions: ["odp"]
        },
        "application/vnd.oasis.opendocument.presentation-template": {
          source: "iana",
          extensions: ["otp"]
        },
        "application/vnd.oasis.opendocument.spreadsheet": {
          source: "iana",
          compressible: false,
          extensions: ["ods"]
        },
        "application/vnd.oasis.opendocument.spreadsheet-template": {
          source: "iana",
          extensions: ["ots"]
        },
        "application/vnd.oasis.opendocument.text": {
          source: "iana",
          compressible: false,
          extensions: ["odt"]
        },
        "application/vnd.oasis.opendocument.text-master": {
          source: "iana",
          extensions: ["odm"]
        },
        "application/vnd.oasis.opendocument.text-template": {
          source: "iana",
          extensions: ["ott"]
        },
        "application/vnd.oasis.opendocument.text-web": {
          source: "iana",
          extensions: ["oth"]
        },
        "application/vnd.obn": {
          source: "iana"
        },
        "application/vnd.ocf+cbor": {
          source: "iana"
        },
        "application/vnd.oci.image.manifest.v1+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oftn.l10n+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.contentaccessdownload+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.contentaccessstreaming+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.cspg-hexbinary": {
          source: "iana"
        },
        "application/vnd.oipf.dae.svg+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.dae.xhtml+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.mippvcontrolmessage+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.pae.gem": {
          source: "iana"
        },
        "application/vnd.oipf.spdiscovery+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.spdlist+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.ueprofile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oipf.userprofile+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.olpc-sugar": {
          source: "iana",
          extensions: ["xo"]
        },
        "application/vnd.oma-scws-config": {
          source: "iana"
        },
        "application/vnd.oma-scws-http-request": {
          source: "iana"
        },
        "application/vnd.oma-scws-http-response": {
          source: "iana"
        },
        "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.drm-trigger+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.imd+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.ltkm": {
          source: "iana"
        },
        "application/vnd.oma.bcast.notification+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.provisioningtrigger": {
          source: "iana"
        },
        "application/vnd.oma.bcast.sgboot": {
          source: "iana"
        },
        "application/vnd.oma.bcast.sgdd+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.sgdu": {
          source: "iana"
        },
        "application/vnd.oma.bcast.simple-symbol-container": {
          source: "iana"
        },
        "application/vnd.oma.bcast.smartcard-trigger+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.sprov+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.bcast.stkm": {
          source: "iana"
        },
        "application/vnd.oma.cab-address-book+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.cab-feature-handler+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.cab-pcc+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.cab-subs-invite+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.cab-user-prefs+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.dcd": {
          source: "iana"
        },
        "application/vnd.oma.dcdc": {
          source: "iana"
        },
        "application/vnd.oma.dd2+xml": {
          source: "iana",
          compressible: true,
          extensions: ["dd2"]
        },
        "application/vnd.oma.drm.risd+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.group-usage-list+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.lwm2m+cbor": {
          source: "iana"
        },
        "application/vnd.oma.lwm2m+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.lwm2m+tlv": {
          source: "iana"
        },
        "application/vnd.oma.pal+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.poc.detailed-progress-report+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.poc.final-report+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.poc.groups+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.poc.invocation-descriptor+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.poc.optimized-progress-report+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.push": {
          source: "iana"
        },
        "application/vnd.oma.scidm.messages+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oma.xcap-directory+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.omads-email+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.omads-file+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.omads-folder+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.omaloc-supl-init": {
          source: "iana"
        },
        "application/vnd.onepager": {
          source: "iana"
        },
        "application/vnd.onepagertamp": {
          source: "iana"
        },
        "application/vnd.onepagertamx": {
          source: "iana"
        },
        "application/vnd.onepagertat": {
          source: "iana"
        },
        "application/vnd.onepagertatp": {
          source: "iana"
        },
        "application/vnd.onepagertatx": {
          source: "iana"
        },
        "application/vnd.openblox.game+xml": {
          source: "iana",
          compressible: true,
          extensions: ["obgx"]
        },
        "application/vnd.openblox.game-binary": {
          source: "iana"
        },
        "application/vnd.openeye.oeb": {
          source: "iana"
        },
        "application/vnd.openofficeorg.extension": {
          source: "apache",
          extensions: ["oxt"]
        },
        "application/vnd.openstreetmap.data+xml": {
          source: "iana",
          compressible: true,
          extensions: ["osm"]
        },
        "application/vnd.opentimestamps.ots": {
          source: "iana"
        },
        "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawing+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
          source: "iana",
          compressible: false,
          extensions: ["pptx"]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slide": {
          source: "iana",
          extensions: ["sldx"]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
          source: "iana",
          extensions: ["ppsx"]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.template": {
          source: "iana",
          extensions: ["potx"]
        },
        "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
          source: "iana",
          compressible: false,
          extensions: ["xlsx"]
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
          source: "iana",
          extensions: ["xltx"]
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.theme+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.vmldrawing": {
          source: "iana"
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
          source: "iana",
          compressible: false,
          extensions: ["docx"]
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
          source: "iana",
          extensions: ["dotx"]
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-package.core-properties+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.openxmlformats-package.relationships+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oracle.resource+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.orange.indata": {
          source: "iana"
        },
        "application/vnd.osa.netdeploy": {
          source: "iana"
        },
        "application/vnd.osgeo.mapguide.package": {
          source: "iana",
          extensions: ["mgp"]
        },
        "application/vnd.osgi.bundle": {
          source: "iana"
        },
        "application/vnd.osgi.dp": {
          source: "iana",
          extensions: ["dp"]
        },
        "application/vnd.osgi.subsystem": {
          source: "iana",
          extensions: ["esa"]
        },
        "application/vnd.otps.ct-kip+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.oxli.countgraph": {
          source: "iana"
        },
        "application/vnd.pagerduty+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.palm": {
          source: "iana",
          extensions: ["pdb", "pqa", "oprc"]
        },
        "application/vnd.panoply": {
          source: "iana"
        },
        "application/vnd.paos.xml": {
          source: "iana"
        },
        "application/vnd.patentdive": {
          source: "iana"
        },
        "application/vnd.patientecommsdoc": {
          source: "iana"
        },
        "application/vnd.pawaafile": {
          source: "iana",
          extensions: ["paw"]
        },
        "application/vnd.pcos": {
          source: "iana"
        },
        "application/vnd.pg.format": {
          source: "iana",
          extensions: ["str"]
        },
        "application/vnd.pg.osasli": {
          source: "iana",
          extensions: ["ei6"]
        },
        "application/vnd.piaccess.application-licence": {
          source: "iana"
        },
        "application/vnd.picsel": {
          source: "iana",
          extensions: ["efif"]
        },
        "application/vnd.pmi.widget": {
          source: "iana",
          extensions: ["wg"]
        },
        "application/vnd.poc.group-advertisement+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.pocketlearn": {
          source: "iana",
          extensions: ["plf"]
        },
        "application/vnd.powerbuilder6": {
          source: "iana",
          extensions: ["pbd"]
        },
        "application/vnd.powerbuilder6-s": {
          source: "iana"
        },
        "application/vnd.powerbuilder7": {
          source: "iana"
        },
        "application/vnd.powerbuilder7-s": {
          source: "iana"
        },
        "application/vnd.powerbuilder75": {
          source: "iana"
        },
        "application/vnd.powerbuilder75-s": {
          source: "iana"
        },
        "application/vnd.preminet": {
          source: "iana"
        },
        "application/vnd.previewsystems.box": {
          source: "iana",
          extensions: ["box"]
        },
        "application/vnd.proteus.magazine": {
          source: "iana",
          extensions: ["mgz"]
        },
        "application/vnd.psfs": {
          source: "iana"
        },
        "application/vnd.publishare-delta-tree": {
          source: "iana",
          extensions: ["qps"]
        },
        "application/vnd.pvi.ptid1": {
          source: "iana",
          extensions: ["ptid"]
        },
        "application/vnd.pwg-multiplexed": {
          source: "iana"
        },
        "application/vnd.pwg-xhtml-print+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.qualcomm.brew-app-res": {
          source: "iana"
        },
        "application/vnd.quarantainenet": {
          source: "iana"
        },
        "application/vnd.quark.quarkxpress": {
          source: "iana",
          extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
        },
        "application/vnd.quobject-quoxdocument": {
          source: "iana"
        },
        "application/vnd.radisys.moml+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-audit+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-audit-conf+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-audit-conn+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-audit-dialog+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-audit-stream+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-conf+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-base+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-fax-detect+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-group+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-speech+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.radisys.msml-dialog-transform+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.rainstor.data": {
          source: "iana"
        },
        "application/vnd.rapid": {
          source: "iana"
        },
        "application/vnd.rar": {
          source: "iana",
          extensions: ["rar"]
        },
        "application/vnd.realvnc.bed": {
          source: "iana",
          extensions: ["bed"]
        },
        "application/vnd.recordare.musicxml": {
          source: "iana",
          extensions: ["mxl"]
        },
        "application/vnd.recordare.musicxml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["musicxml"]
        },
        "application/vnd.renlearn.rlprint": {
          source: "iana"
        },
        "application/vnd.resilient.logic": {
          source: "iana"
        },
        "application/vnd.restful+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.rig.cryptonote": {
          source: "iana",
          extensions: ["cryptonote"]
        },
        "application/vnd.rim.cod": {
          source: "apache",
          extensions: ["cod"]
        },
        "application/vnd.rn-realmedia": {
          source: "apache",
          extensions: ["rm"]
        },
        "application/vnd.rn-realmedia-vbr": {
          source: "apache",
          extensions: ["rmvb"]
        },
        "application/vnd.route66.link66+xml": {
          source: "iana",
          compressible: true,
          extensions: ["link66"]
        },
        "application/vnd.rs-274x": {
          source: "iana"
        },
        "application/vnd.ruckus.download": {
          source: "iana"
        },
        "application/vnd.s3sms": {
          source: "iana"
        },
        "application/vnd.sailingtracker.track": {
          source: "iana",
          extensions: ["st"]
        },
        "application/vnd.sar": {
          source: "iana"
        },
        "application/vnd.sbm.cid": {
          source: "iana"
        },
        "application/vnd.sbm.mid2": {
          source: "iana"
        },
        "application/vnd.scribus": {
          source: "iana"
        },
        "application/vnd.sealed.3df": {
          source: "iana"
        },
        "application/vnd.sealed.csf": {
          source: "iana"
        },
        "application/vnd.sealed.doc": {
          source: "iana"
        },
        "application/vnd.sealed.eml": {
          source: "iana"
        },
        "application/vnd.sealed.mht": {
          source: "iana"
        },
        "application/vnd.sealed.net": {
          source: "iana"
        },
        "application/vnd.sealed.ppt": {
          source: "iana"
        },
        "application/vnd.sealed.tiff": {
          source: "iana"
        },
        "application/vnd.sealed.xls": {
          source: "iana"
        },
        "application/vnd.sealedmedia.softseal.html": {
          source: "iana"
        },
        "application/vnd.sealedmedia.softseal.pdf": {
          source: "iana"
        },
        "application/vnd.seemail": {
          source: "iana",
          extensions: ["see"]
        },
        "application/vnd.seis+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.sema": {
          source: "iana",
          extensions: ["sema"]
        },
        "application/vnd.semd": {
          source: "iana",
          extensions: ["semd"]
        },
        "application/vnd.semf": {
          source: "iana",
          extensions: ["semf"]
        },
        "application/vnd.shade-save-file": {
          source: "iana"
        },
        "application/vnd.shana.informed.formdata": {
          source: "iana",
          extensions: ["ifm"]
        },
        "application/vnd.shana.informed.formtemplate": {
          source: "iana",
          extensions: ["itp"]
        },
        "application/vnd.shana.informed.interchange": {
          source: "iana",
          extensions: ["iif"]
        },
        "application/vnd.shana.informed.package": {
          source: "iana",
          extensions: ["ipk"]
        },
        "application/vnd.shootproof+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.shopkick+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.shp": {
          source: "iana"
        },
        "application/vnd.shx": {
          source: "iana"
        },
        "application/vnd.sigrok.session": {
          source: "iana"
        },
        "application/vnd.simtech-mindmapper": {
          source: "iana",
          extensions: ["twd", "twds"]
        },
        "application/vnd.siren+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.smaf": {
          source: "iana",
          extensions: ["mmf"]
        },
        "application/vnd.smart.notebook": {
          source: "iana"
        },
        "application/vnd.smart.teacher": {
          source: "iana",
          extensions: ["teacher"]
        },
        "application/vnd.snesdev-page-table": {
          source: "iana"
        },
        "application/vnd.software602.filler.form+xml": {
          source: "iana",
          compressible: true,
          extensions: ["fo"]
        },
        "application/vnd.software602.filler.form-xml-zip": {
          source: "iana"
        },
        "application/vnd.solent.sdkm+xml": {
          source: "iana",
          compressible: true,
          extensions: ["sdkm", "sdkd"]
        },
        "application/vnd.spotfire.dxp": {
          source: "iana",
          extensions: ["dxp"]
        },
        "application/vnd.spotfire.sfs": {
          source: "iana",
          extensions: ["sfs"]
        },
        "application/vnd.sqlite3": {
          source: "iana"
        },
        "application/vnd.sss-cod": {
          source: "iana"
        },
        "application/vnd.sss-dtf": {
          source: "iana"
        },
        "application/vnd.sss-ntf": {
          source: "iana"
        },
        "application/vnd.stardivision.calc": {
          source: "apache",
          extensions: ["sdc"]
        },
        "application/vnd.stardivision.draw": {
          source: "apache",
          extensions: ["sda"]
        },
        "application/vnd.stardivision.impress": {
          source: "apache",
          extensions: ["sdd"]
        },
        "application/vnd.stardivision.math": {
          source: "apache",
          extensions: ["smf"]
        },
        "application/vnd.stardivision.writer": {
          source: "apache",
          extensions: ["sdw", "vor"]
        },
        "application/vnd.stardivision.writer-global": {
          source: "apache",
          extensions: ["sgl"]
        },
        "application/vnd.stepmania.package": {
          source: "iana",
          extensions: ["smzip"]
        },
        "application/vnd.stepmania.stepchart": {
          source: "iana",
          extensions: ["sm"]
        },
        "application/vnd.street-stream": {
          source: "iana"
        },
        "application/vnd.sun.wadl+xml": {
          source: "iana",
          compressible: true,
          extensions: ["wadl"]
        },
        "application/vnd.sun.xml.calc": {
          source: "apache",
          extensions: ["sxc"]
        },
        "application/vnd.sun.xml.calc.template": {
          source: "apache",
          extensions: ["stc"]
        },
        "application/vnd.sun.xml.draw": {
          source: "apache",
          extensions: ["sxd"]
        },
        "application/vnd.sun.xml.draw.template": {
          source: "apache",
          extensions: ["std"]
        },
        "application/vnd.sun.xml.impress": {
          source: "apache",
          extensions: ["sxi"]
        },
        "application/vnd.sun.xml.impress.template": {
          source: "apache",
          extensions: ["sti"]
        },
        "application/vnd.sun.xml.math": {
          source: "apache",
          extensions: ["sxm"]
        },
        "application/vnd.sun.xml.writer": {
          source: "apache",
          extensions: ["sxw"]
        },
        "application/vnd.sun.xml.writer.global": {
          source: "apache",
          extensions: ["sxg"]
        },
        "application/vnd.sun.xml.writer.template": {
          source: "apache",
          extensions: ["stw"]
        },
        "application/vnd.sus-calendar": {
          source: "iana",
          extensions: ["sus", "susp"]
        },
        "application/vnd.svd": {
          source: "iana",
          extensions: ["svd"]
        },
        "application/vnd.swiftview-ics": {
          source: "iana"
        },
        "application/vnd.sycle+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.syft+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.symbian.install": {
          source: "apache",
          extensions: ["sis", "sisx"]
        },
        "application/vnd.syncml+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["xsm"]
        },
        "application/vnd.syncml.dm+wbxml": {
          source: "iana",
          charset: "UTF-8",
          extensions: ["bdm"]
        },
        "application/vnd.syncml.dm+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["xdm"]
        },
        "application/vnd.syncml.dm.notification": {
          source: "iana"
        },
        "application/vnd.syncml.dmddf+wbxml": {
          source: "iana"
        },
        "application/vnd.syncml.dmddf+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["ddf"]
        },
        "application/vnd.syncml.dmtnds+wbxml": {
          source: "iana"
        },
        "application/vnd.syncml.dmtnds+xml": {
          source: "iana",
          charset: "UTF-8",
          compressible: true
        },
        "application/vnd.syncml.ds.notification": {
          source: "iana"
        },
        "application/vnd.tableschema+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.tao.intent-module-archive": {
          source: "iana",
          extensions: ["tao"]
        },
        "application/vnd.tcpdump.pcap": {
          source: "iana",
          extensions: ["pcap", "cap", "dmp"]
        },
        "application/vnd.think-cell.ppttc+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.tmd.mediaflex.api+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.tml": {
          source: "iana"
        },
        "application/vnd.tmobile-livetv": {
          source: "iana",
          extensions: ["tmo"]
        },
        "application/vnd.tri.onesource": {
          source: "iana"
        },
        "application/vnd.trid.tpt": {
          source: "iana",
          extensions: ["tpt"]
        },
        "application/vnd.triscape.mxs": {
          source: "iana",
          extensions: ["mxs"]
        },
        "application/vnd.trueapp": {
          source: "iana",
          extensions: ["tra"]
        },
        "application/vnd.truedoc": {
          source: "iana"
        },
        "application/vnd.ubisoft.webplayer": {
          source: "iana"
        },
        "application/vnd.ufdl": {
          source: "iana",
          extensions: ["ufd", "ufdl"]
        },
        "application/vnd.uiq.theme": {
          source: "iana",
          extensions: ["utz"]
        },
        "application/vnd.umajin": {
          source: "iana",
          extensions: ["umj"]
        },
        "application/vnd.unity": {
          source: "iana",
          extensions: ["unityweb"]
        },
        "application/vnd.uoml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["uoml"]
        },
        "application/vnd.uplanet.alert": {
          source: "iana"
        },
        "application/vnd.uplanet.alert-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.bearer-choice": {
          source: "iana"
        },
        "application/vnd.uplanet.bearer-choice-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.cacheop": {
          source: "iana"
        },
        "application/vnd.uplanet.cacheop-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.channel": {
          source: "iana"
        },
        "application/vnd.uplanet.channel-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.list": {
          source: "iana"
        },
        "application/vnd.uplanet.list-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.listcmd": {
          source: "iana"
        },
        "application/vnd.uplanet.listcmd-wbxml": {
          source: "iana"
        },
        "application/vnd.uplanet.signal": {
          source: "iana"
        },
        "application/vnd.uri-map": {
          source: "iana"
        },
        "application/vnd.valve.source.material": {
          source: "iana"
        },
        "application/vnd.vcx": {
          source: "iana",
          extensions: ["vcx"]
        },
        "application/vnd.vd-study": {
          source: "iana"
        },
        "application/vnd.vectorworks": {
          source: "iana"
        },
        "application/vnd.vel+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.verimatrix.vcas": {
          source: "iana"
        },
        "application/vnd.veritone.aion+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.veryant.thin": {
          source: "iana"
        },
        "application/vnd.ves.encrypted": {
          source: "iana"
        },
        "application/vnd.vidsoft.vidconference": {
          source: "iana"
        },
        "application/vnd.visio": {
          source: "iana",
          extensions: ["vsd", "vst", "vss", "vsw"]
        },
        "application/vnd.visionary": {
          source: "iana",
          extensions: ["vis"]
        },
        "application/vnd.vividence.scriptfile": {
          source: "iana"
        },
        "application/vnd.vsf": {
          source: "iana",
          extensions: ["vsf"]
        },
        "application/vnd.wap.sic": {
          source: "iana"
        },
        "application/vnd.wap.slc": {
          source: "iana"
        },
        "application/vnd.wap.wbxml": {
          source: "iana",
          charset: "UTF-8",
          extensions: ["wbxml"]
        },
        "application/vnd.wap.wmlc": {
          source: "iana",
          extensions: ["wmlc"]
        },
        "application/vnd.wap.wmlscriptc": {
          source: "iana",
          extensions: ["wmlsc"]
        },
        "application/vnd.webturbo": {
          source: "iana",
          extensions: ["wtb"]
        },
        "application/vnd.wfa.dpp": {
          source: "iana"
        },
        "application/vnd.wfa.p2p": {
          source: "iana"
        },
        "application/vnd.wfa.wsc": {
          source: "iana"
        },
        "application/vnd.windows.devicepairing": {
          source: "iana"
        },
        "application/vnd.wmc": {
          source: "iana"
        },
        "application/vnd.wmf.bootstrap": {
          source: "iana"
        },
        "application/vnd.wolfram.mathematica": {
          source: "iana"
        },
        "application/vnd.wolfram.mathematica.package": {
          source: "iana"
        },
        "application/vnd.wolfram.player": {
          source: "iana",
          extensions: ["nbp"]
        },
        "application/vnd.wordperfect": {
          source: "iana",
          extensions: ["wpd"]
        },
        "application/vnd.wqd": {
          source: "iana",
          extensions: ["wqd"]
        },
        "application/vnd.wrq-hp3000-labelled": {
          source: "iana"
        },
        "application/vnd.wt.stf": {
          source: "iana",
          extensions: ["stf"]
        },
        "application/vnd.wv.csp+wbxml": {
          source: "iana"
        },
        "application/vnd.wv.csp+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.wv.ssp+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.xacml+json": {
          source: "iana",
          compressible: true
        },
        "application/vnd.xara": {
          source: "iana",
          extensions: ["xar"]
        },
        "application/vnd.xfdl": {
          source: "iana",
          extensions: ["xfdl"]
        },
        "application/vnd.xfdl.webform": {
          source: "iana"
        },
        "application/vnd.xmi+xml": {
          source: "iana",
          compressible: true
        },
        "application/vnd.xmpie.cpkg": {
          source: "iana"
        },
        "application/vnd.xmpie.dpkg": {
          source: "iana"
        },
        "application/vnd.xmpie.plan": {
          source: "iana"
        },
        "application/vnd.xmpie.ppkg": {
          source: "iana"
        },
        "application/vnd.xmpie.xlim": {
          source: "iana"
        },
        "application/vnd.yamaha.hv-dic": {
          source: "iana",
          extensions: ["hvd"]
        },
        "application/vnd.yamaha.hv-script": {
          source: "iana",
          extensions: ["hvs"]
        },
        "application/vnd.yamaha.hv-voice": {
          source: "iana",
          extensions: ["hvp"]
        },
        "application/vnd.yamaha.openscoreformat": {
          source: "iana",
          extensions: ["osf"]
        },
        "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
          source: "iana",
          compressible: true,
          extensions: ["osfpvg"]
        },
        "application/vnd.yamaha.remote-setup": {
          source: "iana"
        },
        "application/vnd.yamaha.smaf-audio": {
          source: "iana",
          extensions: ["saf"]
        },
        "application/vnd.yamaha.smaf-phrase": {
          source: "iana",
          extensions: ["spf"]
        },
        "application/vnd.yamaha.through-ngn": {
          source: "iana"
        },
        "application/vnd.yamaha.tunnel-udpencap": {
          source: "iana"
        },
        "application/vnd.yaoweme": {
          source: "iana"
        },
        "application/vnd.yellowriver-custom-menu": {
          source: "iana",
          extensions: ["cmp"]
        },
        "application/vnd.youtube.yt": {
          source: "iana"
        },
        "application/vnd.zul": {
          source: "iana",
          extensions: ["zir", "zirz"]
        },
        "application/vnd.zzazz.deck+xml": {
          source: "iana",
          compressible: true,
          extensions: ["zaz"]
        },
        "application/voicexml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["vxml"]
        },
        "application/voucher-cms+json": {
          source: "iana",
          compressible: true
        },
        "application/vq-rtcpxr": {
          source: "iana"
        },
        "application/wasm": {
          source: "iana",
          compressible: true,
          extensions: ["wasm"]
        },
        "application/watcherinfo+xml": {
          source: "iana",
          compressible: true,
          extensions: ["wif"]
        },
        "application/webpush-options+json": {
          source: "iana",
          compressible: true
        },
        "application/whoispp-query": {
          source: "iana"
        },
        "application/whoispp-response": {
          source: "iana"
        },
        "application/widget": {
          source: "iana",
          extensions: ["wgt"]
        },
        "application/winhlp": {
          source: "apache",
          extensions: ["hlp"]
        },
        "application/wita": {
          source: "iana"
        },
        "application/wordperfect5.1": {
          source: "iana"
        },
        "application/wsdl+xml": {
          source: "iana",
          compressible: true,
          extensions: ["wsdl"]
        },
        "application/wspolicy+xml": {
          source: "iana",
          compressible: true,
          extensions: ["wspolicy"]
        },
        "application/x-7z-compressed": {
          source: "apache",
          compressible: false,
          extensions: ["7z"]
        },
        "application/x-abiword": {
          source: "apache",
          extensions: ["abw"]
        },
        "application/x-ace-compressed": {
          source: "apache",
          extensions: ["ace"]
        },
        "application/x-amf": {
          source: "apache"
        },
        "application/x-apple-diskimage": {
          source: "apache",
          extensions: ["dmg"]
        },
        "application/x-arj": {
          compressible: false,
          extensions: ["arj"]
        },
        "application/x-authorware-bin": {
          source: "apache",
          extensions: ["aab", "x32", "u32", "vox"]
        },
        "application/x-authorware-map": {
          source: "apache",
          extensions: ["aam"]
        },
        "application/x-authorware-seg": {
          source: "apache",
          extensions: ["aas"]
        },
        "application/x-bcpio": {
          source: "apache",
          extensions: ["bcpio"]
        },
        "application/x-bdoc": {
          compressible: false,
          extensions: ["bdoc"]
        },
        "application/x-bittorrent": {
          source: "apache",
          extensions: ["torrent"]
        },
        "application/x-blorb": {
          source: "apache",
          extensions: ["blb", "blorb"]
        },
        "application/x-bzip": {
          source: "apache",
          compressible: false,
          extensions: ["bz"]
        },
        "application/x-bzip2": {
          source: "apache",
          compressible: false,
          extensions: ["bz2", "boz"]
        },
        "application/x-cbr": {
          source: "apache",
          extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
        },
        "application/x-cdlink": {
          source: "apache",
          extensions: ["vcd"]
        },
        "application/x-cfs-compressed": {
          source: "apache",
          extensions: ["cfs"]
        },
        "application/x-chat": {
          source: "apache",
          extensions: ["chat"]
        },
        "application/x-chess-pgn": {
          source: "apache",
          extensions: ["pgn"]
        },
        "application/x-chrome-extension": {
          extensions: ["crx"]
        },
        "application/x-cocoa": {
          source: "nginx",
          extensions: ["cco"]
        },
        "application/x-compress": {
          source: "apache"
        },
        "application/x-conference": {
          source: "apache",
          extensions: ["nsc"]
        },
        "application/x-cpio": {
          source: "apache",
          extensions: ["cpio"]
        },
        "application/x-csh": {
          source: "apache",
          extensions: ["csh"]
        },
        "application/x-deb": {
          compressible: false
        },
        "application/x-debian-package": {
          source: "apache",
          extensions: ["deb", "udeb"]
        },
        "application/x-dgc-compressed": {
          source: "apache",
          extensions: ["dgc"]
        },
        "application/x-director": {
          source: "apache",
          extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
        },
        "application/x-doom": {
          source: "apache",
          extensions: ["wad"]
        },
        "application/x-dtbncx+xml": {
          source: "apache",
          compressible: true,
          extensions: ["ncx"]
        },
        "application/x-dtbook+xml": {
          source: "apache",
          compressible: true,
          extensions: ["dtb"]
        },
        "application/x-dtbresource+xml": {
          source: "apache",
          compressible: true,
          extensions: ["res"]
        },
        "application/x-dvi": {
          source: "apache",
          compressible: false,
          extensions: ["dvi"]
        },
        "application/x-envoy": {
          source: "apache",
          extensions: ["evy"]
        },
        "application/x-eva": {
          source: "apache",
          extensions: ["eva"]
        },
        "application/x-font-bdf": {
          source: "apache",
          extensions: ["bdf"]
        },
        "application/x-font-dos": {
          source: "apache"
        },
        "application/x-font-framemaker": {
          source: "apache"
        },
        "application/x-font-ghostscript": {
          source: "apache",
          extensions: ["gsf"]
        },
        "application/x-font-libgrx": {
          source: "apache"
        },
        "application/x-font-linux-psf": {
          source: "apache",
          extensions: ["psf"]
        },
        "application/x-font-pcf": {
          source: "apache",
          extensions: ["pcf"]
        },
        "application/x-font-snf": {
          source: "apache",
          extensions: ["snf"]
        },
        "application/x-font-speedo": {
          source: "apache"
        },
        "application/x-font-sunos-news": {
          source: "apache"
        },
        "application/x-font-type1": {
          source: "apache",
          extensions: ["pfa", "pfb", "pfm", "afm"]
        },
        "application/x-font-vfont": {
          source: "apache"
        },
        "application/x-freearc": {
          source: "apache",
          extensions: ["arc"]
        },
        "application/x-futuresplash": {
          source: "apache",
          extensions: ["spl"]
        },
        "application/x-gca-compressed": {
          source: "apache",
          extensions: ["gca"]
        },
        "application/x-glulx": {
          source: "apache",
          extensions: ["ulx"]
        },
        "application/x-gnumeric": {
          source: "apache",
          extensions: ["gnumeric"]
        },
        "application/x-gramps-xml": {
          source: "apache",
          extensions: ["gramps"]
        },
        "application/x-gtar": {
          source: "apache",
          extensions: ["gtar"]
        },
        "application/x-gzip": {
          source: "apache"
        },
        "application/x-hdf": {
          source: "apache",
          extensions: ["hdf"]
        },
        "application/x-httpd-php": {
          compressible: true,
          extensions: ["php"]
        },
        "application/x-install-instructions": {
          source: "apache",
          extensions: ["install"]
        },
        "application/x-iso9660-image": {
          source: "apache",
          extensions: ["iso"]
        },
        "application/x-iwork-keynote-sffkey": {
          extensions: ["key"]
        },
        "application/x-iwork-numbers-sffnumbers": {
          extensions: ["numbers"]
        },
        "application/x-iwork-pages-sffpages": {
          extensions: ["pages"]
        },
        "application/x-java-archive-diff": {
          source: "nginx",
          extensions: ["jardiff"]
        },
        "application/x-java-jnlp-file": {
          source: "apache",
          compressible: false,
          extensions: ["jnlp"]
        },
        "application/x-javascript": {
          compressible: true
        },
        "application/x-keepass2": {
          extensions: ["kdbx"]
        },
        "application/x-latex": {
          source: "apache",
          compressible: false,
          extensions: ["latex"]
        },
        "application/x-lua-bytecode": {
          extensions: ["luac"]
        },
        "application/x-lzh-compressed": {
          source: "apache",
          extensions: ["lzh", "lha"]
        },
        "application/x-makeself": {
          source: "nginx",
          extensions: ["run"]
        },
        "application/x-mie": {
          source: "apache",
          extensions: ["mie"]
        },
        "application/x-mobipocket-ebook": {
          source: "apache",
          extensions: ["prc", "mobi"]
        },
        "application/x-mpegurl": {
          compressible: false
        },
        "application/x-ms-application": {
          source: "apache",
          extensions: ["application"]
        },
        "application/x-ms-shortcut": {
          source: "apache",
          extensions: ["lnk"]
        },
        "application/x-ms-wmd": {
          source: "apache",
          extensions: ["wmd"]
        },
        "application/x-ms-wmz": {
          source: "apache",
          extensions: ["wmz"]
        },
        "application/x-ms-xbap": {
          source: "apache",
          extensions: ["xbap"]
        },
        "application/x-msaccess": {
          source: "apache",
          extensions: ["mdb"]
        },
        "application/x-msbinder": {
          source: "apache",
          extensions: ["obd"]
        },
        "application/x-mscardfile": {
          source: "apache",
          extensions: ["crd"]
        },
        "application/x-msclip": {
          source: "apache",
          extensions: ["clp"]
        },
        "application/x-msdos-program": {
          extensions: ["exe"]
        },
        "application/x-msdownload": {
          source: "apache",
          extensions: ["exe", "dll", "com", "bat", "msi"]
        },
        "application/x-msmediaview": {
          source: "apache",
          extensions: ["mvb", "m13", "m14"]
        },
        "application/x-msmetafile": {
          source: "apache",
          extensions: ["wmf", "wmz", "emf", "emz"]
        },
        "application/x-msmoney": {
          source: "apache",
          extensions: ["mny"]
        },
        "application/x-mspublisher": {
          source: "apache",
          extensions: ["pub"]
        },
        "application/x-msschedule": {
          source: "apache",
          extensions: ["scd"]
        },
        "application/x-msterminal": {
          source: "apache",
          extensions: ["trm"]
        },
        "application/x-mswrite": {
          source: "apache",
          extensions: ["wri"]
        },
        "application/x-netcdf": {
          source: "apache",
          extensions: ["nc", "cdf"]
        },
        "application/x-ns-proxy-autoconfig": {
          compressible: true,
          extensions: ["pac"]
        },
        "application/x-nzb": {
          source: "apache",
          extensions: ["nzb"]
        },
        "application/x-perl": {
          source: "nginx",
          extensions: ["pl", "pm"]
        },
        "application/x-pilot": {
          source: "nginx",
          extensions: ["prc", "pdb"]
        },
        "application/x-pkcs12": {
          source: "apache",
          compressible: false,
          extensions: ["p12", "pfx"]
        },
        "application/x-pkcs7-certificates": {
          source: "apache",
          extensions: ["p7b", "spc"]
        },
        "application/x-pkcs7-certreqresp": {
          source: "apache",
          extensions: ["p7r"]
        },
        "application/x-pki-message": {
          source: "iana"
        },
        "application/x-rar-compressed": {
          source: "apache",
          compressible: false,
          extensions: ["rar"]
        },
        "application/x-redhat-package-manager": {
          source: "nginx",
          extensions: ["rpm"]
        },
        "application/x-research-info-systems": {
          source: "apache",
          extensions: ["ris"]
        },
        "application/x-sea": {
          source: "nginx",
          extensions: ["sea"]
        },
        "application/x-sh": {
          source: "apache",
          compressible: true,
          extensions: ["sh"]
        },
        "application/x-shar": {
          source: "apache",
          extensions: ["shar"]
        },
        "application/x-shockwave-flash": {
          source: "apache",
          compressible: false,
          extensions: ["swf"]
        },
        "application/x-silverlight-app": {
          source: "apache",
          extensions: ["xap"]
        },
        "application/x-sql": {
          source: "apache",
          extensions: ["sql"]
        },
        "application/x-stuffit": {
          source: "apache",
          compressible: false,
          extensions: ["sit"]
        },
        "application/x-stuffitx": {
          source: "apache",
          extensions: ["sitx"]
        },
        "application/x-subrip": {
          source: "apache",
          extensions: ["srt"]
        },
        "application/x-sv4cpio": {
          source: "apache",
          extensions: ["sv4cpio"]
        },
        "application/x-sv4crc": {
          source: "apache",
          extensions: ["sv4crc"]
        },
        "application/x-t3vm-image": {
          source: "apache",
          extensions: ["t3"]
        },
        "application/x-tads": {
          source: "apache",
          extensions: ["gam"]
        },
        "application/x-tar": {
          source: "apache",
          compressible: true,
          extensions: ["tar"]
        },
        "application/x-tcl": {
          source: "apache",
          extensions: ["tcl", "tk"]
        },
        "application/x-tex": {
          source: "apache",
          extensions: ["tex"]
        },
        "application/x-tex-tfm": {
          source: "apache",
          extensions: ["tfm"]
        },
        "application/x-texinfo": {
          source: "apache",
          extensions: ["texinfo", "texi"]
        },
        "application/x-tgif": {
          source: "apache",
          extensions: ["obj"]
        },
        "application/x-ustar": {
          source: "apache",
          extensions: ["ustar"]
        },
        "application/x-virtualbox-hdd": {
          compressible: true,
          extensions: ["hdd"]
        },
        "application/x-virtualbox-ova": {
          compressible: true,
          extensions: ["ova"]
        },
        "application/x-virtualbox-ovf": {
          compressible: true,
          extensions: ["ovf"]
        },
        "application/x-virtualbox-vbox": {
          compressible: true,
          extensions: ["vbox"]
        },
        "application/x-virtualbox-vbox-extpack": {
          compressible: false,
          extensions: ["vbox-extpack"]
        },
        "application/x-virtualbox-vdi": {
          compressible: true,
          extensions: ["vdi"]
        },
        "application/x-virtualbox-vhd": {
          compressible: true,
          extensions: ["vhd"]
        },
        "application/x-virtualbox-vmdk": {
          compressible: true,
          extensions: ["vmdk"]
        },
        "application/x-wais-source": {
          source: "apache",
          extensions: ["src"]
        },
        "application/x-web-app-manifest+json": {
          compressible: true,
          extensions: ["webapp"]
        },
        "application/x-www-form-urlencoded": {
          source: "iana",
          compressible: true
        },
        "application/x-x509-ca-cert": {
          source: "iana",
          extensions: ["der", "crt", "pem"]
        },
        "application/x-x509-ca-ra-cert": {
          source: "iana"
        },
        "application/x-x509-next-ca-cert": {
          source: "iana"
        },
        "application/x-xfig": {
          source: "apache",
          extensions: ["fig"]
        },
        "application/x-xliff+xml": {
          source: "apache",
          compressible: true,
          extensions: ["xlf"]
        },
        "application/x-xpinstall": {
          source: "apache",
          compressible: false,
          extensions: ["xpi"]
        },
        "application/x-xz": {
          source: "apache",
          extensions: ["xz"]
        },
        "application/x-zmachine": {
          source: "apache",
          extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
        },
        "application/x400-bp": {
          source: "iana"
        },
        "application/xacml+xml": {
          source: "iana",
          compressible: true
        },
        "application/xaml+xml": {
          source: "apache",
          compressible: true,
          extensions: ["xaml"]
        },
        "application/xcap-att+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xav"]
        },
        "application/xcap-caps+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xca"]
        },
        "application/xcap-diff+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xdf"]
        },
        "application/xcap-el+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xel"]
        },
        "application/xcap-error+xml": {
          source: "iana",
          compressible: true
        },
        "application/xcap-ns+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xns"]
        },
        "application/xcon-conference-info+xml": {
          source: "iana",
          compressible: true
        },
        "application/xcon-conference-info-diff+xml": {
          source: "iana",
          compressible: true
        },
        "application/xenc+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xenc"]
        },
        "application/xhtml+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xhtml", "xht"]
        },
        "application/xhtml-voice+xml": {
          source: "apache",
          compressible: true
        },
        "application/xliff+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xlf"]
        },
        "application/xml": {
          source: "iana",
          compressible: true,
          extensions: ["xml", "xsl", "xsd", "rng"]
        },
        "application/xml-dtd": {
          source: "iana",
          compressible: true,
          extensions: ["dtd"]
        },
        "application/xml-external-parsed-entity": {
          source: "iana"
        },
        "application/xml-patch+xml": {
          source: "iana",
          compressible: true
        },
        "application/xmpp+xml": {
          source: "iana",
          compressible: true
        },
        "application/xop+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xop"]
        },
        "application/xproc+xml": {
          source: "apache",
          compressible: true,
          extensions: ["xpl"]
        },
        "application/xslt+xml": {
          source: "iana",
          compressible: true,
          extensions: ["xsl", "xslt"]
        },
        "application/xspf+xml": {
          source: "apache",
          compressible: true,
          extensions: ["xspf"]
        },
        "application/xv+xml": {
          source: "iana",
          compressible: true,
          extensions: ["mxml", "xhvml", "xvml", "xvm"]
        },
        "application/yang": {
          source: "iana",
          extensions: ["yang"]
        },
        "application/yang-data+json": {
          source: "iana",
          compressible: true
        },
        "application/yang-data+xml": {
          source: "iana",
          compressible: true
        },
        "application/yang-patch+json": {
          source: "iana",
          compressible: true
        },
        "application/yang-patch+xml": {
          source: "iana",
          compressible: true
        },
        "application/yin+xml": {
          source: "iana",
          compressible: true,
          extensions: ["yin"]
        },
        "application/zip": {
          source: "iana",
          compressible: false,
          extensions: ["zip"]
        },
        "application/zlib": {
          source: "iana"
        },
        "application/zstd": {
          source: "iana"
        },
        "audio/1d-interleaved-parityfec": {
          source: "iana"
        },
        "audio/32kadpcm": {
          source: "iana"
        },
        "audio/3gpp": {
          source: "iana",
          compressible: false,
          extensions: ["3gpp"]
        },
        "audio/3gpp2": {
          source: "iana"
        },
        "audio/aac": {
          source: "iana"
        },
        "audio/ac3": {
          source: "iana"
        },
        "audio/adpcm": {
          source: "apache",
          extensions: ["adp"]
        },
        "audio/amr": {
          source: "iana",
          extensions: ["amr"]
        },
        "audio/amr-wb": {
          source: "iana"
        },
        "audio/amr-wb+": {
          source: "iana"
        },
        "audio/aptx": {
          source: "iana"
        },
        "audio/asc": {
          source: "iana"
        },
        "audio/atrac-advanced-lossless": {
          source: "iana"
        },
        "audio/atrac-x": {
          source: "iana"
        },
        "audio/atrac3": {
          source: "iana"
        },
        "audio/basic": {
          source: "iana",
          compressible: false,
          extensions: ["au", "snd"]
        },
        "audio/bv16": {
          source: "iana"
        },
        "audio/bv32": {
          source: "iana"
        },
        "audio/clearmode": {
          source: "iana"
        },
        "audio/cn": {
          source: "iana"
        },
        "audio/dat12": {
          source: "iana"
        },
        "audio/dls": {
          source: "iana"
        },
        "audio/dsr-es201108": {
          source: "iana"
        },
        "audio/dsr-es202050": {
          source: "iana"
        },
        "audio/dsr-es202211": {
          source: "iana"
        },
        "audio/dsr-es202212": {
          source: "iana"
        },
        "audio/dv": {
          source: "iana"
        },
        "audio/dvi4": {
          source: "iana"
        },
        "audio/eac3": {
          source: "iana"
        },
        "audio/encaprtp": {
          source: "iana"
        },
        "audio/evrc": {
          source: "iana"
        },
        "audio/evrc-qcp": {
          source: "iana"
        },
        "audio/evrc0": {
          source: "iana"
        },
        "audio/evrc1": {
          source: "iana"
        },
        "audio/evrcb": {
          source: "iana"
        },
        "audio/evrcb0": {
          source: "iana"
        },
        "audio/evrcb1": {
          source: "iana"
        },
        "audio/evrcnw": {
          source: "iana"
        },
        "audio/evrcnw0": {
          source: "iana"
        },
        "audio/evrcnw1": {
          source: "iana"
        },
        "audio/evrcwb": {
          source: "iana"
        },
        "audio/evrcwb0": {
          source: "iana"
        },
        "audio/evrcwb1": {
          source: "iana"
        },
        "audio/evs": {
          source: "iana"
        },
        "audio/flexfec": {
          source: "iana"
        },
        "audio/fwdred": {
          source: "iana"
        },
        "audio/g711-0": {
          source: "iana"
        },
        "audio/g719": {
          source: "iana"
        },
        "audio/g722": {
          source: "iana"
        },
        "audio/g7221": {
          source: "iana"
        },
        "audio/g723": {
          source: "iana"
        },
        "audio/g726-16": {
          source: "iana"
        },
        "audio/g726-24": {
          source: "iana"
        },
        "audio/g726-32": {
          source: "iana"
        },
        "audio/g726-40": {
          source: "iana"
        },
        "audio/g728": {
          source: "iana"
        },
        "audio/g729": {
          source: "iana"
        },
        "audio/g7291": {
          source: "iana"
        },
        "audio/g729d": {
          source: "iana"
        },
        "audio/g729e": {
          source: "iana"
        },
        "audio/gsm": {
          source: "iana"
        },
        "audio/gsm-efr": {
          source: "iana"
        },
        "audio/gsm-hr-08": {
          source: "iana"
        },
        "audio/ilbc": {
          source: "iana"
        },
        "audio/ip-mr_v2.5": {
          source: "iana"
        },
        "audio/isac": {
          source: "apache"
        },
        "audio/l16": {
          source: "iana"
        },
        "audio/l20": {
          source: "iana"
        },
        "audio/l24": {
          source: "iana",
          compressible: false
        },
        "audio/l8": {
          source: "iana"
        },
        "audio/lpc": {
          source: "iana"
        },
        "audio/melp": {
          source: "iana"
        },
        "audio/melp1200": {
          source: "iana"
        },
        "audio/melp2400": {
          source: "iana"
        },
        "audio/melp600": {
          source: "iana"
        },
        "audio/mhas": {
          source: "iana"
        },
        "audio/midi": {
          source: "apache",
          extensions: ["mid", "midi", "kar", "rmi"]
        },
        "audio/mobile-xmf": {
          source: "iana",
          extensions: ["mxmf"]
        },
        "audio/mp3": {
          compressible: false,
          extensions: ["mp3"]
        },
        "audio/mp4": {
          source: "iana",
          compressible: false,
          extensions: ["m4a", "mp4a"]
        },
        "audio/mp4a-latm": {
          source: "iana"
        },
        "audio/mpa": {
          source: "iana"
        },
        "audio/mpa-robust": {
          source: "iana"
        },
        "audio/mpeg": {
          source: "iana",
          compressible: false,
          extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
        },
        "audio/mpeg4-generic": {
          source: "iana"
        },
        "audio/musepack": {
          source: "apache"
        },
        "audio/ogg": {
          source: "iana",
          compressible: false,
          extensions: ["oga", "ogg", "spx", "opus"]
        },
        "audio/opus": {
          source: "iana"
        },
        "audio/parityfec": {
          source: "iana"
        },
        "audio/pcma": {
          source: "iana"
        },
        "audio/pcma-wb": {
          source: "iana"
        },
        "audio/pcmu": {
          source: "iana"
        },
        "audio/pcmu-wb": {
          source: "iana"
        },
        "audio/prs.sid": {
          source: "iana"
        },
        "audio/qcelp": {
          source: "iana"
        },
        "audio/raptorfec": {
          source: "iana"
        },
        "audio/red": {
          source: "iana"
        },
        "audio/rtp-enc-aescm128": {
          source: "iana"
        },
        "audio/rtp-midi": {
          source: "iana"
        },
        "audio/rtploopback": {
          source: "iana"
        },
        "audio/rtx": {
          source: "iana"
        },
        "audio/s3m": {
          source: "apache",
          extensions: ["s3m"]
        },
        "audio/scip": {
          source: "iana"
        },
        "audio/silk": {
          source: "apache",
          extensions: ["sil"]
        },
        "audio/smv": {
          source: "iana"
        },
        "audio/smv-qcp": {
          source: "iana"
        },
        "audio/smv0": {
          source: "iana"
        },
        "audio/sofa": {
          source: "iana"
        },
        "audio/sp-midi": {
          source: "iana"
        },
        "audio/speex": {
          source: "iana"
        },
        "audio/t140c": {
          source: "iana"
        },
        "audio/t38": {
          source: "iana"
        },
        "audio/telephone-event": {
          source: "iana"
        },
        "audio/tetra_acelp": {
          source: "iana"
        },
        "audio/tetra_acelp_bb": {
          source: "iana"
        },
        "audio/tone": {
          source: "iana"
        },
        "audio/tsvcis": {
          source: "iana"
        },
        "audio/uemclip": {
          source: "iana"
        },
        "audio/ulpfec": {
          source: "iana"
        },
        "audio/usac": {
          source: "iana"
        },
        "audio/vdvi": {
          source: "iana"
        },
        "audio/vmr-wb": {
          source: "iana"
        },
        "audio/vnd.3gpp.iufp": {
          source: "iana"
        },
        "audio/vnd.4sb": {
          source: "iana"
        },
        "audio/vnd.audiokoz": {
          source: "iana"
        },
        "audio/vnd.celp": {
          source: "iana"
        },
        "audio/vnd.cisco.nse": {
          source: "iana"
        },
        "audio/vnd.cmles.radio-events": {
          source: "iana"
        },
        "audio/vnd.cns.anp1": {
          source: "iana"
        },
        "audio/vnd.cns.inf1": {
          source: "iana"
        },
        "audio/vnd.dece.audio": {
          source: "iana",
          extensions: ["uva", "uvva"]
        },
        "audio/vnd.digital-winds": {
          source: "iana",
          extensions: ["eol"]
        },
        "audio/vnd.dlna.adts": {
          source: "iana"
        },
        "audio/vnd.dolby.heaac.1": {
          source: "iana"
        },
        "audio/vnd.dolby.heaac.2": {
          source: "iana"
        },
        "audio/vnd.dolby.mlp": {
          source: "iana"
        },
        "audio/vnd.dolby.mps": {
          source: "iana"
        },
        "audio/vnd.dolby.pl2": {
          source: "iana"
        },
        "audio/vnd.dolby.pl2x": {
          source: "iana"
        },
        "audio/vnd.dolby.pl2z": {
          source: "iana"
        },
        "audio/vnd.dolby.pulse.1": {
          source: "iana"
        },
        "audio/vnd.dra": {
          source: "iana",
          extensions: ["dra"]
        },
        "audio/vnd.dts": {
          source: "iana",
          extensions: ["dts"]
        },
        "audio/vnd.dts.hd": {
          source: "iana",
          extensions: ["dtshd"]
        },
        "audio/vnd.dts.uhd": {
          source: "iana"
        },
        "audio/vnd.dvb.file": {
          source: "iana"
        },
        "audio/vnd.everad.plj": {
          source: "iana"
        },
        "audio/vnd.hns.audio": {
          source: "iana"
        },
        "audio/vnd.lucent.voice": {
          source: "iana",
          extensions: ["lvp"]
        },
        "audio/vnd.ms-playready.media.pya": {
          source: "iana",
          extensions: ["pya"]
        },
        "audio/vnd.nokia.mobile-xmf": {
          source: "iana"
        },
        "audio/vnd.nortel.vbk": {
          source: "iana"
        },
        "audio/vnd.nuera.ecelp4800": {
          source: "iana",
          extensions: ["ecelp4800"]
        },
        "audio/vnd.nuera.ecelp7470": {
          source: "iana",
          extensions: ["ecelp7470"]
        },
        "audio/vnd.nuera.ecelp9600": {
          source: "iana",
          extensions: ["ecelp9600"]
        },
        "audio/vnd.octel.sbc": {
          source: "iana"
        },
        "audio/vnd.presonus.multitrack": {
          source: "iana"
        },
        "audio/vnd.qcelp": {
          source: "iana"
        },
        "audio/vnd.rhetorex.32kadpcm": {
          source: "iana"
        },
        "audio/vnd.rip": {
          source: "iana",
          extensions: ["rip"]
        },
        "audio/vnd.rn-realaudio": {
          compressible: false
        },
        "audio/vnd.sealedmedia.softseal.mpeg": {
          source: "iana"
        },
        "audio/vnd.vmx.cvsd": {
          source: "iana"
        },
        "audio/vnd.wave": {
          compressible: false
        },
        "audio/vorbis": {
          source: "iana",
          compressible: false
        },
        "audio/vorbis-config": {
          source: "iana"
        },
        "audio/wav": {
          compressible: false,
          extensions: ["wav"]
        },
        "audio/wave": {
          compressible: false,
          extensions: ["wav"]
        },
        "audio/webm": {
          source: "apache",
          compressible: false,
          extensions: ["weba"]
        },
        "audio/x-aac": {
          source: "apache",
          compressible: false,
          extensions: ["aac"]
        },
        "audio/x-aiff": {
          source: "apache",
          extensions: ["aif", "aiff", "aifc"]
        },
        "audio/x-caf": {
          source: "apache",
          compressible: false,
          extensions: ["caf"]
        },
        "audio/x-flac": {
          source: "apache",
          extensions: ["flac"]
        },
        "audio/x-m4a": {
          source: "nginx",
          extensions: ["m4a"]
        },
        "audio/x-matroska": {
          source: "apache",
          extensions: ["mka"]
        },
        "audio/x-mpegurl": {
          source: "apache",
          extensions: ["m3u"]
        },
        "audio/x-ms-wax": {
          source: "apache",
          extensions: ["wax"]
        },
        "audio/x-ms-wma": {
          source: "apache",
          extensions: ["wma"]
        },
        "audio/x-pn-realaudio": {
          source: "apache",
          extensions: ["ram", "ra"]
        },
        "audio/x-pn-realaudio-plugin": {
          source: "apache",
          extensions: ["rmp"]
        },
        "audio/x-realaudio": {
          source: "nginx",
          extensions: ["ra"]
        },
        "audio/x-tta": {
          source: "apache"
        },
        "audio/x-wav": {
          source: "apache",
          extensions: ["wav"]
        },
        "audio/xm": {
          source: "apache",
          extensions: ["xm"]
        },
        "chemical/x-cdx": {
          source: "apache",
          extensions: ["cdx"]
        },
        "chemical/x-cif": {
          source: "apache",
          extensions: ["cif"]
        },
        "chemical/x-cmdf": {
          source: "apache",
          extensions: ["cmdf"]
        },
        "chemical/x-cml": {
          source: "apache",
          extensions: ["cml"]
        },
        "chemical/x-csml": {
          source: "apache",
          extensions: ["csml"]
        },
        "chemical/x-pdb": {
          source: "apache"
        },
        "chemical/x-xyz": {
          source: "apache",
          extensions: ["xyz"]
        },
        "font/collection": {
          source: "iana",
          extensions: ["ttc"]
        },
        "font/otf": {
          source: "iana",
          compressible: true,
          extensions: ["otf"]
        },
        "font/sfnt": {
          source: "iana"
        },
        "font/ttf": {
          source: "iana",
          compressible: true,
          extensions: ["ttf"]
        },
        "font/woff": {
          source: "iana",
          extensions: ["woff"]
        },
        "font/woff2": {
          source: "iana",
          extensions: ["woff2"]
        },
        "image/aces": {
          source: "iana",
          extensions: ["exr"]
        },
        "image/apng": {
          compressible: false,
          extensions: ["apng"]
        },
        "image/avci": {
          source: "iana",
          extensions: ["avci"]
        },
        "image/avcs": {
          source: "iana",
          extensions: ["avcs"]
        },
        "image/avif": {
          source: "iana",
          compressible: false,
          extensions: ["avif"]
        },
        "image/bmp": {
          source: "iana",
          compressible: true,
          extensions: ["bmp"]
        },
        "image/cgm": {
          source: "iana",
          extensions: ["cgm"]
        },
        "image/dicom-rle": {
          source: "iana",
          extensions: ["drle"]
        },
        "image/emf": {
          source: "iana",
          extensions: ["emf"]
        },
        "image/fits": {
          source: "iana",
          extensions: ["fits"]
        },
        "image/g3fax": {
          source: "iana",
          extensions: ["g3"]
        },
        "image/gif": {
          source: "iana",
          compressible: false,
          extensions: ["gif"]
        },
        "image/heic": {
          source: "iana",
          extensions: ["heic"]
        },
        "image/heic-sequence": {
          source: "iana",
          extensions: ["heics"]
        },
        "image/heif": {
          source: "iana",
          extensions: ["heif"]
        },
        "image/heif-sequence": {
          source: "iana",
          extensions: ["heifs"]
        },
        "image/hej2k": {
          source: "iana",
          extensions: ["hej2"]
        },
        "image/hsj2": {
          source: "iana",
          extensions: ["hsj2"]
        },
        "image/ief": {
          source: "iana",
          extensions: ["ief"]
        },
        "image/jls": {
          source: "iana",
          extensions: ["jls"]
        },
        "image/jp2": {
          source: "iana",
          compressible: false,
          extensions: ["jp2", "jpg2"]
        },
        "image/jpeg": {
          source: "iana",
          compressible: false,
          extensions: ["jpeg", "jpg", "jpe"]
        },
        "image/jph": {
          source: "iana",
          extensions: ["jph"]
        },
        "image/jphc": {
          source: "iana",
          extensions: ["jhc"]
        },
        "image/jpm": {
          source: "iana",
          compressible: false,
          extensions: ["jpm"]
        },
        "image/jpx": {
          source: "iana",
          compressible: false,
          extensions: ["jpx", "jpf"]
        },
        "image/jxr": {
          source: "iana",
          extensions: ["jxr"]
        },
        "image/jxra": {
          source: "iana",
          extensions: ["jxra"]
        },
        "image/jxrs": {
          source: "iana",
          extensions: ["jxrs"]
        },
        "image/jxs": {
          source: "iana",
          extensions: ["jxs"]
        },
        "image/jxsc": {
          source: "iana",
          extensions: ["jxsc"]
        },
        "image/jxsi": {
          source: "iana",
          extensions: ["jxsi"]
        },
        "image/jxss": {
          source: "iana",
          extensions: ["jxss"]
        },
        "image/ktx": {
          source: "iana",
          extensions: ["ktx"]
        },
        "image/ktx2": {
          source: "iana",
          extensions: ["ktx2"]
        },
        "image/naplps": {
          source: "iana"
        },
        "image/pjpeg": {
          compressible: false
        },
        "image/png": {
          source: "iana",
          compressible: false,
          extensions: ["png"]
        },
        "image/prs.btif": {
          source: "iana",
          extensions: ["btif"]
        },
        "image/prs.pti": {
          source: "iana",
          extensions: ["pti"]
        },
        "image/pwg-raster": {
          source: "iana"
        },
        "image/sgi": {
          source: "apache",
          extensions: ["sgi"]
        },
        "image/svg+xml": {
          source: "iana",
          compressible: true,
          extensions: ["svg", "svgz"]
        },
        "image/t38": {
          source: "iana",
          extensions: ["t38"]
        },
        "image/tiff": {
          source: "iana",
          compressible: false,
          extensions: ["tif", "tiff"]
        },
        "image/tiff-fx": {
          source: "iana",
          extensions: ["tfx"]
        },
        "image/vnd.adobe.photoshop": {
          source: "iana",
          compressible: true,
          extensions: ["psd"]
        },
        "image/vnd.airzip.accelerator.azv": {
          source: "iana",
          extensions: ["azv"]
        },
        "image/vnd.cns.inf2": {
          source: "iana"
        },
        "image/vnd.dece.graphic": {
          source: "iana",
          extensions: ["uvi", "uvvi", "uvg", "uvvg"]
        },
        "image/vnd.djvu": {
          source: "iana",
          extensions: ["djvu", "djv"]
        },
        "image/vnd.dvb.subtitle": {
          source: "iana",
          extensions: ["sub"]
        },
        "image/vnd.dwg": {
          source: "iana",
          extensions: ["dwg"]
        },
        "image/vnd.dxf": {
          source: "iana",
          extensions: ["dxf"]
        },
        "image/vnd.fastbidsheet": {
          source: "iana",
          extensions: ["fbs"]
        },
        "image/vnd.fpx": {
          source: "iana",
          extensions: ["fpx"]
        },
        "image/vnd.fst": {
          source: "iana",
          extensions: ["fst"]
        },
        "image/vnd.fujixerox.edmics-mmr": {
          source: "iana",
          extensions: ["mmr"]
        },
        "image/vnd.fujixerox.edmics-rlc": {
          source: "iana",
          extensions: ["rlc"]
        },
        "image/vnd.globalgraphics.pgb": {
          source: "iana"
        },
        "image/vnd.microsoft.icon": {
          source: "iana",
          compressible: true,
          extensions: ["ico"]
        },
        "image/vnd.mix": {
          source: "iana"
        },
        "image/vnd.mozilla.apng": {
          source: "iana"
        },
        "image/vnd.ms-dds": {
          compressible: true,
          extensions: ["dds"]
        },
        "image/vnd.ms-modi": {
          source: "iana",
          extensions: ["mdi"]
        },
        "image/vnd.ms-photo": {
          source: "apache",
          extensions: ["wdp"]
        },
        "image/vnd.net-fpx": {
          source: "iana",
          extensions: ["npx"]
        },
        "image/vnd.pco.b16": {
          source: "iana",
          extensions: ["b16"]
        },
        "image/vnd.radiance": {
          source: "iana"
        },
        "image/vnd.sealed.png": {
          source: "iana"
        },
        "image/vnd.sealedmedia.softseal.gif": {
          source: "iana"
        },
        "image/vnd.sealedmedia.softseal.jpg": {
          source: "iana"
        },
        "image/vnd.svf": {
          source: "iana"
        },
        "image/vnd.tencent.tap": {
          source: "iana",
          extensions: ["tap"]
        },
        "image/vnd.valve.source.texture": {
          source: "iana",
          extensions: ["vtf"]
        },
        "image/vnd.wap.wbmp": {
          source: "iana",
          extensions: ["wbmp"]
        },
        "image/vnd.xiff": {
          source: "iana",
          extensions: ["xif"]
        },
        "image/vnd.zbrush.pcx": {
          source: "iana",
          extensions: ["pcx"]
        },
        "image/webp": {
          source: "apache",
          extensions: ["webp"]
        },
        "image/wmf": {
          source: "iana",
          extensions: ["wmf"]
        },
        "image/x-3ds": {
          source: "apache",
          extensions: ["3ds"]
        },
        "image/x-cmu-raster": {
          source: "apache",
          extensions: ["ras"]
        },
        "image/x-cmx": {
          source: "apache",
          extensions: ["cmx"]
        },
        "image/x-freehand": {
          source: "apache",
          extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
        },
        "image/x-icon": {
          source: "apache",
          compressible: true,
          extensions: ["ico"]
        },
        "image/x-jng": {
          source: "nginx",
          extensions: ["jng"]
        },
        "image/x-mrsid-image": {
          source: "apache",
          extensions: ["sid"]
        },
        "image/x-ms-bmp": {
          source: "nginx",
          compressible: true,
          extensions: ["bmp"]
        },
        "image/x-pcx": {
          source: "apache",
          extensions: ["pcx"]
        },
        "image/x-pict": {
          source: "apache",
          extensions: ["pic", "pct"]
        },
        "image/x-portable-anymap": {
          source: "apache",
          extensions: ["pnm"]
        },
        "image/x-portable-bitmap": {
          source: "apache",
          extensions: ["pbm"]
        },
        "image/x-portable-graymap": {
          source: "apache",
          extensions: ["pgm"]
        },
        "image/x-portable-pixmap": {
          source: "apache",
          extensions: ["ppm"]
        },
        "image/x-rgb": {
          source: "apache",
          extensions: ["rgb"]
        },
        "image/x-tga": {
          source: "apache",
          extensions: ["tga"]
        },
        "image/x-xbitmap": {
          source: "apache",
          extensions: ["xbm"]
        },
        "image/x-xcf": {
          compressible: false
        },
        "image/x-xpixmap": {
          source: "apache",
          extensions: ["xpm"]
        },
        "image/x-xwindowdump": {
          source: "apache",
          extensions: ["xwd"]
        },
        "message/cpim": {
          source: "iana"
        },
        "message/delivery-status": {
          source: "iana"
        },
        "message/disposition-notification": {
          source: "iana",
          extensions: [
            "disposition-notification"
          ]
        },
        "message/external-body": {
          source: "iana"
        },
        "message/feedback-report": {
          source: "iana"
        },
        "message/global": {
          source: "iana",
          extensions: ["u8msg"]
        },
        "message/global-delivery-status": {
          source: "iana",
          extensions: ["u8dsn"]
        },
        "message/global-disposition-notification": {
          source: "iana",
          extensions: ["u8mdn"]
        },
        "message/global-headers": {
          source: "iana",
          extensions: ["u8hdr"]
        },
        "message/http": {
          source: "iana",
          compressible: false
        },
        "message/imdn+xml": {
          source: "iana",
          compressible: true
        },
        "message/news": {
          source: "iana"
        },
        "message/partial": {
          source: "iana",
          compressible: false
        },
        "message/rfc822": {
          source: "iana",
          compressible: true,
          extensions: ["eml", "mime"]
        },
        "message/s-http": {
          source: "iana"
        },
        "message/sip": {
          source: "iana"
        },
        "message/sipfrag": {
          source: "iana"
        },
        "message/tracking-status": {
          source: "iana"
        },
        "message/vnd.si.simp": {
          source: "iana"
        },
        "message/vnd.wfa.wsc": {
          source: "iana",
          extensions: ["wsc"]
        },
        "model/3mf": {
          source: "iana",
          extensions: ["3mf"]
        },
        "model/e57": {
          source: "iana"
        },
        "model/gltf+json": {
          source: "iana",
          compressible: true,
          extensions: ["gltf"]
        },
        "model/gltf-binary": {
          source: "iana",
          compressible: true,
          extensions: ["glb"]
        },
        "model/iges": {
          source: "iana",
          compressible: false,
          extensions: ["igs", "iges"]
        },
        "model/mesh": {
          source: "iana",
          compressible: false,
          extensions: ["msh", "mesh", "silo"]
        },
        "model/mtl": {
          source: "iana",
          extensions: ["mtl"]
        },
        "model/obj": {
          source: "iana",
          extensions: ["obj"]
        },
        "model/step": {
          source: "iana"
        },
        "model/step+xml": {
          source: "iana",
          compressible: true,
          extensions: ["stpx"]
        },
        "model/step+zip": {
          source: "iana",
          compressible: false,
          extensions: ["stpz"]
        },
        "model/step-xml+zip": {
          source: "iana",
          compressible: false,
          extensions: ["stpxz"]
        },
        "model/stl": {
          source: "iana",
          extensions: ["stl"]
        },
        "model/vnd.collada+xml": {
          source: "iana",
          compressible: true,
          extensions: ["dae"]
        },
        "model/vnd.dwf": {
          source: "iana",
          extensions: ["dwf"]
        },
        "model/vnd.flatland.3dml": {
          source: "iana"
        },
        "model/vnd.gdl": {
          source: "iana",
          extensions: ["gdl"]
        },
        "model/vnd.gs-gdl": {
          source: "apache"
        },
        "model/vnd.gs.gdl": {
          source: "iana"
        },
        "model/vnd.gtw": {
          source: "iana",
          extensions: ["gtw"]
        },
        "model/vnd.moml+xml": {
          source: "iana",
          compressible: true
        },
        "model/vnd.mts": {
          source: "iana",
          extensions: ["mts"]
        },
        "model/vnd.opengex": {
          source: "iana",
          extensions: ["ogex"]
        },
        "model/vnd.parasolid.transmit.binary": {
          source: "iana",
          extensions: ["x_b"]
        },
        "model/vnd.parasolid.transmit.text": {
          source: "iana",
          extensions: ["x_t"]
        },
        "model/vnd.pytha.pyox": {
          source: "iana"
        },
        "model/vnd.rosette.annotated-data-model": {
          source: "iana"
        },
        "model/vnd.sap.vds": {
          source: "iana",
          extensions: ["vds"]
        },
        "model/vnd.usdz+zip": {
          source: "iana",
          compressible: false,
          extensions: ["usdz"]
        },
        "model/vnd.valve.source.compiled-map": {
          source: "iana",
          extensions: ["bsp"]
        },
        "model/vnd.vtu": {
          source: "iana",
          extensions: ["vtu"]
        },
        "model/vrml": {
          source: "iana",
          compressible: false,
          extensions: ["wrl", "vrml"]
        },
        "model/x3d+binary": {
          source: "apache",
          compressible: false,
          extensions: ["x3db", "x3dbz"]
        },
        "model/x3d+fastinfoset": {
          source: "iana",
          extensions: ["x3db"]
        },
        "model/x3d+vrml": {
          source: "apache",
          compressible: false,
          extensions: ["x3dv", "x3dvz"]
        },
        "model/x3d+xml": {
          source: "iana",
          compressible: true,
          extensions: ["x3d", "x3dz"]
        },
        "model/x3d-vrml": {
          source: "iana",
          extensions: ["x3dv"]
        },
        "multipart/alternative": {
          source: "iana",
          compressible: false
        },
        "multipart/appledouble": {
          source: "iana"
        },
        "multipart/byteranges": {
          source: "iana"
        },
        "multipart/digest": {
          source: "iana"
        },
        "multipart/encrypted": {
          source: "iana",
          compressible: false
        },
        "multipart/form-data": {
          source: "iana",
          compressible: false
        },
        "multipart/header-set": {
          source: "iana"
        },
        "multipart/mixed": {
          source: "iana"
        },
        "multipart/multilingual": {
          source: "iana"
        },
        "multipart/parallel": {
          source: "iana"
        },
        "multipart/related": {
          source: "iana",
          compressible: false
        },
        "multipart/report": {
          source: "iana"
        },
        "multipart/signed": {
          source: "iana",
          compressible: false
        },
        "multipart/vnd.bint.med-plus": {
          source: "iana"
        },
        "multipart/voice-message": {
          source: "iana"
        },
        "multipart/x-mixed-replace": {
          source: "iana"
        },
        "text/1d-interleaved-parityfec": {
          source: "iana"
        },
        "text/cache-manifest": {
          source: "iana",
          compressible: true,
          extensions: ["appcache", "manifest"]
        },
        "text/calendar": {
          source: "iana",
          extensions: ["ics", "ifb"]
        },
        "text/calender": {
          compressible: true
        },
        "text/cmd": {
          compressible: true
        },
        "text/coffeescript": {
          extensions: ["coffee", "litcoffee"]
        },
        "text/cql": {
          source: "iana"
        },
        "text/cql-expression": {
          source: "iana"
        },
        "text/cql-identifier": {
          source: "iana"
        },
        "text/css": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["css"]
        },
        "text/csv": {
          source: "iana",
          compressible: true,
          extensions: ["csv"]
        },
        "text/csv-schema": {
          source: "iana"
        },
        "text/directory": {
          source: "iana"
        },
        "text/dns": {
          source: "iana"
        },
        "text/ecmascript": {
          source: "iana"
        },
        "text/encaprtp": {
          source: "iana"
        },
        "text/enriched": {
          source: "iana"
        },
        "text/fhirpath": {
          source: "iana"
        },
        "text/flexfec": {
          source: "iana"
        },
        "text/fwdred": {
          source: "iana"
        },
        "text/gff3": {
          source: "iana"
        },
        "text/grammar-ref-list": {
          source: "iana"
        },
        "text/html": {
          source: "iana",
          compressible: true,
          extensions: ["html", "htm", "shtml"]
        },
        "text/jade": {
          extensions: ["jade"]
        },
        "text/javascript": {
          source: "iana",
          compressible: true
        },
        "text/jcr-cnd": {
          source: "iana"
        },
        "text/jsx": {
          compressible: true,
          extensions: ["jsx"]
        },
        "text/less": {
          compressible: true,
          extensions: ["less"]
        },
        "text/markdown": {
          source: "iana",
          compressible: true,
          extensions: ["markdown", "md"]
        },
        "text/mathml": {
          source: "nginx",
          extensions: ["mml"]
        },
        "text/mdx": {
          compressible: true,
          extensions: ["mdx"]
        },
        "text/mizar": {
          source: "iana"
        },
        "text/n3": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["n3"]
        },
        "text/parameters": {
          source: "iana",
          charset: "UTF-8"
        },
        "text/parityfec": {
          source: "iana"
        },
        "text/plain": {
          source: "iana",
          compressible: true,
          extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
        },
        "text/provenance-notation": {
          source: "iana",
          charset: "UTF-8"
        },
        "text/prs.fallenstein.rst": {
          source: "iana"
        },
        "text/prs.lines.tag": {
          source: "iana",
          extensions: ["dsc"]
        },
        "text/prs.prop.logic": {
          source: "iana"
        },
        "text/raptorfec": {
          source: "iana"
        },
        "text/red": {
          source: "iana"
        },
        "text/rfc822-headers": {
          source: "iana"
        },
        "text/richtext": {
          source: "iana",
          compressible: true,
          extensions: ["rtx"]
        },
        "text/rtf": {
          source: "iana",
          compressible: true,
          extensions: ["rtf"]
        },
        "text/rtp-enc-aescm128": {
          source: "iana"
        },
        "text/rtploopback": {
          source: "iana"
        },
        "text/rtx": {
          source: "iana"
        },
        "text/sgml": {
          source: "iana",
          extensions: ["sgml", "sgm"]
        },
        "text/shaclc": {
          source: "iana"
        },
        "text/shex": {
          source: "iana",
          extensions: ["shex"]
        },
        "text/slim": {
          extensions: ["slim", "slm"]
        },
        "text/spdx": {
          source: "iana",
          extensions: ["spdx"]
        },
        "text/strings": {
          source: "iana"
        },
        "text/stylus": {
          extensions: ["stylus", "styl"]
        },
        "text/t140": {
          source: "iana"
        },
        "text/tab-separated-values": {
          source: "iana",
          compressible: true,
          extensions: ["tsv"]
        },
        "text/troff": {
          source: "iana",
          extensions: ["t", "tr", "roff", "man", "me", "ms"]
        },
        "text/turtle": {
          source: "iana",
          charset: "UTF-8",
          extensions: ["ttl"]
        },
        "text/ulpfec": {
          source: "iana"
        },
        "text/uri-list": {
          source: "iana",
          compressible: true,
          extensions: ["uri", "uris", "urls"]
        },
        "text/vcard": {
          source: "iana",
          compressible: true,
          extensions: ["vcard"]
        },
        "text/vnd.a": {
          source: "iana"
        },
        "text/vnd.abc": {
          source: "iana"
        },
        "text/vnd.ascii-art": {
          source: "iana"
        },
        "text/vnd.curl": {
          source: "iana",
          extensions: ["curl"]
        },
        "text/vnd.curl.dcurl": {
          source: "apache",
          extensions: ["dcurl"]
        },
        "text/vnd.curl.mcurl": {
          source: "apache",
          extensions: ["mcurl"]
        },
        "text/vnd.curl.scurl": {
          source: "apache",
          extensions: ["scurl"]
        },
        "text/vnd.debian.copyright": {
          source: "iana",
          charset: "UTF-8"
        },
        "text/vnd.dmclientscript": {
          source: "iana"
        },
        "text/vnd.dvb.subtitle": {
          source: "iana",
          extensions: ["sub"]
        },
        "text/vnd.esmertec.theme-descriptor": {
          source: "iana",
          charset: "UTF-8"
        },
        "text/vnd.familysearch.gedcom": {
          source: "iana",
          extensions: ["ged"]
        },
        "text/vnd.ficlab.flt": {
          source: "iana"
        },
        "text/vnd.fly": {
          source: "iana",
          extensions: ["fly"]
        },
        "text/vnd.fmi.flexstor": {
          source: "iana",
          extensions: ["flx"]
        },
        "text/vnd.gml": {
          source: "iana"
        },
        "text/vnd.graphviz": {
          source: "iana",
          extensions: ["gv"]
        },
        "text/vnd.hans": {
          source: "iana"
        },
        "text/vnd.hgl": {
          source: "iana"
        },
        "text/vnd.in3d.3dml": {
          source: "iana",
          extensions: ["3dml"]
        },
        "text/vnd.in3d.spot": {
          source: "iana",
          extensions: ["spot"]
        },
        "text/vnd.iptc.newsml": {
          source: "iana"
        },
        "text/vnd.iptc.nitf": {
          source: "iana"
        },
        "text/vnd.latex-z": {
          source: "iana"
        },
        "text/vnd.motorola.reflex": {
          source: "iana"
        },
        "text/vnd.ms-mediapackage": {
          source: "iana"
        },
        "text/vnd.net2phone.commcenter.command": {
          source: "iana"
        },
        "text/vnd.radisys.msml-basic-layout": {
          source: "iana"
        },
        "text/vnd.senx.warpscript": {
          source: "iana"
        },
        "text/vnd.si.uricatalogue": {
          source: "iana"
        },
        "text/vnd.sosi": {
          source: "iana"
        },
        "text/vnd.sun.j2me.app-descriptor": {
          source: "iana",
          charset: "UTF-8",
          extensions: ["jad"]
        },
        "text/vnd.trolltech.linguist": {
          source: "iana",
          charset: "UTF-8"
        },
        "text/vnd.wap.si": {
          source: "iana"
        },
        "text/vnd.wap.sl": {
          source: "iana"
        },
        "text/vnd.wap.wml": {
          source: "iana",
          extensions: ["wml"]
        },
        "text/vnd.wap.wmlscript": {
          source: "iana",
          extensions: ["wmls"]
        },
        "text/vtt": {
          source: "iana",
          charset: "UTF-8",
          compressible: true,
          extensions: ["vtt"]
        },
        "text/x-asm": {
          source: "apache",
          extensions: ["s", "asm"]
        },
        "text/x-c": {
          source: "apache",
          extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
        },
        "text/x-component": {
          source: "nginx",
          extensions: ["htc"]
        },
        "text/x-fortran": {
          source: "apache",
          extensions: ["f", "for", "f77", "f90"]
        },
        "text/x-gwt-rpc": {
          compressible: true
        },
        "text/x-handlebars-template": {
          extensions: ["hbs"]
        },
        "text/x-java-source": {
          source: "apache",
          extensions: ["java"]
        },
        "text/x-jquery-tmpl": {
          compressible: true
        },
        "text/x-lua": {
          extensions: ["lua"]
        },
        "text/x-markdown": {
          compressible: true,
          extensions: ["mkd"]
        },
        "text/x-nfo": {
          source: "apache",
          extensions: ["nfo"]
        },
        "text/x-opml": {
          source: "apache",
          extensions: ["opml"]
        },
        "text/x-org": {
          compressible: true,
          extensions: ["org"]
        },
        "text/x-pascal": {
          source: "apache",
          extensions: ["p", "pas"]
        },
        "text/x-processing": {
          compressible: true,
          extensions: ["pde"]
        },
        "text/x-sass": {
          extensions: ["sass"]
        },
        "text/x-scss": {
          extensions: ["scss"]
        },
        "text/x-setext": {
          source: "apache",
          extensions: ["etx"]
        },
        "text/x-sfv": {
          source: "apache",
          extensions: ["sfv"]
        },
        "text/x-suse-ymp": {
          compressible: true,
          extensions: ["ymp"]
        },
        "text/x-uuencode": {
          source: "apache",
          extensions: ["uu"]
        },
        "text/x-vcalendar": {
          source: "apache",
          extensions: ["vcs"]
        },
        "text/x-vcard": {
          source: "apache",
          extensions: ["vcf"]
        },
        "text/xml": {
          source: "iana",
          compressible: true,
          extensions: ["xml"]
        },
        "text/xml-external-parsed-entity": {
          source: "iana"
        },
        "text/yaml": {
          compressible: true,
          extensions: ["yaml", "yml"]
        },
        "video/1d-interleaved-parityfec": {
          source: "iana"
        },
        "video/3gpp": {
          source: "iana",
          extensions: ["3gp", "3gpp"]
        },
        "video/3gpp-tt": {
          source: "iana"
        },
        "video/3gpp2": {
          source: "iana",
          extensions: ["3g2"]
        },
        "video/av1": {
          source: "iana"
        },
        "video/bmpeg": {
          source: "iana"
        },
        "video/bt656": {
          source: "iana"
        },
        "video/celb": {
          source: "iana"
        },
        "video/dv": {
          source: "iana"
        },
        "video/encaprtp": {
          source: "iana"
        },
        "video/ffv1": {
          source: "iana"
        },
        "video/flexfec": {
          source: "iana"
        },
        "video/h261": {
          source: "iana",
          extensions: ["h261"]
        },
        "video/h263": {
          source: "iana",
          extensions: ["h263"]
        },
        "video/h263-1998": {
          source: "iana"
        },
        "video/h263-2000": {
          source: "iana"
        },
        "video/h264": {
          source: "iana",
          extensions: ["h264"]
        },
        "video/h264-rcdo": {
          source: "iana"
        },
        "video/h264-svc": {
          source: "iana"
        },
        "video/h265": {
          source: "iana"
        },
        "video/iso.segment": {
          source: "iana",
          extensions: ["m4s"]
        },
        "video/jpeg": {
          source: "iana",
          extensions: ["jpgv"]
        },
        "video/jpeg2000": {
          source: "iana"
        },
        "video/jpm": {
          source: "apache",
          extensions: ["jpm", "jpgm"]
        },
        "video/jxsv": {
          source: "iana"
        },
        "video/mj2": {
          source: "iana",
          extensions: ["mj2", "mjp2"]
        },
        "video/mp1s": {
          source: "iana"
        },
        "video/mp2p": {
          source: "iana"
        },
        "video/mp2t": {
          source: "iana",
          extensions: ["ts"]
        },
        "video/mp4": {
          source: "iana",
          compressible: false,
          extensions: ["mp4", "mp4v", "mpg4"]
        },
        "video/mp4v-es": {
          source: "iana"
        },
        "video/mpeg": {
          source: "iana",
          compressible: false,
          extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
        },
        "video/mpeg4-generic": {
          source: "iana"
        },
        "video/mpv": {
          source: "iana"
        },
        "video/nv": {
          source: "iana"
        },
        "video/ogg": {
          source: "iana",
          compressible: false,
          extensions: ["ogv"]
        },
        "video/parityfec": {
          source: "iana"
        },
        "video/pointer": {
          source: "iana"
        },
        "video/quicktime": {
          source: "iana",
          compressible: false,
          extensions: ["qt", "mov"]
        },
        "video/raptorfec": {
          source: "iana"
        },
        "video/raw": {
          source: "iana"
        },
        "video/rtp-enc-aescm128": {
          source: "iana"
        },
        "video/rtploopback": {
          source: "iana"
        },
        "video/rtx": {
          source: "iana"
        },
        "video/scip": {
          source: "iana"
        },
        "video/smpte291": {
          source: "iana"
        },
        "video/smpte292m": {
          source: "iana"
        },
        "video/ulpfec": {
          source: "iana"
        },
        "video/vc1": {
          source: "iana"
        },
        "video/vc2": {
          source: "iana"
        },
        "video/vnd.cctv": {
          source: "iana"
        },
        "video/vnd.dece.hd": {
          source: "iana",
          extensions: ["uvh", "uvvh"]
        },
        "video/vnd.dece.mobile": {
          source: "iana",
          extensions: ["uvm", "uvvm"]
        },
        "video/vnd.dece.mp4": {
          source: "iana"
        },
        "video/vnd.dece.pd": {
          source: "iana",
          extensions: ["uvp", "uvvp"]
        },
        "video/vnd.dece.sd": {
          source: "iana",
          extensions: ["uvs", "uvvs"]
        },
        "video/vnd.dece.video": {
          source: "iana",
          extensions: ["uvv", "uvvv"]
        },
        "video/vnd.directv.mpeg": {
          source: "iana"
        },
        "video/vnd.directv.mpeg-tts": {
          source: "iana"
        },
        "video/vnd.dlna.mpeg-tts": {
          source: "iana"
        },
        "video/vnd.dvb.file": {
          source: "iana",
          extensions: ["dvb"]
        },
        "video/vnd.fvt": {
          source: "iana",
          extensions: ["fvt"]
        },
        "video/vnd.hns.video": {
          source: "iana"
        },
        "video/vnd.iptvforum.1dparityfec-1010": {
          source: "iana"
        },
        "video/vnd.iptvforum.1dparityfec-2005": {
          source: "iana"
        },
        "video/vnd.iptvforum.2dparityfec-1010": {
          source: "iana"
        },
        "video/vnd.iptvforum.2dparityfec-2005": {
          source: "iana"
        },
        "video/vnd.iptvforum.ttsavc": {
          source: "iana"
        },
        "video/vnd.iptvforum.ttsmpeg2": {
          source: "iana"
        },
        "video/vnd.motorola.video": {
          source: "iana"
        },
        "video/vnd.motorola.videop": {
          source: "iana"
        },
        "video/vnd.mpegurl": {
          source: "iana",
          extensions: ["mxu", "m4u"]
        },
        "video/vnd.ms-playready.media.pyv": {
          source: "iana",
          extensions: ["pyv"]
        },
        "video/vnd.nokia.interleaved-multimedia": {
          source: "iana"
        },
        "video/vnd.nokia.mp4vr": {
          source: "iana"
        },
        "video/vnd.nokia.videovoip": {
          source: "iana"
        },
        "video/vnd.objectvideo": {
          source: "iana"
        },
        "video/vnd.radgamettools.bink": {
          source: "iana"
        },
        "video/vnd.radgamettools.smacker": {
          source: "iana"
        },
        "video/vnd.sealed.mpeg1": {
          source: "iana"
        },
        "video/vnd.sealed.mpeg4": {
          source: "iana"
        },
        "video/vnd.sealed.swf": {
          source: "iana"
        },
        "video/vnd.sealedmedia.softseal.mov": {
          source: "iana"
        },
        "video/vnd.uvvu.mp4": {
          source: "iana",
          extensions: ["uvu", "uvvu"]
        },
        "video/vnd.vivo": {
          source: "iana",
          extensions: ["viv"]
        },
        "video/vnd.youtube.yt": {
          source: "iana"
        },
        "video/vp8": {
          source: "iana"
        },
        "video/vp9": {
          source: "iana"
        },
        "video/webm": {
          source: "apache",
          compressible: false,
          extensions: ["webm"]
        },
        "video/x-f4v": {
          source: "apache",
          extensions: ["f4v"]
        },
        "video/x-fli": {
          source: "apache",
          extensions: ["fli"]
        },
        "video/x-flv": {
          source: "apache",
          compressible: false,
          extensions: ["flv"]
        },
        "video/x-m4v": {
          source: "apache",
          extensions: ["m4v"]
        },
        "video/x-matroska": {
          source: "apache",
          compressible: false,
          extensions: ["mkv", "mk3d", "mks"]
        },
        "video/x-mng": {
          source: "apache",
          extensions: ["mng"]
        },
        "video/x-ms-asf": {
          source: "apache",
          extensions: ["asf", "asx"]
        },
        "video/x-ms-vob": {
          source: "apache",
          extensions: ["vob"]
        },
        "video/x-ms-wm": {
          source: "apache",
          extensions: ["wm"]
        },
        "video/x-ms-wmv": {
          source: "apache",
          compressible: false,
          extensions: ["wmv"]
        },
        "video/x-ms-wmx": {
          source: "apache",
          extensions: ["wmx"]
        },
        "video/x-ms-wvx": {
          source: "apache",
          extensions: ["wvx"]
        },
        "video/x-msvideo": {
          source: "apache",
          extensions: ["avi"]
        },
        "video/x-sgi-movie": {
          source: "apache",
          extensions: ["movie"]
        },
        "video/x-smv": {
          source: "apache",
          extensions: ["smv"]
        },
        "x-conference/x-cooltalk": {
          source: "apache",
          extensions: ["ice"]
        },
        "x-shader/x-fragment": {
          compressible: true
        },
        "x-shader/x-vertex": {
          compressible: true
        }
      };
    }
  });

  // ../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js
  var require_mime_db = __commonJS({
    "../../node_modules/.pnpm/mime-db@1.52.0/node_modules/mime-db/index.js"(exports, module2) {
      module2.exports = require_db();
    }
  });

  // ../../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js
  var require_mime_types = __commonJS({
    "../../node_modules/.pnpm/mime-types@2.1.35/node_modules/mime-types/index.js"(exports) {
      "use strict";
      var db = require_mime_db();
      var extname = __require2("path").extname;
      var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
      var TEXT_TYPE_REGEXP = /^text\//i;
      exports.charset = charset;
      exports.charsets = { lookup: charset };
      exports.contentType = contentType;
      exports.extension = extension;
      exports.extensions = /* @__PURE__ */ Object.create(null);
      exports.lookup = lookup;
      exports.types = /* @__PURE__ */ Object.create(null);
      populateMaps(exports.extensions, exports.types);
      function charset(type3) {
        if (!type3 || typeof type3 !== "string") {
          return false;
        }
        var match3 = EXTRACT_TYPE_REGEXP.exec(type3);
        var mime = match3 && db[match3[1].toLowerCase()];
        if (mime && mime.charset) {
          return mime.charset;
        }
        if (match3 && TEXT_TYPE_REGEXP.test(match3[1])) {
          return "UTF-8";
        }
        return false;
      }
      function contentType(str) {
        if (!str || typeof str !== "string") {
          return false;
        }
        var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
        if (!mime) {
          return false;
        }
        if (mime.indexOf("charset") === -1) {
          var charset2 = exports.charset(mime);
          if (charset2)
            mime += "; charset=" + charset2.toLowerCase();
        }
        return mime;
      }
      function extension(type3) {
        if (!type3 || typeof type3 !== "string") {
          return false;
        }
        var match3 = EXTRACT_TYPE_REGEXP.exec(type3);
        var exts = match3 && exports.extensions[match3[1].toLowerCase()];
        if (!exts || !exts.length) {
          return false;
        }
        return exts[0];
      }
      function lookup(path4) {
        if (!path4 || typeof path4 !== "string") {
          return false;
        }
        var extension2 = extname("x." + path4).toLowerCase().substr(1);
        if (!extension2) {
          return false;
        }
        return exports.types[extension2] || false;
      }
      function populateMaps(extensions, types2) {
        var preference = ["nginx", "apache", void 0, "iana"];
        Object.keys(db).forEach(function forEachMimeType(type3) {
          var mime = db[type3];
          var exts = mime.extensions;
          if (!exts || !exts.length) {
            return;
          }
          extensions[type3] = exts;
          for (var i = 0; i < exts.length; i++) {
            var extension2 = exts[i];
            if (types2[extension2]) {
              var from = preference.indexOf(db[types2[extension2]].source);
              var to = preference.indexOf(mime.source);
              if (types2[extension2] !== "application/octet-stream" && (from > to || from === to && types2[extension2].substr(0, 12) === "application/")) {
                continue;
              }
            }
            types2[extension2] = type3;
          }
        });
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js
  var require_defer = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/defer.js"(exports, module2) {
      module2.exports = defer2;
      function defer2(fn) {
        var nextTick = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
        if (nextTick) {
          nextTick(fn);
        } else {
          setTimeout(fn, 0);
        }
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js
  var require_async = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/async.js"(exports, module2) {
      var defer2 = require_defer();
      module2.exports = async;
      function async(callback) {
        var isAsync = false;
        defer2(function() {
          isAsync = true;
        });
        return function async_callback(err, result) {
          if (isAsync) {
            callback(err, result);
          } else {
            defer2(function nextTick_callback() {
              callback(err, result);
            });
          }
        };
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js
  var require_abort = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/abort.js"(exports, module2) {
      module2.exports = abort;
      function abort(state) {
        Object.keys(state.jobs).forEach(clean.bind(state));
        state.jobs = {};
      }
      function clean(key) {
        if (typeof this.jobs[key] == "function") {
          this.jobs[key]();
        }
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js
  var require_iterate = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/iterate.js"(exports, module2) {
      var async = require_async();
      var abort = require_abort();
      module2.exports = iterate2;
      function iterate2(list, iterator, state, callback) {
        var key = state["keyedList"] ? state["keyedList"][state.index] : state.index;
        state.jobs[key] = runJob(iterator, key, list[key], function(error2, output3) {
          if (!(key in state.jobs)) {
            return;
          }
          delete state.jobs[key];
          if (error2) {
            abort(state);
          } else {
            state.results[key] = output3;
          }
          callback(error2, state.results);
        });
      }
      function runJob(iterator, key, item, callback) {
        var aborter;
        if (iterator.length == 2) {
          aborter = iterator(item, async(callback));
        } else {
          aborter = iterator(item, key, async(callback));
        }
        return aborter;
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js
  var require_state = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/state.js"(exports, module2) {
      module2.exports = state;
      function state(list, sortMethod) {
        var isNamedList = !Array.isArray(list), initState = {
          index: 0,
          keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
          jobs: {},
          results: isNamedList ? {} : [],
          size: isNamedList ? Object.keys(list).length : list.length
        };
        if (sortMethod) {
          initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
            return sortMethod(list[a], list[b]);
          });
        }
        return initState;
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js
  var require_terminator = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/lib/terminator.js"(exports, module2) {
      var abort = require_abort();
      var async = require_async();
      module2.exports = terminator;
      function terminator(callback) {
        if (!Object.keys(this.jobs).length) {
          return;
        }
        this.index = this.size;
        abort(this);
        async(callback)(null, this.results);
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js
  var require_parallel = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/parallel.js"(exports, module2) {
      var iterate2 = require_iterate();
      var initState = require_state();
      var terminator = require_terminator();
      module2.exports = parallel;
      function parallel(list, iterator, callback) {
        var state = initState(list);
        while (state.index < (state["keyedList"] || list).length) {
          iterate2(list, iterator, state, function(error2, result) {
            if (error2) {
              callback(error2, result);
              return;
            }
            if (Object.keys(state.jobs).length === 0) {
              callback(null, state.results);
              return;
            }
          });
          state.index++;
        }
        return terminator.bind(state, callback);
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js
  var require_serialOrdered = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serialOrdered.js"(exports, module2) {
      var iterate2 = require_iterate();
      var initState = require_state();
      var terminator = require_terminator();
      module2.exports = serialOrdered;
      module2.exports.ascending = ascending;
      module2.exports.descending = descending;
      function serialOrdered(list, iterator, sortMethod, callback) {
        var state = initState(list, sortMethod);
        iterate2(list, iterator, state, function iteratorHandler(error2, result) {
          if (error2) {
            callback(error2, result);
            return;
          }
          state.index++;
          if (state.index < (state["keyedList"] || list).length) {
            iterate2(list, iterator, state, iteratorHandler);
            return;
          }
          callback(null, state.results);
        });
        return terminator.bind(state, callback);
      }
      function ascending(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }
      function descending(a, b) {
        return -1 * ascending(a, b);
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js
  var require_serial = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/serial.js"(exports, module2) {
      var serialOrdered = require_serialOrdered();
      module2.exports = serial;
      function serial(list, iterator, callback) {
        return serialOrdered(list, iterator, null, callback);
      }
    }
  });

  // ../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js
  var require_asynckit = __commonJS({
    "../../node_modules/.pnpm/asynckit@0.4.0/node_modules/asynckit/index.js"(exports, module2) {
      module2.exports = {
        parallel: require_parallel(),
        serial: require_serial(),
        serialOrdered: require_serialOrdered()
      };
    }
  });

  // ../../node_modules/.pnpm/form-data@3.0.1/node_modules/form-data/lib/populate.js
  var require_populate = __commonJS({
    "../../node_modules/.pnpm/form-data@3.0.1/node_modules/form-data/lib/populate.js"(exports, module2) {
      module2.exports = function(dst, src) {
        Object.keys(src).forEach(function(prop) {
          dst[prop] = dst[prop] || src[prop];
        });
        return dst;
      };
    }
  });

  // ../../node_modules/.pnpm/form-data@3.0.1/node_modules/form-data/lib/form_data.js
  var require_form_data = __commonJS({
    "../../node_modules/.pnpm/form-data@3.0.1/node_modules/form-data/lib/form_data.js"(exports, module2) {
      var CombinedStream = require_combined_stream();
      var util = __require2("util");
      var path4 = __require2("path");
      var http2 = __require2("http");
      var https2 = __require2("https");
      var parseUrl = __require2("url").parse;
      var fs4 = __require2("fs");
      var mime = require_mime_types();
      var asynckit = require_asynckit();
      var populate = require_populate();
      module2.exports = FormData2;
      util.inherits(FormData2, CombinedStream);
      function FormData2(options) {
        if (!(this instanceof FormData2)) {
          return new FormData2(options);
        }
        this._overheadLength = 0;
        this._valueLength = 0;
        this._valuesToMeasure = [];
        CombinedStream.call(this);
        options = options || {};
        for (var option in options) {
          this[option] = options[option];
        }
      }
      FormData2.LINE_BREAK = "\r\n";
      FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
      FormData2.prototype.append = function(field, value, options) {
        options = options || {};
        if (typeof options == "string") {
          options = { filename: options };
        }
        var append = CombinedStream.prototype.append.bind(this);
        if (typeof value == "number") {
          value = "" + value;
        }
        if (util.isArray(value)) {
          this._error(new Error("Arrays are not supported."));
          return;
        }
        var header = this._multiPartHeader(field, value, options);
        var footer = this._multiPartFooter();
        append(header);
        append(value);
        append(footer);
        this._trackLength(header, value, options);
      };
      FormData2.prototype._trackLength = function(header, value, options) {
        var valueLength = 0;
        if (options.knownLength != null) {
          valueLength += +options.knownLength;
        } else if (Buffer.isBuffer(value)) {
          valueLength = value.length;
        } else if (typeof value === "string") {
          valueLength = Buffer.byteLength(value);
        }
        this._valueLength += valueLength;
        this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
        if (!value || !value.path && !(value.readable && value.hasOwnProperty("httpVersion"))) {
          return;
        }
        if (!options.knownLength) {
          this._valuesToMeasure.push(value);
        }
      };
      FormData2.prototype._lengthRetriever = function(value, callback) {
        if (value.hasOwnProperty("fd")) {
          if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
            callback(null, value.end + 1 - (value.start ? value.start : 0));
          } else {
            fs4.stat(value.path, function(err, stat) {
              var fileSize;
              if (err) {
                callback(err);
                return;
              }
              fileSize = stat.size - (value.start ? value.start : 0);
              callback(null, fileSize);
            });
          }
        } else if (value.hasOwnProperty("httpVersion")) {
          callback(null, +value.headers["content-length"]);
        } else if (value.hasOwnProperty("httpModule")) {
          value.on("response", function(response) {
            value.pause();
            callback(null, +response.headers["content-length"]);
          });
          value.resume();
        } else {
          callback("Unknown stream");
        }
      };
      FormData2.prototype._multiPartHeader = function(field, value, options) {
        if (typeof options.header == "string") {
          return options.header;
        }
        var contentDisposition = this._getContentDisposition(value, options);
        var contentType = this._getContentType(value, options);
        var contents = "";
        var headers = {
          // add custom disposition as third element or keep it two elements if not
          "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
          // if no content type. allow it to be empty array
          "Content-Type": [].concat(contentType || [])
        };
        if (typeof options.header == "object") {
          populate(headers, options.header);
        }
        var header;
        for (var prop in headers) {
          if (!headers.hasOwnProperty(prop))
            continue;
          header = headers[prop];
          if (header == null) {
            continue;
          }
          if (!Array.isArray(header)) {
            header = [header];
          }
          if (header.length) {
            contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
          }
        }
        return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
      };
      FormData2.prototype._getContentDisposition = function(value, options) {
        var filename, contentDisposition;
        if (typeof options.filepath === "string") {
          filename = path4.normalize(options.filepath).replace(/\\/g, "/");
        } else if (options.filename || value.name || value.path) {
          filename = path4.basename(options.filename || value.name || value.path);
        } else if (value.readable && value.hasOwnProperty("httpVersion")) {
          filename = path4.basename(value.client._httpMessage.path || "");
        }
        if (filename) {
          contentDisposition = 'filename="' + filename + '"';
        }
        return contentDisposition;
      };
      FormData2.prototype._getContentType = function(value, options) {
        var contentType = options.contentType;
        if (!contentType && value.name) {
          contentType = mime.lookup(value.name);
        }
        if (!contentType && value.path) {
          contentType = mime.lookup(value.path);
        }
        if (!contentType && value.readable && value.hasOwnProperty("httpVersion")) {
          contentType = value.headers["content-type"];
        }
        if (!contentType && (options.filepath || options.filename)) {
          contentType = mime.lookup(options.filepath || options.filename);
        }
        if (!contentType && typeof value == "object") {
          contentType = FormData2.DEFAULT_CONTENT_TYPE;
        }
        return contentType;
      };
      FormData2.prototype._multiPartFooter = function() {
        return function(next) {
          var footer = FormData2.LINE_BREAK;
          var lastPart = this._streams.length === 0;
          if (lastPart) {
            footer += this._lastBoundary();
          }
          next(footer);
        }.bind(this);
      };
      FormData2.prototype._lastBoundary = function() {
        return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
      };
      FormData2.prototype.getHeaders = function(userHeaders) {
        var header;
        var formHeaders = {
          "content-type": "multipart/form-data; boundary=" + this.getBoundary()
        };
        for (header in userHeaders) {
          if (userHeaders.hasOwnProperty(header)) {
            formHeaders[header.toLowerCase()] = userHeaders[header];
          }
        }
        return formHeaders;
      };
      FormData2.prototype.setBoundary = function(boundary) {
        this._boundary = boundary;
      };
      FormData2.prototype.getBoundary = function() {
        if (!this._boundary) {
          this._generateBoundary();
        }
        return this._boundary;
      };
      FormData2.prototype.getBuffer = function() {
        var dataBuffer = new Buffer.alloc(0);
        var boundary = this.getBoundary();
        for (var i = 0, len = this._streams.length; i < len; i++) {
          if (typeof this._streams[i] !== "function") {
            if (Buffer.isBuffer(this._streams[i])) {
              dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
            } else {
              dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
            }
            if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
              dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
            }
          }
        }
        return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
      };
      FormData2.prototype._generateBoundary = function() {
        var boundary = "--------------------------";
        for (var i = 0; i < 24; i++) {
          boundary += Math.floor(Math.random() * 10).toString(16);
        }
        this._boundary = boundary;
      };
      FormData2.prototype.getLengthSync = function() {
        var knownLength = this._overheadLength + this._valueLength;
        if (this._streams.length) {
          knownLength += this._lastBoundary().length;
        }
        if (!this.hasKnownLength()) {
          this._error(new Error("Cannot calculate proper length in synchronous way."));
        }
        return knownLength;
      };
      FormData2.prototype.hasKnownLength = function() {
        var hasKnownLength = true;
        if (this._valuesToMeasure.length) {
          hasKnownLength = false;
        }
        return hasKnownLength;
      };
      FormData2.prototype.getLength = function(cb) {
        var knownLength = this._overheadLength + this._valueLength;
        if (this._streams.length) {
          knownLength += this._lastBoundary().length;
        }
        if (!this._valuesToMeasure.length) {
          process.nextTick(cb.bind(this, null, knownLength));
          return;
        }
        asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
          if (err) {
            cb(err);
            return;
          }
          values.forEach(function(length) {
            knownLength += length;
          });
          cb(null, knownLength);
        });
      };
      FormData2.prototype.submit = function(params, cb) {
        var request, options, defaults2 = { method: "post" };
        if (typeof params == "string") {
          params = parseUrl(params);
          options = populate({
            port: params.port,
            path: params.pathname,
            host: params.hostname,
            protocol: params.protocol
          }, defaults2);
        } else {
          options = populate(params, defaults2);
          if (!options.port) {
            options.port = options.protocol == "https:" ? 443 : 80;
          }
        }
        options.headers = this.getHeaders(params.headers);
        if (options.protocol == "https:") {
          request = https2.request(options);
        } else {
          request = http2.request(options);
        }
        this.getLength(function(err, length) {
          if (err) {
            this._error(err);
            return;
          }
          request.setHeader("Content-Length", length);
          this.pipe(request);
          if (cb) {
            var onResponse;
            var callback = function(error2, responce) {
              request.removeListener("error", callback);
              request.removeListener("response", onResponse);
              return cb.call(this, error2, responce);
            };
            onResponse = callback.bind(this, null);
            request.on("error", callback);
            request.on("response", onResponse);
          }
        }.bind(this));
        return request;
      };
      FormData2.prototype._error = function(err) {
        if (!this.error) {
          this.error = err;
          this.pause();
          this.emit("error", err);
        }
      };
      FormData2.prototype.toString = function() {
        return "[object FormData]";
      };
    }
  });

  // ../../node_modules/.pnpm/graphql-request@5.0.0_graphql@16.6.0/node_modules/graphql-request/dist/defaultJsonSerializer.js
  var require_defaultJsonSerializer = __commonJS({
    "../../node_modules/.pnpm/graphql-request@5.0.0_graphql@16.6.0/node_modules/graphql-request/dist/defaultJsonSerializer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.defaultJsonSerializer = void 0;
      exports.defaultJsonSerializer = {
        parse: JSON.parse,
        stringify: JSON.stringify
      };
    }
  });

  // ../../node_modules/.pnpm/graphql-request@5.0.0_graphql@16.6.0/node_modules/graphql-request/dist/createRequestBody.js
  var require_createRequestBody = __commonJS({
    "../../node_modules/.pnpm/graphql-request@5.0.0_graphql@16.6.0/node_modules/graphql-request/dist/createRequestBody.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var extract_files_1 = require_public();
      var form_data_1 = __importDefault(require_form_data());
      var defaultJsonSerializer_1 = require_defaultJsonSerializer();
      var isExtractableFileEnhanced = function(value) {
        return extract_files_1.isExtractableFile(value) || value !== null && typeof value === "object" && typeof value.pipe === "function";
      };
      function createRequestBody(query, variables, operationName, jsonSerializer) {
        if (jsonSerializer === void 0) {
          jsonSerializer = defaultJsonSerializer_1.defaultJsonSerializer;
        }
        var _a = extract_files_1.extractFiles({ query, variables, operationName }, "", isExtractableFileEnhanced), clone5 = _a.clone, files = _a.files;
        if (files.size === 0) {
          if (!Array.isArray(query)) {
            return jsonSerializer.stringify(clone5);
          }
          if (typeof variables !== "undefined" && !Array.isArray(variables)) {
            throw new Error("Cannot create request body with given variable type, array expected");
          }
          var payload = query.reduce(function(accu, currentQuery, index) {
            accu.push({ query: currentQuery, variables: variables ? variables[index] : void 0 });
            return accu;
          }, []);
          return jsonSerializer.stringify(payload);
        }
        var Form = typeof FormData === "undefined" ? form_data_1.default : FormData;
        var form = new Form();
        form.append("operations", jsonSerializer.stringify(clone5));
        var map2 = {};
        var i = 0;
        files.forEach(function(paths) {
          map2[++i] = paths;
        });
        form.append("map", jsonSerializer.stringify(map2));
        i = 0;
        files.forEach(function(paths, file) {
          form.append("" + ++i, file);
        });
        return form;
      }
      exports.default = createRequestBody;
    }
  });

  // ../../node_modules/.pnpm/graphql-request@5.0.0_graphql@16.6.0/node_modules/graphql-request/dist/parseArgs.js
  var require_parseArgs = __commonJS({
    "../../node_modules/.pnpm/graphql-request@5.0.0_graphql@16.6.0/node_modules/graphql-request/dist/parseArgs.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parseBatchRequestsExtendedArgs = exports.parseRawRequestExtendedArgs = exports.parseRequestExtendedArgs = exports.parseBatchRequestArgs = exports.parseRawRequestArgs = exports.parseRequestArgs = void 0;
      function parseRequestArgs(documentOrOptions, variables, requestHeaders) {
        return documentOrOptions.document ? documentOrOptions : {
          document: documentOrOptions,
          variables,
          requestHeaders,
          signal: void 0
        };
      }
      exports.parseRequestArgs = parseRequestArgs;
      function parseRawRequestArgs(queryOrOptions, variables, requestHeaders) {
        return queryOrOptions.query ? queryOrOptions : {
          query: queryOrOptions,
          variables,
          requestHeaders,
          signal: void 0
        };
      }
      exports.parseRawRequestArgs = parseRawRequestArgs;
      function parseBatchRequestArgs(documentsOrOptions, requestHeaders) {
        return documentsOrOptions.documents ? documentsOrOptions : {
          documents: documentsOrOptions,
          requestHeaders,
          signal: void 0
        };
      }
      exports.parseBatchRequestArgs = parseBatchRequestArgs;
      function parseRequestExtendedArgs(urlOrOptions, document2, variables, requestHeaders) {
        return urlOrOptions.document ? urlOrOptions : {
          url: urlOrOptions,
          document: document2,
          variables,
          requestHeaders,
          signal: void 0
        };
      }
      exports.parseRequestExtendedArgs = parseRequestExtendedArgs;
      function parseRawRequestExtendedArgs(urlOrOptions, query, variables, requestHeaders) {
        return urlOrOptions.query ? urlOrOptions : {
          url: urlOrOptions,
          query,
          variables,
          requestHeaders,
          signal: void 0
        };
      }
      exports.parseRawRequestExtendedArgs = parseRawRequestExtendedArgs;
      function parseBatchRequestsExtendedArgs(urlOrOptions, documents, requestHeaders) {
        return urlOrOptions.documents ? urlOrOptions : {
          url: urlOrOptions,
          documents,
          requestHeaders,
          signal: void 0
        };
      }
      exports.parseBatchRequestsExtendedArgs = parseBatchRequestsExtendedArgs;
    }
  });

  // ../../node_modules/.pnpm/graphql-request@5.0.0_graphql@16.6.0/node_modules/graphql-request/dist/types.js
  var require_types = __commonJS({
    "../../node_modules/.pnpm/graphql-request@5.0.0_graphql@16.6.0/node_modules/graphql-request/dist/types.js"(exports) {
      "use strict";
      var __extends = exports && exports.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ClientError = void 0;
      var ClientError = (
        /** @class */
        function(_super) {
          __extends(ClientError2, _super);
          function ClientError2(response, request) {
            var _this = this;
            var message = ClientError2.extractMessage(response) + ": " + JSON.stringify({
              response,
              request
            });
            _this = _super.call(this, message) || this;
            Object.setPrototypeOf(_this, ClientError2.prototype);
            _this.response = response;
            _this.request = request;
            if (typeof Error.captureStackTrace === "function") {
              Error.captureStackTrace(_this, ClientError2);
            }
            return _this;
          }
          ClientError2.extractMessage = function(response) {
            try {
              return response.errors[0].message;
            } catch (e) {
              return "GraphQL Error (Code: " + response.status + ")";
            }
          };
          return ClientError2;
        }(Error)
      );
      exports.ClientError = ClientError;
    }
  });

  // ../../node_modules/.pnpm/graphql-request@5.0.0_graphql@16.6.0/node_modules/graphql-request/dist/graphql-ws.js
  var require_graphql_ws = __commonJS({
    "../../node_modules/.pnpm/graphql-request@5.0.0_graphql@16.6.0/node_modules/graphql-request/dist/graphql-ws.js"(exports) {
      "use strict";
      var __assign2 = exports && exports.__assign || function() {
        __assign2 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign2.apply(this, arguments);
      };
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve4) {
            resolve4(value);
          });
        }
        return new (P || (P = Promise))(function(resolve4, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve4(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f2, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f2 = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GraphQLWebSocketClient = void 0;
      var types_1 = require_types();
      var _1 = require_dist2();
      var CONNECTION_INIT = "connection_init";
      var CONNECTION_ACK = "connection_ack";
      var PING = "ping";
      var PONG = "pong";
      var SUBSCRIBE = "subscribe";
      var NEXT = "next";
      var ERROR2 = "error";
      var COMPLETE = "complete";
      var GraphQLWebSocketMessage = (
        /** @class */
        function() {
          function GraphQLWebSocketMessage2(type3, payload, id) {
            this._type = type3;
            this._payload = payload;
            this._id = id;
          }
          Object.defineProperty(GraphQLWebSocketMessage2.prototype, "type", {
            get: function() {
              return this._type;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(GraphQLWebSocketMessage2.prototype, "id", {
            get: function() {
              return this._id;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(GraphQLWebSocketMessage2.prototype, "payload", {
            get: function() {
              return this._payload;
            },
            enumerable: false,
            configurable: true
          });
          Object.defineProperty(GraphQLWebSocketMessage2.prototype, "text", {
            get: function() {
              var result = { type: this.type };
              if (this.id != null && this.id != void 0)
                result.id = this.id;
              if (this.payload != null && this.payload != void 0)
                result.payload = this.payload;
              return JSON.stringify(result);
            },
            enumerable: false,
            configurable: true
          });
          GraphQLWebSocketMessage2.parse = function(data, f2) {
            var _a = JSON.parse(data), type3 = _a.type, payload = _a.payload, id = _a.id;
            return new GraphQLWebSocketMessage2(type3, f2(payload), id);
          };
          return GraphQLWebSocketMessage2;
        }()
      );
      var GraphQLWebSocketClient = (
        /** @class */
        function() {
          function GraphQLWebSocketClient2(socket, _a) {
            var _this = this;
            var onInit = _a.onInit, onAcknowledged = _a.onAcknowledged, onPing = _a.onPing, onPong = _a.onPong;
            this.socketState = { acknowledged: false, lastRequestId: 0, subscriptions: {} };
            this.socket = socket;
            socket.onopen = function(e) {
              return __awaiter(_this, void 0, void 0, function() {
                var _a2, _b, _c, _d;
                return __generator(this, function(_e) {
                  switch (_e.label) {
                    case 0:
                      this.socketState.acknowledged = false;
                      this.socketState.subscriptions = {};
                      _b = (_a2 = socket).send;
                      _c = ConnectionInit;
                      if (!onInit)
                        return [3, 2];
                      return [4, onInit()];
                    case 1:
                      _d = _e.sent();
                      return [3, 3];
                    case 2:
                      _d = null;
                      _e.label = 3;
                    case 3:
                      _b.apply(_a2, [_c.apply(void 0, [_d]).text]);
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            };
            socket.onclose = function(e) {
              _this.socketState.acknowledged = false;
              _this.socketState.subscriptions = {};
            };
            socket.onerror = function(e) {
              console.error(e);
            };
            socket.onmessage = function(e) {
              try {
                var message = parseMessage(e.data);
                switch (message.type) {
                  case CONNECTION_ACK: {
                    if (_this.socketState.acknowledged) {
                      console.warn("Duplicate CONNECTION_ACK message ignored");
                    } else {
                      _this.socketState.acknowledged = true;
                      if (onAcknowledged)
                        onAcknowledged(message.payload);
                    }
                    return;
                  }
                  case PING: {
                    if (onPing)
                      onPing(message.payload).then(function(r) {
                        return socket.send(Pong(r).text);
                      });
                    else
                      socket.send(Pong(null).text);
                    return;
                  }
                  case PONG: {
                    if (onPong)
                      onPong(message.payload);
                    return;
                  }
                }
                if (!_this.socketState.acknowledged) {
                  return;
                }
                if (message.id === void 0 || message.id === null || !_this.socketState.subscriptions[message.id]) {
                  return;
                }
                var _a2 = _this.socketState.subscriptions[message.id], query = _a2.query, variables = _a2.variables, subscriber = _a2.subscriber;
                switch (message.type) {
                  case NEXT: {
                    if (!message.payload.errors && message.payload.data) {
                      subscriber.next && subscriber.next(message.payload.data);
                    }
                    if (message.payload.errors) {
                      subscriber.error && subscriber.error(new types_1.ClientError(__assign2(__assign2({}, message.payload), { status: 200 }), { query, variables }));
                    } else {
                    }
                    return;
                  }
                  case ERROR2: {
                    subscriber.error && subscriber.error(new types_1.ClientError({ errors: message.payload, status: 200 }, { query, variables }));
                    return;
                  }
                  case COMPLETE: {
                    subscriber.complete && subscriber.complete();
                    delete _this.socketState.subscriptions[message.id];
                    return;
                  }
                }
              } catch (e2) {
                console.error(e2);
                socket.close(1006);
              }
              socket.close(4400, "Unknown graphql-ws message.");
            };
          }
          GraphQLWebSocketClient2.prototype.makeSubscribe = function(query, operationName, variables, subscriber) {
            var _this = this;
            var subscriptionId = (this.socketState.lastRequestId++).toString();
            this.socketState.subscriptions[subscriptionId] = { query, variables, subscriber };
            this.socket.send(Subscribe(subscriptionId, { query, operationName, variables }).text);
            return function() {
              _this.socket.send(Complete(subscriptionId).text);
              delete _this.socketState.subscriptions[subscriptionId];
            };
          };
          GraphQLWebSocketClient2.prototype.rawRequest = function(query, variables) {
            var _this = this;
            return new Promise(function(resolve4, reject) {
              var result;
              _this.rawSubscribe(query, {
                next: function(data, extensions) {
                  return result = { data, extensions };
                },
                error: reject,
                complete: function() {
                  return resolve4(result);
                }
              }, variables);
            });
          };
          GraphQLWebSocketClient2.prototype.request = function(document2, variables) {
            var _this = this;
            return new Promise(function(resolve4, reject) {
              var result;
              _this.subscribe(document2, {
                next: function(data) {
                  return result = data;
                },
                error: reject,
                complete: function() {
                  return resolve4(result);
                }
              }, variables);
            });
          };
          GraphQLWebSocketClient2.prototype.subscribe = function(document2, subscriber, variables) {
            var _a = _1.resolveRequestDocument(document2), query = _a.query, operationName = _a.operationName;
            return this.makeSubscribe(query, operationName, variables, subscriber);
          };
          GraphQLWebSocketClient2.prototype.rawSubscribe = function(query, subscriber, variables) {
            return this.makeSubscribe(query, void 0, variables, subscriber);
          };
          GraphQLWebSocketClient2.prototype.ping = function(payload) {
            this.socket.send(Ping(payload).text);
          };
          GraphQLWebSocketClient2.prototype.close = function() {
            this.socket.close(1e3);
          };
          GraphQLWebSocketClient2.PROTOCOL = "graphql-transport-ws";
          return GraphQLWebSocketClient2;
        }()
      );
      exports.GraphQLWebSocketClient = GraphQLWebSocketClient;
      function parseMessage(data, f2) {
        if (f2 === void 0) {
          f2 = function(a) {
            return a;
          };
        }
        var m = GraphQLWebSocketMessage.parse(data, f2);
        return m;
      }
      function ConnectionInit(payload) {
        return new GraphQLWebSocketMessage(CONNECTION_INIT, payload);
      }
      function Ping(payload) {
        return new GraphQLWebSocketMessage(PING, payload, void 0);
      }
      function Pong(payload) {
        return new GraphQLWebSocketMessage(PONG, payload, void 0);
      }
      function Subscribe(id, payload) {
        return new GraphQLWebSocketMessage(SUBSCRIBE, payload, id);
      }
      function Complete(id) {
        return new GraphQLWebSocketMessage(COMPLETE, void 0, id);
      }
    }
  });

  // ../../node_modules/.pnpm/graphql-request@5.0.0_graphql@16.6.0/node_modules/graphql-request/dist/index.js
  var require_dist2 = __commonJS({
    "../../node_modules/.pnpm/graphql-request@5.0.0_graphql@16.6.0/node_modules/graphql-request/dist/index.js"(exports) {
      "use strict";
      var __assign2 = exports && exports.__assign || function() {
        __assign2 = Object.assign || function(t) {
          for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
              if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
          }
          return t;
        };
        return __assign2.apply(this, arguments);
      };
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve4) {
            resolve4(value);
          });
        }
        return new (P || (P = Promise))(function(resolve4, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve4(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __generator = exports && exports.__generator || function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f2, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f2)
            throw new TypeError("Generator is already executing.");
          while (_)
            try {
              if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f2 = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      var __rest = exports && exports.__rest || function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.GraphQLWebSocketClient = exports.gql = exports.resolveRequestDocument = exports.batchRequests = exports.request = exports.rawRequest = exports.GraphQLClient = exports.ClientError = void 0;
      var cross_fetch_1 = __importStar(require_node_ponyfill());
      var CrossFetch = cross_fetch_1;
      var parser_1 = require_parser3();
      var printer_1 = require_printer2();
      var createRequestBody_1 = __importDefault(require_createRequestBody());
      var defaultJsonSerializer_1 = require_defaultJsonSerializer();
      var parseArgs_1 = require_parseArgs();
      var types_1 = require_types();
      Object.defineProperty(exports, "ClientError", { enumerable: true, get: function() {
        return types_1.ClientError;
      } });
      var resolveHeaders = function(headers) {
        var oHeaders = {};
        if (headers) {
          if (typeof Headers !== "undefined" && headers instanceof Headers || CrossFetch && CrossFetch.Headers && headers instanceof CrossFetch.Headers) {
            oHeaders = HeadersInstanceToPlainObject(headers);
          } else if (Array.isArray(headers)) {
            headers.forEach(function(_a) {
              var name = _a[0], value = _a[1];
              oHeaders[name] = value;
            });
          } else {
            oHeaders = headers;
          }
        }
        return oHeaders;
      };
      var queryCleanner = function(str) {
        return str.replace(/([\s,]|#[^\n\r]+)+/g, " ").trim();
      };
      var buildGetQueryParams = function(_a) {
        var query = _a.query, variables = _a.variables, operationName = _a.operationName, jsonSerializer = _a.jsonSerializer;
        if (!Array.isArray(query)) {
          var search = ["query=" + encodeURIComponent(queryCleanner(query))];
          if (variables) {
            search.push("variables=" + encodeURIComponent(jsonSerializer.stringify(variables)));
          }
          if (operationName) {
            search.push("operationName=" + encodeURIComponent(operationName));
          }
          return search.join("&");
        }
        if (typeof variables !== "undefined" && !Array.isArray(variables)) {
          throw new Error("Cannot create query with given variable type, array expected");
        }
        var payload = query.reduce(function(accu, currentQuery, index) {
          accu.push({
            query: queryCleanner(currentQuery),
            variables: variables ? jsonSerializer.stringify(variables[index]) : void 0
          });
          return accu;
        }, []);
        return "query=" + encodeURIComponent(jsonSerializer.stringify(payload));
      };
      var post = function(_a) {
        var url = _a.url, query = _a.query, variables = _a.variables, operationName = _a.operationName, headers = _a.headers, fetch2 = _a.fetch, fetchOptions = _a.fetchOptions, middleware = _a.middleware;
        return __awaiter(void 0, void 0, void 0, function() {
          var body, options;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                body = createRequestBody_1.default(query, variables, operationName, fetchOptions.jsonSerializer);
                options = __assign2({ method: "POST", headers: __assign2(__assign2({}, typeof body === "string" ? { "Content-Type": "application/json" } : {}), headers), body }, fetchOptions);
                if (!middleware)
                  return [3, 2];
                return [4, Promise.resolve(middleware(options))];
              case 1:
                options = _b.sent();
                _b.label = 2;
              case 2:
                return [4, fetch2(url, options)];
              case 3:
                return [2, _b.sent()];
            }
          });
        });
      };
      var get = function(_a) {
        var url = _a.url, query = _a.query, variables = _a.variables, operationName = _a.operationName, headers = _a.headers, fetch2 = _a.fetch, fetchOptions = _a.fetchOptions, middleware = _a.middleware;
        return __awaiter(void 0, void 0, void 0, function() {
          var queryParams, options;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                queryParams = buildGetQueryParams({
                  query,
                  variables,
                  operationName,
                  jsonSerializer: fetchOptions.jsonSerializer
                });
                options = __assign2({ method: "GET", headers }, fetchOptions);
                if (!middleware)
                  return [3, 2];
                return [4, Promise.resolve(middleware(options))];
              case 1:
                options = _b.sent();
                _b.label = 2;
              case 2:
                return [4, fetch2(url + "?" + queryParams, options)];
              case 3:
                return [2, _b.sent()];
            }
          });
        });
      };
      var GraphQLClient2 = (
        /** @class */
        function() {
          function GraphQLClient3(url, options) {
            if (options === void 0) {
              options = {};
            }
            this.url = url;
            this.options = options;
          }
          GraphQLClient3.prototype.rawRequest = function(queryOrOptions, variables, requestHeaders) {
            return __awaiter(this, void 0, void 0, function() {
              var rawRequestOptions, _a, headers, _b, fetch2, _c, method, requestMiddleware, responseMiddleware, fetchOptions, url, operationName;
              return __generator(this, function(_d) {
                rawRequestOptions = parseArgs_1.parseRawRequestArgs(queryOrOptions, variables, requestHeaders);
                _a = this.options, headers = _a.headers, _b = _a.fetch, fetch2 = _b === void 0 ? cross_fetch_1.default : _b, _c = _a.method, method = _c === void 0 ? "POST" : _c, requestMiddleware = _a.requestMiddleware, responseMiddleware = _a.responseMiddleware, fetchOptions = __rest(_a, ["headers", "fetch", "method", "requestMiddleware", "responseMiddleware"]);
                url = this.url;
                if (rawRequestOptions.signal !== void 0) {
                  fetchOptions.signal = rawRequestOptions.signal;
                }
                operationName = resolveRequestDocument(rawRequestOptions.query).operationName;
                return [2, makeRequest({
                  url,
                  query: rawRequestOptions.query,
                  variables: rawRequestOptions.variables,
                  headers: __assign2(__assign2({}, resolveHeaders(callOrIdentity(headers))), resolveHeaders(rawRequestOptions.requestHeaders)),
                  operationName,
                  fetch: fetch2,
                  method,
                  fetchOptions,
                  middleware: requestMiddleware
                }).then(function(response) {
                  if (responseMiddleware) {
                    responseMiddleware(response);
                  }
                  return response;
                }).catch(function(error2) {
                  if (responseMiddleware) {
                    responseMiddleware(error2);
                  }
                  throw error2;
                })];
              });
            });
          };
          GraphQLClient3.prototype.request = function(documentOrOptions) {
            var variablesAndRequestHeaders = [];
            for (var _i = 1; _i < arguments.length; _i++) {
              variablesAndRequestHeaders[_i - 1] = arguments[_i];
            }
            var variables = variablesAndRequestHeaders[0], requestHeaders = variablesAndRequestHeaders[1];
            var requestOptions = parseArgs_1.parseRequestArgs(documentOrOptions, variables, requestHeaders);
            var _a = this.options, headers = _a.headers, _b = _a.fetch, fetch2 = _b === void 0 ? cross_fetch_1.default : _b, _c = _a.method, method = _c === void 0 ? "POST" : _c, requestMiddleware = _a.requestMiddleware, responseMiddleware = _a.responseMiddleware, fetchOptions = __rest(_a, ["headers", "fetch", "method", "requestMiddleware", "responseMiddleware"]);
            var url = this.url;
            if (requestOptions.signal !== void 0) {
              fetchOptions.signal = requestOptions.signal;
            }
            var _d = resolveRequestDocument(requestOptions.document), query = _d.query, operationName = _d.operationName;
            return makeRequest({
              url,
              query,
              variables: requestOptions.variables,
              headers: __assign2(__assign2({}, resolveHeaders(callOrIdentity(headers))), resolveHeaders(requestOptions.requestHeaders)),
              operationName,
              fetch: fetch2,
              method,
              fetchOptions,
              middleware: requestMiddleware
            }).then(function(response) {
              if (responseMiddleware) {
                responseMiddleware(response);
              }
              return response.data;
            }).catch(function(error2) {
              if (responseMiddleware) {
                responseMiddleware(error2);
              }
              throw error2;
            });
          };
          GraphQLClient3.prototype.batchRequests = function(documentsOrOptions, requestHeaders) {
            var batchRequestOptions = parseArgs_1.parseBatchRequestArgs(documentsOrOptions, requestHeaders);
            var _a = this.options, headers = _a.headers, _b = _a.fetch, fetch2 = _b === void 0 ? cross_fetch_1.default : _b, _c = _a.method, method = _c === void 0 ? "POST" : _c, requestMiddleware = _a.requestMiddleware, responseMiddleware = _a.responseMiddleware, fetchOptions = __rest(_a, ["headers", "fetch", "method", "requestMiddleware", "responseMiddleware"]);
            var url = this.url;
            if (batchRequestOptions.signal !== void 0) {
              fetchOptions.signal = batchRequestOptions.signal;
            }
            var queries = batchRequestOptions.documents.map(function(_a2) {
              var document2 = _a2.document;
              return resolveRequestDocument(document2).query;
            });
            var variables = batchRequestOptions.documents.map(function(_a2) {
              var variables2 = _a2.variables;
              return variables2;
            });
            return makeRequest({
              url,
              query: queries,
              variables,
              headers: __assign2(__assign2({}, resolveHeaders(callOrIdentity(headers))), resolveHeaders(batchRequestOptions.requestHeaders)),
              operationName: void 0,
              fetch: fetch2,
              method,
              fetchOptions,
              middleware: requestMiddleware
            }).then(function(response) {
              if (responseMiddleware) {
                responseMiddleware(response);
              }
              return response.data;
            }).catch(function(error2) {
              if (responseMiddleware) {
                responseMiddleware(error2);
              }
              throw error2;
            });
          };
          GraphQLClient3.prototype.setHeaders = function(headers) {
            this.options.headers = headers;
            return this;
          };
          GraphQLClient3.prototype.setHeader = function(key, value) {
            var _a;
            var headers = this.options.headers;
            if (headers) {
              headers[key] = value;
            } else {
              this.options.headers = (_a = {}, _a[key] = value, _a);
            }
            return this;
          };
          GraphQLClient3.prototype.setEndpoint = function(value) {
            this.url = value;
            return this;
          };
          return GraphQLClient3;
        }()
      );
      exports.GraphQLClient = GraphQLClient2;
      function makeRequest(_a) {
        var url = _a.url, query = _a.query, variables = _a.variables, headers = _a.headers, operationName = _a.operationName, fetch2 = _a.fetch, _b = _a.method, method = _b === void 0 ? "POST" : _b, fetchOptions = _a.fetchOptions, middleware = _a.middleware;
        return __awaiter(this, void 0, void 0, function() {
          var fetcher, isBathchingQuery, response, result, successfullyReceivedData, successfullyPassedErrorPolicy, headers_1, status_1, errors, rest, data, errorResult;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                fetcher = method.toUpperCase() === "POST" ? post : get;
                isBathchingQuery = Array.isArray(query);
                return [4, fetcher({
                  url,
                  query,
                  variables,
                  operationName,
                  headers,
                  fetch: fetch2,
                  fetchOptions,
                  middleware
                })];
              case 1:
                response = _c.sent();
                return [4, getResult(response, fetchOptions.jsonSerializer)];
              case 2:
                result = _c.sent();
                successfullyReceivedData = isBathchingQuery && Array.isArray(result) ? !result.some(function(_a2) {
                  var data2 = _a2.data;
                  return !data2;
                }) : !!result.data;
                successfullyPassedErrorPolicy = !result.errors || fetchOptions.errorPolicy === "all" || fetchOptions.errorPolicy === "ignore";
                if (response.ok && successfullyPassedErrorPolicy && successfullyReceivedData) {
                  headers_1 = response.headers, status_1 = response.status;
                  errors = result.errors, rest = __rest(result, ["errors"]);
                  data = fetchOptions.errorPolicy === "ignore" ? rest : result;
                  return [2, __assign2(__assign2({}, isBathchingQuery ? { data } : data), { headers: headers_1, status: status_1 })];
                } else {
                  errorResult = typeof result === "string" ? { error: result } : result;
                  throw new types_1.ClientError(__assign2(__assign2({}, errorResult), { status: response.status, headers: response.headers }), { query, variables });
                }
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }
      function rawRequest(urlOrOptions, query, variables, requestHeaders) {
        return __awaiter(this, void 0, void 0, function() {
          var requestOptions, client;
          return __generator(this, function(_a) {
            requestOptions = parseArgs_1.parseRawRequestExtendedArgs(urlOrOptions, query, variables, requestHeaders);
            client = new GraphQLClient2(requestOptions.url);
            return [2, client.rawRequest(__assign2({}, requestOptions))];
          });
        });
      }
      exports.rawRequest = rawRequest;
      function request(urlOrOptions, document2) {
        var variablesAndRequestHeaders = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          variablesAndRequestHeaders[_i - 2] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function() {
          var variables, requestHeaders, requestOptions, client;
          return __generator(this, function(_a) {
            variables = variablesAndRequestHeaders[0], requestHeaders = variablesAndRequestHeaders[1];
            requestOptions = parseArgs_1.parseRequestExtendedArgs(urlOrOptions, document2, variables, requestHeaders);
            client = new GraphQLClient2(requestOptions.url);
            return [2, client.request(__assign2({}, requestOptions))];
          });
        });
      }
      exports.request = request;
      function batchRequests(urlOrOptions, documents, requestHeaders) {
        return __awaiter(this, void 0, void 0, function() {
          var requestOptions, client;
          return __generator(this, function(_a) {
            requestOptions = parseArgs_1.parseBatchRequestsExtendedArgs(urlOrOptions, documents, requestHeaders);
            client = new GraphQLClient2(requestOptions.url);
            return [2, client.batchRequests(__assign2({}, requestOptions))];
          });
        });
      }
      exports.batchRequests = batchRequests;
      exports.default = request;
      function getResult(response, jsonSerializer) {
        if (jsonSerializer === void 0) {
          jsonSerializer = defaultJsonSerializer_1.defaultJsonSerializer;
        }
        return __awaiter(this, void 0, void 0, function() {
          var contentType, _a, _b;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                response.headers.forEach(function(value, key) {
                  if (key.toLowerCase() === "content-type") {
                    contentType = value;
                  }
                });
                if (!(contentType && contentType.toLowerCase().startsWith("application/json")))
                  return [3, 2];
                _b = (_a = jsonSerializer).parse;
                return [4, response.text()];
              case 1:
                return [2, _b.apply(_a, [_c.sent()])];
              case 2:
                return [2, response.text()];
            }
          });
        });
      }
      function extractOperationName(document2) {
        var _a;
        var operationName = void 0;
        var operationDefinitions = document2.definitions.filter(function(definition) {
          return definition.kind === "OperationDefinition";
        });
        if (operationDefinitions.length === 1) {
          operationName = (_a = operationDefinitions[0].name) === null || _a === void 0 ? void 0 : _a.value;
        }
        return operationName;
      }
      function resolveRequestDocument(document2) {
        if (typeof document2 === "string") {
          var operationName_1 = void 0;
          try {
            var parsedDocument = parser_1.parse(document2);
            operationName_1 = extractOperationName(parsedDocument);
          } catch (err) {
          }
          return { query: document2, operationName: operationName_1 };
        }
        var operationName = extractOperationName(document2);
        return { query: printer_1.print(document2), operationName };
      }
      exports.resolveRequestDocument = resolveRequestDocument;
      function callOrIdentity(value) {
        return typeof value === "function" ? value() : value;
      }
      function gql2(chunks) {
        var variables = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          variables[_i - 1] = arguments[_i];
        }
        return chunks.reduce(function(accumulator, chunk, index) {
          return "" + accumulator + chunk + (index in variables ? variables[index] : "");
        }, "");
      }
      exports.gql = gql2;
      function HeadersInstanceToPlainObject(headers) {
        var o = {};
        headers.forEach(function(v, k) {
          o[k] = v;
        });
        return o;
      }
      var graphql_ws_1 = require_graphql_ws();
      Object.defineProperty(exports, "GraphQLWebSocketClient", { enumerable: true, get: function() {
        return graphql_ws_1.GraphQLWebSocketClient;
      } });
    }
  });

  // ../../node_modules/.pnpm/long@4.0.0/node_modules/long/src/long.js
  var require_long = __commonJS({
    "../../node_modules/.pnpm/long@4.0.0/node_modules/long/src/long.js"(exports, module2) {
      module2.exports = Long;
      var wasm = null;
      try {
        wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
          0,
          97,
          115,
          109,
          1,
          0,
          0,
          0,
          1,
          13,
          2,
          96,
          0,
          1,
          127,
          96,
          4,
          127,
          127,
          127,
          127,
          1,
          127,
          3,
          7,
          6,
          0,
          1,
          1,
          1,
          1,
          1,
          6,
          6,
          1,
          127,
          1,
          65,
          0,
          11,
          7,
          50,
          6,
          3,
          109,
          117,
          108,
          0,
          1,
          5,
          100,
          105,
          118,
          95,
          115,
          0,
          2,
          5,
          100,
          105,
          118,
          95,
          117,
          0,
          3,
          5,
          114,
          101,
          109,
          95,
          115,
          0,
          4,
          5,
          114,
          101,
          109,
          95,
          117,
          0,
          5,
          8,
          103,
          101,
          116,
          95,
          104,
          105,
          103,
          104,
          0,
          0,
          10,
          191,
          1,
          6,
          4,
          0,
          35,
          0,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          126,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          127,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          128,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          129,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          130,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11
        ])), {}).exports;
      } catch (e) {
      }
      function Long(low, high, unsigned) {
        this.low = low | 0;
        this.high = high | 0;
        this.unsigned = !!unsigned;
      }
      Long.prototype.__isLong__;
      Object.defineProperty(Long.prototype, "__isLong__", { value: true });
      function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
      }
      Long.isLong = isLong;
      var INT_CACHE = {};
      var UINT_CACHE = {};
      function fromInt(value, unsigned) {
        var obj, cachedObj, cache2;
        if (unsigned) {
          value >>>= 0;
          if (cache2 = 0 <= value && value < 256) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
          if (cache2)
            UINT_CACHE[value] = obj;
          return obj;
        } else {
          value |= 0;
          if (cache2 = -128 <= value && value < 128) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
              return cachedObj;
          }
          obj = fromBits(value, value < 0 ? -1 : 0, false);
          if (cache2)
            INT_CACHE[value] = obj;
          return obj;
        }
      }
      Long.fromInt = fromInt;
      function fromNumber(value, unsigned) {
        if (isNaN(value))
          return unsigned ? UZERO : ZERO2;
        if (unsigned) {
          if (value < 0)
            return UZERO;
          if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
        } else {
          if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
          if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
        }
        if (value < 0)
          return fromNumber(-value, unsigned).neg();
        return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
      }
      Long.fromNumber = fromNumber;
      function fromBits(lowBits, highBits, unsigned) {
        return new Long(lowBits, highBits, unsigned);
      }
      Long.fromBits = fromBits;
      var pow_dbl = Math.pow;
      function fromString(str, unsigned, radix) {
        if (str.length === 0)
          throw Error("empty string");
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
          return ZERO2;
        if (typeof unsigned === "number") {
          radix = unsigned, unsigned = false;
        } else {
          unsigned = !!unsigned;
        }
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        var p;
        if ((p = str.indexOf("-")) > 0)
          throw Error("interior hyphen");
        else if (p === 0) {
          return fromString(str.substring(1), unsigned, radix).neg();
        }
        var radixToPower = fromNumber(pow_dbl(radix, 8));
        var result = ZERO2;
        for (var i = 0; i < str.length; i += 8) {
          var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
          if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
          } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
          }
        }
        result.unsigned = unsigned;
        return result;
      }
      Long.fromString = fromString;
      function fromValue(val, unsigned) {
        if (typeof val === "number")
          return fromNumber(val, unsigned);
        if (typeof val === "string")
          return fromString(val, unsigned);
        return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
      }
      Long.fromValue = fromValue;
      var TWO_PWR_16_DBL = 1 << 16;
      var TWO_PWR_24_DBL = 1 << 24;
      var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
      var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
      var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
      var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
      var ZERO2 = fromInt(0);
      Long.ZERO = ZERO2;
      var UZERO = fromInt(0, true);
      Long.UZERO = UZERO;
      var ONE = fromInt(1);
      Long.ONE = ONE;
      var UONE = fromInt(1, true);
      Long.UONE = UONE;
      var NEG_ONE = fromInt(-1);
      Long.NEG_ONE = NEG_ONE;
      var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
      Long.MAX_VALUE = MAX_VALUE;
      var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
      Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
      var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
      Long.MIN_VALUE = MIN_VALUE;
      var LongPrototype = Long.prototype;
      LongPrototype.toInt = function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
      };
      LongPrototype.toNumber = function toNumber3() {
        if (this.unsigned)
          return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
      };
      LongPrototype.toString = function toString3(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix)
          throw RangeError("radix");
        if (this.isZero())
          return "0";
        if (this.isNegative()) {
          if (this.eq(MIN_VALUE)) {
            var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
          } else
            return "-" + this.neg().toString(radix);
        }
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
        var result = "";
        while (true) {
          var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
          rem = remDiv;
          if (rem.isZero())
            return digits + result;
          else {
            while (digits.length < 6)
              digits = "0" + digits;
            result = "" + digits + result;
          }
        }
      };
      LongPrototype.getHighBits = function getHighBits() {
        return this.high;
      };
      LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
        return this.high >>> 0;
      };
      LongPrototype.getLowBits = function getLowBits() {
        return this.low;
      };
      LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
        return this.low >>> 0;
      };
      LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
        if (this.isNegative())
          return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--)
          if ((val & 1 << bit) != 0)
            break;
        return this.high != 0 ? bit + 33 : bit + 1;
      };
      LongPrototype.isZero = function isZero() {
        return this.high === 0 && this.low === 0;
      };
      LongPrototype.eqz = LongPrototype.isZero;
      LongPrototype.isNegative = function isNegative() {
        return !this.unsigned && this.high < 0;
      };
      LongPrototype.isPositive = function isPositive() {
        return this.unsigned || this.high >= 0;
      };
      LongPrototype.isOdd = function isOdd() {
        return (this.low & 1) === 1;
      };
      LongPrototype.isEven = function isEven() {
        return (this.low & 1) === 0;
      };
      LongPrototype.equals = function equals3(other) {
        if (!isLong(other))
          other = fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
          return false;
        return this.high === other.high && this.low === other.low;
      };
      LongPrototype.eq = LongPrototype.equals;
      LongPrototype.notEquals = function notEquals(other) {
        return !this.eq(
          /* validates */
          other
        );
      };
      LongPrototype.neq = LongPrototype.notEquals;
      LongPrototype.ne = LongPrototype.notEquals;
      LongPrototype.lessThan = function lessThan(other) {
        return this.comp(
          /* validates */
          other
        ) < 0;
      };
      LongPrototype.lt = LongPrototype.lessThan;
      LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) <= 0;
      };
      LongPrototype.lte = LongPrototype.lessThanOrEqual;
      LongPrototype.le = LongPrototype.lessThanOrEqual;
      LongPrototype.greaterThan = function greaterThan(other) {
        return this.comp(
          /* validates */
          other
        ) > 0;
      };
      LongPrototype.gt = LongPrototype.greaterThan;
      LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) >= 0;
      };
      LongPrototype.gte = LongPrototype.greaterThanOrEqual;
      LongPrototype.ge = LongPrototype.greaterThanOrEqual;
      LongPrototype.compare = function compare(other) {
        if (!isLong(other))
          other = fromValue(other);
        if (this.eq(other))
          return 0;
        var thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg)
          return -1;
        if (!thisNeg && otherNeg)
          return 1;
        if (!this.unsigned)
          return this.sub(other).isNegative() ? -1 : 1;
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
      };
      LongPrototype.comp = LongPrototype.compare;
      LongPrototype.negate = function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE))
          return MIN_VALUE;
        return this.not().add(ONE);
      };
      LongPrototype.neg = LongPrototype.negate;
      LongPrototype.add = function add3(addend) {
        if (!isLong(addend))
          addend = fromValue(addend);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = addend.high >>> 16;
        var b32 = addend.high & 65535;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 + b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.subtract = function subtract(subtrahend) {
        if (!isLong(subtrahend))
          subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
      };
      LongPrototype.sub = LongPrototype.subtract;
      LongPrototype.multiply = function multiply(multiplier) {
        if (this.isZero())
          return ZERO2;
        if (!isLong(multiplier))
          multiplier = fromValue(multiplier);
        if (wasm) {
          var low = wasm.mul(
            this.low,
            this.high,
            multiplier.low,
            multiplier.high
          );
          return fromBits(low, wasm.get_high(), this.unsigned);
        }
        if (multiplier.isZero())
          return ZERO2;
        if (this.eq(MIN_VALUE))
          return multiplier.isOdd() ? MIN_VALUE : ZERO2;
        if (multiplier.eq(MIN_VALUE))
          return this.isOdd() ? MIN_VALUE : ZERO2;
        if (this.isNegative()) {
          if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
          else
            return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative())
          return this.mul(multiplier.neg()).neg();
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
          return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 65535;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      };
      LongPrototype.mul = LongPrototype.multiply;
      LongPrototype.divide = function divide(divisor) {
        if (!isLong(divisor))
          divisor = fromValue(divisor);
        if (divisor.isZero())
          throw Error("division by zero");
        if (wasm) {
          if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
            return this;
          }
          var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
          );
          return fromBits(low, wasm.get_high(), this.unsigned);
        }
        if (this.isZero())
          return this.unsigned ? UZERO : ZERO2;
        var approx, rem, res;
        if (!this.unsigned) {
          if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
              return MIN_VALUE;
            else if (divisor.eq(MIN_VALUE))
              return ONE;
            else {
              var halfThis = this.shr(1);
              approx = halfThis.div(divisor).shl(1);
              if (approx.eq(ZERO2)) {
                return divisor.isNegative() ? ONE : NEG_ONE;
              } else {
                rem = this.sub(divisor.mul(approx));
                res = approx.add(rem.div(divisor));
                return res;
              }
            }
          } else if (divisor.eq(MIN_VALUE))
            return this.unsigned ? UZERO : ZERO2;
          if (this.isNegative()) {
            if (divisor.isNegative())
              return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
          } else if (divisor.isNegative())
            return this.div(divisor.neg()).neg();
          res = ZERO2;
        } else {
          if (!divisor.unsigned)
            divisor = divisor.toUnsigned();
          if (divisor.gt(this))
            return UZERO;
          if (divisor.gt(this.shru(1)))
            return UONE;
          res = UZERO;
        }
        rem = this;
        while (rem.gte(divisor)) {
          approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
          var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
          while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
          }
          if (approxRes.isZero())
            approxRes = ONE;
          res = res.add(approxRes);
          rem = rem.sub(approxRem);
        }
        return res;
      };
      LongPrototype.div = LongPrototype.divide;
      LongPrototype.modulo = function modulo(divisor) {
        if (!isLong(divisor))
          divisor = fromValue(divisor);
        if (wasm) {
          var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
          );
          return fromBits(low, wasm.get_high(), this.unsigned);
        }
        return this.sub(this.div(divisor).mul(divisor));
      };
      LongPrototype.mod = LongPrototype.modulo;
      LongPrototype.rem = LongPrototype.modulo;
      LongPrototype.not = function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
      };
      LongPrototype.and = function and(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
      };
      LongPrototype.or = function or(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
      };
      LongPrototype.xor = function xor(other) {
        if (!isLong(other))
          other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
      };
      LongPrototype.shiftLeft = function shiftLeft(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
        else
          return fromBits(0, this.low << numBits - 32, this.unsigned);
      };
      LongPrototype.shl = LongPrototype.shiftLeft;
      LongPrototype.shiftRight = function shiftRight(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        if ((numBits &= 63) === 0)
          return this;
        else if (numBits < 32)
          return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
        else
          return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      };
      LongPrototype.shr = LongPrototype.shiftRight;
      LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
        if (isLong(numBits))
          numBits = numBits.toInt();
        numBits &= 63;
        if (numBits === 0)
          return this;
        else {
          var high = this.high;
          if (numBits < 32) {
            var low = this.low;
            return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
          } else if (numBits === 32)
            return fromBits(high, 0, this.unsigned);
          else
            return fromBits(high >>> numBits - 32, 0, this.unsigned);
        }
      };
      LongPrototype.shru = LongPrototype.shiftRightUnsigned;
      LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
      LongPrototype.toSigned = function toSigned() {
        if (!this.unsigned)
          return this;
        return fromBits(this.low, this.high, false);
      };
      LongPrototype.toUnsigned = function toUnsigned() {
        if (this.unsigned)
          return this;
        return fromBits(this.low, this.high, true);
      };
      LongPrototype.toBytes = function toBytes4(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
      };
      LongPrototype.toBytesLE = function toBytesLE() {
        var hi = this.high, lo = this.low;
        return [
          lo & 255,
          lo >>> 8 & 255,
          lo >>> 16 & 255,
          lo >>> 24,
          hi & 255,
          hi >>> 8 & 255,
          hi >>> 16 & 255,
          hi >>> 24
        ];
      };
      LongPrototype.toBytesBE = function toBytesBE() {
        var hi = this.high, lo = this.low;
        return [
          hi >>> 24,
          hi >>> 16 & 255,
          hi >>> 8 & 255,
          hi & 255,
          lo >>> 24,
          lo >>> 16 & 255,
          lo >>> 8 & 255,
          lo & 255
        ];
      };
      Long.fromBytes = function fromBytes(bytes3, unsigned, le) {
        return le ? Long.fromBytesLE(bytes3, unsigned) : Long.fromBytesBE(bytes3, unsigned);
      };
      Long.fromBytesLE = function fromBytesLE(bytes3, unsigned) {
        return new Long(
          bytes3[0] | bytes3[1] << 8 | bytes3[2] << 16 | bytes3[3] << 24,
          bytes3[4] | bytes3[5] << 8 | bytes3[6] << 16 | bytes3[7] << 24,
          unsigned
        );
      };
      Long.fromBytesBE = function fromBytesBE(bytes3, unsigned) {
        return new Long(
          bytes3[4] << 24 | bytes3[5] << 16 | bytes3[6] << 8 | bytes3[7],
          bytes3[0] << 24 | bytes3[1] << 16 | bytes3[2] << 8 | bytes3[3],
          unsigned
        );
      };
    }
  });

  // ../../node_modules/.pnpm/tai64@1.0.0/node_modules/tai64/lib/leapSeconds.js
  var require_leapSeconds = __commonJS({
    "../../node_modules/.pnpm/tai64@1.0.0/node_modules/tai64/lib/leapSeconds.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var leapSeconds = [
        [1483228800, 37],
        [1435708800, 36],
        [1341100800, 35],
        [1230768e3, 34],
        [1136073600, 33],
        [915148800, 32],
        [867715200, 31],
        [820454400, 30],
        [773020800, 29],
        [741484800, 28],
        [709948800, 27],
        [662688e3, 26],
        [631152e3, 25],
        [567993600, 24],
        [489024e3, 23],
        [425865600, 22],
        [394329600, 21],
        [362793600, 20],
        [315532800, 19],
        [283996800, 18],
        [252460800, 17],
        [220924800, 16],
        [189302400, 15],
        [157766400, 14],
        [126230400, 13],
        [94694400, 12],
        [78796800, 11],
        [63072e3, 10]
      ];
      var addLeapSeconds = (timestamp) => {
        const leapSecond = leapSeconds.find(([ts]) => timestamp >= ts);
        return timestamp + (leapSecond ? leapSecond[1] : 0);
      };
      exports.addLeapSeconds = addLeapSeconds;
      var removeLeapSeconds = (timestamp) => {
        const leapSecond = leapSeconds.find(([ts, offset]) => timestamp - offset >= ts);
        return timestamp - (leapSecond ? leapSecond[1] : 0);
      };
      exports.removeLeapSeconds = removeLeapSeconds;
    }
  });

  // ../../node_modules/.pnpm/tai64@1.0.0/node_modules/tai64/lib/TAI64.js
  var require_TAI64 = __commonJS({
    "../../node_modules/.pnpm/tai64@1.0.0/node_modules/tai64/lib/TAI64.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var long_1 = __importDefault(require_long());
      var leapSeconds_1 = require_leapSeconds();
      var TAI642 = class {
        /**
         * Construct an instance of TAI64.
         *
         * @param label - The TAI64 label between 0 and 2^63-1, inclusive
         * @returns An instance of TAI64
         * @throws RangeError if the given label is not between 0 and 2^63-1, inclusive
         */
        constructor(label) {
          this.label = label;
          if (label.lt(long_1.default.ZERO) || label.gte(long_1.default.MAX_VALUE)) {
            throw new RangeError("Label must be an integer between 0 and 2^63-1, inclusive");
          }
        }
        /**
         * Return a TAI64 the current number of seconds elapsed since 1970 TAI.
         *
         * @returns An instance of TAI64
         */
        static now() {
          const unixTimestamp = Math.floor(Date.now() / 1e3);
          return TAI642.fromUnix(unixTimestamp);
        }
        /**
         * Return a TAI64 corresponding to the given UNIX timestamp.
         *
         * @param timestamp - The UNIX timestamp in seconds
         * @returns An instance of TAI64
         */
        static fromUnix(timestamp) {
          const seconds = leapSeconds_1.addLeapSeconds(timestamp);
          const label = TAI642.EPOCH.label.add(seconds);
          return new TAI642(label);
        }
        /**
         * Return a TAI64 corresponding to the given hexadecimal string representing a TAI64. This method
         * is an alias for `TAI64#fromString()` method.
         *
         * @param hexString - The hexadecimal string
         * @returns An instance of TAI64
         */
        static fromHexString(hexString) {
          return TAI642.fromString(hexString);
        }
        /**
         * Return a TAI64 corresponding to the given string representing a TAI64 in the given radix.
         *
         * @param str - The string
         * @param radix - An integer that represents the radix (the base in mathematical numeral systems), defaults to `16`
         * @returns An instance of TAI64
         */
        static fromString(str, radix = 16) {
          const label = long_1.default.fromString(str, false, radix);
          return new TAI642(label);
        }
        /**
         * Return a TAI64 corresponding to the given byte array representing a TAI64.
         *
         * @param bytes - The byte array
         * @returns An instance of TAI64
         */
        static fromByteArray(bytes3) {
          const label = long_1.default.fromBytes(bytes3, false);
          return new TAI642(label);
        }
        /**
         * Return if this TAI64 is after the given TAI64.
         *
         * @param other - The other TAI64 to compare
         * @returns `true` if this TAI64 is after the given TAI64, `false` otherwise
         */
        isAfter(other) {
          return this.compareTo(other) > 0;
        }
        /**
         * Return if this TAI64 is before the given TAI64.
         *
         * @param other - The other TAI64 to compare
         * @returns `true` if this TAI64 is before the given TAI64, `false` otherwise
         */
        isBefore(other) {
          return this.compareTo(other) < 0;
        }
        /**
         * Return if this TAI64 is equal to the given TAI64.
         *
         * @param other - The other TAI64 to compare
         * @returns `true` if this TAI64 is equal to the given TAI64, `false` otherwise
         */
        isEqual(other) {
          return this.compareTo(other) === 0;
        }
        /**
         * Compare this TAI64 to the given TAI64.
         *
         * @param other - The other TAI64 to compare
         * @returns
         * - `1` if this TAI64 is before the given TAI64
         * - `-1` if this TAI64 is before the given TAI64
         * - `0` if this TAI64 is equal to the given TAI64
         */
        compareTo(other) {
          return this.label.compare(other.label);
        }
        /**
         * Return a byte array representation of this TAI64.
         */
        toByteArray() {
          return this.label.toBytes();
        }
        /**
         * Return an hexadecimal string representation of this TAI64. This method
         * is an alias for `TAI64#toString()` method.
         */
        toHexString() {
          return this.toString();
        }
        /**
         * Return a string representation of this TAI64.
         *
         * @param radix - An integer that represents the radix (the base in mathematical numeral systems), defaults to `16`
         */
        toString(radix = 16) {
          return this.label.toString(radix);
        }
        /**
         * Return a UNIX timestamp corresponding to this TAI64.
         */
        toUnix() {
          const elapsedSeconds = this.label.sub(TAI642.EPOCH.label);
          return leapSeconds_1.removeLeapSeconds(elapsedSeconds.toNumber());
        }
      };
      TAI642.EPOCH = new TAI642(long_1.default.MAX_VALUE.shiftRight(1).add(1));
      exports.TAI64 = TAI642;
    }
  });

  // ../../node_modules/.pnpm/tai64@1.0.0/node_modules/tai64/lib/index.js
  var require_lib4 = __commonJS({
    "../../node_modules/.pnpm/tai64@1.0.0/node_modules/tai64/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var TAI64_1 = require_TAI64();
      exports.TAI64 = TAI64_1.TAI64;
    }
  });

  // ../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/package.json
  var require_package = __commonJS({
    "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/package.json"(exports, module2) {
      module2.exports = {
        name: "elliptic",
        version: "6.5.4",
        description: "EC cryptography",
        main: "lib/elliptic.js",
        files: [
          "lib"
        ],
        scripts: {
          lint: "eslint lib test",
          "lint:fix": "npm run lint -- --fix",
          unit: "istanbul test _mocha --reporter=spec test/index.js",
          test: "npm run lint && npm run unit",
          version: "grunt dist && git add dist/"
        },
        repository: {
          type: "git",
          url: "git@github.com:indutny/elliptic"
        },
        keywords: [
          "EC",
          "Elliptic",
          "curve",
          "Cryptography"
        ],
        author: "Fedor Indutny <fedor@indutny.com>",
        license: "MIT",
        bugs: {
          url: "https://github.com/indutny/elliptic/issues"
        },
        homepage: "https://github.com/indutny/elliptic",
        devDependencies: {
          brfs: "^2.0.2",
          coveralls: "^3.1.0",
          eslint: "^7.6.0",
          grunt: "^1.2.1",
          "grunt-browserify": "^5.3.0",
          "grunt-cli": "^1.3.2",
          "grunt-contrib-connect": "^3.0.0",
          "grunt-contrib-copy": "^1.0.0",
          "grunt-contrib-uglify": "^5.0.0",
          "grunt-mocha-istanbul": "^5.0.2",
          "grunt-saucelabs": "^9.0.1",
          istanbul: "^0.4.5",
          mocha: "^8.0.1"
        },
        dependencies: {
          "bn.js": "^4.11.9",
          brorand: "^1.1.0",
          "hash.js": "^1.0.0",
          "hmac-drbg": "^1.0.1",
          inherits: "^2.0.4",
          "minimalistic-assert": "^1.0.1",
          "minimalistic-crypto-utils": "^1.0.1"
        }
      };
    }
  });

  // ../../node_modules/.pnpm/bn.js@4.12.0/node_modules/bn.js/lib/bn.js
  var require_bn2 = __commonJS({
    "../../node_modules/.pnpm/bn.js@4.12.0/node_modules/bn.js/lib/bn.js"(exports, module2) {
      (function(module3, exports2) {
        "use strict";
        function assert5(val, msg) {
          if (!val)
            throw new Error(msg || "Assertion failed");
        }
        function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
        function BN2(number4, base, endian) {
          if (BN2.isBN(number4)) {
            return number4;
          }
          this.negative = 0;
          this.words = null;
          this.length = 0;
          this.red = null;
          if (number4 !== null) {
            if (base === "le" || base === "be") {
              endian = base;
              base = 10;
            }
            this._init(number4 || 0, base || 10, endian || "be");
          }
        }
        if (typeof module3 === "object") {
          module3.exports = BN2;
        } else {
          exports2.BN = BN2;
        }
        BN2.BN = BN2;
        BN2.wordSize = 26;
        var Buffer2;
        try {
          if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
            Buffer2 = window.Buffer;
          } else {
            Buffer2 = __require2("buffer").Buffer;
          }
        } catch (e) {
        }
        BN2.isBN = function isBN(num) {
          if (num instanceof BN2) {
            return true;
          }
          return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
        };
        BN2.max = function max2(left, right) {
          if (left.cmp(right) > 0)
            return left;
          return right;
        };
        BN2.min = function min(left, right) {
          if (left.cmp(right) < 0)
            return left;
          return right;
        };
        BN2.prototype._init = function init2(number4, base, endian) {
          if (typeof number4 === "number") {
            return this._initNumber(number4, base, endian);
          }
          if (typeof number4 === "object") {
            return this._initArray(number4, base, endian);
          }
          if (base === "hex") {
            base = 16;
          }
          assert5(base === (base | 0) && base >= 2 && base <= 36);
          number4 = number4.toString().replace(/\s+/g, "");
          var start = 0;
          if (number4[0] === "-") {
            start++;
            this.negative = 1;
          }
          if (start < number4.length) {
            if (base === 16) {
              this._parseHex(number4, start, endian);
            } else {
              this._parseBase(number4, base, start);
              if (endian === "le") {
                this._initArray(this.toArray(), base, endian);
              }
            }
          }
        };
        BN2.prototype._initNumber = function _initNumber(number4, base, endian) {
          if (number4 < 0) {
            this.negative = 1;
            number4 = -number4;
          }
          if (number4 < 67108864) {
            this.words = [number4 & 67108863];
            this.length = 1;
          } else if (number4 < 4503599627370496) {
            this.words = [
              number4 & 67108863,
              number4 / 67108864 & 67108863
            ];
            this.length = 2;
          } else {
            assert5(number4 < 9007199254740992);
            this.words = [
              number4 & 67108863,
              number4 / 67108864 & 67108863,
              1
            ];
            this.length = 3;
          }
          if (endian !== "le")
            return;
          this._initArray(this.toArray(), base, endian);
        };
        BN2.prototype._initArray = function _initArray(number4, base, endian) {
          assert5(typeof number4.length === "number");
          if (number4.length <= 0) {
            this.words = [0];
            this.length = 1;
            return this;
          }
          this.length = Math.ceil(number4.length / 3);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var j, w;
          var off = 0;
          if (endian === "be") {
            for (i = number4.length - 1, j = 0; i >= 0; i -= 3) {
              w = number4[i] | number4[i - 1] << 8 | number4[i - 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          } else if (endian === "le") {
            for (i = 0, j = 0; i < number4.length; i += 3) {
              w = number4[i] | number4[i + 1] << 8 | number4[i + 2] << 16;
              this.words[j] |= w << off & 67108863;
              this.words[j + 1] = w >>> 26 - off & 67108863;
              off += 24;
              if (off >= 26) {
                off -= 26;
                j++;
              }
            }
          }
          return this.strip();
        };
        function parseHex4Bits(string2, index) {
          var c = string2.charCodeAt(index);
          if (c >= 65 && c <= 70) {
            return c - 55;
          } else if (c >= 97 && c <= 102) {
            return c - 87;
          } else {
            return c - 48 & 15;
          }
        }
        function parseHexByte(string2, lowerBound, index) {
          var r = parseHex4Bits(string2, index);
          if (index - 1 >= lowerBound) {
            r |= parseHex4Bits(string2, index - 1) << 4;
          }
          return r;
        }
        BN2.prototype._parseHex = function _parseHex(number4, start, endian) {
          this.length = Math.ceil((number4.length - start) / 6);
          this.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            this.words[i] = 0;
          }
          var off = 0;
          var j = 0;
          var w;
          if (endian === "be") {
            for (i = number4.length - 1; i >= start; i -= 2) {
              w = parseHexByte(number4, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          } else {
            var parseLength = number4.length - start;
            for (i = parseLength % 2 === 0 ? start + 1 : start; i < number4.length; i += 2) {
              w = parseHexByte(number4, start, i) << off;
              this.words[j] |= w & 67108863;
              if (off >= 18) {
                off -= 18;
                j += 1;
                this.words[j] |= w >>> 26;
              } else {
                off += 8;
              }
            }
          }
          this.strip();
        };
        function parseBase(str, start, end, mul) {
          var r = 0;
          var len = Math.min(str.length, end);
          for (var i = start; i < len; i++) {
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            if (c >= 49) {
              r += c - 49 + 10;
            } else if (c >= 17) {
              r += c - 17 + 10;
            } else {
              r += c;
            }
          }
          return r;
        }
        BN2.prototype._parseBase = function _parseBase(number4, base, start) {
          this.words = [0];
          this.length = 1;
          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
            limbLen++;
          }
          limbLen--;
          limbPow = limbPow / base | 0;
          var total = number4.length - start;
          var mod = total % limbLen;
          var end = Math.min(total, total - mod) + start;
          var word = 0;
          for (var i = start; i < end; i += limbLen) {
            word = parseBase(number4, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          if (mod !== 0) {
            var pow = 1;
            word = parseBase(number4, i, number4.length, base);
            for (i = 0; i < mod; i++) {
              pow *= base;
            }
            this.imuln(pow);
            if (this.words[0] + word < 67108864) {
              this.words[0] += word;
            } else {
              this._iaddn(word);
            }
          }
          this.strip();
        };
        BN2.prototype.copy = function copy(dest) {
          dest.words = new Array(this.length);
          for (var i = 0; i < this.length; i++) {
            dest.words[i] = this.words[i];
          }
          dest.length = this.length;
          dest.negative = this.negative;
          dest.red = this.red;
        };
        BN2.prototype.clone = function clone5() {
          var r = new BN2(null);
          this.copy(r);
          return r;
        };
        BN2.prototype._expand = function _expand(size) {
          while (this.length < size) {
            this.words[this.length++] = 0;
          }
          return this;
        };
        BN2.prototype.strip = function strip() {
          while (this.length > 1 && this.words[this.length - 1] === 0) {
            this.length--;
          }
          return this._normSign();
        };
        BN2.prototype._normSign = function _normSign() {
          if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
          }
          return this;
        };
        BN2.prototype.inspect = function inspect2() {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var zeros = [
          "",
          "0",
          "00",
          "000",
          "0000",
          "00000",
          "000000",
          "0000000",
          "00000000",
          "000000000",
          "0000000000",
          "00000000000",
          "000000000000",
          "0000000000000",
          "00000000000000",
          "000000000000000",
          "0000000000000000",
          "00000000000000000",
          "000000000000000000",
          "0000000000000000000",
          "00000000000000000000",
          "000000000000000000000",
          "0000000000000000000000",
          "00000000000000000000000",
          "000000000000000000000000",
          "0000000000000000000000000"
        ];
        var groupSizes = [
          0,
          0,
          25,
          16,
          12,
          11,
          10,
          9,
          8,
          8,
          7,
          7,
          7,
          7,
          6,
          6,
          6,
          6,
          6,
          6,
          6,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5
        ];
        var groupBases = [
          0,
          0,
          33554432,
          43046721,
          16777216,
          48828125,
          60466176,
          40353607,
          16777216,
          43046721,
          1e7,
          19487171,
          35831808,
          62748517,
          7529536,
          11390625,
          16777216,
          24137569,
          34012224,
          47045881,
          64e6,
          4084101,
          5153632,
          6436343,
          7962624,
          9765625,
          11881376,
          14348907,
          17210368,
          20511149,
          243e5,
          28629151,
          33554432,
          39135393,
          45435424,
          52521875,
          60466176
        ];
        BN2.prototype.toString = function toString3(base, padding) {
          base = base || 10;
          padding = padding | 0 || 1;
          var out;
          if (base === 16 || base === "hex") {
            out = "";
            var off = 0;
            var carry = 0;
            for (var i = 0; i < this.length; i++) {
              var w = this.words[i];
              var word = ((w << off | carry) & 16777215).toString(16);
              carry = w >>> 24 - off & 16777215;
              if (carry !== 0 || i !== this.length - 1) {
                out = zeros[6 - word.length] + word + out;
              } else {
                out = word + out;
              }
              off += 2;
              if (off >= 26) {
                off -= 26;
                i--;
              }
            }
            if (carry !== 0) {
              out = carry.toString(16) + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          if (base === (base | 0) && base >= 2 && base <= 36) {
            var groupSize = groupSizes[base];
            var groupBase = groupBases[base];
            out = "";
            var c = this.clone();
            c.negative = 0;
            while (!c.isZero()) {
              var r = c.modn(groupBase).toString(base);
              c = c.idivn(groupBase);
              if (!c.isZero()) {
                out = zeros[groupSize - r.length] + r + out;
              } else {
                out = r + out;
              }
            }
            if (this.isZero()) {
              out = "0" + out;
            }
            while (out.length % padding !== 0) {
              out = "0" + out;
            }
            if (this.negative !== 0) {
              out = "-" + out;
            }
            return out;
          }
          assert5(false, "Base should be between 2 and 36");
        };
        BN2.prototype.toNumber = function toNumber3() {
          var ret3 = this.words[0];
          if (this.length === 2) {
            ret3 += this.words[1] * 67108864;
          } else if (this.length === 3 && this.words[2] === 1) {
            ret3 += 4503599627370496 + this.words[1] * 67108864;
          } else if (this.length > 2) {
            assert5(false, "Number can only safely store up to 53 bits");
          }
          return this.negative !== 0 ? -ret3 : ret3;
        };
        BN2.prototype.toJSON = function toJSON() {
          return this.toString(16);
        };
        BN2.prototype.toBuffer = function toBuffer(endian, length) {
          assert5(typeof Buffer2 !== "undefined");
          return this.toArrayLike(Buffer2, endian, length);
        };
        BN2.prototype.toArray = function toArray2(endian, length) {
          return this.toArrayLike(Array, endian, length);
        };
        BN2.prototype.toArrayLike = function toArrayLike(ArrayType4, endian, length) {
          var byteLength = this.byteLength();
          var reqLength = length || Math.max(1, byteLength);
          assert5(byteLength <= reqLength, "byte array longer than desired length");
          assert5(reqLength > 0, "Requested array length <= 0");
          this.strip();
          var littleEndian = endian === "le";
          var res = new ArrayType4(reqLength);
          var b, i;
          var q = this.clone();
          if (!littleEndian) {
            for (i = 0; i < reqLength - byteLength; i++) {
              res[i] = 0;
            }
            for (i = 0; !q.isZero(); i++) {
              b = q.andln(255);
              q.iushrn(8);
              res[reqLength - i - 1] = b;
            }
          } else {
            for (i = 0; !q.isZero(); i++) {
              b = q.andln(255);
              q.iushrn(8);
              res[i] = b;
            }
            for (; i < reqLength; i++) {
              res[i] = 0;
            }
          }
          return res;
        };
        if (Math.clz32) {
          BN2.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
          };
        } else {
          BN2.prototype._countBits = function _countBits(w) {
            var t = w;
            var r = 0;
            if (t >= 4096) {
              r += 13;
              t >>>= 13;
            }
            if (t >= 64) {
              r += 7;
              t >>>= 7;
            }
            if (t >= 8) {
              r += 4;
              t >>>= 4;
            }
            if (t >= 2) {
              r += 2;
              t >>>= 2;
            }
            return r + t;
          };
        }
        BN2.prototype._zeroBits = function _zeroBits(w) {
          if (w === 0)
            return 26;
          var t = w;
          var r = 0;
          if ((t & 8191) === 0) {
            r += 13;
            t >>>= 13;
          }
          if ((t & 127) === 0) {
            r += 7;
            t >>>= 7;
          }
          if ((t & 15) === 0) {
            r += 4;
            t >>>= 4;
          }
          if ((t & 3) === 0) {
            r += 2;
            t >>>= 2;
          }
          if ((t & 1) === 0) {
            r++;
          }
          return r;
        };
        BN2.prototype.bitLength = function bitLength() {
          var w = this.words[this.length - 1];
          var hi = this._countBits(w);
          return (this.length - 1) * 26 + hi;
        };
        function toBitArray(num) {
          var w = new Array(num.bitLength());
          for (var bit = 0; bit < w.length; bit++) {
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
          }
          return w;
        }
        BN2.prototype.zeroBits = function zeroBits() {
          if (this.isZero())
            return 0;
          var r = 0;
          for (var i = 0; i < this.length; i++) {
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26)
              break;
          }
          return r;
        };
        BN2.prototype.byteLength = function byteLength() {
          return Math.ceil(this.bitLength() / 8);
        };
        BN2.prototype.toTwos = function toTwos2(width) {
          if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
          }
          return this.clone();
        };
        BN2.prototype.fromTwos = function fromTwos2(width) {
          if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
          }
          return this.clone();
        };
        BN2.prototype.isNeg = function isNeg() {
          return this.negative !== 0;
        };
        BN2.prototype.neg = function neg() {
          return this.clone().ineg();
        };
        BN2.prototype.ineg = function ineg() {
          if (!this.isZero()) {
            this.negative ^= 1;
          }
          return this;
        };
        BN2.prototype.iuor = function iuor(num) {
          while (this.length < num.length) {
            this.words[this.length++] = 0;
          }
          for (var i = 0; i < num.length; i++) {
            this.words[i] = this.words[i] | num.words[i];
          }
          return this.strip();
        };
        BN2.prototype.ior = function ior(num) {
          assert5((this.negative | num.negative) === 0);
          return this.iuor(num);
        };
        BN2.prototype.or = function or(num) {
          if (this.length > num.length)
            return this.clone().ior(num);
          return num.clone().ior(this);
        };
        BN2.prototype.uor = function uor(num) {
          if (this.length > num.length)
            return this.clone().iuor(num);
          return num.clone().iuor(this);
        };
        BN2.prototype.iuand = function iuand(num) {
          var b;
          if (this.length > num.length) {
            b = num;
          } else {
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = this.words[i] & num.words[i];
          }
          this.length = b.length;
          return this.strip();
        };
        BN2.prototype.iand = function iand(num) {
          assert5((this.negative | num.negative) === 0);
          return this.iuand(num);
        };
        BN2.prototype.and = function and(num) {
          if (this.length > num.length)
            return this.clone().iand(num);
          return num.clone().iand(this);
        };
        BN2.prototype.uand = function uand(num) {
          if (this.length > num.length)
            return this.clone().iuand(num);
          return num.clone().iuand(this);
        };
        BN2.prototype.iuxor = function iuxor(num) {
          var a;
          var b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          for (var i = 0; i < b.length; i++) {
            this.words[i] = a.words[i] ^ b.words[i];
          }
          if (this !== a) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = a.length;
          return this.strip();
        };
        BN2.prototype.ixor = function ixor(num) {
          assert5((this.negative | num.negative) === 0);
          return this.iuxor(num);
        };
        BN2.prototype.xor = function xor(num) {
          if (this.length > num.length)
            return this.clone().ixor(num);
          return num.clone().ixor(this);
        };
        BN2.prototype.uxor = function uxor(num) {
          if (this.length > num.length)
            return this.clone().iuxor(num);
          return num.clone().iuxor(this);
        };
        BN2.prototype.inotn = function inotn(width) {
          assert5(typeof width === "number" && width >= 0);
          var bytesNeeded = Math.ceil(width / 26) | 0;
          var bitsLeft = width % 26;
          this._expand(bytesNeeded);
          if (bitsLeft > 0) {
            bytesNeeded--;
          }
          for (var i = 0; i < bytesNeeded; i++) {
            this.words[i] = ~this.words[i] & 67108863;
          }
          if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
          }
          return this.strip();
        };
        BN2.prototype.notn = function notn(width) {
          return this.clone().inotn(width);
        };
        BN2.prototype.setn = function setn(bit, val) {
          assert5(typeof bit === "number" && bit >= 0);
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          this._expand(off + 1);
          if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
          } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
          }
          return this.strip();
        };
        BN2.prototype.iadd = function iadd(num) {
          var r;
          if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
          } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
          }
          var a, b;
          if (this.length > num.length) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 67108863;
            carry = r >>> 26;
          }
          this.length = a.length;
          if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
          } else if (a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          return this;
        };
        BN2.prototype.add = function add3(num) {
          var res;
          if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
          } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
          }
          if (this.length > num.length)
            return this.clone().iadd(num);
          return num.clone().iadd(this);
        };
        BN2.prototype.isub = function isub(num) {
          if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
          } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
          }
          var cmp = this.cmp(num);
          if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
          }
          var a, b;
          if (cmp > 0) {
            a = this;
            b = num;
          } else {
            a = num;
            b = this;
          }
          var carry = 0;
          for (var i = 0; i < b.length; i++) {
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          for (; carry !== 0 && i < a.length; i++) {
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 67108863;
          }
          if (carry === 0 && i < a.length && a !== this) {
            for (; i < a.length; i++) {
              this.words[i] = a.words[i];
            }
          }
          this.length = Math.max(this.length, i);
          if (a !== this) {
            this.negative = 1;
          }
          return this.strip();
        };
        BN2.prototype.sub = function sub(num) {
          return this.clone().isub(num);
        };
        function smallMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          var len = self2.length + num.length | 0;
          out.length = len;
          len = len - 1 | 0;
          var a = self2.words[0] | 0;
          var b = num.words[0] | 0;
          var r = a * b;
          var lo = r & 67108863;
          var carry = r / 67108864 | 0;
          out.words[0] = lo;
          for (var k = 1; k < len; k++) {
            var ncarry = carry >>> 26;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j | 0;
              a = self2.words[i] | 0;
              b = num.words[j] | 0;
              r = a * b + rword;
              ncarry += r / 67108864 | 0;
              rword = r & 67108863;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
          }
          if (carry !== 0) {
            out.words[k] = carry | 0;
          } else {
            out.length--;
          }
          return out.strip();
        }
        var comb10MulTo = function comb10MulTo2(self2, num, out) {
          var a = self2.words;
          var b = num.words;
          var o = out.words;
          var c = 0;
          var lo;
          var mid;
          var hi;
          var a0 = a[0] | 0;
          var al0 = a0 & 8191;
          var ah0 = a0 >>> 13;
          var a1 = a[1] | 0;
          var al1 = a1 & 8191;
          var ah1 = a1 >>> 13;
          var a2 = a[2] | 0;
          var al2 = a2 & 8191;
          var ah2 = a2 >>> 13;
          var a3 = a[3] | 0;
          var al3 = a3 & 8191;
          var ah3 = a3 >>> 13;
          var a4 = a[4] | 0;
          var al4 = a4 & 8191;
          var ah4 = a4 >>> 13;
          var a5 = a[5] | 0;
          var al5 = a5 & 8191;
          var ah5 = a5 >>> 13;
          var a6 = a[6] | 0;
          var al6 = a6 & 8191;
          var ah6 = a6 >>> 13;
          var a7 = a[7] | 0;
          var al7 = a7 & 8191;
          var ah7 = a7 >>> 13;
          var a8 = a[8] | 0;
          var al8 = a8 & 8191;
          var ah8 = a8 >>> 13;
          var a9 = a[9] | 0;
          var al9 = a9 & 8191;
          var ah9 = a9 >>> 13;
          var b0 = b[0] | 0;
          var bl0 = b0 & 8191;
          var bh0 = b0 >>> 13;
          var b1 = b[1] | 0;
          var bl1 = b1 & 8191;
          var bh1 = b1 >>> 13;
          var b2 = b[2] | 0;
          var bl2 = b2 & 8191;
          var bh2 = b2 >>> 13;
          var b3 = b[3] | 0;
          var bl3 = b3 & 8191;
          var bh3 = b3 >>> 13;
          var b4 = b[4] | 0;
          var bl4 = b4 & 8191;
          var bh4 = b4 >>> 13;
          var b5 = b[5] | 0;
          var bl5 = b5 & 8191;
          var bh5 = b5 >>> 13;
          var b6 = b[6] | 0;
          var bl6 = b6 & 8191;
          var bh6 = b6 >>> 13;
          var b7 = b[7] | 0;
          var bl7 = b7 & 8191;
          var bh7 = b7 >>> 13;
          var b8 = b[8] | 0;
          var bl8 = b8 & 8191;
          var bh8 = b8 >>> 13;
          var b9 = b[9] | 0;
          var bl9 = b9 & 8191;
          var bh9 = b9 >>> 13;
          out.negative = self2.negative ^ num.negative;
          out.length = 19;
          lo = Math.imul(al0, bl0);
          mid = Math.imul(al0, bh0);
          mid = mid + Math.imul(ah0, bl0) | 0;
          hi = Math.imul(ah0, bh0);
          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
          w0 &= 67108863;
          lo = Math.imul(al1, bl0);
          mid = Math.imul(al1, bh0);
          mid = mid + Math.imul(ah1, bl0) | 0;
          hi = Math.imul(ah1, bh0);
          lo = lo + Math.imul(al0, bl1) | 0;
          mid = mid + Math.imul(al0, bh1) | 0;
          mid = mid + Math.imul(ah0, bl1) | 0;
          hi = hi + Math.imul(ah0, bh1) | 0;
          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
          w1 &= 67108863;
          lo = Math.imul(al2, bl0);
          mid = Math.imul(al2, bh0);
          mid = mid + Math.imul(ah2, bl0) | 0;
          hi = Math.imul(ah2, bh0);
          lo = lo + Math.imul(al1, bl1) | 0;
          mid = mid + Math.imul(al1, bh1) | 0;
          mid = mid + Math.imul(ah1, bl1) | 0;
          hi = hi + Math.imul(ah1, bh1) | 0;
          lo = lo + Math.imul(al0, bl2) | 0;
          mid = mid + Math.imul(al0, bh2) | 0;
          mid = mid + Math.imul(ah0, bl2) | 0;
          hi = hi + Math.imul(ah0, bh2) | 0;
          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
          w2 &= 67108863;
          lo = Math.imul(al3, bl0);
          mid = Math.imul(al3, bh0);
          mid = mid + Math.imul(ah3, bl0) | 0;
          hi = Math.imul(ah3, bh0);
          lo = lo + Math.imul(al2, bl1) | 0;
          mid = mid + Math.imul(al2, bh1) | 0;
          mid = mid + Math.imul(ah2, bl1) | 0;
          hi = hi + Math.imul(ah2, bh1) | 0;
          lo = lo + Math.imul(al1, bl2) | 0;
          mid = mid + Math.imul(al1, bh2) | 0;
          mid = mid + Math.imul(ah1, bl2) | 0;
          hi = hi + Math.imul(ah1, bh2) | 0;
          lo = lo + Math.imul(al0, bl3) | 0;
          mid = mid + Math.imul(al0, bh3) | 0;
          mid = mid + Math.imul(ah0, bl3) | 0;
          hi = hi + Math.imul(ah0, bh3) | 0;
          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
          w3 &= 67108863;
          lo = Math.imul(al4, bl0);
          mid = Math.imul(al4, bh0);
          mid = mid + Math.imul(ah4, bl0) | 0;
          hi = Math.imul(ah4, bh0);
          lo = lo + Math.imul(al3, bl1) | 0;
          mid = mid + Math.imul(al3, bh1) | 0;
          mid = mid + Math.imul(ah3, bl1) | 0;
          hi = hi + Math.imul(ah3, bh1) | 0;
          lo = lo + Math.imul(al2, bl2) | 0;
          mid = mid + Math.imul(al2, bh2) | 0;
          mid = mid + Math.imul(ah2, bl2) | 0;
          hi = hi + Math.imul(ah2, bh2) | 0;
          lo = lo + Math.imul(al1, bl3) | 0;
          mid = mid + Math.imul(al1, bh3) | 0;
          mid = mid + Math.imul(ah1, bl3) | 0;
          hi = hi + Math.imul(ah1, bh3) | 0;
          lo = lo + Math.imul(al0, bl4) | 0;
          mid = mid + Math.imul(al0, bh4) | 0;
          mid = mid + Math.imul(ah0, bl4) | 0;
          hi = hi + Math.imul(ah0, bh4) | 0;
          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
          w4 &= 67108863;
          lo = Math.imul(al5, bl0);
          mid = Math.imul(al5, bh0);
          mid = mid + Math.imul(ah5, bl0) | 0;
          hi = Math.imul(ah5, bh0);
          lo = lo + Math.imul(al4, bl1) | 0;
          mid = mid + Math.imul(al4, bh1) | 0;
          mid = mid + Math.imul(ah4, bl1) | 0;
          hi = hi + Math.imul(ah4, bh1) | 0;
          lo = lo + Math.imul(al3, bl2) | 0;
          mid = mid + Math.imul(al3, bh2) | 0;
          mid = mid + Math.imul(ah3, bl2) | 0;
          hi = hi + Math.imul(ah3, bh2) | 0;
          lo = lo + Math.imul(al2, bl3) | 0;
          mid = mid + Math.imul(al2, bh3) | 0;
          mid = mid + Math.imul(ah2, bl3) | 0;
          hi = hi + Math.imul(ah2, bh3) | 0;
          lo = lo + Math.imul(al1, bl4) | 0;
          mid = mid + Math.imul(al1, bh4) | 0;
          mid = mid + Math.imul(ah1, bl4) | 0;
          hi = hi + Math.imul(ah1, bh4) | 0;
          lo = lo + Math.imul(al0, bl5) | 0;
          mid = mid + Math.imul(al0, bh5) | 0;
          mid = mid + Math.imul(ah0, bl5) | 0;
          hi = hi + Math.imul(ah0, bh5) | 0;
          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
          w5 &= 67108863;
          lo = Math.imul(al6, bl0);
          mid = Math.imul(al6, bh0);
          mid = mid + Math.imul(ah6, bl0) | 0;
          hi = Math.imul(ah6, bh0);
          lo = lo + Math.imul(al5, bl1) | 0;
          mid = mid + Math.imul(al5, bh1) | 0;
          mid = mid + Math.imul(ah5, bl1) | 0;
          hi = hi + Math.imul(ah5, bh1) | 0;
          lo = lo + Math.imul(al4, bl2) | 0;
          mid = mid + Math.imul(al4, bh2) | 0;
          mid = mid + Math.imul(ah4, bl2) | 0;
          hi = hi + Math.imul(ah4, bh2) | 0;
          lo = lo + Math.imul(al3, bl3) | 0;
          mid = mid + Math.imul(al3, bh3) | 0;
          mid = mid + Math.imul(ah3, bl3) | 0;
          hi = hi + Math.imul(ah3, bh3) | 0;
          lo = lo + Math.imul(al2, bl4) | 0;
          mid = mid + Math.imul(al2, bh4) | 0;
          mid = mid + Math.imul(ah2, bl4) | 0;
          hi = hi + Math.imul(ah2, bh4) | 0;
          lo = lo + Math.imul(al1, bl5) | 0;
          mid = mid + Math.imul(al1, bh5) | 0;
          mid = mid + Math.imul(ah1, bl5) | 0;
          hi = hi + Math.imul(ah1, bh5) | 0;
          lo = lo + Math.imul(al0, bl6) | 0;
          mid = mid + Math.imul(al0, bh6) | 0;
          mid = mid + Math.imul(ah0, bl6) | 0;
          hi = hi + Math.imul(ah0, bh6) | 0;
          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
          w6 &= 67108863;
          lo = Math.imul(al7, bl0);
          mid = Math.imul(al7, bh0);
          mid = mid + Math.imul(ah7, bl0) | 0;
          hi = Math.imul(ah7, bh0);
          lo = lo + Math.imul(al6, bl1) | 0;
          mid = mid + Math.imul(al6, bh1) | 0;
          mid = mid + Math.imul(ah6, bl1) | 0;
          hi = hi + Math.imul(ah6, bh1) | 0;
          lo = lo + Math.imul(al5, bl2) | 0;
          mid = mid + Math.imul(al5, bh2) | 0;
          mid = mid + Math.imul(ah5, bl2) | 0;
          hi = hi + Math.imul(ah5, bh2) | 0;
          lo = lo + Math.imul(al4, bl3) | 0;
          mid = mid + Math.imul(al4, bh3) | 0;
          mid = mid + Math.imul(ah4, bl3) | 0;
          hi = hi + Math.imul(ah4, bh3) | 0;
          lo = lo + Math.imul(al3, bl4) | 0;
          mid = mid + Math.imul(al3, bh4) | 0;
          mid = mid + Math.imul(ah3, bl4) | 0;
          hi = hi + Math.imul(ah3, bh4) | 0;
          lo = lo + Math.imul(al2, bl5) | 0;
          mid = mid + Math.imul(al2, bh5) | 0;
          mid = mid + Math.imul(ah2, bl5) | 0;
          hi = hi + Math.imul(ah2, bh5) | 0;
          lo = lo + Math.imul(al1, bl6) | 0;
          mid = mid + Math.imul(al1, bh6) | 0;
          mid = mid + Math.imul(ah1, bl6) | 0;
          hi = hi + Math.imul(ah1, bh6) | 0;
          lo = lo + Math.imul(al0, bl7) | 0;
          mid = mid + Math.imul(al0, bh7) | 0;
          mid = mid + Math.imul(ah0, bl7) | 0;
          hi = hi + Math.imul(ah0, bh7) | 0;
          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
          w7 &= 67108863;
          lo = Math.imul(al8, bl0);
          mid = Math.imul(al8, bh0);
          mid = mid + Math.imul(ah8, bl0) | 0;
          hi = Math.imul(ah8, bh0);
          lo = lo + Math.imul(al7, bl1) | 0;
          mid = mid + Math.imul(al7, bh1) | 0;
          mid = mid + Math.imul(ah7, bl1) | 0;
          hi = hi + Math.imul(ah7, bh1) | 0;
          lo = lo + Math.imul(al6, bl2) | 0;
          mid = mid + Math.imul(al6, bh2) | 0;
          mid = mid + Math.imul(ah6, bl2) | 0;
          hi = hi + Math.imul(ah6, bh2) | 0;
          lo = lo + Math.imul(al5, bl3) | 0;
          mid = mid + Math.imul(al5, bh3) | 0;
          mid = mid + Math.imul(ah5, bl3) | 0;
          hi = hi + Math.imul(ah5, bh3) | 0;
          lo = lo + Math.imul(al4, bl4) | 0;
          mid = mid + Math.imul(al4, bh4) | 0;
          mid = mid + Math.imul(ah4, bl4) | 0;
          hi = hi + Math.imul(ah4, bh4) | 0;
          lo = lo + Math.imul(al3, bl5) | 0;
          mid = mid + Math.imul(al3, bh5) | 0;
          mid = mid + Math.imul(ah3, bl5) | 0;
          hi = hi + Math.imul(ah3, bh5) | 0;
          lo = lo + Math.imul(al2, bl6) | 0;
          mid = mid + Math.imul(al2, bh6) | 0;
          mid = mid + Math.imul(ah2, bl6) | 0;
          hi = hi + Math.imul(ah2, bh6) | 0;
          lo = lo + Math.imul(al1, bl7) | 0;
          mid = mid + Math.imul(al1, bh7) | 0;
          mid = mid + Math.imul(ah1, bl7) | 0;
          hi = hi + Math.imul(ah1, bh7) | 0;
          lo = lo + Math.imul(al0, bl8) | 0;
          mid = mid + Math.imul(al0, bh8) | 0;
          mid = mid + Math.imul(ah0, bl8) | 0;
          hi = hi + Math.imul(ah0, bh8) | 0;
          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
          w8 &= 67108863;
          lo = Math.imul(al9, bl0);
          mid = Math.imul(al9, bh0);
          mid = mid + Math.imul(ah9, bl0) | 0;
          hi = Math.imul(ah9, bh0);
          lo = lo + Math.imul(al8, bl1) | 0;
          mid = mid + Math.imul(al8, bh1) | 0;
          mid = mid + Math.imul(ah8, bl1) | 0;
          hi = hi + Math.imul(ah8, bh1) | 0;
          lo = lo + Math.imul(al7, bl2) | 0;
          mid = mid + Math.imul(al7, bh2) | 0;
          mid = mid + Math.imul(ah7, bl2) | 0;
          hi = hi + Math.imul(ah7, bh2) | 0;
          lo = lo + Math.imul(al6, bl3) | 0;
          mid = mid + Math.imul(al6, bh3) | 0;
          mid = mid + Math.imul(ah6, bl3) | 0;
          hi = hi + Math.imul(ah6, bh3) | 0;
          lo = lo + Math.imul(al5, bl4) | 0;
          mid = mid + Math.imul(al5, bh4) | 0;
          mid = mid + Math.imul(ah5, bl4) | 0;
          hi = hi + Math.imul(ah5, bh4) | 0;
          lo = lo + Math.imul(al4, bl5) | 0;
          mid = mid + Math.imul(al4, bh5) | 0;
          mid = mid + Math.imul(ah4, bl5) | 0;
          hi = hi + Math.imul(ah4, bh5) | 0;
          lo = lo + Math.imul(al3, bl6) | 0;
          mid = mid + Math.imul(al3, bh6) | 0;
          mid = mid + Math.imul(ah3, bl6) | 0;
          hi = hi + Math.imul(ah3, bh6) | 0;
          lo = lo + Math.imul(al2, bl7) | 0;
          mid = mid + Math.imul(al2, bh7) | 0;
          mid = mid + Math.imul(ah2, bl7) | 0;
          hi = hi + Math.imul(ah2, bh7) | 0;
          lo = lo + Math.imul(al1, bl8) | 0;
          mid = mid + Math.imul(al1, bh8) | 0;
          mid = mid + Math.imul(ah1, bl8) | 0;
          hi = hi + Math.imul(ah1, bh8) | 0;
          lo = lo + Math.imul(al0, bl9) | 0;
          mid = mid + Math.imul(al0, bh9) | 0;
          mid = mid + Math.imul(ah0, bl9) | 0;
          hi = hi + Math.imul(ah0, bh9) | 0;
          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
          w9 &= 67108863;
          lo = Math.imul(al9, bl1);
          mid = Math.imul(al9, bh1);
          mid = mid + Math.imul(ah9, bl1) | 0;
          hi = Math.imul(ah9, bh1);
          lo = lo + Math.imul(al8, bl2) | 0;
          mid = mid + Math.imul(al8, bh2) | 0;
          mid = mid + Math.imul(ah8, bl2) | 0;
          hi = hi + Math.imul(ah8, bh2) | 0;
          lo = lo + Math.imul(al7, bl3) | 0;
          mid = mid + Math.imul(al7, bh3) | 0;
          mid = mid + Math.imul(ah7, bl3) | 0;
          hi = hi + Math.imul(ah7, bh3) | 0;
          lo = lo + Math.imul(al6, bl4) | 0;
          mid = mid + Math.imul(al6, bh4) | 0;
          mid = mid + Math.imul(ah6, bl4) | 0;
          hi = hi + Math.imul(ah6, bh4) | 0;
          lo = lo + Math.imul(al5, bl5) | 0;
          mid = mid + Math.imul(al5, bh5) | 0;
          mid = mid + Math.imul(ah5, bl5) | 0;
          hi = hi + Math.imul(ah5, bh5) | 0;
          lo = lo + Math.imul(al4, bl6) | 0;
          mid = mid + Math.imul(al4, bh6) | 0;
          mid = mid + Math.imul(ah4, bl6) | 0;
          hi = hi + Math.imul(ah4, bh6) | 0;
          lo = lo + Math.imul(al3, bl7) | 0;
          mid = mid + Math.imul(al3, bh7) | 0;
          mid = mid + Math.imul(ah3, bl7) | 0;
          hi = hi + Math.imul(ah3, bh7) | 0;
          lo = lo + Math.imul(al2, bl8) | 0;
          mid = mid + Math.imul(al2, bh8) | 0;
          mid = mid + Math.imul(ah2, bl8) | 0;
          hi = hi + Math.imul(ah2, bh8) | 0;
          lo = lo + Math.imul(al1, bl9) | 0;
          mid = mid + Math.imul(al1, bh9) | 0;
          mid = mid + Math.imul(ah1, bl9) | 0;
          hi = hi + Math.imul(ah1, bh9) | 0;
          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
          w10 &= 67108863;
          lo = Math.imul(al9, bl2);
          mid = Math.imul(al9, bh2);
          mid = mid + Math.imul(ah9, bl2) | 0;
          hi = Math.imul(ah9, bh2);
          lo = lo + Math.imul(al8, bl3) | 0;
          mid = mid + Math.imul(al8, bh3) | 0;
          mid = mid + Math.imul(ah8, bl3) | 0;
          hi = hi + Math.imul(ah8, bh3) | 0;
          lo = lo + Math.imul(al7, bl4) | 0;
          mid = mid + Math.imul(al7, bh4) | 0;
          mid = mid + Math.imul(ah7, bl4) | 0;
          hi = hi + Math.imul(ah7, bh4) | 0;
          lo = lo + Math.imul(al6, bl5) | 0;
          mid = mid + Math.imul(al6, bh5) | 0;
          mid = mid + Math.imul(ah6, bl5) | 0;
          hi = hi + Math.imul(ah6, bh5) | 0;
          lo = lo + Math.imul(al5, bl6) | 0;
          mid = mid + Math.imul(al5, bh6) | 0;
          mid = mid + Math.imul(ah5, bl6) | 0;
          hi = hi + Math.imul(ah5, bh6) | 0;
          lo = lo + Math.imul(al4, bl7) | 0;
          mid = mid + Math.imul(al4, bh7) | 0;
          mid = mid + Math.imul(ah4, bl7) | 0;
          hi = hi + Math.imul(ah4, bh7) | 0;
          lo = lo + Math.imul(al3, bl8) | 0;
          mid = mid + Math.imul(al3, bh8) | 0;
          mid = mid + Math.imul(ah3, bl8) | 0;
          hi = hi + Math.imul(ah3, bh8) | 0;
          lo = lo + Math.imul(al2, bl9) | 0;
          mid = mid + Math.imul(al2, bh9) | 0;
          mid = mid + Math.imul(ah2, bl9) | 0;
          hi = hi + Math.imul(ah2, bh9) | 0;
          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
          w11 &= 67108863;
          lo = Math.imul(al9, bl3);
          mid = Math.imul(al9, bh3);
          mid = mid + Math.imul(ah9, bl3) | 0;
          hi = Math.imul(ah9, bh3);
          lo = lo + Math.imul(al8, bl4) | 0;
          mid = mid + Math.imul(al8, bh4) | 0;
          mid = mid + Math.imul(ah8, bl4) | 0;
          hi = hi + Math.imul(ah8, bh4) | 0;
          lo = lo + Math.imul(al7, bl5) | 0;
          mid = mid + Math.imul(al7, bh5) | 0;
          mid = mid + Math.imul(ah7, bl5) | 0;
          hi = hi + Math.imul(ah7, bh5) | 0;
          lo = lo + Math.imul(al6, bl6) | 0;
          mid = mid + Math.imul(al6, bh6) | 0;
          mid = mid + Math.imul(ah6, bl6) | 0;
          hi = hi + Math.imul(ah6, bh6) | 0;
          lo = lo + Math.imul(al5, bl7) | 0;
          mid = mid + Math.imul(al5, bh7) | 0;
          mid = mid + Math.imul(ah5, bl7) | 0;
          hi = hi + Math.imul(ah5, bh7) | 0;
          lo = lo + Math.imul(al4, bl8) | 0;
          mid = mid + Math.imul(al4, bh8) | 0;
          mid = mid + Math.imul(ah4, bl8) | 0;
          hi = hi + Math.imul(ah4, bh8) | 0;
          lo = lo + Math.imul(al3, bl9) | 0;
          mid = mid + Math.imul(al3, bh9) | 0;
          mid = mid + Math.imul(ah3, bl9) | 0;
          hi = hi + Math.imul(ah3, bh9) | 0;
          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
          w12 &= 67108863;
          lo = Math.imul(al9, bl4);
          mid = Math.imul(al9, bh4);
          mid = mid + Math.imul(ah9, bl4) | 0;
          hi = Math.imul(ah9, bh4);
          lo = lo + Math.imul(al8, bl5) | 0;
          mid = mid + Math.imul(al8, bh5) | 0;
          mid = mid + Math.imul(ah8, bl5) | 0;
          hi = hi + Math.imul(ah8, bh5) | 0;
          lo = lo + Math.imul(al7, bl6) | 0;
          mid = mid + Math.imul(al7, bh6) | 0;
          mid = mid + Math.imul(ah7, bl6) | 0;
          hi = hi + Math.imul(ah7, bh6) | 0;
          lo = lo + Math.imul(al6, bl7) | 0;
          mid = mid + Math.imul(al6, bh7) | 0;
          mid = mid + Math.imul(ah6, bl7) | 0;
          hi = hi + Math.imul(ah6, bh7) | 0;
          lo = lo + Math.imul(al5, bl8) | 0;
          mid = mid + Math.imul(al5, bh8) | 0;
          mid = mid + Math.imul(ah5, bl8) | 0;
          hi = hi + Math.imul(ah5, bh8) | 0;
          lo = lo + Math.imul(al4, bl9) | 0;
          mid = mid + Math.imul(al4, bh9) | 0;
          mid = mid + Math.imul(ah4, bl9) | 0;
          hi = hi + Math.imul(ah4, bh9) | 0;
          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
          w13 &= 67108863;
          lo = Math.imul(al9, bl5);
          mid = Math.imul(al9, bh5);
          mid = mid + Math.imul(ah9, bl5) | 0;
          hi = Math.imul(ah9, bh5);
          lo = lo + Math.imul(al8, bl6) | 0;
          mid = mid + Math.imul(al8, bh6) | 0;
          mid = mid + Math.imul(ah8, bl6) | 0;
          hi = hi + Math.imul(ah8, bh6) | 0;
          lo = lo + Math.imul(al7, bl7) | 0;
          mid = mid + Math.imul(al7, bh7) | 0;
          mid = mid + Math.imul(ah7, bl7) | 0;
          hi = hi + Math.imul(ah7, bh7) | 0;
          lo = lo + Math.imul(al6, bl8) | 0;
          mid = mid + Math.imul(al6, bh8) | 0;
          mid = mid + Math.imul(ah6, bl8) | 0;
          hi = hi + Math.imul(ah6, bh8) | 0;
          lo = lo + Math.imul(al5, bl9) | 0;
          mid = mid + Math.imul(al5, bh9) | 0;
          mid = mid + Math.imul(ah5, bl9) | 0;
          hi = hi + Math.imul(ah5, bh9) | 0;
          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
          w14 &= 67108863;
          lo = Math.imul(al9, bl6);
          mid = Math.imul(al9, bh6);
          mid = mid + Math.imul(ah9, bl6) | 0;
          hi = Math.imul(ah9, bh6);
          lo = lo + Math.imul(al8, bl7) | 0;
          mid = mid + Math.imul(al8, bh7) | 0;
          mid = mid + Math.imul(ah8, bl7) | 0;
          hi = hi + Math.imul(ah8, bh7) | 0;
          lo = lo + Math.imul(al7, bl8) | 0;
          mid = mid + Math.imul(al7, bh8) | 0;
          mid = mid + Math.imul(ah7, bl8) | 0;
          hi = hi + Math.imul(ah7, bh8) | 0;
          lo = lo + Math.imul(al6, bl9) | 0;
          mid = mid + Math.imul(al6, bh9) | 0;
          mid = mid + Math.imul(ah6, bl9) | 0;
          hi = hi + Math.imul(ah6, bh9) | 0;
          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
          w15 &= 67108863;
          lo = Math.imul(al9, bl7);
          mid = Math.imul(al9, bh7);
          mid = mid + Math.imul(ah9, bl7) | 0;
          hi = Math.imul(ah9, bh7);
          lo = lo + Math.imul(al8, bl8) | 0;
          mid = mid + Math.imul(al8, bh8) | 0;
          mid = mid + Math.imul(ah8, bl8) | 0;
          hi = hi + Math.imul(ah8, bh8) | 0;
          lo = lo + Math.imul(al7, bl9) | 0;
          mid = mid + Math.imul(al7, bh9) | 0;
          mid = mid + Math.imul(ah7, bl9) | 0;
          hi = hi + Math.imul(ah7, bh9) | 0;
          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
          w16 &= 67108863;
          lo = Math.imul(al9, bl8);
          mid = Math.imul(al9, bh8);
          mid = mid + Math.imul(ah9, bl8) | 0;
          hi = Math.imul(ah9, bh8);
          lo = lo + Math.imul(al8, bl9) | 0;
          mid = mid + Math.imul(al8, bh9) | 0;
          mid = mid + Math.imul(ah8, bl9) | 0;
          hi = hi + Math.imul(ah8, bh9) | 0;
          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
          w17 &= 67108863;
          lo = Math.imul(al9, bl9);
          mid = Math.imul(al9, bh9);
          mid = mid + Math.imul(ah9, bl9) | 0;
          hi = Math.imul(ah9, bh9);
          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
          c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
          w18 &= 67108863;
          o[0] = w0;
          o[1] = w1;
          o[2] = w2;
          o[3] = w3;
          o[4] = w4;
          o[5] = w5;
          o[6] = w6;
          o[7] = w7;
          o[8] = w8;
          o[9] = w9;
          o[10] = w10;
          o[11] = w11;
          o[12] = w12;
          o[13] = w13;
          o[14] = w14;
          o[15] = w15;
          o[16] = w16;
          o[17] = w17;
          o[18] = w18;
          if (c !== 0) {
            o[19] = c;
            out.length++;
          }
          return out;
        };
        if (!Math.imul) {
          comb10MulTo = smallMulTo;
        }
        function bigMulTo(self2, num, out) {
          out.negative = num.negative ^ self2.negative;
          out.length = self2.length + num.length;
          var carry = 0;
          var hncarry = 0;
          for (var k = 0; k < out.length - 1; k++) {
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 67108863;
            var maxJ = Math.min(k, num.length - 1);
            for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
              var i = k - j;
              var a = self2.words[i] | 0;
              var b = num.words[j] | 0;
              var r = a * b;
              var lo = r & 67108863;
              ncarry = ncarry + (r / 67108864 | 0) | 0;
              lo = lo + rword | 0;
              rword = lo & 67108863;
              ncarry = ncarry + (lo >>> 26) | 0;
              hncarry += ncarry >>> 26;
              ncarry &= 67108863;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
          }
          if (carry !== 0) {
            out.words[k] = carry;
          } else {
            out.length--;
          }
          return out.strip();
        }
        function jumboMulTo(self2, num, out) {
          var fftm = new FFTM();
          return fftm.mulp(self2, num, out);
        }
        BN2.prototype.mulTo = function mulTo(num, out) {
          var res;
          var len = this.length + num.length;
          if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
          } else if (len < 63) {
            res = smallMulTo(this, num, out);
          } else if (len < 1024) {
            res = bigMulTo(this, num, out);
          } else {
            res = jumboMulTo(this, num, out);
          }
          return res;
        };
        function FFTM(x, y) {
          this.x = x;
          this.y = y;
        }
        FFTM.prototype.makeRBT = function makeRBT(N) {
          var t = new Array(N);
          var l = BN2.prototype._countBits(N) - 1;
          for (var i = 0; i < N; i++) {
            t[i] = this.revBin(i, l, N);
          }
          return t;
        };
        FFTM.prototype.revBin = function revBin(x, l, N) {
          if (x === 0 || x === N - 1)
            return x;
          var rb = 0;
          for (var i = 0; i < l; i++) {
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
          }
          return rb;
        };
        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
          for (var i = 0; i < N; i++) {
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
          }
        };
        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
          this.permute(rbt, rws, iws, rtws, itws, N);
          for (var s = 1; s < N; s <<= 1) {
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for (var p = 0; p < N; p += l) {
              var rtwdf_ = rtwdf;
              var itwdf_ = itwdf;
              for (var j = 0; j < s; j++) {
                var re = rtws[p + j];
                var ie = itws[p + j];
                var ro = rtws[p + j + s];
                var io = itws[p + j + s];
                var rx = rtwdf_ * ro - itwdf_ * io;
                io = rtwdf_ * io + itwdf_ * ro;
                ro = rx;
                rtws[p + j] = re + ro;
                itws[p + j] = ie + io;
                rtws[p + j + s] = re - ro;
                itws[p + j + s] = ie - io;
                if (j !== l) {
                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                  rtwdf_ = rx;
                }
              }
            }
          }
        };
        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
          var N = Math.max(m, n) | 1;
          var odd = N & 1;
          var i = 0;
          for (N = N / 2 | 0; N; N = N >>> 1) {
            i++;
          }
          return 1 << i + 1 + odd;
        };
        FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
          if (N <= 1)
            return;
          for (var i = 0; i < N / 2; i++) {
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
          }
        };
        FFTM.prototype.normalize13b = function normalize13b(ws, N) {
          var carry = 0;
          for (var i = 0; i < N / 2; i++) {
            var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 67108863;
            if (w < 67108864) {
              carry = 0;
            } else {
              carry = w / 67108864 | 0;
            }
          }
          return ws;
        };
        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
          var carry = 0;
          for (var i = 0; i < len; i++) {
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 8191;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 8191;
            carry = carry >>> 13;
          }
          for (i = 2 * len; i < N; ++i) {
            rws[i] = 0;
          }
          assert5(carry === 0);
          assert5((carry & ~8191) === 0);
        };
        FFTM.prototype.stub = function stub(N) {
          var ph = new Array(N);
          for (var i = 0; i < N; i++) {
            ph[i] = 0;
          }
          return ph;
        };
        FFTM.prototype.mulp = function mulp(x, y, out) {
          var N = 2 * this.guessLen13b(x.length, y.length);
          var rbt = this.makeRBT(N);
          var _ = this.stub(N);
          var rws = new Array(N);
          var rwst = new Array(N);
          var iwst = new Array(N);
          var nrws = new Array(N);
          var nrwst = new Array(N);
          var niwst = new Array(N);
          var rmws = out.words;
          rmws.length = N;
          this.convert13b(x.words, x.length, rws, N);
          this.convert13b(y.words, y.length, nrws, N);
          this.transform(rws, _, rwst, iwst, N, rbt);
          this.transform(nrws, _, nrwst, niwst, N, rbt);
          for (var i = 0; i < N; i++) {
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
          }
          this.conjugate(rwst, iwst, N);
          this.transform(rwst, iwst, rmws, _, N, rbt);
          this.conjugate(rmws, _, N);
          this.normalize13b(rmws, N);
          out.negative = x.negative ^ y.negative;
          out.length = x.length + y.length;
          return out.strip();
        };
        BN2.prototype.mul = function mul(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return this.mulTo(num, out);
        };
        BN2.prototype.mulf = function mulf(num) {
          var out = new BN2(null);
          out.words = new Array(this.length + num.length);
          return jumboMulTo(this, num, out);
        };
        BN2.prototype.imul = function imul(num) {
          return this.clone().mulTo(num, this);
        };
        BN2.prototype.imuln = function imuln(num) {
          assert5(typeof num === "number");
          assert5(num < 67108864);
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = (this.words[i] | 0) * num;
            var lo = (w & 67108863) + (carry & 67108863);
            carry >>= 26;
            carry += w / 67108864 | 0;
            carry += lo >>> 26;
            this.words[i] = lo & 67108863;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.muln = function muln(num) {
          return this.clone().imuln(num);
        };
        BN2.prototype.sqr = function sqr() {
          return this.mul(this);
        };
        BN2.prototype.isqr = function isqr() {
          return this.imul(this.clone());
        };
        BN2.prototype.pow = function pow(num) {
          var w = toBitArray(num);
          if (w.length === 0)
            return new BN2(1);
          var res = this;
          for (var i = 0; i < w.length; i++, res = res.sqr()) {
            if (w[i] !== 0)
              break;
          }
          if (++i < w.length) {
            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
              if (w[i] === 0)
                continue;
              res = res.mul(q);
            }
          }
          return res;
        };
        BN2.prototype.iushln = function iushln(bits) {
          assert5(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          var carryMask = 67108863 >>> 26 - r << 26 - r;
          var i;
          if (r !== 0) {
            var carry = 0;
            for (i = 0; i < this.length; i++) {
              var newCarry = this.words[i] & carryMask;
              var c = (this.words[i] | 0) - newCarry << r;
              this.words[i] = c | carry;
              carry = newCarry >>> 26 - r;
            }
            if (carry) {
              this.words[i] = carry;
              this.length++;
            }
          }
          if (s !== 0) {
            for (i = this.length - 1; i >= 0; i--) {
              this.words[i + s] = this.words[i];
            }
            for (i = 0; i < s; i++) {
              this.words[i] = 0;
            }
            this.length += s;
          }
          return this.strip();
        };
        BN2.prototype.ishln = function ishln(bits) {
          assert5(this.negative === 0);
          return this.iushln(bits);
        };
        BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
          assert5(typeof bits === "number" && bits >= 0);
          var h;
          if (hint) {
            h = (hint - hint % 26) / 26;
          } else {
            h = 0;
          }
          var r = bits % 26;
          var s = Math.min((bits - r) / 26, this.length);
          var mask2 = 67108863 ^ 67108863 >>> r << r;
          var maskedWords = extended;
          h -= s;
          h = Math.max(0, h);
          if (maskedWords) {
            for (var i = 0; i < s; i++) {
              maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
          }
          if (s === 0) {
          } else if (this.length > s) {
            this.length -= s;
            for (i = 0; i < this.length; i++) {
              this.words[i] = this.words[i + s];
            }
          } else {
            this.words[0] = 0;
            this.length = 1;
          }
          var carry = 0;
          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask2;
          }
          if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
          }
          if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
          }
          return this.strip();
        };
        BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
          assert5(this.negative === 0);
          return this.iushrn(bits, hint, extended);
        };
        BN2.prototype.shln = function shln(bits) {
          return this.clone().ishln(bits);
        };
        BN2.prototype.ushln = function ushln(bits) {
          return this.clone().iushln(bits);
        };
        BN2.prototype.shrn = function shrn(bits) {
          return this.clone().ishrn(bits);
        };
        BN2.prototype.ushrn = function ushrn(bits) {
          return this.clone().iushrn(bits);
        };
        BN2.prototype.testn = function testn(bit) {
          assert5(typeof bit === "number" && bit >= 0);
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s)
            return false;
          var w = this.words[s];
          return !!(w & q);
        };
        BN2.prototype.imaskn = function imaskn(bits) {
          assert5(typeof bits === "number" && bits >= 0);
          var r = bits % 26;
          var s = (bits - r) / 26;
          assert5(this.negative === 0, "imaskn works only with positive numbers");
          if (this.length <= s) {
            return this;
          }
          if (r !== 0) {
            s++;
          }
          this.length = Math.min(s, this.length);
          if (r !== 0) {
            var mask2 = 67108863 ^ 67108863 >>> r << r;
            this.words[this.length - 1] &= mask2;
          }
          return this.strip();
        };
        BN2.prototype.maskn = function maskn(bits) {
          return this.clone().imaskn(bits);
        };
        BN2.prototype.iaddn = function iaddn(num) {
          assert5(typeof num === "number");
          assert5(num < 67108864);
          if (num < 0)
            return this.isubn(-num);
          if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) < num) {
              this.words[0] = num - (this.words[0] | 0);
              this.negative = 0;
              return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
          }
          return this._iaddn(num);
        };
        BN2.prototype._iaddn = function _iaddn(num) {
          this.words[0] += num;
          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
            this.words[i] -= 67108864;
            if (i === this.length - 1) {
              this.words[i + 1] = 1;
            } else {
              this.words[i + 1]++;
            }
          }
          this.length = Math.max(this.length, i + 1);
          return this;
        };
        BN2.prototype.isubn = function isubn(num) {
          assert5(typeof num === "number");
          assert5(num < 67108864);
          if (num < 0)
            return this.iaddn(-num);
          if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
          }
          this.words[0] -= num;
          if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
          } else {
            for (var i = 0; i < this.length && this.words[i] < 0; i++) {
              this.words[i] += 67108864;
              this.words[i + 1] -= 1;
            }
          }
          return this.strip();
        };
        BN2.prototype.addn = function addn(num) {
          return this.clone().iaddn(num);
        };
        BN2.prototype.subn = function subn(num) {
          return this.clone().isubn(num);
        };
        BN2.prototype.iabs = function iabs() {
          this.negative = 0;
          return this;
        };
        BN2.prototype.abs = function abs() {
          return this.clone().iabs();
        };
        BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
          var len = num.length + shift;
          var i;
          this._expand(len);
          var w;
          var carry = 0;
          for (i = 0; i < num.length; i++) {
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 67108863;
            carry = (w >> 26) - (right / 67108864 | 0);
            this.words[i + shift] = w & 67108863;
          }
          for (; i < this.length - shift; i++) {
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 67108863;
          }
          if (carry === 0)
            return this.strip();
          assert5(carry === -1);
          carry = 0;
          for (i = 0; i < this.length; i++) {
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 67108863;
          }
          this.negative = 1;
          return this.strip();
        };
        BN2.prototype._wordDiv = function _wordDiv(num, mode) {
          var shift = this.length - num.length;
          var a = this.clone();
          var b = num;
          var bhi = b.words[b.length - 1] | 0;
          var bhiBits = this._countBits(bhi);
          shift = 26 - bhiBits;
          if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
          }
          var m = a.length - b.length;
          var q;
          if (mode !== "mod") {
            q = new BN2(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for (var i = 0; i < q.length; i++) {
              q.words[i] = 0;
            }
          }
          var diff = a.clone()._ishlnsubmul(b, 1, m);
          if (diff.negative === 0) {
            a = diff;
            if (q) {
              q.words[m] = 1;
            }
          }
          for (var j = m - 1; j >= 0; j--) {
            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
            qj = Math.min(qj / bhi | 0, 67108863);
            a._ishlnsubmul(b, qj, j);
            while (a.negative !== 0) {
              qj--;
              a.negative = 0;
              a._ishlnsubmul(b, 1, j);
              if (!a.isZero()) {
                a.negative ^= 1;
              }
            }
            if (q) {
              q.words[j] = qj;
            }
          }
          if (q) {
            q.strip();
          }
          a.strip();
          if (mode !== "div" && shift !== 0) {
            a.iushrn(shift);
          }
          return {
            div: q || null,
            mod: a
          };
        };
        BN2.prototype.divmod = function divmod(num, mode, positive) {
          assert5(!num.isZero());
          if (this.isZero()) {
            return {
              div: new BN2(0),
              mod: new BN2(0)
            };
          }
          var div, mod, res;
          if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.iadd(num);
              }
            }
            return {
              div,
              mod
            };
          }
          if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== "mod") {
              div = res.div.neg();
            }
            return {
              div,
              mod: res.mod
            };
          }
          if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== "div") {
              mod = res.mod.neg();
              if (positive && mod.negative !== 0) {
                mod.isub(num);
              }
            }
            return {
              div: res.div,
              mod
            };
          }
          if (num.length > this.length || this.cmp(num) < 0) {
            return {
              div: new BN2(0),
              mod: this
            };
          }
          if (num.length === 1) {
            if (mode === "div") {
              return {
                div: this.divn(num.words[0]),
                mod: null
              };
            }
            if (mode === "mod") {
              return {
                div: null,
                mod: new BN2(this.modn(num.words[0]))
              };
            }
            return {
              div: this.divn(num.words[0]),
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return this._wordDiv(num, mode);
        };
        BN2.prototype.div = function div(num) {
          return this.divmod(num, "div", false).div;
        };
        BN2.prototype.mod = function mod(num) {
          return this.divmod(num, "mod", false).mod;
        };
        BN2.prototype.umod = function umod(num) {
          return this.divmod(num, "mod", true).mod;
        };
        BN2.prototype.divRound = function divRound(num) {
          var dm = this.divmod(num);
          if (dm.mod.isZero())
            return dm.div;
          var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
          var half = num.ushrn(1);
          var r2 = num.andln(1);
          var cmp = mod.cmp(half);
          if (cmp < 0 || r2 === 1 && cmp === 0)
            return dm.div;
          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
        };
        BN2.prototype.modn = function modn(num) {
          assert5(num <= 67108863);
          var p = (1 << 26) % num;
          var acc = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            acc = (p * acc + (this.words[i] | 0)) % num;
          }
          return acc;
        };
        BN2.prototype.idivn = function idivn(num) {
          assert5(num <= 67108863);
          var carry = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var w = (this.words[i] | 0) + carry * 67108864;
            this.words[i] = w / num | 0;
            carry = w % num;
          }
          return this.strip();
        };
        BN2.prototype.divn = function divn(num) {
          return this.clone().idivn(num);
        };
        BN2.prototype.egcd = function egcd(p) {
          assert5(p.negative === 0);
          assert5(!p.isZero());
          var x = this;
          var y = p.clone();
          if (x.negative !== 0) {
            x = x.umod(p);
          } else {
            x = x.clone();
          }
          var A = new BN2(1);
          var B = new BN2(0);
          var C = new BN2(0);
          var D = new BN2(1);
          var g = 0;
          while (x.isEven() && y.isEven()) {
            x.iushrn(1);
            y.iushrn(1);
            ++g;
          }
          var yp = y.clone();
          var xp = x.clone();
          while (!x.isZero()) {
            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              x.iushrn(i);
              while (i-- > 0) {
                if (A.isOdd() || B.isOdd()) {
                  A.iadd(yp);
                  B.isub(xp);
                }
                A.iushrn(1);
                B.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              y.iushrn(j);
              while (j-- > 0) {
                if (C.isOdd() || D.isOdd()) {
                  C.iadd(yp);
                  D.isub(xp);
                }
                C.iushrn(1);
                D.iushrn(1);
              }
            }
            if (x.cmp(y) >= 0) {
              x.isub(y);
              A.isub(C);
              B.isub(D);
            } else {
              y.isub(x);
              C.isub(A);
              D.isub(B);
            }
          }
          return {
            a: C,
            b: D,
            gcd: y.iushln(g)
          };
        };
        BN2.prototype._invmp = function _invmp(p) {
          assert5(p.negative === 0);
          assert5(!p.isZero());
          var a = this;
          var b = p.clone();
          if (a.negative !== 0) {
            a = a.umod(p);
          } else {
            a = a.clone();
          }
          var x1 = new BN2(1);
          var x2 = new BN2(0);
          var delta = b.clone();
          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
              ;
            if (i > 0) {
              a.iushrn(i);
              while (i-- > 0) {
                if (x1.isOdd()) {
                  x1.iadd(delta);
                }
                x1.iushrn(1);
              }
            }
            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
              ;
            if (j > 0) {
              b.iushrn(j);
              while (j-- > 0) {
                if (x2.isOdd()) {
                  x2.iadd(delta);
                }
                x2.iushrn(1);
              }
            }
            if (a.cmp(b) >= 0) {
              a.isub(b);
              x1.isub(x2);
            } else {
              b.isub(a);
              x2.isub(x1);
            }
          }
          var res;
          if (a.cmpn(1) === 0) {
            res = x1;
          } else {
            res = x2;
          }
          if (res.cmpn(0) < 0) {
            res.iadd(p);
          }
          return res;
        };
        BN2.prototype.gcd = function gcd(num) {
          if (this.isZero())
            return num.abs();
          if (num.isZero())
            return this.abs();
          var a = this.clone();
          var b = num.clone();
          a.negative = 0;
          b.negative = 0;
          for (var shift = 0; a.isEven() && b.isEven(); shift++) {
            a.iushrn(1);
            b.iushrn(1);
          }
          do {
            while (a.isEven()) {
              a.iushrn(1);
            }
            while (b.isEven()) {
              b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
              var t = a;
              a = b;
              b = t;
            } else if (r === 0 || b.cmpn(1) === 0) {
              break;
            }
            a.isub(b);
          } while (true);
          return b.iushln(shift);
        };
        BN2.prototype.invm = function invm(num) {
          return this.egcd(num).a.umod(num);
        };
        BN2.prototype.isEven = function isEven() {
          return (this.words[0] & 1) === 0;
        };
        BN2.prototype.isOdd = function isOdd() {
          return (this.words[0] & 1) === 1;
        };
        BN2.prototype.andln = function andln(num) {
          return this.words[0] & num;
        };
        BN2.prototype.bincn = function bincn(bit) {
          assert5(typeof bit === "number");
          var r = bit % 26;
          var s = (bit - r) / 26;
          var q = 1 << r;
          if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
          }
          var carry = q;
          for (var i = s; carry !== 0 && i < this.length; i++) {
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 67108863;
            this.words[i] = w;
          }
          if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
          }
          return this;
        };
        BN2.prototype.isZero = function isZero() {
          return this.length === 1 && this.words[0] === 0;
        };
        BN2.prototype.cmpn = function cmpn(num) {
          var negative = num < 0;
          if (this.negative !== 0 && !negative)
            return -1;
          if (this.negative === 0 && negative)
            return 1;
          this.strip();
          var res;
          if (this.length > 1) {
            res = 1;
          } else {
            if (negative) {
              num = -num;
            }
            assert5(num <= 67108863, "Number is too big");
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
          }
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.cmp = function cmp(num) {
          if (this.negative !== 0 && num.negative === 0)
            return -1;
          if (this.negative === 0 && num.negative !== 0)
            return 1;
          var res = this.ucmp(num);
          if (this.negative !== 0)
            return -res | 0;
          return res;
        };
        BN2.prototype.ucmp = function ucmp(num) {
          if (this.length > num.length)
            return 1;
          if (this.length < num.length)
            return -1;
          var res = 0;
          for (var i = this.length - 1; i >= 0; i--) {
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b)
              continue;
            if (a < b) {
              res = -1;
            } else if (a > b) {
              res = 1;
            }
            break;
          }
          return res;
        };
        BN2.prototype.gtn = function gtn(num) {
          return this.cmpn(num) === 1;
        };
        BN2.prototype.gt = function gt(num) {
          return this.cmp(num) === 1;
        };
        BN2.prototype.gten = function gten(num) {
          return this.cmpn(num) >= 0;
        };
        BN2.prototype.gte = function gte(num) {
          return this.cmp(num) >= 0;
        };
        BN2.prototype.ltn = function ltn(num) {
          return this.cmpn(num) === -1;
        };
        BN2.prototype.lt = function lt(num) {
          return this.cmp(num) === -1;
        };
        BN2.prototype.lten = function lten(num) {
          return this.cmpn(num) <= 0;
        };
        BN2.prototype.lte = function lte(num) {
          return this.cmp(num) <= 0;
        };
        BN2.prototype.eqn = function eqn(num) {
          return this.cmpn(num) === 0;
        };
        BN2.prototype.eq = function eq(num) {
          return this.cmp(num) === 0;
        };
        BN2.red = function red2(num) {
          return new Red(num);
        };
        BN2.prototype.toRed = function toRed(ctx) {
          assert5(!this.red, "Already a number in reduction context");
          assert5(this.negative === 0, "red works only with positives");
          return ctx.convertTo(this)._forceRed(ctx);
        };
        BN2.prototype.fromRed = function fromRed() {
          assert5(this.red, "fromRed works only with numbers in reduction context");
          return this.red.convertFrom(this);
        };
        BN2.prototype._forceRed = function _forceRed(ctx) {
          this.red = ctx;
          return this;
        };
        BN2.prototype.forceRed = function forceRed(ctx) {
          assert5(!this.red, "Already a number in reduction context");
          return this._forceRed(ctx);
        };
        BN2.prototype.redAdd = function redAdd(num) {
          assert5(this.red, "redAdd works only with red numbers");
          return this.red.add(this, num);
        };
        BN2.prototype.redIAdd = function redIAdd(num) {
          assert5(this.red, "redIAdd works only with red numbers");
          return this.red.iadd(this, num);
        };
        BN2.prototype.redSub = function redSub(num) {
          assert5(this.red, "redSub works only with red numbers");
          return this.red.sub(this, num);
        };
        BN2.prototype.redISub = function redISub(num) {
          assert5(this.red, "redISub works only with red numbers");
          return this.red.isub(this, num);
        };
        BN2.prototype.redShl = function redShl(num) {
          assert5(this.red, "redShl works only with red numbers");
          return this.red.shl(this, num);
        };
        BN2.prototype.redMul = function redMul(num) {
          assert5(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.mul(this, num);
        };
        BN2.prototype.redIMul = function redIMul(num) {
          assert5(this.red, "redMul works only with red numbers");
          this.red._verify2(this, num);
          return this.red.imul(this, num);
        };
        BN2.prototype.redSqr = function redSqr() {
          assert5(this.red, "redSqr works only with red numbers");
          this.red._verify1(this);
          return this.red.sqr(this);
        };
        BN2.prototype.redISqr = function redISqr() {
          assert5(this.red, "redISqr works only with red numbers");
          this.red._verify1(this);
          return this.red.isqr(this);
        };
        BN2.prototype.redSqrt = function redSqrt() {
          assert5(this.red, "redSqrt works only with red numbers");
          this.red._verify1(this);
          return this.red.sqrt(this);
        };
        BN2.prototype.redInvm = function redInvm() {
          assert5(this.red, "redInvm works only with red numbers");
          this.red._verify1(this);
          return this.red.invm(this);
        };
        BN2.prototype.redNeg = function redNeg() {
          assert5(this.red, "redNeg works only with red numbers");
          this.red._verify1(this);
          return this.red.neg(this);
        };
        BN2.prototype.redPow = function redPow(num) {
          assert5(this.red && !num.red, "redPow(normalNum)");
          this.red._verify1(this);
          return this.red.pow(this, num);
        };
        var primes = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };
        function MPrime(name, p) {
          this.name = name;
          this.p = new BN2(p, 16);
          this.n = this.p.bitLength();
          this.k = new BN2(1).iushln(this.n).isub(this.p);
          this.tmp = this._tmp();
        }
        MPrime.prototype._tmp = function _tmp() {
          var tmp = new BN2(null);
          tmp.words = new Array(Math.ceil(this.n / 13));
          return tmp;
        };
        MPrime.prototype.ireduce = function ireduce(num) {
          var r = num;
          var rlen;
          do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
          } while (rlen > this.n);
          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
          if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
          } else if (cmp > 0) {
            r.isub(this.p);
          } else {
            if (r.strip !== void 0) {
              r.strip();
            } else {
              r._strip();
            }
          }
          return r;
        };
        MPrime.prototype.split = function split4(input, out) {
          input.iushrn(this.n, 0, out);
        };
        MPrime.prototype.imulK = function imulK(num) {
          return num.imul(this.k);
        };
        function K256() {
          MPrime.call(
            this,
            "k256",
            "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
          );
        }
        inherits(K256, MPrime);
        K256.prototype.split = function split4(input, output3) {
          var mask2 = 4194303;
          var outLen = Math.min(input.length, 9);
          for (var i = 0; i < outLen; i++) {
            output3.words[i] = input.words[i];
          }
          output3.length = outLen;
          if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
          }
          var prev = input.words[9];
          output3.words[output3.length++] = prev & mask2;
          for (i = 10; i < input.length; i++) {
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask2) << 4 | prev >>> 22;
            prev = next;
          }
          prev >>>= 22;
          input.words[i - 10] = prev;
          if (prev === 0 && input.length > 10) {
            input.length -= 10;
          } else {
            input.length -= 9;
          }
        };
        K256.prototype.imulK = function imulK(num) {
          num.words[num.length] = 0;
          num.words[num.length + 1] = 0;
          num.length += 2;
          var lo = 0;
          for (var i = 0; i < num.length; i++) {
            var w = num.words[i] | 0;
            lo += w * 977;
            num.words[i] = lo & 67108863;
            lo = w * 64 + (lo / 67108864 | 0);
          }
          if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
              num.length--;
            }
          }
          return num;
        };
        function P224() {
          MPrime.call(
            this,
            "p224",
            "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
          );
        }
        inherits(P224, MPrime);
        function P192() {
          MPrime.call(
            this,
            "p192",
            "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
          );
        }
        inherits(P192, MPrime);
        function P25519() {
          MPrime.call(
            this,
            "25519",
            "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
          );
        }
        inherits(P25519, MPrime);
        P25519.prototype.imulK = function imulK(num) {
          var carry = 0;
          for (var i = 0; i < num.length; i++) {
            var hi = (num.words[i] | 0) * 19 + carry;
            var lo = hi & 67108863;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
          }
          if (carry !== 0) {
            num.words[num.length++] = carry;
          }
          return num;
        };
        BN2._prime = function prime(name) {
          if (primes[name])
            return primes[name];
          var prime2;
          if (name === "k256") {
            prime2 = new K256();
          } else if (name === "p224") {
            prime2 = new P224();
          } else if (name === "p192") {
            prime2 = new P192();
          } else if (name === "p25519") {
            prime2 = new P25519();
          } else {
            throw new Error("Unknown prime " + name);
          }
          primes[name] = prime2;
          return prime2;
        };
        function Red(m) {
          if (typeof m === "string") {
            var prime = BN2._prime(m);
            this.m = prime.p;
            this.prime = prime;
          } else {
            assert5(m.gtn(1), "modulus must be greater than 1");
            this.m = m;
            this.prime = null;
          }
        }
        Red.prototype._verify1 = function _verify1(a) {
          assert5(a.negative === 0, "red works only with positives");
          assert5(a.red, "red works only with red numbers");
        };
        Red.prototype._verify2 = function _verify2(a, b) {
          assert5((a.negative | b.negative) === 0, "red works only with positives");
          assert5(
            a.red && a.red === b.red,
            "red works only with red numbers"
          );
        };
        Red.prototype.imod = function imod(a) {
          if (this.prime)
            return this.prime.ireduce(a)._forceRed(this);
          return a.umod(this.m)._forceRed(this);
        };
        Red.prototype.neg = function neg(a) {
          if (a.isZero()) {
            return a.clone();
          }
          return this.m.sub(a)._forceRed(this);
        };
        Red.prototype.add = function add3(a, b) {
          this._verify2(a, b);
          var res = a.add(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.iadd = function iadd(a, b) {
          this._verify2(a, b);
          var res = a.iadd(b);
          if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
          }
          return res;
        };
        Red.prototype.sub = function sub(a, b) {
          this._verify2(a, b);
          var res = a.sub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Red.prototype.isub = function isub(a, b) {
          this._verify2(a, b);
          var res = a.isub(b);
          if (res.cmpn(0) < 0) {
            res.iadd(this.m);
          }
          return res;
        };
        Red.prototype.shl = function shl(a, num) {
          this._verify1(a);
          return this.imod(a.ushln(num));
        };
        Red.prototype.imul = function imul(a, b) {
          this._verify2(a, b);
          return this.imod(a.imul(b));
        };
        Red.prototype.mul = function mul(a, b) {
          this._verify2(a, b);
          return this.imod(a.mul(b));
        };
        Red.prototype.isqr = function isqr(a) {
          return this.imul(a, a.clone());
        };
        Red.prototype.sqr = function sqr(a) {
          return this.mul(a, a);
        };
        Red.prototype.sqrt = function sqrt(a) {
          if (a.isZero())
            return a.clone();
          var mod3 = this.m.andln(3);
          assert5(mod3 % 2 === 1);
          if (mod3 === 3) {
            var pow = this.m.add(new BN2(1)).iushrn(2);
            return this.pow(a, pow);
          }
          var q = this.m.subn(1);
          var s = 0;
          while (!q.isZero() && q.andln(1) === 0) {
            s++;
            q.iushrn(1);
          }
          assert5(!q.isZero());
          var one = new BN2(1).toRed(this);
          var nOne = one.redNeg();
          var lpow = this.m.subn(1).iushrn(1);
          var z = this.m.bitLength();
          z = new BN2(2 * z * z).toRed(this);
          while (this.pow(z, lpow).cmp(nOne) !== 0) {
            z.redIAdd(nOne);
          }
          var c = this.pow(z, q);
          var r = this.pow(a, q.addn(1).iushrn(1));
          var t = this.pow(a, q);
          var m = s;
          while (t.cmp(one) !== 0) {
            var tmp = t;
            for (var i = 0; tmp.cmp(one) !== 0; i++) {
              tmp = tmp.redSqr();
            }
            assert5(i < m);
            var b = this.pow(c, new BN2(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
          }
          return r;
        };
        Red.prototype.invm = function invm(a) {
          var inv = a._invmp(this.m);
          if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
          } else {
            return this.imod(inv);
          }
        };
        Red.prototype.pow = function pow(a, num) {
          if (num.isZero())
            return new BN2(1).toRed(this);
          if (num.cmpn(1) === 0)
            return a.clone();
          var windowSize = 4;
          var wnd = new Array(1 << windowSize);
          wnd[0] = new BN2(1).toRed(this);
          wnd[1] = a;
          for (var i = 2; i < wnd.length; i++) {
            wnd[i] = this.mul(wnd[i - 1], a);
          }
          var res = wnd[0];
          var current = 0;
          var currentLen = 0;
          var start = num.bitLength() % 26;
          if (start === 0) {
            start = 26;
          }
          for (i = num.length - 1; i >= 0; i--) {
            var word = num.words[i];
            for (var j = start - 1; j >= 0; j--) {
              var bit = word >> j & 1;
              if (res !== wnd[0]) {
                res = this.sqr(res);
              }
              if (bit === 0 && current === 0) {
                currentLen = 0;
                continue;
              }
              current <<= 1;
              current |= bit;
              currentLen++;
              if (currentLen !== windowSize && (i !== 0 || j !== 0))
                continue;
              res = this.mul(res, wnd[current]);
              currentLen = 0;
              current = 0;
            }
            start = 26;
          }
          return res;
        };
        Red.prototype.convertTo = function convertTo(num) {
          var r = num.umod(this.m);
          return r === num ? r.clone() : r;
        };
        Red.prototype.convertFrom = function convertFrom(num) {
          var res = num.clone();
          res.red = null;
          return res;
        };
        BN2.mont = function mont(num) {
          return new Mont(num);
        };
        function Mont(m) {
          Red.call(this, m);
          this.shift = this.m.bitLength();
          if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
          }
          this.r = new BN2(1).iushln(this.shift);
          this.r2 = this.imod(this.r.sqr());
          this.rinv = this.r._invmp(this.m);
          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
          this.minv = this.minv.umod(this.r);
          this.minv = this.r.sub(this.minv);
        }
        inherits(Mont, Red);
        Mont.prototype.convertTo = function convertTo(num) {
          return this.imod(num.ushln(this.shift));
        };
        Mont.prototype.convertFrom = function convertFrom(num) {
          var r = this.imod(num.mul(this.rinv));
          r.red = null;
          return r;
        };
        Mont.prototype.imul = function imul(a, b) {
          if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
          }
          var t = a.imul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.mul = function mul(a, b) {
          if (a.isZero() || b.isZero())
            return new BN2(0)._forceRed(this);
          var t = a.mul(b);
          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
          var u = t.isub(c).iushrn(this.shift);
          var res = u;
          if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
          } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
          }
          return res._forceRed(this);
        };
        Mont.prototype.invm = function invm(a) {
          var res = this.imod(a._invmp(this.m).mul(this.r2));
          return res._forceRed(this);
        };
      })(typeof module2 === "undefined" || module2, exports);
    }
  });

  // ../../node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js
  var require_minimalistic_assert = __commonJS({
    "../../node_modules/.pnpm/minimalistic-assert@1.0.1/node_modules/minimalistic-assert/index.js"(exports, module2) {
      module2.exports = assert5;
      function assert5(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      assert5.equal = function assertEqual(l, r, msg) {
        if (l != r)
          throw new Error(msg || "Assertion failed: " + l + " != " + r);
      };
    }
  });

  // ../../node_modules/.pnpm/minimalistic-crypto-utils@1.0.1/node_modules/minimalistic-crypto-utils/lib/utils.js
  var require_utils4 = __commonJS({
    "../../node_modules/.pnpm/minimalistic-crypto-utils@1.0.1/node_modules/minimalistic-crypto-utils/lib/utils.js"(exports) {
      "use strict";
      var utils = exports;
      function toArray2(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg !== "string") {
          for (var i = 0; i < msg.length; i++)
            res[i] = msg[i] | 0;
          return res;
        }
        if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (var i = 0; i < msg.length; i += 2)
            res.push(parseInt(msg[i] + msg[i + 1], 16));
        } else {
          for (var i = 0; i < msg.length; i++) {
            var c = msg.charCodeAt(i);
            var hi = c >> 8;
            var lo = c & 255;
            if (hi)
              res.push(hi, lo);
            else
              res.push(lo);
          }
        }
        return res;
      }
      utils.toArray = toArray2;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      utils.zero2 = zero2;
      function toHex2(msg) {
        var res = "";
        for (var i = 0; i < msg.length; i++)
          res += zero2(msg[i].toString(16));
        return res;
      }
      utils.toHex = toHex2;
      utils.encode = function encode(arr, enc) {
        if (enc === "hex")
          return toHex2(arr);
        else
          return arr;
      };
    }
  });

  // ../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/utils.js
  var require_utils5 = __commonJS({
    "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/utils.js"(exports) {
      "use strict";
      var utils = exports;
      var BN2 = require_bn2();
      var minAssert = require_minimalistic_assert();
      var minUtils = require_utils4();
      utils.assert = minAssert;
      utils.toArray = minUtils.toArray;
      utils.zero2 = minUtils.zero2;
      utils.toHex = minUtils.toHex;
      utils.encode = minUtils.encode;
      function getNAF(num, w, bits) {
        var naf = new Array(Math.max(num.bitLength(), bits) + 1);
        naf.fill(0);
        var ws = 1 << w + 1;
        var k = num.clone();
        for (var i = 0; i < naf.length; i++) {
          var z;
          var mod = k.andln(ws - 1);
          if (k.isOdd()) {
            if (mod > (ws >> 1) - 1)
              z = (ws >> 1) - mod;
            else
              z = mod;
            k.isubn(z);
          } else {
            z = 0;
          }
          naf[i] = z;
          k.iushrn(1);
        }
        return naf;
      }
      utils.getNAF = getNAF;
      function getJSF(k1, k2) {
        var jsf = [
          [],
          []
        ];
        k1 = k1.clone();
        k2 = k2.clone();
        var d1 = 0;
        var d2 = 0;
        var m8;
        while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
          var m14 = k1.andln(3) + d1 & 3;
          var m24 = k2.andln(3) + d2 & 3;
          if (m14 === 3)
            m14 = -1;
          if (m24 === 3)
            m24 = -1;
          var u1;
          if ((m14 & 1) === 0) {
            u1 = 0;
          } else {
            m8 = k1.andln(7) + d1 & 7;
            if ((m8 === 3 || m8 === 5) && m24 === 2)
              u1 = -m14;
            else
              u1 = m14;
          }
          jsf[0].push(u1);
          var u2;
          if ((m24 & 1) === 0) {
            u2 = 0;
          } else {
            m8 = k2.andln(7) + d2 & 7;
            if ((m8 === 3 || m8 === 5) && m14 === 2)
              u2 = -m24;
            else
              u2 = m24;
          }
          jsf[1].push(u2);
          if (2 * d1 === u1 + 1)
            d1 = 1 - d1;
          if (2 * d2 === u2 + 1)
            d2 = 1 - d2;
          k1.iushrn(1);
          k2.iushrn(1);
        }
        return jsf;
      }
      utils.getJSF = getJSF;
      function cachedProperty(obj, name, computer) {
        var key = "_" + name;
        obj.prototype[name] = function cachedProperty2() {
          return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
        };
      }
      utils.cachedProperty = cachedProperty;
      function parseBytes(bytes3) {
        return typeof bytes3 === "string" ? utils.toArray(bytes3, "hex") : bytes3;
      }
      utils.parseBytes = parseBytes;
      function intFromLE(bytes3) {
        return new BN2(bytes3, "hex", "le");
      }
      utils.intFromLE = intFromLE;
    }
  });

  // ../../node_modules/.pnpm/brorand@1.1.0/node_modules/brorand/index.js
  var require_brorand = __commonJS({
    "../../node_modules/.pnpm/brorand@1.1.0/node_modules/brorand/index.js"(exports, module2) {
      var r;
      module2.exports = function rand(len) {
        if (!r)
          r = new Rand(null);
        return r.generate(len);
      };
      function Rand(rand) {
        this.rand = rand;
      }
      module2.exports.Rand = Rand;
      Rand.prototype.generate = function generate(len) {
        return this._rand(len);
      };
      Rand.prototype._rand = function _rand(n) {
        if (this.rand.getBytes)
          return this.rand.getBytes(n);
        var res = new Uint8Array(n);
        for (var i = 0; i < res.length; i++)
          res[i] = this.rand.getByte();
        return res;
      };
      if (typeof self === "object") {
        if (self.crypto && self.crypto.getRandomValues) {
          Rand.prototype._rand = function _rand(n) {
            var arr = new Uint8Array(n);
            self.crypto.getRandomValues(arr);
            return arr;
          };
        } else if (self.msCrypto && self.msCrypto.getRandomValues) {
          Rand.prototype._rand = function _rand(n) {
            var arr = new Uint8Array(n);
            self.msCrypto.getRandomValues(arr);
            return arr;
          };
        } else if (typeof window === "object") {
          Rand.prototype._rand = function() {
            throw new Error("Not implemented yet");
          };
        }
      } else {
        try {
          crypto7 = __require2("crypto");
          if (typeof crypto7.randomBytes !== "function")
            throw new Error("Not supported");
          Rand.prototype._rand = function _rand(n) {
            return crypto7.randomBytes(n);
          };
        } catch (e) {
        }
      }
      var crypto7;
    }
  });

  // ../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/curve/base.js
  var require_base3 = __commonJS({
    "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/curve/base.js"(exports, module2) {
      "use strict";
      var BN2 = require_bn2();
      var utils = require_utils5();
      var getNAF = utils.getNAF;
      var getJSF = utils.getJSF;
      var assert5 = utils.assert;
      function BaseCurve(type3, conf) {
        this.type = type3;
        this.p = new BN2(conf.p, 16);
        this.red = conf.prime ? BN2.red(conf.prime) : BN2.mont(this.p);
        this.zero = new BN2(0).toRed(this.red);
        this.one = new BN2(1).toRed(this.red);
        this.two = new BN2(2).toRed(this.red);
        this.n = conf.n && new BN2(conf.n, 16);
        this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
        this._wnafT1 = new Array(4);
        this._wnafT2 = new Array(4);
        this._wnafT3 = new Array(4);
        this._wnafT4 = new Array(4);
        this._bitLength = this.n ? this.n.bitLength() : 0;
        var adjustCount = this.n && this.p.div(this.n);
        if (!adjustCount || adjustCount.cmpn(100) > 0) {
          this.redN = null;
        } else {
          this._maxwellTrick = true;
          this.redN = this.n.toRed(this.red);
        }
      }
      module2.exports = BaseCurve;
      BaseCurve.prototype.point = function point() {
        throw new Error("Not implemented");
      };
      BaseCurve.prototype.validate = function validate() {
        throw new Error("Not implemented");
      };
      BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
        assert5(p.precomputed);
        var doubles = p._getDoubles();
        var naf = getNAF(k, 1, this._bitLength);
        var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
        I /= 3;
        var repr = [];
        var j;
        var nafW;
        for (j = 0; j < naf.length; j += doubles.step) {
          nafW = 0;
          for (var l = j + doubles.step - 1; l >= j; l--)
            nafW = (nafW << 1) + naf[l];
          repr.push(nafW);
        }
        var a = this.jpoint(null, null, null);
        var b = this.jpoint(null, null, null);
        for (var i = I; i > 0; i--) {
          for (j = 0; j < repr.length; j++) {
            nafW = repr[j];
            if (nafW === i)
              b = b.mixedAdd(doubles.points[j]);
            else if (nafW === -i)
              b = b.mixedAdd(doubles.points[j].neg());
          }
          a = a.add(b);
        }
        return a.toP();
      };
      BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
        var w = 4;
        var nafPoints = p._getNAFPoints(w);
        w = nafPoints.wnd;
        var wnd = nafPoints.points;
        var naf = getNAF(k, w, this._bitLength);
        var acc = this.jpoint(null, null, null);
        for (var i = naf.length - 1; i >= 0; i--) {
          for (var l = 0; i >= 0 && naf[i] === 0; i--)
            l++;
          if (i >= 0)
            l++;
          acc = acc.dblp(l);
          if (i < 0)
            break;
          var z = naf[i];
          assert5(z !== 0);
          if (p.type === "affine") {
            if (z > 0)
              acc = acc.mixedAdd(wnd[z - 1 >> 1]);
            else
              acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
          } else {
            if (z > 0)
              acc = acc.add(wnd[z - 1 >> 1]);
            else
              acc = acc.add(wnd[-z - 1 >> 1].neg());
          }
        }
        return p.type === "affine" ? acc.toP() : acc;
      };
      BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
        var wndWidth = this._wnafT1;
        var wnd = this._wnafT2;
        var naf = this._wnafT3;
        var max2 = 0;
        var i;
        var j;
        var p;
        for (i = 0; i < len; i++) {
          p = points[i];
          var nafPoints = p._getNAFPoints(defW);
          wndWidth[i] = nafPoints.wnd;
          wnd[i] = nafPoints.points;
        }
        for (i = len - 1; i >= 1; i -= 2) {
          var a = i - 1;
          var b = i;
          if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
            naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
            naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
            max2 = Math.max(naf[a].length, max2);
            max2 = Math.max(naf[b].length, max2);
            continue;
          }
          var comb = [
            points[a],
            /* 1 */
            null,
            /* 3 */
            null,
            /* 5 */
            points[b]
            /* 7 */
          ];
          if (points[a].y.cmp(points[b].y) === 0) {
            comb[1] = points[a].add(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
          } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].add(points[b].neg());
          } else {
            comb[1] = points[a].toJ().mixedAdd(points[b]);
            comb[2] = points[a].toJ().mixedAdd(points[b].neg());
          }
          var index = [
            -3,
            /* -1 -1 */
            -1,
            /* -1 0 */
            -5,
            /* -1 1 */
            -7,
            /* 0 -1 */
            0,
            /* 0 0 */
            7,
            /* 0 1 */
            5,
            /* 1 -1 */
            1,
            /* 1 0 */
            3
            /* 1 1 */
          ];
          var jsf = getJSF(coeffs[a], coeffs[b]);
          max2 = Math.max(jsf[0].length, max2);
          naf[a] = new Array(max2);
          naf[b] = new Array(max2);
          for (j = 0; j < max2; j++) {
            var ja = jsf[0][j] | 0;
            var jb = jsf[1][j] | 0;
            naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
            naf[b][j] = 0;
            wnd[a] = comb;
          }
        }
        var acc = this.jpoint(null, null, null);
        var tmp = this._wnafT4;
        for (i = max2; i >= 0; i--) {
          var k = 0;
          while (i >= 0) {
            var zero = true;
            for (j = 0; j < len; j++) {
              tmp[j] = naf[j][i] | 0;
              if (tmp[j] !== 0)
                zero = false;
            }
            if (!zero)
              break;
            k++;
            i--;
          }
          if (i >= 0)
            k++;
          acc = acc.dblp(k);
          if (i < 0)
            break;
          for (j = 0; j < len; j++) {
            var z = tmp[j];
            p;
            if (z === 0)
              continue;
            else if (z > 0)
              p = wnd[j][z - 1 >> 1];
            else if (z < 0)
              p = wnd[j][-z - 1 >> 1].neg();
            if (p.type === "affine")
              acc = acc.mixedAdd(p);
            else
              acc = acc.add(p);
          }
        }
        for (i = 0; i < len; i++)
          wnd[i] = null;
        if (jacobianResult)
          return acc;
        else
          return acc.toP();
      };
      function BasePoint(curve, type3) {
        this.curve = curve;
        this.type = type3;
        this.precomputed = null;
      }
      BaseCurve.BasePoint = BasePoint;
      BasePoint.prototype.eq = function eq() {
        throw new Error("Not implemented");
      };
      BasePoint.prototype.validate = function validate() {
        return this.curve.validate(this);
      };
      BaseCurve.prototype.decodePoint = function decodePoint(bytes3, enc) {
        bytes3 = utils.toArray(bytes3, enc);
        var len = this.p.byteLength();
        if ((bytes3[0] === 4 || bytes3[0] === 6 || bytes3[0] === 7) && bytes3.length - 1 === 2 * len) {
          if (bytes3[0] === 6)
            assert5(bytes3[bytes3.length - 1] % 2 === 0);
          else if (bytes3[0] === 7)
            assert5(bytes3[bytes3.length - 1] % 2 === 1);
          var res = this.point(
            bytes3.slice(1, 1 + len),
            bytes3.slice(1 + len, 1 + 2 * len)
          );
          return res;
        } else if ((bytes3[0] === 2 || bytes3[0] === 3) && bytes3.length - 1 === len) {
          return this.pointFromX(bytes3.slice(1, 1 + len), bytes3[0] === 3);
        }
        throw new Error("Unknown point format");
      };
      BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
        return this.encode(enc, true);
      };
      BasePoint.prototype._encode = function _encode(compact) {
        var len = this.curve.p.byteLength();
        var x = this.getX().toArray("be", len);
        if (compact)
          return [this.getY().isEven() ? 2 : 3].concat(x);
        return [4].concat(x, this.getY().toArray("be", len));
      };
      BasePoint.prototype.encode = function encode(enc, compact) {
        return utils.encode(this._encode(compact), enc);
      };
      BasePoint.prototype.precompute = function precompute(power) {
        if (this.precomputed)
          return this;
        var precomputed = {
          doubles: null,
          naf: null,
          beta: null
        };
        precomputed.naf = this._getNAFPoints(8);
        precomputed.doubles = this._getDoubles(4, power);
        precomputed.beta = this._getBeta();
        this.precomputed = precomputed;
        return this;
      };
      BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
        if (!this.precomputed)
          return false;
        var doubles = this.precomputed.doubles;
        if (!doubles)
          return false;
        return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
      };
      BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
        if (this.precomputed && this.precomputed.doubles)
          return this.precomputed.doubles;
        var doubles = [this];
        var acc = this;
        for (var i = 0; i < power; i += step) {
          for (var j = 0; j < step; j++)
            acc = acc.dbl();
          doubles.push(acc);
        }
        return {
          step,
          points: doubles
        };
      };
      BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
        if (this.precomputed && this.precomputed.naf)
          return this.precomputed.naf;
        var res = [this];
        var max2 = (1 << wnd) - 1;
        var dbl = max2 === 1 ? null : this.dbl();
        for (var i = 1; i < max2; i++)
          res[i] = res[i - 1].add(dbl);
        return {
          wnd,
          points: res
        };
      };
      BasePoint.prototype._getBeta = function _getBeta() {
        return null;
      };
      BasePoint.prototype.dblp = function dblp(k) {
        var r = this;
        for (var i = 0; i < k; i++)
          r = r.dbl();
        return r;
      };
    }
  });

  // ../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/curve/short.js
  var require_short = __commonJS({
    "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/curve/short.js"(exports, module2) {
      "use strict";
      var utils = require_utils5();
      var BN2 = require_bn2();
      var inherits = require_inherits();
      var Base = require_base3();
      var assert5 = utils.assert;
      function ShortCurve(conf) {
        Base.call(this, "short", conf);
        this.a = new BN2(conf.a, 16).toRed(this.red);
        this.b = new BN2(conf.b, 16).toRed(this.red);
        this.tinv = this.two.redInvm();
        this.zeroA = this.a.fromRed().cmpn(0) === 0;
        this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
        this.endo = this._getEndomorphism(conf);
        this._endoWnafT1 = new Array(4);
        this._endoWnafT2 = new Array(4);
      }
      inherits(ShortCurve, Base);
      module2.exports = ShortCurve;
      ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
        if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
          return;
        var beta;
        var lambda;
        if (conf.beta) {
          beta = new BN2(conf.beta, 16).toRed(this.red);
        } else {
          var betas = this._getEndoRoots(this.p);
          beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
          beta = beta.toRed(this.red);
        }
        if (conf.lambda) {
          lambda = new BN2(conf.lambda, 16);
        } else {
          var lambdas = this._getEndoRoots(this.n);
          if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
            lambda = lambdas[0];
          } else {
            lambda = lambdas[1];
            assert5(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
          }
        }
        var basis;
        if (conf.basis) {
          basis = conf.basis.map(function(vec) {
            return {
              a: new BN2(vec.a, 16),
              b: new BN2(vec.b, 16)
            };
          });
        } else {
          basis = this._getEndoBasis(lambda);
        }
        return {
          beta,
          lambda,
          basis
        };
      };
      ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
        var red2 = num === this.p ? this.red : BN2.mont(num);
        var tinv = new BN2(2).toRed(red2).redInvm();
        var ntinv = tinv.redNeg();
        var s = new BN2(3).toRed(red2).redNeg().redSqrt().redMul(tinv);
        var l1 = ntinv.redAdd(s).fromRed();
        var l2 = ntinv.redSub(s).fromRed();
        return [l1, l2];
      };
      ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
        var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
        var u = lambda;
        var v = this.n.clone();
        var x1 = new BN2(1);
        var y1 = new BN2(0);
        var x2 = new BN2(0);
        var y2 = new BN2(1);
        var a0;
        var b0;
        var a1;
        var b1;
        var a2;
        var b2;
        var prevR;
        var i = 0;
        var r;
        var x;
        while (u.cmpn(0) !== 0) {
          var q = v.div(u);
          r = v.sub(q.mul(u));
          x = x2.sub(q.mul(x1));
          var y = y2.sub(q.mul(y1));
          if (!a1 && r.cmp(aprxSqrt) < 0) {
            a0 = prevR.neg();
            b0 = x1;
            a1 = r.neg();
            b1 = x;
          } else if (a1 && ++i === 2) {
            break;
          }
          prevR = r;
          v = u;
          u = r;
          x2 = x1;
          x1 = x;
          y2 = y1;
          y1 = y;
        }
        a2 = r.neg();
        b2 = x;
        var len1 = a1.sqr().add(b1.sqr());
        var len2 = a2.sqr().add(b2.sqr());
        if (len2.cmp(len1) >= 0) {
          a2 = a0;
          b2 = b0;
        }
        if (a1.negative) {
          a1 = a1.neg();
          b1 = b1.neg();
        }
        if (a2.negative) {
          a2 = a2.neg();
          b2 = b2.neg();
        }
        return [
          { a: a1, b: b1 },
          { a: a2, b: b2 }
        ];
      };
      ShortCurve.prototype._endoSplit = function _endoSplit(k) {
        var basis = this.endo.basis;
        var v1 = basis[0];
        var v2 = basis[1];
        var c1 = v2.b.mul(k).divRound(this.n);
        var c2 = v1.b.neg().mul(k).divRound(this.n);
        var p1 = c1.mul(v1.a);
        var p2 = c2.mul(v2.a);
        var q1 = c1.mul(v1.b);
        var q2 = c2.mul(v2.b);
        var k1 = k.sub(p1).sub(p2);
        var k2 = q1.add(q2).neg();
        return { k1, k2 };
      };
      ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
        x = new BN2(x, 16);
        if (!x.red)
          x = x.toRed(this.red);
        var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
        var y = y2.redSqrt();
        if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd)
          y = y.redNeg();
        return this.point(x, y);
      };
      ShortCurve.prototype.validate = function validate(point) {
        if (point.inf)
          return true;
        var x = point.x;
        var y = point.y;
        var ax = this.a.redMul(x);
        var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
        return y.redSqr().redISub(rhs).cmpn(0) === 0;
      };
      ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
        var npoints = this._endoWnafT1;
        var ncoeffs = this._endoWnafT2;
        for (var i = 0; i < points.length; i++) {
          var split4 = this._endoSplit(coeffs[i]);
          var p = points[i];
          var beta = p._getBeta();
          if (split4.k1.negative) {
            split4.k1.ineg();
            p = p.neg(true);
          }
          if (split4.k2.negative) {
            split4.k2.ineg();
            beta = beta.neg(true);
          }
          npoints[i * 2] = p;
          npoints[i * 2 + 1] = beta;
          ncoeffs[i * 2] = split4.k1;
          ncoeffs[i * 2 + 1] = split4.k2;
        }
        var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
        for (var j = 0; j < i * 2; j++) {
          npoints[j] = null;
          ncoeffs[j] = null;
        }
        return res;
      };
      function Point(curve, x, y, isRed) {
        Base.BasePoint.call(this, curve, "affine");
        if (x === null && y === null) {
          this.x = null;
          this.y = null;
          this.inf = true;
        } else {
          this.x = new BN2(x, 16);
          this.y = new BN2(y, 16);
          if (isRed) {
            this.x.forceRed(this.curve.red);
            this.y.forceRed(this.curve.red);
          }
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.y.red)
            this.y = this.y.toRed(this.curve.red);
          this.inf = false;
        }
      }
      inherits(Point, Base.BasePoint);
      ShortCurve.prototype.point = function point(x, y, isRed) {
        return new Point(this, x, y, isRed);
      };
      ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red2) {
        return Point.fromJSON(this, obj, red2);
      };
      Point.prototype._getBeta = function _getBeta() {
        if (!this.curve.endo)
          return;
        var pre = this.precomputed;
        if (pre && pre.beta)
          return pre.beta;
        var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
        if (pre) {
          var curve = this.curve;
          var endoMul = function(p) {
            return curve.point(p.x.redMul(curve.endo.beta), p.y);
          };
          pre.beta = beta;
          beta.precomputed = {
            beta: null,
            naf: pre.naf && {
              wnd: pre.naf.wnd,
              points: pre.naf.points.map(endoMul)
            },
            doubles: pre.doubles && {
              step: pre.doubles.step,
              points: pre.doubles.points.map(endoMul)
            }
          };
        }
        return beta;
      };
      Point.prototype.toJSON = function toJSON() {
        if (!this.precomputed)
          return [this.x, this.y];
        return [this.x, this.y, this.precomputed && {
          doubles: this.precomputed.doubles && {
            step: this.precomputed.doubles.step,
            points: this.precomputed.doubles.points.slice(1)
          },
          naf: this.precomputed.naf && {
            wnd: this.precomputed.naf.wnd,
            points: this.precomputed.naf.points.slice(1)
          }
        }];
      };
      Point.fromJSON = function fromJSON(curve, obj, red2) {
        if (typeof obj === "string")
          obj = JSON.parse(obj);
        var res = curve.point(obj[0], obj[1], red2);
        if (!obj[2])
          return res;
        function obj2point(obj2) {
          return curve.point(obj2[0], obj2[1], red2);
        }
        var pre = obj[2];
        res.precomputed = {
          beta: null,
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: [res].concat(pre.doubles.points.map(obj2point))
          },
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: [res].concat(pre.naf.points.map(obj2point))
          }
        };
        return res;
      };
      Point.prototype.inspect = function inspect2() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.inf;
      };
      Point.prototype.add = function add3(p) {
        if (this.inf)
          return p;
        if (p.inf)
          return this;
        if (this.eq(p))
          return this.dbl();
        if (this.neg().eq(p))
          return this.curve.point(null, null);
        if (this.x.cmp(p.x) === 0)
          return this.curve.point(null, null);
        var c = this.y.redSub(p.y);
        if (c.cmpn(0) !== 0)
          c = c.redMul(this.x.redSub(p.x).redInvm());
        var nx = c.redSqr().redISub(this.x).redISub(p.x);
        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
      };
      Point.prototype.dbl = function dbl() {
        if (this.inf)
          return this;
        var ys1 = this.y.redAdd(this.y);
        if (ys1.cmpn(0) === 0)
          return this.curve.point(null, null);
        var a = this.curve.a;
        var x2 = this.x.redSqr();
        var dyinv = ys1.redInvm();
        var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
        var nx = c.redSqr().redISub(this.x.redAdd(this.x));
        var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
        return this.curve.point(nx, ny);
      };
      Point.prototype.getX = function getX() {
        return this.x.fromRed();
      };
      Point.prototype.getY = function getY() {
        return this.y.fromRed();
      };
      Point.prototype.mul = function mul(k) {
        k = new BN2(k, 16);
        if (this.isInfinity())
          return this;
        else if (this._hasDoubles(k))
          return this.curve._fixedNafMul(this, k);
        else if (this.curve.endo)
          return this.curve._endoWnafMulAdd([this], [k]);
        else
          return this.curve._wnafMul(this, k);
      };
      Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
        var points = [this, p2];
        var coeffs = [k1, k2];
        if (this.curve.endo)
          return this.curve._endoWnafMulAdd(points, coeffs);
        else
          return this.curve._wnafMulAdd(1, points, coeffs, 2);
      };
      Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
        var points = [this, p2];
        var coeffs = [k1, k2];
        if (this.curve.endo)
          return this.curve._endoWnafMulAdd(points, coeffs, true);
        else
          return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
      };
      Point.prototype.eq = function eq(p) {
        return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
      };
      Point.prototype.neg = function neg(_precompute) {
        if (this.inf)
          return this;
        var res = this.curve.point(this.x, this.y.redNeg());
        if (_precompute && this.precomputed) {
          var pre = this.precomputed;
          var negate = function(p) {
            return p.neg();
          };
          res.precomputed = {
            naf: pre.naf && {
              wnd: pre.naf.wnd,
              points: pre.naf.points.map(negate)
            },
            doubles: pre.doubles && {
              step: pre.doubles.step,
              points: pre.doubles.points.map(negate)
            }
          };
        }
        return res;
      };
      Point.prototype.toJ = function toJ() {
        if (this.inf)
          return this.curve.jpoint(null, null, null);
        var res = this.curve.jpoint(this.x, this.y, this.curve.one);
        return res;
      };
      function JPoint(curve, x, y, z) {
        Base.BasePoint.call(this, curve, "jacobian");
        if (x === null && y === null && z === null) {
          this.x = this.curve.one;
          this.y = this.curve.one;
          this.z = new BN2(0);
        } else {
          this.x = new BN2(x, 16);
          this.y = new BN2(y, 16);
          this.z = new BN2(z, 16);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
      }
      inherits(JPoint, Base.BasePoint);
      ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
        return new JPoint(this, x, y, z);
      };
      JPoint.prototype.toP = function toP() {
        if (this.isInfinity())
          return this.curve.point(null, null);
        var zinv = this.z.redInvm();
        var zinv2 = zinv.redSqr();
        var ax = this.x.redMul(zinv2);
        var ay = this.y.redMul(zinv2).redMul(zinv);
        return this.curve.point(ax, ay);
      };
      JPoint.prototype.neg = function neg() {
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
      };
      JPoint.prototype.add = function add3(p) {
        if (this.isInfinity())
          return p;
        if (p.isInfinity())
          return this;
        var pz2 = p.z.redSqr();
        var z2 = this.z.redSqr();
        var u1 = this.x.redMul(pz2);
        var u2 = p.x.redMul(z2);
        var s1 = this.y.redMul(pz2.redMul(p.z));
        var s2 = p.y.redMul(z2.redMul(this.z));
        var h = u1.redSub(u2);
        var r = s1.redSub(s2);
        if (h.cmpn(0) === 0) {
          if (r.cmpn(0) !== 0)
            return this.curve.jpoint(null, null, null);
          else
            return this.dbl();
        }
        var h2 = h.redSqr();
        var h3 = h2.redMul(h);
        var v = u1.redMul(h2);
        var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
        var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
        var nz = this.z.redMul(p.z).redMul(h);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.mixedAdd = function mixedAdd(p) {
        if (this.isInfinity())
          return p.toJ();
        if (p.isInfinity())
          return this;
        var z2 = this.z.redSqr();
        var u1 = this.x;
        var u2 = p.x.redMul(z2);
        var s1 = this.y;
        var s2 = p.y.redMul(z2).redMul(this.z);
        var h = u1.redSub(u2);
        var r = s1.redSub(s2);
        if (h.cmpn(0) === 0) {
          if (r.cmpn(0) !== 0)
            return this.curve.jpoint(null, null, null);
          else
            return this.dbl();
        }
        var h2 = h.redSqr();
        var h3 = h2.redMul(h);
        var v = u1.redMul(h2);
        var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
        var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
        var nz = this.z.redMul(h);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.dblp = function dblp(pow) {
        if (pow === 0)
          return this;
        if (this.isInfinity())
          return this;
        if (!pow)
          return this.dbl();
        var i;
        if (this.curve.zeroA || this.curve.threeA) {
          var r = this;
          for (i = 0; i < pow; i++)
            r = r.dbl();
          return r;
        }
        var a = this.curve.a;
        var tinv = this.curve.tinv;
        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();
        var jyd = jy.redAdd(jy);
        for (i = 0; i < pow; i++) {
          var jx2 = jx.redSqr();
          var jyd2 = jyd.redSqr();
          var jyd4 = jyd2.redSqr();
          var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
          var t1 = jx.redMul(jyd2);
          var nx = c.redSqr().redISub(t1.redAdd(t1));
          var t2 = t1.redISub(nx);
          var dny = c.redMul(t2);
          dny = dny.redIAdd(dny).redISub(jyd4);
          var nz = jyd.redMul(jz);
          if (i + 1 < pow)
            jz4 = jz4.redMul(jyd4);
          jx = nx;
          jz = nz;
          jyd = dny;
        }
        return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
      };
      JPoint.prototype.dbl = function dbl() {
        if (this.isInfinity())
          return this;
        if (this.curve.zeroA)
          return this._zeroDbl();
        else if (this.curve.threeA)
          return this._threeDbl();
        else
          return this._dbl();
      };
      JPoint.prototype._zeroDbl = function _zeroDbl() {
        var nx;
        var ny;
        var nz;
        if (this.zOne) {
          var xx = this.x.redSqr();
          var yy = this.y.redSqr();
          var yyyy = yy.redSqr();
          var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
          s = s.redIAdd(s);
          var m = xx.redAdd(xx).redIAdd(xx);
          var t = m.redSqr().redISub(s).redISub(s);
          var yyyy8 = yyyy.redIAdd(yyyy);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          nx = t;
          ny = m.redMul(s.redISub(t)).redISub(yyyy8);
          nz = this.y.redAdd(this.y);
        } else {
          var a = this.x.redSqr();
          var b = this.y.redSqr();
          var c = b.redSqr();
          var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
          d = d.redIAdd(d);
          var e = a.redAdd(a).redIAdd(a);
          var f2 = e.redSqr();
          var c8 = c.redIAdd(c);
          c8 = c8.redIAdd(c8);
          c8 = c8.redIAdd(c8);
          nx = f2.redISub(d).redISub(d);
          ny = e.redMul(d.redISub(nx)).redISub(c8);
          nz = this.y.redMul(this.z);
          nz = nz.redIAdd(nz);
        }
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype._threeDbl = function _threeDbl() {
        var nx;
        var ny;
        var nz;
        if (this.zOne) {
          var xx = this.x.redSqr();
          var yy = this.y.redSqr();
          var yyyy = yy.redSqr();
          var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
          s = s.redIAdd(s);
          var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
          var t = m.redSqr().redISub(s).redISub(s);
          nx = t;
          var yyyy8 = yyyy.redIAdd(yyyy);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          yyyy8 = yyyy8.redIAdd(yyyy8);
          ny = m.redMul(s.redISub(t)).redISub(yyyy8);
          nz = this.y.redAdd(this.y);
        } else {
          var delta = this.z.redSqr();
          var gamma = this.y.redSqr();
          var beta = this.x.redMul(gamma);
          var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
          alpha = alpha.redAdd(alpha).redIAdd(alpha);
          var beta4 = beta.redIAdd(beta);
          beta4 = beta4.redIAdd(beta4);
          var beta8 = beta4.redAdd(beta4);
          nx = alpha.redSqr().redISub(beta8);
          nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
          var ggamma8 = gamma.redSqr();
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ggamma8 = ggamma8.redIAdd(ggamma8);
          ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
        }
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype._dbl = function _dbl() {
        var a = this.curve.a;
        var jx = this.x;
        var jy = this.y;
        var jz = this.z;
        var jz4 = jz.redSqr().redSqr();
        var jx2 = jx.redSqr();
        var jy2 = jy.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var jxd4 = jx.redAdd(jx);
        jxd4 = jxd4.redIAdd(jxd4);
        var t1 = jxd4.redMul(jy2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var jyd8 = jy2.redSqr();
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        jyd8 = jyd8.redIAdd(jyd8);
        var ny = c.redMul(t2).redISub(jyd8);
        var nz = jy.redAdd(jy).redMul(jz);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.trpl = function trpl() {
        if (!this.curve.zeroA)
          return this.dbl().add(this);
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var zz = this.z.redSqr();
        var yyyy = yy.redSqr();
        var m = xx.redAdd(xx).redIAdd(xx);
        var mm = m.redSqr();
        var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        e = e.redIAdd(e);
        e = e.redAdd(e).redIAdd(e);
        e = e.redISub(mm);
        var ee = e.redSqr();
        var t = yyyy.redIAdd(yyyy);
        t = t.redIAdd(t);
        t = t.redIAdd(t);
        t = t.redIAdd(t);
        var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
        var yyu4 = yy.redMul(u);
        yyu4 = yyu4.redIAdd(yyu4);
        yyu4 = yyu4.redIAdd(yyu4);
        var nx = this.x.redMul(ee).redISub(yyu4);
        nx = nx.redIAdd(nx);
        nx = nx.redIAdd(nx);
        var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        ny = ny.redIAdd(ny);
        var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
        return this.curve.jpoint(nx, ny, nz);
      };
      JPoint.prototype.mul = function mul(k, kbase) {
        k = new BN2(k, kbase);
        return this.curve._wnafMul(this, k);
      };
      JPoint.prototype.eq = function eq(p) {
        if (p.type === "affine")
          return this.eq(p.toJ());
        if (this === p)
          return true;
        var z2 = this.z.redSqr();
        var pz2 = p.z.redSqr();
        if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
          return false;
        var z3 = z2.redMul(this.z);
        var pz3 = pz2.redMul(p.z);
        return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
      };
      JPoint.prototype.eqXToP = function eqXToP(x) {
        var zs = this.z.redSqr();
        var rx = x.toRed(this.curve.red).redMul(zs);
        if (this.x.cmp(rx) === 0)
          return true;
        var xc = x.clone();
        var t = this.curve.redN.redMul(zs);
        for (; ; ) {
          xc.iadd(this.curve.n);
          if (xc.cmp(this.curve.p) >= 0)
            return false;
          rx.redIAdd(t);
          if (this.x.cmp(rx) === 0)
            return true;
        }
      };
      JPoint.prototype.inspect = function inspect2() {
        if (this.isInfinity())
          return "<EC JPoint Infinity>";
        return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
      };
      JPoint.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
      };
    }
  });

  // ../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/curve/mont.js
  var require_mont = __commonJS({
    "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/curve/mont.js"(exports, module2) {
      "use strict";
      var BN2 = require_bn2();
      var inherits = require_inherits();
      var Base = require_base3();
      var utils = require_utils5();
      function MontCurve(conf) {
        Base.call(this, "mont", conf);
        this.a = new BN2(conf.a, 16).toRed(this.red);
        this.b = new BN2(conf.b, 16).toRed(this.red);
        this.i4 = new BN2(4).toRed(this.red).redInvm();
        this.two = new BN2(2).toRed(this.red);
        this.a24 = this.i4.redMul(this.a.redAdd(this.two));
      }
      inherits(MontCurve, Base);
      module2.exports = MontCurve;
      MontCurve.prototype.validate = function validate(point) {
        var x = point.normalize().x;
        var x2 = x.redSqr();
        var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
        var y = rhs.redSqrt();
        return y.redSqr().cmp(rhs) === 0;
      };
      function Point(curve, x, z) {
        Base.BasePoint.call(this, curve, "projective");
        if (x === null && z === null) {
          this.x = this.curve.one;
          this.z = this.curve.zero;
        } else {
          this.x = new BN2(x, 16);
          this.z = new BN2(z, 16);
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.z.red)
            this.z = this.z.toRed(this.curve.red);
        }
      }
      inherits(Point, Base.BasePoint);
      MontCurve.prototype.decodePoint = function decodePoint(bytes3, enc) {
        return this.point(utils.toArray(bytes3, enc), 1);
      };
      MontCurve.prototype.point = function point(x, z) {
        return new Point(this, x, z);
      };
      MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point.fromJSON(this, obj);
      };
      Point.prototype.precompute = function precompute() {
      };
      Point.prototype._encode = function _encode() {
        return this.getX().toArray("be", this.curve.p.byteLength());
      };
      Point.fromJSON = function fromJSON(curve, obj) {
        return new Point(curve, obj[0], obj[1] || curve.one);
      };
      Point.prototype.inspect = function inspect2() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.z.cmpn(0) === 0;
      };
      Point.prototype.dbl = function dbl() {
        var a = this.x.redAdd(this.z);
        var aa = a.redSqr();
        var b = this.x.redSub(this.z);
        var bb = b.redSqr();
        var c = aa.redSub(bb);
        var nx = aa.redMul(bb);
        var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
        return this.curve.point(nx, nz);
      };
      Point.prototype.add = function add3() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.diffAdd = function diffAdd(p, diff) {
        var a = this.x.redAdd(this.z);
        var b = this.x.redSub(this.z);
        var c = p.x.redAdd(p.z);
        var d = p.x.redSub(p.z);
        var da = d.redMul(a);
        var cb = c.redMul(b);
        var nx = diff.z.redMul(da.redAdd(cb).redSqr());
        var nz = diff.x.redMul(da.redISub(cb).redSqr());
        return this.curve.point(nx, nz);
      };
      Point.prototype.mul = function mul(k) {
        var t = k.clone();
        var a = this;
        var b = this.curve.point(null, null);
        var c = this;
        for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
          bits.push(t.andln(1));
        for (var i = bits.length - 1; i >= 0; i--) {
          if (bits[i] === 0) {
            a = a.diffAdd(b, c);
            b = b.dbl();
          } else {
            b = a.diffAdd(b, c);
            a = a.dbl();
          }
        }
        return b;
      };
      Point.prototype.mulAdd = function mulAdd() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.jumlAdd = function jumlAdd() {
        throw new Error("Not supported on Montgomery curve");
      };
      Point.prototype.eq = function eq(other) {
        return this.getX().cmp(other.getX()) === 0;
      };
      Point.prototype.normalize = function normalize4() {
        this.x = this.x.redMul(this.z.redInvm());
        this.z = this.curve.one;
        return this;
      };
      Point.prototype.getX = function getX() {
        this.normalize();
        return this.x.fromRed();
      };
    }
  });

  // ../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/curve/edwards.js
  var require_edwards = __commonJS({
    "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports, module2) {
      "use strict";
      var utils = require_utils5();
      var BN2 = require_bn2();
      var inherits = require_inherits();
      var Base = require_base3();
      var assert5 = utils.assert;
      function EdwardsCurve(conf) {
        this.twisted = (conf.a | 0) !== 1;
        this.mOneA = this.twisted && (conf.a | 0) === -1;
        this.extended = this.mOneA;
        Base.call(this, "edwards", conf);
        this.a = new BN2(conf.a, 16).umod(this.red.m);
        this.a = this.a.toRed(this.red);
        this.c = new BN2(conf.c, 16).toRed(this.red);
        this.c2 = this.c.redSqr();
        this.d = new BN2(conf.d, 16).toRed(this.red);
        this.dd = this.d.redAdd(this.d);
        assert5(!this.twisted || this.c.fromRed().cmpn(1) === 0);
        this.oneC = (conf.c | 0) === 1;
      }
      inherits(EdwardsCurve, Base);
      module2.exports = EdwardsCurve;
      EdwardsCurve.prototype._mulA = function _mulA(num) {
        if (this.mOneA)
          return num.redNeg();
        else
          return this.a.redMul(num);
      };
      EdwardsCurve.prototype._mulC = function _mulC(num) {
        if (this.oneC)
          return num;
        else
          return this.c.redMul(num);
      };
      EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
        return this.point(x, y, z, t);
      };
      EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
        x = new BN2(x, 16);
        if (!x.red)
          x = x.toRed(this.red);
        var x2 = x.redSqr();
        var rhs = this.c2.redSub(this.a.redMul(x2));
        var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
        var y2 = rhs.redMul(lhs.redInvm());
        var y = y2.redSqrt();
        if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        var isOdd = y.fromRed().isOdd();
        if (odd && !isOdd || !odd && isOdd)
          y = y.redNeg();
        return this.point(x, y);
      };
      EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
        y = new BN2(y, 16);
        if (!y.red)
          y = y.toRed(this.red);
        var y2 = y.redSqr();
        var lhs = y2.redSub(this.c2);
        var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
        var x2 = lhs.redMul(rhs.redInvm());
        if (x2.cmp(this.zero) === 0) {
          if (odd)
            throw new Error("invalid point");
          else
            return this.point(this.zero, y);
        }
        var x = x2.redSqrt();
        if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
          throw new Error("invalid point");
        if (x.fromRed().isOdd() !== odd)
          x = x.redNeg();
        return this.point(x, y);
      };
      EdwardsCurve.prototype.validate = function validate(point) {
        if (point.isInfinity())
          return true;
        point.normalize();
        var x2 = point.x.redSqr();
        var y2 = point.y.redSqr();
        var lhs = x2.redMul(this.a).redAdd(y2);
        var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
        return lhs.cmp(rhs) === 0;
      };
      function Point(curve, x, y, z, t) {
        Base.BasePoint.call(this, curve, "projective");
        if (x === null && y === null && z === null) {
          this.x = this.curve.zero;
          this.y = this.curve.one;
          this.z = this.curve.one;
          this.t = this.curve.zero;
          this.zOne = true;
        } else {
          this.x = new BN2(x, 16);
          this.y = new BN2(y, 16);
          this.z = z ? new BN2(z, 16) : this.curve.one;
          this.t = t && new BN2(t, 16);
          if (!this.x.red)
            this.x = this.x.toRed(this.curve.red);
          if (!this.y.red)
            this.y = this.y.toRed(this.curve.red);
          if (!this.z.red)
            this.z = this.z.toRed(this.curve.red);
          if (this.t && !this.t.red)
            this.t = this.t.toRed(this.curve.red);
          this.zOne = this.z === this.curve.one;
          if (this.curve.extended && !this.t) {
            this.t = this.x.redMul(this.y);
            if (!this.zOne)
              this.t = this.t.redMul(this.z.redInvm());
          }
        }
      }
      inherits(Point, Base.BasePoint);
      EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
        return Point.fromJSON(this, obj);
      };
      EdwardsCurve.prototype.point = function point(x, y, z, t) {
        return new Point(this, x, y, z, t);
      };
      Point.fromJSON = function fromJSON(curve, obj) {
        return new Point(curve, obj[0], obj[1], obj[2]);
      };
      Point.prototype.inspect = function inspect2() {
        if (this.isInfinity())
          return "<EC Point Infinity>";
        return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
      };
      Point.prototype.isInfinity = function isInfinity() {
        return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
      };
      Point.prototype._extDbl = function _extDbl() {
        var a = this.x.redSqr();
        var b = this.y.redSqr();
        var c = this.z.redSqr();
        c = c.redIAdd(c);
        var d = this.curve._mulA(a);
        var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
        var g = d.redAdd(b);
        var f2 = g.redSub(c);
        var h = d.redSub(b);
        var nx = e.redMul(f2);
        var ny = g.redMul(h);
        var nt = e.redMul(h);
        var nz = f2.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
      };
      Point.prototype._projDbl = function _projDbl() {
        var b = this.x.redAdd(this.y).redSqr();
        var c = this.x.redSqr();
        var d = this.y.redSqr();
        var nx;
        var ny;
        var nz;
        var e;
        var h;
        var j;
        if (this.curve.twisted) {
          e = this.curve._mulA(c);
          var f2 = e.redAdd(d);
          if (this.zOne) {
            nx = b.redSub(c).redSub(d).redMul(f2.redSub(this.curve.two));
            ny = f2.redMul(e.redSub(d));
            nz = f2.redSqr().redSub(f2).redSub(f2);
          } else {
            h = this.z.redSqr();
            j = f2.redSub(h).redISub(h);
            nx = b.redSub(c).redISub(d).redMul(j);
            ny = f2.redMul(e.redSub(d));
            nz = f2.redMul(j);
          }
        } else {
          e = c.redAdd(d);
          h = this.curve._mulC(this.z).redSqr();
          j = e.redSub(h).redSub(h);
          nx = this.curve._mulC(b.redISub(e)).redMul(j);
          ny = this.curve._mulC(e).redMul(c.redISub(d));
          nz = e.redMul(j);
        }
        return this.curve.point(nx, ny, nz);
      };
      Point.prototype.dbl = function dbl() {
        if (this.isInfinity())
          return this;
        if (this.curve.extended)
          return this._extDbl();
        else
          return this._projDbl();
      };
      Point.prototype._extAdd = function _extAdd(p) {
        var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
        var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
        var c = this.t.redMul(this.curve.dd).redMul(p.t);
        var d = this.z.redMul(p.z.redAdd(p.z));
        var e = b.redSub(a);
        var f2 = d.redSub(c);
        var g = d.redAdd(c);
        var h = b.redAdd(a);
        var nx = e.redMul(f2);
        var ny = g.redMul(h);
        var nt = e.redMul(h);
        var nz = f2.redMul(g);
        return this.curve.point(nx, ny, nz, nt);
      };
      Point.prototype._projAdd = function _projAdd(p) {
        var a = this.z.redMul(p.z);
        var b = a.redSqr();
        var c = this.x.redMul(p.x);
        var d = this.y.redMul(p.y);
        var e = this.curve.d.redMul(c).redMul(d);
        var f2 = b.redSub(e);
        var g = b.redAdd(e);
        var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
        var nx = a.redMul(f2).redMul(tmp);
        var ny;
        var nz;
        if (this.curve.twisted) {
          ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
          nz = f2.redMul(g);
        } else {
          ny = a.redMul(g).redMul(d.redSub(c));
          nz = this.curve._mulC(f2).redMul(g);
        }
        return this.curve.point(nx, ny, nz);
      };
      Point.prototype.add = function add3(p) {
        if (this.isInfinity())
          return p;
        if (p.isInfinity())
          return this;
        if (this.curve.extended)
          return this._extAdd(p);
        else
          return this._projAdd(p);
      };
      Point.prototype.mul = function mul(k) {
        if (this._hasDoubles(k))
          return this.curve._fixedNafMul(this, k);
        else
          return this.curve._wnafMul(this, k);
      };
      Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
        return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
      };
      Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
        return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
      };
      Point.prototype.normalize = function normalize4() {
        if (this.zOne)
          return this;
        var zi = this.z.redInvm();
        this.x = this.x.redMul(zi);
        this.y = this.y.redMul(zi);
        if (this.t)
          this.t = this.t.redMul(zi);
        this.z = this.curve.one;
        this.zOne = true;
        return this;
      };
      Point.prototype.neg = function neg() {
        return this.curve.point(
          this.x.redNeg(),
          this.y,
          this.z,
          this.t && this.t.redNeg()
        );
      };
      Point.prototype.getX = function getX() {
        this.normalize();
        return this.x.fromRed();
      };
      Point.prototype.getY = function getY() {
        this.normalize();
        return this.y.fromRed();
      };
      Point.prototype.eq = function eq(other) {
        return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
      };
      Point.prototype.eqXToP = function eqXToP(x) {
        var rx = x.toRed(this.curve.red).redMul(this.z);
        if (this.x.cmp(rx) === 0)
          return true;
        var xc = x.clone();
        var t = this.curve.redN.redMul(this.z);
        for (; ; ) {
          xc.iadd(this.curve.n);
          if (xc.cmp(this.curve.p) >= 0)
            return false;
          rx.redIAdd(t);
          if (this.x.cmp(rx) === 0)
            return true;
        }
      };
      Point.prototype.toP = Point.prototype.normalize;
      Point.prototype.mixedAdd = Point.prototype.add;
    }
  });

  // ../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/curve/index.js
  var require_curve = __commonJS({
    "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/curve/index.js"(exports) {
      "use strict";
      var curve = exports;
      curve.base = require_base3();
      curve.short = require_short();
      curve.mont = require_mont();
      curve.edwards = require_edwards();
    }
  });

  // ../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/utils.js
  var require_utils6 = __commonJS({
    "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/utils.js"(exports) {
      "use strict";
      var assert5 = require_minimalistic_assert();
      var inherits = require_inherits();
      exports.inherits = inherits;
      function isSurrogatePair(msg, i) {
        if ((msg.charCodeAt(i) & 64512) !== 55296) {
          return false;
        }
        if (i < 0 || i + 1 >= msg.length) {
          return false;
        }
        return (msg.charCodeAt(i + 1) & 64512) === 56320;
      }
      function toArray2(msg, enc) {
        if (Array.isArray(msg))
          return msg.slice();
        if (!msg)
          return [];
        var res = [];
        if (typeof msg === "string") {
          if (!enc) {
            var p = 0;
            for (var i = 0; i < msg.length; i++) {
              var c = msg.charCodeAt(i);
              if (c < 128) {
                res[p++] = c;
              } else if (c < 2048) {
                res[p++] = c >> 6 | 192;
                res[p++] = c & 63 | 128;
              } else if (isSurrogatePair(msg, i)) {
                c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
                res[p++] = c >> 18 | 240;
                res[p++] = c >> 12 & 63 | 128;
                res[p++] = c >> 6 & 63 | 128;
                res[p++] = c & 63 | 128;
              } else {
                res[p++] = c >> 12 | 224;
                res[p++] = c >> 6 & 63 | 128;
                res[p++] = c & 63 | 128;
              }
            }
          } else if (enc === "hex") {
            msg = msg.replace(/[^a-z0-9]+/ig, "");
            if (msg.length % 2 !== 0)
              msg = "0" + msg;
            for (i = 0; i < msg.length; i += 2)
              res.push(parseInt(msg[i] + msg[i + 1], 16));
          }
        } else {
          for (i = 0; i < msg.length; i++)
            res[i] = msg[i] | 0;
        }
        return res;
      }
      exports.toArray = toArray2;
      function toHex2(msg) {
        var res = "";
        for (var i = 0; i < msg.length; i++)
          res += zero2(msg[i].toString(16));
        return res;
      }
      exports.toHex = toHex2;
      function htonl(w) {
        var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
        return res >>> 0;
      }
      exports.htonl = htonl;
      function toHex32(msg, endian) {
        var res = "";
        for (var i = 0; i < msg.length; i++) {
          var w = msg[i];
          if (endian === "little")
            w = htonl(w);
          res += zero8(w.toString(16));
        }
        return res;
      }
      exports.toHex32 = toHex32;
      function zero2(word) {
        if (word.length === 1)
          return "0" + word;
        else
          return word;
      }
      exports.zero2 = zero2;
      function zero8(word) {
        if (word.length === 7)
          return "0" + word;
        else if (word.length === 6)
          return "00" + word;
        else if (word.length === 5)
          return "000" + word;
        else if (word.length === 4)
          return "0000" + word;
        else if (word.length === 3)
          return "00000" + word;
        else if (word.length === 2)
          return "000000" + word;
        else if (word.length === 1)
          return "0000000" + word;
        else
          return word;
      }
      exports.zero8 = zero8;
      function join322(msg, start, end, endian) {
        var len = end - start;
        assert5(len % 4 === 0);
        var res = new Array(len / 4);
        for (var i = 0, k = start; i < res.length; i++, k += 4) {
          var w;
          if (endian === "big")
            w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
          else
            w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
          res[i] = w >>> 0;
        }
        return res;
      }
      exports.join32 = join322;
      function split32(msg, endian) {
        var res = new Array(msg.length * 4);
        for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
          var m = msg[i];
          if (endian === "big") {
            res[k] = m >>> 24;
            res[k + 1] = m >>> 16 & 255;
            res[k + 2] = m >>> 8 & 255;
            res[k + 3] = m & 255;
          } else {
            res[k + 3] = m >>> 24;
            res[k + 2] = m >>> 16 & 255;
            res[k + 1] = m >>> 8 & 255;
            res[k] = m & 255;
          }
        }
        return res;
      }
      exports.split32 = split32;
      function rotr32(w, b) {
        return w >>> b | w << 32 - b;
      }
      exports.rotr32 = rotr32;
      function rotl32(w, b) {
        return w << b | w >>> 32 - b;
      }
      exports.rotl32 = rotl32;
      function sum32(a, b) {
        return a + b >>> 0;
      }
      exports.sum32 = sum32;
      function sum32_3(a, b, c) {
        return a + b + c >>> 0;
      }
      exports.sum32_3 = sum32_3;
      function sum32_4(a, b, c, d) {
        return a + b + c + d >>> 0;
      }
      exports.sum32_4 = sum32_4;
      function sum32_5(a, b, c, d, e) {
        return a + b + c + d + e >>> 0;
      }
      exports.sum32_5 = sum32_5;
      function sum64(buf, pos, ah, al) {
        var bh = buf[pos];
        var bl = buf[pos + 1];
        var lo = al + bl >>> 0;
        var hi = (lo < al ? 1 : 0) + ah + bh;
        buf[pos] = hi >>> 0;
        buf[pos + 1] = lo;
      }
      exports.sum64 = sum64;
      function sum64_hi(ah, al, bh, bl) {
        var lo = al + bl >>> 0;
        var hi = (lo < al ? 1 : 0) + ah + bh;
        return hi >>> 0;
      }
      exports.sum64_hi = sum64_hi;
      function sum64_lo(ah, al, bh, bl) {
        var lo = al + bl;
        return lo >>> 0;
      }
      exports.sum64_lo = sum64_lo;
      function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
        var carry = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry += lo < dl ? 1 : 0;
        var hi = ah + bh + ch + dh + carry;
        return hi >>> 0;
      }
      exports.sum64_4_hi = sum64_4_hi;
      function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
        var lo = al + bl + cl + dl;
        return lo >>> 0;
      }
      exports.sum64_4_lo = sum64_4_lo;
      function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var carry = 0;
        var lo = al;
        lo = lo + bl >>> 0;
        carry += lo < al ? 1 : 0;
        lo = lo + cl >>> 0;
        carry += lo < cl ? 1 : 0;
        lo = lo + dl >>> 0;
        carry += lo < dl ? 1 : 0;
        lo = lo + el >>> 0;
        carry += lo < el ? 1 : 0;
        var hi = ah + bh + ch + dh + eh + carry;
        return hi >>> 0;
      }
      exports.sum64_5_hi = sum64_5_hi;
      function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
        var lo = al + bl + cl + dl + el;
        return lo >>> 0;
      }
      exports.sum64_5_lo = sum64_5_lo;
      function rotr64_hi(ah, al, num) {
        var r = al << 32 - num | ah >>> num;
        return r >>> 0;
      }
      exports.rotr64_hi = rotr64_hi;
      function rotr64_lo(ah, al, num) {
        var r = ah << 32 - num | al >>> num;
        return r >>> 0;
      }
      exports.rotr64_lo = rotr64_lo;
      function shr64_hi(ah, al, num) {
        return ah >>> num;
      }
      exports.shr64_hi = shr64_hi;
      function shr64_lo(ah, al, num) {
        var r = ah << 32 - num | al >>> num;
        return r >>> 0;
      }
      exports.shr64_lo = shr64_lo;
    }
  });

  // ../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/common.js
  var require_common2 = __commonJS({
    "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/common.js"(exports) {
      "use strict";
      var utils = require_utils6();
      var assert5 = require_minimalistic_assert();
      function BlockHash() {
        this.pending = null;
        this.pendingTotal = 0;
        this.blockSize = this.constructor.blockSize;
        this.outSize = this.constructor.outSize;
        this.hmacStrength = this.constructor.hmacStrength;
        this.padLength = this.constructor.padLength / 8;
        this.endian = "big";
        this._delta8 = this.blockSize / 8;
        this._delta32 = this.blockSize / 32;
      }
      exports.BlockHash = BlockHash;
      BlockHash.prototype.update = function update(msg, enc) {
        msg = utils.toArray(msg, enc);
        if (!this.pending)
          this.pending = msg;
        else
          this.pending = this.pending.concat(msg);
        this.pendingTotal += msg.length;
        if (this.pending.length >= this._delta8) {
          msg = this.pending;
          var r = msg.length % this._delta8;
          this.pending = msg.slice(msg.length - r, msg.length);
          if (this.pending.length === 0)
            this.pending = null;
          msg = utils.join32(msg, 0, msg.length - r, this.endian);
          for (var i = 0; i < msg.length; i += this._delta32)
            this._update(msg, i, i + this._delta32);
        }
        return this;
      };
      BlockHash.prototype.digest = function digest(enc) {
        this.update(this._pad());
        assert5(this.pending === null);
        return this._digest(enc);
      };
      BlockHash.prototype._pad = function pad3() {
        var len = this.pendingTotal;
        var bytes3 = this._delta8;
        var k = bytes3 - (len + this.padLength) % bytes3;
        var res = new Array(k + this.padLength);
        res[0] = 128;
        for (var i = 1; i < k; i++)
          res[i] = 0;
        len <<= 3;
        if (this.endian === "big") {
          for (var t = 8; t < this.padLength; t++)
            res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = len >>> 24 & 255;
          res[i++] = len >>> 16 & 255;
          res[i++] = len >>> 8 & 255;
          res[i++] = len & 255;
        } else {
          res[i++] = len & 255;
          res[i++] = len >>> 8 & 255;
          res[i++] = len >>> 16 & 255;
          res[i++] = len >>> 24 & 255;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          res[i++] = 0;
          for (t = 8; t < this.padLength; t++)
            res[i++] = 0;
        }
        return res;
      };
    }
  });

  // ../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/common.js
  var require_common3 = __commonJS({
    "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/common.js"(exports) {
      "use strict";
      var utils = require_utils6();
      var rotr32 = utils.rotr32;
      function ft_1(s, x, y, z) {
        if (s === 0)
          return ch32(x, y, z);
        if (s === 1 || s === 3)
          return p32(x, y, z);
        if (s === 2)
          return maj32(x, y, z);
      }
      exports.ft_1 = ft_1;
      function ch32(x, y, z) {
        return x & y ^ ~x & z;
      }
      exports.ch32 = ch32;
      function maj32(x, y, z) {
        return x & y ^ x & z ^ y & z;
      }
      exports.maj32 = maj32;
      function p32(x, y, z) {
        return x ^ y ^ z;
      }
      exports.p32 = p32;
      function s0_256(x) {
        return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
      }
      exports.s0_256 = s0_256;
      function s1_256(x) {
        return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
      }
      exports.s1_256 = s1_256;
      function g0_256(x) {
        return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
      }
      exports.g0_256 = g0_256;
      function g1_256(x) {
        return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
      }
      exports.g1_256 = g1_256;
    }
  });

  // ../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/1.js
  var require__ = __commonJS({
    "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/1.js"(exports, module2) {
      "use strict";
      var utils = require_utils6();
      var common = require_common2();
      var shaCommon = require_common3();
      var rotl32 = utils.rotl32;
      var sum32 = utils.sum32;
      var sum32_5 = utils.sum32_5;
      var ft_1 = shaCommon.ft_1;
      var BlockHash = common.BlockHash;
      var sha1_K = [
        1518500249,
        1859775393,
        2400959708,
        3395469782
      ];
      function SHA1() {
        if (!(this instanceof SHA1))
          return new SHA1();
        BlockHash.call(this);
        this.h = [
          1732584193,
          4023233417,
          2562383102,
          271733878,
          3285377520
        ];
        this.W = new Array(80);
      }
      utils.inherits(SHA1, BlockHash);
      module2.exports = SHA1;
      SHA1.blockSize = 512;
      SHA1.outSize = 160;
      SHA1.hmacStrength = 80;
      SHA1.padLength = 64;
      SHA1.prototype._update = function _update(msg, start) {
        var W = this.W;
        for (var i = 0; i < 16; i++)
          W[i] = msg[start + i];
        for (; i < W.length; i++)
          W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
        var a = this.h[0];
        var b = this.h[1];
        var c = this.h[2];
        var d = this.h[3];
        var e = this.h[4];
        for (i = 0; i < W.length; i++) {
          var s = ~~(i / 20);
          var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
          e = d;
          d = c;
          c = rotl32(b, 30);
          b = a;
          a = t;
        }
        this.h[0] = sum32(this.h[0], a);
        this.h[1] = sum32(this.h[1], b);
        this.h[2] = sum32(this.h[2], c);
        this.h[3] = sum32(this.h[3], d);
        this.h[4] = sum32(this.h[4], e);
      };
      SHA1.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
    }
  });

  // ../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/256.js
  var require__2 = __commonJS({
    "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/256.js"(exports, module2) {
      "use strict";
      var utils = require_utils6();
      var common = require_common2();
      var shaCommon = require_common3();
      var assert5 = require_minimalistic_assert();
      var sum32 = utils.sum32;
      var sum32_4 = utils.sum32_4;
      var sum32_5 = utils.sum32_5;
      var ch32 = shaCommon.ch32;
      var maj32 = shaCommon.maj32;
      var s0_256 = shaCommon.s0_256;
      var s1_256 = shaCommon.s1_256;
      var g0_256 = shaCommon.g0_256;
      var g1_256 = shaCommon.g1_256;
      var BlockHash = common.BlockHash;
      var sha256_K = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      function SHA2562() {
        if (!(this instanceof SHA2562))
          return new SHA2562();
        BlockHash.call(this);
        this.h = [
          1779033703,
          3144134277,
          1013904242,
          2773480762,
          1359893119,
          2600822924,
          528734635,
          1541459225
        ];
        this.k = sha256_K;
        this.W = new Array(64);
      }
      utils.inherits(SHA2562, BlockHash);
      module2.exports = SHA2562;
      SHA2562.blockSize = 512;
      SHA2562.outSize = 256;
      SHA2562.hmacStrength = 192;
      SHA2562.padLength = 64;
      SHA2562.prototype._update = function _update(msg, start) {
        var W = this.W;
        for (var i = 0; i < 16; i++)
          W[i] = msg[start + i];
        for (; i < W.length; i++)
          W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
        var a = this.h[0];
        var b = this.h[1];
        var c = this.h[2];
        var d = this.h[3];
        var e = this.h[4];
        var f2 = this.h[5];
        var g = this.h[6];
        var h = this.h[7];
        assert5(this.k.length === W.length);
        for (i = 0; i < W.length; i++) {
          var T1 = sum32_5(h, s1_256(e), ch32(e, f2, g), this.k[i], W[i]);
          var T2 = sum32(s0_256(a), maj32(a, b, c));
          h = g;
          g = f2;
          f2 = e;
          e = sum32(d, T1);
          d = c;
          c = b;
          b = a;
          a = sum32(T1, T2);
        }
        this.h[0] = sum32(this.h[0], a);
        this.h[1] = sum32(this.h[1], b);
        this.h[2] = sum32(this.h[2], c);
        this.h[3] = sum32(this.h[3], d);
        this.h[4] = sum32(this.h[4], e);
        this.h[5] = sum32(this.h[5], f2);
        this.h[6] = sum32(this.h[6], g);
        this.h[7] = sum32(this.h[7], h);
      };
      SHA2562.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
    }
  });

  // ../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/224.js
  var require__3 = __commonJS({
    "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/224.js"(exports, module2) {
      "use strict";
      var utils = require_utils6();
      var SHA2562 = require__2();
      function SHA2242() {
        if (!(this instanceof SHA2242))
          return new SHA2242();
        SHA2562.call(this);
        this.h = [
          3238371032,
          914150663,
          812702999,
          4144912697,
          4290775857,
          1750603025,
          1694076839,
          3204075428
        ];
      }
      utils.inherits(SHA2242, SHA2562);
      module2.exports = SHA2242;
      SHA2242.blockSize = 512;
      SHA2242.outSize = 224;
      SHA2242.hmacStrength = 192;
      SHA2242.padLength = 64;
      SHA2242.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h.slice(0, 7), "big");
        else
          return utils.split32(this.h.slice(0, 7), "big");
      };
    }
  });

  // ../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/512.js
  var require__4 = __commonJS({
    "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/512.js"(exports, module2) {
      "use strict";
      var utils = require_utils6();
      var common = require_common2();
      var assert5 = require_minimalistic_assert();
      var rotr64_hi = utils.rotr64_hi;
      var rotr64_lo = utils.rotr64_lo;
      var shr64_hi = utils.shr64_hi;
      var shr64_lo = utils.shr64_lo;
      var sum64 = utils.sum64;
      var sum64_hi = utils.sum64_hi;
      var sum64_lo = utils.sum64_lo;
      var sum64_4_hi = utils.sum64_4_hi;
      var sum64_4_lo = utils.sum64_4_lo;
      var sum64_5_hi = utils.sum64_5_hi;
      var sum64_5_lo = utils.sum64_5_lo;
      var BlockHash = common.BlockHash;
      var sha512_K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function SHA512() {
        if (!(this instanceof SHA512))
          return new SHA512();
        BlockHash.call(this);
        this.h = [
          1779033703,
          4089235720,
          3144134277,
          2227873595,
          1013904242,
          4271175723,
          2773480762,
          1595750129,
          1359893119,
          2917565137,
          2600822924,
          725511199,
          528734635,
          4215389547,
          1541459225,
          327033209
        ];
        this.k = sha512_K;
        this.W = new Array(160);
      }
      utils.inherits(SHA512, BlockHash);
      module2.exports = SHA512;
      SHA512.blockSize = 1024;
      SHA512.outSize = 512;
      SHA512.hmacStrength = 192;
      SHA512.padLength = 128;
      SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
        var W = this.W;
        for (var i = 0; i < 32; i++)
          W[i] = msg[start + i];
        for (; i < W.length; i += 2) {
          var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
          var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
          var c1_hi = W[i - 14];
          var c1_lo = W[i - 13];
          var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
          var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
          var c3_hi = W[i - 32];
          var c3_lo = W[i - 31];
          W[i] = sum64_4_hi(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo
          );
          W[i + 1] = sum64_4_lo(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo
          );
        }
      };
      SHA512.prototype._update = function _update(msg, start) {
        this._prepareBlock(msg, start);
        var W = this.W;
        var ah = this.h[0];
        var al = this.h[1];
        var bh = this.h[2];
        var bl = this.h[3];
        var ch = this.h[4];
        var cl = this.h[5];
        var dh = this.h[6];
        var dl = this.h[7];
        var eh = this.h[8];
        var el = this.h[9];
        var fh = this.h[10];
        var fl = this.h[11];
        var gh = this.h[12];
        var gl = this.h[13];
        var hh = this.h[14];
        var hl = this.h[15];
        assert5(this.k.length === W.length);
        for (var i = 0; i < W.length; i += 2) {
          var c0_hi = hh;
          var c0_lo = hl;
          var c1_hi = s1_512_hi(eh, el);
          var c1_lo = s1_512_lo(eh, el);
          var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
          var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
          var c3_hi = this.k[i];
          var c3_lo = this.k[i + 1];
          var c4_hi = W[i];
          var c4_lo = W[i + 1];
          var T1_hi = sum64_5_hi(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo,
            c4_hi,
            c4_lo
          );
          var T1_lo = sum64_5_lo(
            c0_hi,
            c0_lo,
            c1_hi,
            c1_lo,
            c2_hi,
            c2_lo,
            c3_hi,
            c3_lo,
            c4_hi,
            c4_lo
          );
          c0_hi = s0_512_hi(ah, al);
          c0_lo = s0_512_lo(ah, al);
          c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
          c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
          var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
          var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
          hh = gh;
          hl = gl;
          gh = fh;
          gl = fl;
          fh = eh;
          fl = el;
          eh = sum64_hi(dh, dl, T1_hi, T1_lo);
          el = sum64_lo(dl, dl, T1_hi, T1_lo);
          dh = ch;
          dl = cl;
          ch = bh;
          cl = bl;
          bh = ah;
          bl = al;
          ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
          al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
        }
        sum64(this.h, 0, ah, al);
        sum64(this.h, 2, bh, bl);
        sum64(this.h, 4, ch, cl);
        sum64(this.h, 6, dh, dl);
        sum64(this.h, 8, eh, el);
        sum64(this.h, 10, fh, fl);
        sum64(this.h, 12, gh, gl);
        sum64(this.h, 14, hh, hl);
      };
      SHA512.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "big");
        else
          return utils.split32(this.h, "big");
      };
      function ch64_hi(xh, xl, yh, yl, zh) {
        var r = xh & yh ^ ~xh & zh;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function ch64_lo(xh, xl, yh, yl, zh, zl) {
        var r = xl & yl ^ ~xl & zl;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function maj64_hi(xh, xl, yh, yl, zh) {
        var r = xh & yh ^ xh & zh ^ yh & zh;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function maj64_lo(xh, xl, yh, yl, zh, zl) {
        var r = xl & yl ^ xl & zl ^ yl & zl;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 28);
        var c1_hi = rotr64_hi(xl, xh, 2);
        var c2_hi = rotr64_hi(xl, xh, 7);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 28);
        var c1_lo = rotr64_lo(xl, xh, 2);
        var c2_lo = rotr64_lo(xl, xh, 7);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 14);
        var c1_hi = rotr64_hi(xh, xl, 18);
        var c2_hi = rotr64_hi(xl, xh, 9);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function s1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 14);
        var c1_lo = rotr64_lo(xh, xl, 18);
        var c2_lo = rotr64_lo(xl, xh, 9);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g0_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 1);
        var c1_hi = rotr64_hi(xh, xl, 8);
        var c2_hi = shr64_hi(xh, xl, 7);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g0_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 1);
        var c1_lo = rotr64_lo(xh, xl, 8);
        var c2_lo = shr64_lo(xh, xl, 7);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g1_512_hi(xh, xl) {
        var c0_hi = rotr64_hi(xh, xl, 19);
        var c1_hi = rotr64_hi(xl, xh, 29);
        var c2_hi = shr64_hi(xh, xl, 6);
        var r = c0_hi ^ c1_hi ^ c2_hi;
        if (r < 0)
          r += 4294967296;
        return r;
      }
      function g1_512_lo(xh, xl) {
        var c0_lo = rotr64_lo(xh, xl, 19);
        var c1_lo = rotr64_lo(xl, xh, 29);
        var c2_lo = shr64_lo(xh, xl, 6);
        var r = c0_lo ^ c1_lo ^ c2_lo;
        if (r < 0)
          r += 4294967296;
        return r;
      }
    }
  });

  // ../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/384.js
  var require__5 = __commonJS({
    "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha/384.js"(exports, module2) {
      "use strict";
      var utils = require_utils6();
      var SHA512 = require__4();
      function SHA384() {
        if (!(this instanceof SHA384))
          return new SHA384();
        SHA512.call(this);
        this.h = [
          3418070365,
          3238371032,
          1654270250,
          914150663,
          2438529370,
          812702999,
          355462360,
          4144912697,
          1731405415,
          4290775857,
          2394180231,
          1750603025,
          3675008525,
          1694076839,
          1203062813,
          3204075428
        ];
      }
      utils.inherits(SHA384, SHA512);
      module2.exports = SHA384;
      SHA384.blockSize = 1024;
      SHA384.outSize = 384;
      SHA384.hmacStrength = 192;
      SHA384.padLength = 128;
      SHA384.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h.slice(0, 12), "big");
        else
          return utils.split32(this.h.slice(0, 12), "big");
      };
    }
  });

  // ../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha.js
  var require_sha = __commonJS({
    "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/sha.js"(exports) {
      "use strict";
      exports.sha1 = require__();
      exports.sha224 = require__3();
      exports.sha256 = require__2();
      exports.sha384 = require__5();
      exports.sha512 = require__4();
    }
  });

  // ../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/ripemd.js
  var require_ripemd = __commonJS({
    "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/ripemd.js"(exports) {
      "use strict";
      var utils = require_utils6();
      var common = require_common2();
      var rotl32 = utils.rotl32;
      var sum32 = utils.sum32;
      var sum32_3 = utils.sum32_3;
      var sum32_4 = utils.sum32_4;
      var BlockHash = common.BlockHash;
      function RIPEMD1602() {
        if (!(this instanceof RIPEMD1602))
          return new RIPEMD1602();
        BlockHash.call(this);
        this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
        this.endian = "little";
      }
      utils.inherits(RIPEMD1602, BlockHash);
      exports.ripemd160 = RIPEMD1602;
      RIPEMD1602.blockSize = 512;
      RIPEMD1602.outSize = 160;
      RIPEMD1602.hmacStrength = 192;
      RIPEMD1602.padLength = 64;
      RIPEMD1602.prototype._update = function update(msg, start) {
        var A = this.h[0];
        var B = this.h[1];
        var C = this.h[2];
        var D = this.h[3];
        var E = this.h[4];
        var Ah = A;
        var Bh = B;
        var Ch = C;
        var Dh = D;
        var Eh = E;
        for (var j = 0; j < 80; j++) {
          var T = sum32(
            rotl32(
              sum32_4(A, f2(j, B, C, D), msg[r[j] + start], K(j)),
              s[j]
            ),
            E
          );
          A = E;
          E = D;
          D = rotl32(C, 10);
          C = B;
          B = T;
          T = sum32(
            rotl32(
              sum32_4(Ah, f2(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
              sh[j]
            ),
            Eh
          );
          Ah = Eh;
          Eh = Dh;
          Dh = rotl32(Ch, 10);
          Ch = Bh;
          Bh = T;
        }
        T = sum32_3(this.h[1], C, Dh);
        this.h[1] = sum32_3(this.h[2], D, Eh);
        this.h[2] = sum32_3(this.h[3], E, Ah);
        this.h[3] = sum32_3(this.h[4], A, Bh);
        this.h[4] = sum32_3(this.h[0], B, Ch);
        this.h[0] = T;
      };
      RIPEMD1602.prototype._digest = function digest(enc) {
        if (enc === "hex")
          return utils.toHex32(this.h, "little");
        else
          return utils.split32(this.h, "little");
      };
      function f2(j, x, y, z) {
        if (j <= 15)
          return x ^ y ^ z;
        else if (j <= 31)
          return x & y | ~x & z;
        else if (j <= 47)
          return (x | ~y) ^ z;
        else if (j <= 63)
          return x & z | y & ~z;
        else
          return x ^ (y | ~z);
      }
      function K(j) {
        if (j <= 15)
          return 0;
        else if (j <= 31)
          return 1518500249;
        else if (j <= 47)
          return 1859775393;
        else if (j <= 63)
          return 2400959708;
        else
          return 2840853838;
      }
      function Kh(j) {
        if (j <= 15)
          return 1352829926;
        else if (j <= 31)
          return 1548603684;
        else if (j <= 47)
          return 1836072691;
        else if (j <= 63)
          return 2053994217;
        else
          return 0;
      }
      var r = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        7,
        4,
        13,
        1,
        10,
        6,
        15,
        3,
        12,
        0,
        9,
        5,
        2,
        14,
        11,
        8,
        3,
        10,
        14,
        4,
        9,
        15,
        8,
        1,
        2,
        7,
        0,
        6,
        13,
        11,
        5,
        12,
        1,
        9,
        11,
        10,
        0,
        8,
        12,
        4,
        13,
        3,
        7,
        15,
        14,
        5,
        6,
        2,
        4,
        0,
        5,
        9,
        7,
        12,
        2,
        10,
        14,
        1,
        3,
        8,
        11,
        6,
        15,
        13
      ];
      var rh = [
        5,
        14,
        7,
        0,
        9,
        2,
        11,
        4,
        13,
        6,
        15,
        8,
        1,
        10,
        3,
        12,
        6,
        11,
        3,
        7,
        0,
        13,
        5,
        10,
        14,
        15,
        8,
        12,
        4,
        9,
        1,
        2,
        15,
        5,
        1,
        3,
        7,
        14,
        6,
        9,
        11,
        8,
        12,
        2,
        10,
        0,
        4,
        13,
        8,
        6,
        4,
        1,
        3,
        11,
        15,
        0,
        5,
        12,
        2,
        13,
        9,
        7,
        10,
        14,
        12,
        15,
        10,
        4,
        1,
        5,
        8,
        7,
        6,
        2,
        13,
        14,
        0,
        3,
        9,
        11
      ];
      var s = [
        11,
        14,
        15,
        12,
        5,
        8,
        7,
        9,
        11,
        13,
        14,
        15,
        6,
        7,
        9,
        8,
        7,
        6,
        8,
        13,
        11,
        9,
        7,
        15,
        7,
        12,
        15,
        9,
        11,
        7,
        13,
        12,
        11,
        13,
        6,
        7,
        14,
        9,
        13,
        15,
        14,
        8,
        13,
        6,
        5,
        12,
        7,
        5,
        11,
        12,
        14,
        15,
        14,
        15,
        9,
        8,
        9,
        14,
        5,
        6,
        8,
        6,
        5,
        12,
        9,
        15,
        5,
        11,
        6,
        8,
        13,
        12,
        5,
        12,
        13,
        14,
        11,
        8,
        5,
        6
      ];
      var sh = [
        8,
        9,
        9,
        11,
        13,
        15,
        15,
        5,
        7,
        7,
        8,
        11,
        14,
        14,
        12,
        6,
        9,
        13,
        15,
        7,
        12,
        8,
        9,
        11,
        7,
        7,
        12,
        7,
        6,
        15,
        13,
        11,
        9,
        7,
        15,
        11,
        8,
        6,
        6,
        14,
        12,
        13,
        5,
        14,
        13,
        13,
        7,
        5,
        15,
        5,
        8,
        11,
        14,
        14,
        6,
        14,
        6,
        9,
        12,
        9,
        12,
        5,
        15,
        8,
        8,
        5,
        12,
        9,
        12,
        5,
        14,
        6,
        8,
        13,
        6,
        5,
        15,
        13,
        11,
        11
      ];
    }
  });

  // ../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/hmac.js
  var require_hmac = __commonJS({
    "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash/hmac.js"(exports, module2) {
      "use strict";
      var utils = require_utils6();
      var assert5 = require_minimalistic_assert();
      function Hmac(hash5, key, enc) {
        if (!(this instanceof Hmac))
          return new Hmac(hash5, key, enc);
        this.Hash = hash5;
        this.blockSize = hash5.blockSize / 8;
        this.outSize = hash5.outSize / 8;
        this.inner = null;
        this.outer = null;
        this._init(utils.toArray(key, enc));
      }
      module2.exports = Hmac;
      Hmac.prototype._init = function init2(key) {
        if (key.length > this.blockSize)
          key = new this.Hash().update(key).digest();
        assert5(key.length <= this.blockSize);
        for (var i = key.length; i < this.blockSize; i++)
          key.push(0);
        for (i = 0; i < key.length; i++)
          key[i] ^= 54;
        this.inner = new this.Hash().update(key);
        for (i = 0; i < key.length; i++)
          key[i] ^= 106;
        this.outer = new this.Hash().update(key);
      };
      Hmac.prototype.update = function update(msg, enc) {
        this.inner.update(msg, enc);
        return this;
      };
      Hmac.prototype.digest = function digest(enc) {
        this.outer.update(this.inner.digest());
        return this.outer.digest(enc);
      };
    }
  });

  // ../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash.js
  var require_hash = __commonJS({
    "../../node_modules/.pnpm/hash.js@1.1.7/node_modules/hash.js/lib/hash.js"(exports) {
      var hash5 = exports;
      hash5.utils = require_utils6();
      hash5.common = require_common2();
      hash5.sha = require_sha();
      hash5.ripemd = require_ripemd();
      hash5.hmac = require_hmac();
      hash5.sha1 = hash5.sha.sha1;
      hash5.sha256 = hash5.sha.sha256;
      hash5.sha224 = hash5.sha.sha224;
      hash5.sha384 = hash5.sha.sha384;
      hash5.sha512 = hash5.sha.sha512;
      hash5.ripemd160 = hash5.ripemd.ripemd160;
    }
  });

  // ../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
  var require_secp256k1 = __commonJS({
    "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports, module2) {
      module2.exports = {
        doubles: {
          step: 4,
          points: [
            [
              "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
              "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
            ],
            [
              "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
              "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
            ],
            [
              "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
              "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
            ],
            [
              "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
              "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
            ],
            [
              "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
              "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
            ],
            [
              "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
              "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
            ],
            [
              "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
              "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
            ],
            [
              "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
              "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
            ],
            [
              "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
              "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
            ],
            [
              "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
              "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
            ],
            [
              "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
              "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
            ],
            [
              "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
              "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
            ],
            [
              "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
              "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
            ],
            [
              "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
              "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
            ],
            [
              "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
              "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
            ],
            [
              "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
              "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
            ],
            [
              "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
              "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
            ],
            [
              "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
              "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
            ],
            [
              "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
              "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
            ],
            [
              "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
              "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
            ],
            [
              "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
              "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
            ],
            [
              "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
              "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
            ],
            [
              "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
              "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
            ],
            [
              "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
              "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
            ],
            [
              "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
              "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
            ],
            [
              "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
              "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
            ],
            [
              "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
              "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
            ],
            [
              "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
              "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
            ],
            [
              "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
              "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
            ],
            [
              "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
              "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
            ],
            [
              "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
              "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
            ],
            [
              "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
              "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
            ],
            [
              "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
              "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
            ],
            [
              "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
              "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
            ],
            [
              "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
              "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
            ],
            [
              "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
              "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
            ],
            [
              "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
              "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
            ],
            [
              "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
              "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
            ],
            [
              "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
              "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
            ],
            [
              "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
              "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
            ],
            [
              "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
              "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
            ],
            [
              "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
              "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
            ],
            [
              "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
              "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
            ],
            [
              "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
              "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
            ],
            [
              "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
              "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
            ],
            [
              "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
              "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
            ],
            [
              "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
              "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
            ],
            [
              "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
              "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
            ],
            [
              "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
              "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
            ],
            [
              "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
              "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
            ],
            [
              "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
              "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
            ],
            [
              "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
              "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
            ],
            [
              "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
              "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
            ],
            [
              "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
              "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
            ],
            [
              "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
              "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
            ],
            [
              "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
              "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
            ],
            [
              "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
              "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
            ],
            [
              "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
              "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
            ],
            [
              "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
              "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
            ],
            [
              "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
              "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
            ],
            [
              "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
              "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
            ],
            [
              "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
              "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
            ],
            [
              "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
              "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
            ],
            [
              "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
              "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
            ],
            [
              "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
              "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
            ]
          ]
        },
        naf: {
          wnd: 7,
          points: [
            [
              "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
              "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
            ],
            [
              "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
              "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
            ],
            [
              "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
              "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
            ],
            [
              "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
              "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
            ],
            [
              "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
              "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
            ],
            [
              "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
              "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
            ],
            [
              "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
              "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
            ],
            [
              "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
              "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
            ],
            [
              "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
              "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
            ],
            [
              "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
              "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
            ],
            [
              "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
              "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
            ],
            [
              "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
              "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
            ],
            [
              "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
              "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
            ],
            [
              "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
              "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
            ],
            [
              "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
              "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
            ],
            [
              "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
              "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
            ],
            [
              "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
              "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
            ],
            [
              "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
              "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
            ],
            [
              "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
              "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
            ],
            [
              "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
              "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
            ],
            [
              "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
              "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
            ],
            [
              "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
              "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
            ],
            [
              "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
              "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
            ],
            [
              "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
              "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
            ],
            [
              "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
              "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
            ],
            [
              "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
              "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
            ],
            [
              "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
              "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
            ],
            [
              "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
              "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
            ],
            [
              "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
              "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
            ],
            [
              "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
              "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
            ],
            [
              "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
              "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
            ],
            [
              "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
              "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
            ],
            [
              "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
              "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
            ],
            [
              "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
              "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
            ],
            [
              "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
              "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
            ],
            [
              "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
              "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
            ],
            [
              "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
              "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
            ],
            [
              "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
              "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
            ],
            [
              "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
              "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
            ],
            [
              "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
              "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
            ],
            [
              "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
              "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
            ],
            [
              "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
              "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
            ],
            [
              "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
              "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
            ],
            [
              "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
              "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
            ],
            [
              "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
              "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
            ],
            [
              "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
              "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
            ],
            [
              "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
              "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
            ],
            [
              "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
              "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
            ],
            [
              "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
              "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
            ],
            [
              "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
              "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
            ],
            [
              "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
              "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
            ],
            [
              "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
              "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
            ],
            [
              "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
              "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
            ],
            [
              "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
              "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
            ],
            [
              "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
              "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
            ],
            [
              "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
              "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
            ],
            [
              "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
              "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
            ],
            [
              "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
              "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
            ],
            [
              "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
              "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
            ],
            [
              "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
              "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
            ],
            [
              "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
              "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
            ],
            [
              "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
              "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
            ],
            [
              "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
              "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
            ],
            [
              "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
              "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
            ],
            [
              "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
              "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
            ],
            [
              "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
              "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
            ],
            [
              "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
              "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
            ],
            [
              "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
              "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
            ],
            [
              "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
              "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
            ],
            [
              "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
              "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
            ],
            [
              "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
              "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
            ],
            [
              "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
              "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
            ],
            [
              "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
              "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
            ],
            [
              "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
              "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
            ],
            [
              "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
              "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
            ],
            [
              "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
              "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
            ],
            [
              "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
              "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
            ],
            [
              "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
              "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
            ],
            [
              "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
              "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
            ],
            [
              "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
              "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
            ],
            [
              "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
              "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
            ],
            [
              "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
              "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
            ],
            [
              "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
              "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
            ],
            [
              "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
              "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
            ],
            [
              "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
              "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
            ],
            [
              "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
              "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
            ],
            [
              "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
              "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
            ],
            [
              "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
              "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
            ],
            [
              "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
              "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
            ],
            [
              "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
              "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
            ],
            [
              "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
              "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
            ],
            [
              "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
              "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
            ],
            [
              "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
              "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
            ],
            [
              "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
              "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
            ],
            [
              "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
              "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
            ],
            [
              "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
              "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
            ],
            [
              "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
              "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
            ],
            [
              "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
              "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
            ],
            [
              "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
              "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
            ],
            [
              "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
              "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
            ],
            [
              "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
              "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
            ],
            [
              "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
              "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
            ],
            [
              "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
              "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
            ],
            [
              "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
              "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
            ],
            [
              "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
              "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
            ],
            [
              "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
              "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
            ],
            [
              "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
              "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
            ],
            [
              "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
              "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
            ],
            [
              "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
              "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
            ],
            [
              "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
              "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
            ],
            [
              "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
              "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
            ],
            [
              "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
              "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
            ],
            [
              "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
              "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
            ],
            [
              "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
              "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
            ],
            [
              "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
              "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
            ],
            [
              "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
              "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
            ],
            [
              "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
              "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
            ],
            [
              "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
              "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
            ],
            [
              "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
              "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
            ],
            [
              "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
              "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
            ],
            [
              "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
              "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
            ],
            [
              "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
              "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
            ],
            [
              "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
              "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
            ],
            [
              "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
              "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
            ],
            [
              "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
              "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
            ],
            [
              "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
              "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
            ],
            [
              "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
              "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
            ]
          ]
        }
      };
    }
  });

  // ../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/curves.js
  var require_curves = __commonJS({
    "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/curves.js"(exports) {
      "use strict";
      var curves = exports;
      var hash5 = require_hash();
      var curve = require_curve();
      var utils = require_utils5();
      var assert5 = utils.assert;
      function PresetCurve(options) {
        if (options.type === "short")
          this.curve = new curve.short(options);
        else if (options.type === "edwards")
          this.curve = new curve.edwards(options);
        else
          this.curve = new curve.mont(options);
        this.g = this.curve.g;
        this.n = this.curve.n;
        this.hash = options.hash;
        assert5(this.g.validate(), "Invalid curve");
        assert5(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
      }
      curves.PresetCurve = PresetCurve;
      function defineCurve(name, options) {
        Object.defineProperty(curves, name, {
          configurable: true,
          enumerable: true,
          get: function() {
            var curve2 = new PresetCurve(options);
            Object.defineProperty(curves, name, {
              configurable: true,
              enumerable: true,
              value: curve2
            });
            return curve2;
          }
        });
      }
      defineCurve("p192", {
        type: "short",
        prime: "p192",
        p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
        b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
        n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
        hash: hash5.sha256,
        gRed: false,
        g: [
          "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
          "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
        ]
      });
      defineCurve("p224", {
        type: "short",
        prime: "p224",
        p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
        a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
        b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
        n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
        hash: hash5.sha256,
        gRed: false,
        g: [
          "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
          "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
        ]
      });
      defineCurve("p256", {
        type: "short",
        prime: null,
        p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
        a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
        b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
        n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
        hash: hash5.sha256,
        gRed: false,
        g: [
          "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
          "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
        ]
      });
      defineCurve("p384", {
        type: "short",
        prime: null,
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
        a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
        b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
        n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
        hash: hash5.sha384,
        gRed: false,
        g: [
          "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
          "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
        ]
      });
      defineCurve("p521", {
        type: "short",
        prime: null,
        p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
        a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
        b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
        n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
        hash: hash5.sha512,
        gRed: false,
        g: [
          "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
          "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
        ]
      });
      defineCurve("curve25519", {
        type: "mont",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "76d06",
        b: "1",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: hash5.sha256,
        gRed: false,
        g: [
          "9"
        ]
      });
      defineCurve("ed25519", {
        type: "edwards",
        prime: "p25519",
        p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
        a: "-1",
        c: "1",
        // -121665 * (121666^(-1)) (mod P)
        d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
        n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
        hash: hash5.sha256,
        gRed: false,
        g: [
          "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
          // 4/5
          "6666666666666666666666666666666666666666666666666666666666666658"
        ]
      });
      var pre;
      try {
        pre = require_secp256k1();
      } catch (e) {
        pre = void 0;
      }
      defineCurve("secp256k1", {
        type: "short",
        prime: "k256",
        p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
        a: "0",
        b: "7",
        n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
        h: "1",
        hash: hash5.sha256,
        // Precomputed endomorphism
        beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
        lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
        basis: [
          {
            a: "3086d221a7d46bcde86c90e49284eb15",
            b: "-e4437ed6010e88286f547fa90abfe4c3"
          },
          {
            a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
            b: "3086d221a7d46bcde86c90e49284eb15"
          }
        ],
        gRed: false,
        g: [
          "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
          "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
          pre
        ]
      });
    }
  });

  // ../../node_modules/.pnpm/hmac-drbg@1.0.1/node_modules/hmac-drbg/lib/hmac-drbg.js
  var require_hmac_drbg = __commonJS({
    "../../node_modules/.pnpm/hmac-drbg@1.0.1/node_modules/hmac-drbg/lib/hmac-drbg.js"(exports, module2) {
      "use strict";
      var hash5 = require_hash();
      var utils = require_utils4();
      var assert5 = require_minimalistic_assert();
      function HmacDRBG(options) {
        if (!(this instanceof HmacDRBG))
          return new HmacDRBG(options);
        this.hash = options.hash;
        this.predResist = !!options.predResist;
        this.outLen = this.hash.outSize;
        this.minEntropy = options.minEntropy || this.hash.hmacStrength;
        this._reseed = null;
        this.reseedInterval = null;
        this.K = null;
        this.V = null;
        var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
        var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
        var pers = utils.toArray(options.pers, options.persEnc || "hex");
        assert5(
          entropy.length >= this.minEntropy / 8,
          "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
        );
        this._init(entropy, nonce, pers);
      }
      module2.exports = HmacDRBG;
      HmacDRBG.prototype._init = function init2(entropy, nonce, pers) {
        var seed = entropy.concat(nonce).concat(pers);
        this.K = new Array(this.outLen / 8);
        this.V = new Array(this.outLen / 8);
        for (var i = 0; i < this.V.length; i++) {
          this.K[i] = 0;
          this.V[i] = 1;
        }
        this._update(seed);
        this._reseed = 1;
        this.reseedInterval = 281474976710656;
      };
      HmacDRBG.prototype._hmac = function hmac2() {
        return new hash5.hmac(this.hash, this.K);
      };
      HmacDRBG.prototype._update = function update(seed) {
        var kmac = this._hmac().update(this.V).update([0]);
        if (seed)
          kmac = kmac.update(seed);
        this.K = kmac.digest();
        this.V = this._hmac().update(this.V).digest();
        if (!seed)
          return;
        this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
        this.V = this._hmac().update(this.V).digest();
      };
      HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add3, addEnc) {
        if (typeof entropyEnc !== "string") {
          addEnc = add3;
          add3 = entropyEnc;
          entropyEnc = null;
        }
        entropy = utils.toArray(entropy, entropyEnc);
        add3 = utils.toArray(add3, addEnc);
        assert5(
          entropy.length >= this.minEntropy / 8,
          "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
        );
        this._update(entropy.concat(add3 || []));
        this._reseed = 1;
      };
      HmacDRBG.prototype.generate = function generate(len, enc, add3, addEnc) {
        if (this._reseed > this.reseedInterval)
          throw new Error("Reseed is required");
        if (typeof enc !== "string") {
          addEnc = add3;
          add3 = enc;
          enc = null;
        }
        if (add3) {
          add3 = utils.toArray(add3, addEnc || "hex");
          this._update(add3);
        }
        var temp = [];
        while (temp.length < len) {
          this.V = this._hmac().update(this.V).digest();
          temp = temp.concat(this.V);
        }
        var res = temp.slice(0, len);
        this._update(add3);
        this._reseed++;
        return utils.encode(res, enc);
      };
    }
  });

  // ../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/ec/key.js
  var require_key = __commonJS({
    "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/ec/key.js"(exports, module2) {
      "use strict";
      var BN2 = require_bn2();
      var utils = require_utils5();
      var assert5 = utils.assert;
      function KeyPair(ec, options) {
        this.ec = ec;
        this.priv = null;
        this.pub = null;
        if (options.priv)
          this._importPrivate(options.priv, options.privEnc);
        if (options.pub)
          this._importPublic(options.pub, options.pubEnc);
      }
      module2.exports = KeyPair;
      KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
        if (pub instanceof KeyPair)
          return pub;
        return new KeyPair(ec, {
          pub,
          pubEnc: enc
        });
      };
      KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
        if (priv instanceof KeyPair)
          return priv;
        return new KeyPair(ec, {
          priv,
          privEnc: enc
        });
      };
      KeyPair.prototype.validate = function validate() {
        var pub = this.getPublic();
        if (pub.isInfinity())
          return { result: false, reason: "Invalid public key" };
        if (!pub.validate())
          return { result: false, reason: "Public key is not a point" };
        if (!pub.mul(this.ec.curve.n).isInfinity())
          return { result: false, reason: "Public key * N != O" };
        return { result: true, reason: null };
      };
      KeyPair.prototype.getPublic = function getPublic(compact, enc) {
        if (typeof compact === "string") {
          enc = compact;
          compact = null;
        }
        if (!this.pub)
          this.pub = this.ec.g.mul(this.priv);
        if (!enc)
          return this.pub;
        return this.pub.encode(enc, compact);
      };
      KeyPair.prototype.getPrivate = function getPrivate(enc) {
        if (enc === "hex")
          return this.priv.toString(16, 2);
        else
          return this.priv;
      };
      KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
        this.priv = new BN2(key, enc || 16);
        this.priv = this.priv.umod(this.ec.curve.n);
      };
      KeyPair.prototype._importPublic = function _importPublic(key, enc) {
        if (key.x || key.y) {
          if (this.ec.curve.type === "mont") {
            assert5(key.x, "Need x coordinate");
          } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
            assert5(key.x && key.y, "Need both x and y coordinate");
          }
          this.pub = this.ec.curve.point(key.x, key.y);
          return;
        }
        this.pub = this.ec.curve.decodePoint(key, enc);
      };
      KeyPair.prototype.derive = function derive(pub) {
        if (!pub.validate()) {
          assert5(pub.validate(), "public point not validated");
        }
        return pub.mul(this.priv).getX();
      };
      KeyPair.prototype.sign = function sign(msg, enc, options) {
        return this.ec.sign(msg, this, enc, options);
      };
      KeyPair.prototype.verify = function verify(msg, signature) {
        return this.ec.verify(msg, signature, this);
      };
      KeyPair.prototype.inspect = function inspect2() {
        return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
      };
    }
  });

  // ../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/ec/signature.js
  var require_signature = __commonJS({
    "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/ec/signature.js"(exports, module2) {
      "use strict";
      var BN2 = require_bn2();
      var utils = require_utils5();
      var assert5 = utils.assert;
      function Signature2(options, enc) {
        if (options instanceof Signature2)
          return options;
        if (this._importDER(options, enc))
          return;
        assert5(options.r && options.s, "Signature without r or s");
        this.r = new BN2(options.r, 16);
        this.s = new BN2(options.s, 16);
        if (options.recoveryParam === void 0)
          this.recoveryParam = null;
        else
          this.recoveryParam = options.recoveryParam;
      }
      module2.exports = Signature2;
      function Position() {
        this.place = 0;
      }
      function getLength(buf, p) {
        var initial = buf[p.place++];
        if (!(initial & 128)) {
          return initial;
        }
        var octetLen = initial & 15;
        if (octetLen === 0 || octetLen > 4) {
          return false;
        }
        var val = 0;
        for (var i = 0, off = p.place; i < octetLen; i++, off++) {
          val <<= 8;
          val |= buf[off];
          val >>>= 0;
        }
        if (val <= 127) {
          return false;
        }
        p.place = off;
        return val;
      }
      function rmPadding(buf) {
        var i = 0;
        var len = buf.length - 1;
        while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
          i++;
        }
        if (i === 0) {
          return buf;
        }
        return buf.slice(i);
      }
      Signature2.prototype._importDER = function _importDER(data, enc) {
        data = utils.toArray(data, enc);
        var p = new Position();
        if (data[p.place++] !== 48) {
          return false;
        }
        var len = getLength(data, p);
        if (len === false) {
          return false;
        }
        if (len + p.place !== data.length) {
          return false;
        }
        if (data[p.place++] !== 2) {
          return false;
        }
        var rlen = getLength(data, p);
        if (rlen === false) {
          return false;
        }
        var r = data.slice(p.place, rlen + p.place);
        p.place += rlen;
        if (data[p.place++] !== 2) {
          return false;
        }
        var slen = getLength(data, p);
        if (slen === false) {
          return false;
        }
        if (data.length !== slen + p.place) {
          return false;
        }
        var s = data.slice(p.place, slen + p.place);
        if (r[0] === 0) {
          if (r[1] & 128) {
            r = r.slice(1);
          } else {
            return false;
          }
        }
        if (s[0] === 0) {
          if (s[1] & 128) {
            s = s.slice(1);
          } else {
            return false;
          }
        }
        this.r = new BN2(r);
        this.s = new BN2(s);
        this.recoveryParam = null;
        return true;
      };
      function constructLength(arr, len) {
        if (len < 128) {
          arr.push(len);
          return;
        }
        var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
        arr.push(octets | 128);
        while (--octets) {
          arr.push(len >>> (octets << 3) & 255);
        }
        arr.push(len);
      }
      Signature2.prototype.toDER = function toDER(enc) {
        var r = this.r.toArray();
        var s = this.s.toArray();
        if (r[0] & 128)
          r = [0].concat(r);
        if (s[0] & 128)
          s = [0].concat(s);
        r = rmPadding(r);
        s = rmPadding(s);
        while (!s[0] && !(s[1] & 128)) {
          s = s.slice(1);
        }
        var arr = [2];
        constructLength(arr, r.length);
        arr = arr.concat(r);
        arr.push(2);
        constructLength(arr, s.length);
        var backHalf = arr.concat(s);
        var res = [48];
        constructLength(res, backHalf.length);
        res = res.concat(backHalf);
        return utils.encode(res, enc);
      };
    }
  });

  // ../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/ec/index.js
  var require_ec = __commonJS({
    "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/ec/index.js"(exports, module2) {
      "use strict";
      var BN2 = require_bn2();
      var HmacDRBG = require_hmac_drbg();
      var utils = require_utils5();
      var curves = require_curves();
      var rand = require_brorand();
      var assert5 = utils.assert;
      var KeyPair = require_key();
      var Signature2 = require_signature();
      function EC2(options) {
        if (!(this instanceof EC2))
          return new EC2(options);
        if (typeof options === "string") {
          assert5(
            Object.prototype.hasOwnProperty.call(curves, options),
            "Unknown curve " + options
          );
          options = curves[options];
        }
        if (options instanceof curves.PresetCurve)
          options = { curve: options };
        this.curve = options.curve.curve;
        this.n = this.curve.n;
        this.nh = this.n.ushrn(1);
        this.g = this.curve.g;
        this.g = options.curve.g;
        this.g.precompute(options.curve.n.bitLength() + 1);
        this.hash = options.hash || options.curve.hash;
      }
      module2.exports = EC2;
      EC2.prototype.keyPair = function keyPair(options) {
        return new KeyPair(this, options);
      };
      EC2.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
        return KeyPair.fromPrivate(this, priv, enc);
      };
      EC2.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
        return KeyPair.fromPublic(this, pub, enc);
      };
      EC2.prototype.genKeyPair = function genKeyPair(options) {
        if (!options)
          options = {};
        var drbg = new HmacDRBG({
          hash: this.hash,
          pers: options.pers,
          persEnc: options.persEnc || "utf8",
          entropy: options.entropy || rand(this.hash.hmacStrength),
          entropyEnc: options.entropy && options.entropyEnc || "utf8",
          nonce: this.n.toArray()
        });
        var bytes3 = this.n.byteLength();
        var ns2 = this.n.sub(new BN2(2));
        for (; ; ) {
          var priv = new BN2(drbg.generate(bytes3));
          if (priv.cmp(ns2) > 0)
            continue;
          priv.iaddn(1);
          return this.keyFromPrivate(priv);
        }
      };
      EC2.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
        var delta = msg.byteLength() * 8 - this.n.bitLength();
        if (delta > 0)
          msg = msg.ushrn(delta);
        if (!truncOnly && msg.cmp(this.n) >= 0)
          return msg.sub(this.n);
        else
          return msg;
      };
      EC2.prototype.sign = function sign(msg, key, enc, options) {
        if (typeof enc === "object") {
          options = enc;
          enc = null;
        }
        if (!options)
          options = {};
        key = this.keyFromPrivate(key, enc);
        msg = this._truncateToN(new BN2(msg, 16));
        var bytes3 = this.n.byteLength();
        var bkey = key.getPrivate().toArray("be", bytes3);
        var nonce = msg.toArray("be", bytes3);
        var drbg = new HmacDRBG({
          hash: this.hash,
          entropy: bkey,
          nonce,
          pers: options.pers,
          persEnc: options.persEnc || "utf8"
        });
        var ns1 = this.n.sub(new BN2(1));
        for (var iter = 0; ; iter++) {
          var k = options.k ? options.k(iter) : new BN2(drbg.generate(this.n.byteLength()));
          k = this._truncateToN(k, true);
          if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
            continue;
          var kp = this.g.mul(k);
          if (kp.isInfinity())
            continue;
          var kpX = kp.getX();
          var r = kpX.umod(this.n);
          if (r.cmpn(0) === 0)
            continue;
          var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
          s = s.umod(this.n);
          if (s.cmpn(0) === 0)
            continue;
          var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
          if (options.canonical && s.cmp(this.nh) > 0) {
            s = this.n.sub(s);
            recoveryParam ^= 1;
          }
          return new Signature2({ r, s, recoveryParam });
        }
      };
      EC2.prototype.verify = function verify(msg, signature, key, enc) {
        msg = this._truncateToN(new BN2(msg, 16));
        key = this.keyFromPublic(key, enc);
        signature = new Signature2(signature, "hex");
        var r = signature.r;
        var s = signature.s;
        if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
          return false;
        if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
          return false;
        var sinv = s.invm(this.n);
        var u1 = sinv.mul(msg).umod(this.n);
        var u2 = sinv.mul(r).umod(this.n);
        var p;
        if (!this.curve._maxwellTrick) {
          p = this.g.mulAdd(u1, key.getPublic(), u2);
          if (p.isInfinity())
            return false;
          return p.getX().umod(this.n).cmp(r) === 0;
        }
        p = this.g.jmulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity())
          return false;
        return p.eqXToP(r);
      };
      EC2.prototype.recoverPubKey = function(msg, signature, j, enc) {
        assert5((3 & j) === j, "The recovery param is more than two bits");
        signature = new Signature2(signature, enc);
        var n = this.n;
        var e = new BN2(msg);
        var r = signature.r;
        var s = signature.s;
        var isYOdd = j & 1;
        var isSecondKey = j >> 1;
        if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
          throw new Error("Unable to find sencond key candinate");
        if (isSecondKey)
          r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
        else
          r = this.curve.pointFromX(r, isYOdd);
        var rInv = signature.r.invm(n);
        var s1 = n.sub(e).mul(rInv).umod(n);
        var s2 = s.mul(rInv).umod(n);
        return this.g.mulAdd(s1, r, s2);
      };
      EC2.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
        signature = new Signature2(signature, enc);
        if (signature.recoveryParam !== null)
          return signature.recoveryParam;
        for (var i = 0; i < 4; i++) {
          var Qprime;
          try {
            Qprime = this.recoverPubKey(e, signature, i);
          } catch (e2) {
            continue;
          }
          if (Qprime.eq(Q))
            return i;
        }
        throw new Error("Unable to find valid recovery factor");
      };
    }
  });

  // ../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/eddsa/key.js
  var require_key2 = __commonJS({
    "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports, module2) {
      "use strict";
      var utils = require_utils5();
      var assert5 = utils.assert;
      var parseBytes = utils.parseBytes;
      var cachedProperty = utils.cachedProperty;
      function KeyPair(eddsa, params) {
        this.eddsa = eddsa;
        this._secret = parseBytes(params.secret);
        if (eddsa.isPoint(params.pub))
          this._pub = params.pub;
        else
          this._pubBytes = parseBytes(params.pub);
      }
      KeyPair.fromPublic = function fromPublic(eddsa, pub) {
        if (pub instanceof KeyPair)
          return pub;
        return new KeyPair(eddsa, { pub });
      };
      KeyPair.fromSecret = function fromSecret(eddsa, secret) {
        if (secret instanceof KeyPair)
          return secret;
        return new KeyPair(eddsa, { secret });
      };
      KeyPair.prototype.secret = function secret() {
        return this._secret;
      };
      cachedProperty(KeyPair, "pubBytes", function pubBytes() {
        return this.eddsa.encodePoint(this.pub());
      });
      cachedProperty(KeyPair, "pub", function pub() {
        if (this._pubBytes)
          return this.eddsa.decodePoint(this._pubBytes);
        return this.eddsa.g.mul(this.priv());
      });
      cachedProperty(KeyPair, "privBytes", function privBytes() {
        var eddsa = this.eddsa;
        var hash5 = this.hash();
        var lastIx = eddsa.encodingLength - 1;
        var a = hash5.slice(0, eddsa.encodingLength);
        a[0] &= 248;
        a[lastIx] &= 127;
        a[lastIx] |= 64;
        return a;
      });
      cachedProperty(KeyPair, "priv", function priv() {
        return this.eddsa.decodeInt(this.privBytes());
      });
      cachedProperty(KeyPair, "hash", function hash5() {
        return this.eddsa.hash().update(this.secret()).digest();
      });
      cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
        return this.hash().slice(this.eddsa.encodingLength);
      });
      KeyPair.prototype.sign = function sign(message) {
        assert5(this._secret, "KeyPair can only verify");
        return this.eddsa.sign(message, this);
      };
      KeyPair.prototype.verify = function verify(message, sig) {
        return this.eddsa.verify(message, sig, this);
      };
      KeyPair.prototype.getSecret = function getSecret(enc) {
        assert5(this._secret, "KeyPair is public only");
        return utils.encode(this.secret(), enc);
      };
      KeyPair.prototype.getPublic = function getPublic(enc) {
        return utils.encode(this.pubBytes(), enc);
      };
      module2.exports = KeyPair;
    }
  });

  // ../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/eddsa/signature.js
  var require_signature2 = __commonJS({
    "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports, module2) {
      "use strict";
      var BN2 = require_bn2();
      var utils = require_utils5();
      var assert5 = utils.assert;
      var cachedProperty = utils.cachedProperty;
      var parseBytes = utils.parseBytes;
      function Signature2(eddsa, sig) {
        this.eddsa = eddsa;
        if (typeof sig !== "object")
          sig = parseBytes(sig);
        if (Array.isArray(sig)) {
          sig = {
            R: sig.slice(0, eddsa.encodingLength),
            S: sig.slice(eddsa.encodingLength)
          };
        }
        assert5(sig.R && sig.S, "Signature without R or S");
        if (eddsa.isPoint(sig.R))
          this._R = sig.R;
        if (sig.S instanceof BN2)
          this._S = sig.S;
        this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
        this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
      }
      cachedProperty(Signature2, "S", function S() {
        return this.eddsa.decodeInt(this.Sencoded());
      });
      cachedProperty(Signature2, "R", function R() {
        return this.eddsa.decodePoint(this.Rencoded());
      });
      cachedProperty(Signature2, "Rencoded", function Rencoded() {
        return this.eddsa.encodePoint(this.R());
      });
      cachedProperty(Signature2, "Sencoded", function Sencoded() {
        return this.eddsa.encodeInt(this.S());
      });
      Signature2.prototype.toBytes = function toBytes4() {
        return this.Rencoded().concat(this.Sencoded());
      };
      Signature2.prototype.toHex = function toHex2() {
        return utils.encode(this.toBytes(), "hex").toUpperCase();
      };
      module2.exports = Signature2;
    }
  });

  // ../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/eddsa/index.js
  var require_eddsa = __commonJS({
    "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports, module2) {
      "use strict";
      var hash5 = require_hash();
      var curves = require_curves();
      var utils = require_utils5();
      var assert5 = utils.assert;
      var parseBytes = utils.parseBytes;
      var KeyPair = require_key2();
      var Signature2 = require_signature2();
      function EDDSA(curve) {
        assert5(curve === "ed25519", "only tested with ed25519 so far");
        if (!(this instanceof EDDSA))
          return new EDDSA(curve);
        curve = curves[curve].curve;
        this.curve = curve;
        this.g = curve.g;
        this.g.precompute(curve.n.bitLength() + 1);
        this.pointClass = curve.point().constructor;
        this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
        this.hash = hash5.sha512;
      }
      module2.exports = EDDSA;
      EDDSA.prototype.sign = function sign(message, secret) {
        message = parseBytes(message);
        var key = this.keyFromSecret(secret);
        var r = this.hashInt(key.messagePrefix(), message);
        var R = this.g.mul(r);
        var Rencoded = this.encodePoint(R);
        var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
        var S = r.add(s_).umod(this.curve.n);
        return this.makeSignature({ R, S, Rencoded });
      };
      EDDSA.prototype.verify = function verify(message, sig, pub) {
        message = parseBytes(message);
        sig = this.makeSignature(sig);
        var key = this.keyFromPublic(pub);
        var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
        var SG = this.g.mul(sig.S());
        var RplusAh = sig.R().add(key.pub().mul(h));
        return RplusAh.eq(SG);
      };
      EDDSA.prototype.hashInt = function hashInt() {
        var hash6 = this.hash();
        for (var i = 0; i < arguments.length; i++)
          hash6.update(arguments[i]);
        return utils.intFromLE(hash6.digest()).umod(this.curve.n);
      };
      EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
        return KeyPair.fromPublic(this, pub);
      };
      EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
        return KeyPair.fromSecret(this, secret);
      };
      EDDSA.prototype.makeSignature = function makeSignature(sig) {
        if (sig instanceof Signature2)
          return sig;
        return new Signature2(this, sig);
      };
      EDDSA.prototype.encodePoint = function encodePoint(point) {
        var enc = point.getY().toArray("le", this.encodingLength);
        enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
        return enc;
      };
      EDDSA.prototype.decodePoint = function decodePoint(bytes3) {
        bytes3 = utils.parseBytes(bytes3);
        var lastIx = bytes3.length - 1;
        var normed = bytes3.slice(0, lastIx).concat(bytes3[lastIx] & ~128);
        var xIsOdd = (bytes3[lastIx] & 128) !== 0;
        var y = utils.intFromLE(normed);
        return this.curve.pointFromY(y, xIsOdd);
      };
      EDDSA.prototype.encodeInt = function encodeInt(num) {
        return num.toArray("le", this.encodingLength);
      };
      EDDSA.prototype.decodeInt = function decodeInt(bytes3) {
        return utils.intFromLE(bytes3);
      };
      EDDSA.prototype.isPoint = function isPoint(val) {
        return val instanceof this.pointClass;
      };
    }
  });

  // ../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic.js
  var require_elliptic = __commonJS({
    "../../node_modules/.pnpm/elliptic@6.5.4/node_modules/elliptic/lib/elliptic.js"(exports) {
      "use strict";
      var elliptic2 = exports;
      elliptic2.version = require_package().version;
      elliptic2.utils = require_utils5();
      elliptic2.rand = require_brorand();
      elliptic2.curve = require_curve();
      elliptic2.curves = require_curves();
      elliptic2.ec = require_ec();
      elliptic2.eddsa = require_eddsa();
    }
  });

  // ../../node_modules/.pnpm/@fuels+vm-asm@0.36.1/node_modules/@fuels/vm-asm/dist/node/index.cjs
  var require_node = __commonJS({
    "../../node_modules/.pnpm/@fuels+vm-asm@0.36.1/node_modules/@fuels/vm-asm/dist/node/index.cjs"(exports) {
      "use strict";
      var wasm$1;
      var cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
        throw Error("TextDecoder not available");
      } };
      if (typeof TextDecoder !== "undefined") {
        cachedTextDecoder.decode();
      }
      var cachedUint8Memory0 = null;
      function getUint8Memory0() {
        if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
          cachedUint8Memory0 = new Uint8Array(wasm$1.memory.buffer);
        }
        return cachedUint8Memory0;
      }
      function getStringFromWasm0(ptr, len) {
        ptr = ptr >>> 0;
        return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
      }
      function _assertClass(instance, klass) {
        if (!(instance instanceof klass)) {
          throw new Error(`expected instance of ${klass.name}`);
        }
        return instance.ptr;
      }
      function add3(dst, lhs, rhs) {
        const ret4 = wasm$1.add(dst, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function and(dst, lhs, rhs) {
        const ret4 = wasm$1.and(dst, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function div(dst, lhs, rhs) {
        const ret4 = wasm$1.div(dst, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function eq(dst, lhs, rhs) {
        const ret4 = wasm$1.eq(dst, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function exp(dst, lhs, rhs) {
        const ret4 = wasm$1.exp(dst, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function gt(dst, lhs, rhs) {
        const ret4 = wasm$1.gt(dst, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function lt(dst, lhs, rhs) {
        const ret4 = wasm$1.lt(dst, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function mlog(dst, lhs, rhs) {
        const ret4 = wasm$1.mlog(dst, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function mroo(dst, lhs, rhs) {
        const ret4 = wasm$1.mroo(dst, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function mod_(dst, lhs, rhs) {
        const ret4 = wasm$1.mod_(dst, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function move_(dst, src) {
        const ret4 = wasm$1.move_(dst, src);
        return Instruction2.__wrap(ret4);
      }
      function mul(dst, lhs, rhs) {
        const ret4 = wasm$1.mul(dst, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function not(dst, arg) {
        const ret4 = wasm$1.not(dst, arg);
        return Instruction2.__wrap(ret4);
      }
      function or(dst, lhs, rhs) {
        const ret4 = wasm$1.or(dst, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function sll(dst, lhs, rhs) {
        const ret4 = wasm$1.sll(dst, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function srl(dst, lhs, rhs) {
        const ret4 = wasm$1.srl(dst, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function sub(dst, lhs, rhs) {
        const ret4 = wasm$1.sub(dst, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function xor(dst, lhs, rhs) {
        const ret4 = wasm$1.xor(dst, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function mldv(dst, mul_lhs, mul_rhs, divisor) {
        const ret4 = wasm$1.mldv(dst, mul_lhs, mul_rhs, divisor);
        return Instruction2.__wrap(ret4);
      }
      function ret3(value) {
        const ret4 = wasm$1.ret(value);
        return Instruction2.__wrap(ret4);
      }
      function retd2(addr, len) {
        const ret4 = wasm$1.retd(addr, len);
        return Instruction2.__wrap(ret4);
      }
      function aloc(bytes3) {
        const ret4 = wasm$1.aloc(bytes3);
        return Instruction2.__wrap(ret4);
      }
      function mcl(dst_addr, len) {
        const ret4 = wasm$1.mcl(dst_addr, len);
        return Instruction2.__wrap(ret4);
      }
      function mcp(dst_addr, src_addr, len) {
        const ret4 = wasm$1.mcp(dst_addr, src_addr, len);
        return Instruction2.__wrap(ret4);
      }
      function meq(result, lhs_addr, rhs_addr, len) {
        const ret4 = wasm$1.meq(result, lhs_addr, rhs_addr, len);
        return Instruction2.__wrap(ret4);
      }
      function bhsh(dst, heigth) {
        const ret4 = wasm$1.bhsh(dst, heigth);
        return Instruction2.__wrap(ret4);
      }
      function bhei(dst) {
        const ret4 = wasm$1.bhei(dst);
        return Instruction2.__wrap(ret4);
      }
      function burn(amount, sub_id_addr) {
        const ret4 = wasm$1.burn(amount, sub_id_addr);
        return Instruction2.__wrap(ret4);
      }
      function call2(target_struct, fwd_coins, asset_id_addr, fwd_gas) {
        const ret4 = wasm$1.call(target_struct, fwd_coins, asset_id_addr, fwd_gas);
        return Instruction2.__wrap(ret4);
      }
      function ccp(dst_addr, contract_id_addr, offset, len) {
        const ret4 = wasm$1.ccp(dst_addr, contract_id_addr, offset, len);
        return Instruction2.__wrap(ret4);
      }
      function croo(dst_addr, contract_id_addr) {
        const ret4 = wasm$1.croo(dst_addr, contract_id_addr);
        return Instruction2.__wrap(ret4);
      }
      function csiz(dst, contract_id_addr) {
        const ret4 = wasm$1.csiz(dst, contract_id_addr);
        return Instruction2.__wrap(ret4);
      }
      function cb(dst) {
        const ret4 = wasm$1.cb(dst);
        return Instruction2.__wrap(ret4);
      }
      function ldc(contract_id_addr, offset, len) {
        const ret4 = wasm$1.ldc(contract_id_addr, offset, len);
        return Instruction2.__wrap(ret4);
      }
      function log2(a, b, c, d) {
        const ret4 = wasm$1.log(a, b, c, d);
        return Instruction2.__wrap(ret4);
      }
      function logd(a, b, addr, len) {
        const ret4 = wasm$1.logd(a, b, addr, len);
        return Instruction2.__wrap(ret4);
      }
      function mint(amount, sub_id_addr) {
        const ret4 = wasm$1.mint(amount, sub_id_addr);
        return Instruction2.__wrap(ret4);
      }
      function rvrt(value) {
        const ret4 = wasm$1.rvrt(value);
        return Instruction2.__wrap(ret4);
      }
      function scwq(key_addr, status, lenq) {
        const ret4 = wasm$1.scwq(key_addr, status, lenq);
        return Instruction2.__wrap(ret4);
      }
      function srw(dst, status, key_addr) {
        const ret4 = wasm$1.srw(dst, status, key_addr);
        return Instruction2.__wrap(ret4);
      }
      function srwq(dst_addr, status, key_addr, lenq) {
        const ret4 = wasm$1.srwq(dst_addr, status, key_addr, lenq);
        return Instruction2.__wrap(ret4);
      }
      function sww(key_addr, status, value) {
        const ret4 = wasm$1.sww(key_addr, status, value);
        return Instruction2.__wrap(ret4);
      }
      function swwq(key_addr, status, src_addr, lenq) {
        const ret4 = wasm$1.swwq(key_addr, status, src_addr, lenq);
        return Instruction2.__wrap(ret4);
      }
      function tr2(contract_id_addr, amount, asset_id_addr) {
        const ret4 = wasm$1.tr(contract_id_addr, amount, asset_id_addr);
        return Instruction2.__wrap(ret4);
      }
      function tro(contract_id_addr, output_index, amount, asset_id_addr) {
        const ret4 = wasm$1.tro(contract_id_addr, output_index, amount, asset_id_addr);
        return Instruction2.__wrap(ret4);
      }
      function eck1(dst_addr, sig_addr, msg_hash_addr) {
        const ret4 = wasm$1.eck1(dst_addr, sig_addr, msg_hash_addr);
        return Instruction2.__wrap(ret4);
      }
      function ecr1(dst_addr, sig_addr, msg_hash_addr) {
        const ret4 = wasm$1.ecr1(dst_addr, sig_addr, msg_hash_addr);
        return Instruction2.__wrap(ret4);
      }
      function ed19(pub_key_addr, sig_addr, msg_hash_addr) {
        const ret4 = wasm$1.ed19(pub_key_addr, sig_addr, msg_hash_addr);
        return Instruction2.__wrap(ret4);
      }
      function k256(dst_addr, src_addr, len) {
        const ret4 = wasm$1.k256(dst_addr, src_addr, len);
        return Instruction2.__wrap(ret4);
      }
      function s256(dst_addr, src_addr, len) {
        const ret4 = wasm$1.s256(dst_addr, src_addr, len);
        return Instruction2.__wrap(ret4);
      }
      function time(dst, heigth) {
        const ret4 = wasm$1.time(dst, heigth);
        return Instruction2.__wrap(ret4);
      }
      function noop() {
        const ret4 = wasm$1.noop();
        return Instruction2.__wrap(ret4);
      }
      function flag(value) {
        const ret4 = wasm$1.flag(value);
        return Instruction2.__wrap(ret4);
      }
      function bal(dst, asset_id_addr, contract_id_addr) {
        const ret4 = wasm$1.bal(dst, asset_id_addr, contract_id_addr);
        return Instruction2.__wrap(ret4);
      }
      function jmp(abs_target) {
        const ret4 = wasm$1.jmp(abs_target);
        return Instruction2.__wrap(ret4);
      }
      function jne(abs_target, lhs, rhs) {
        const ret4 = wasm$1.jne(abs_target, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function smo(recipient_addr, data_addr, data_len, coins) {
        const ret4 = wasm$1.smo(recipient_addr, data_addr, data_len, coins);
        return Instruction2.__wrap(ret4);
      }
      function addi2(dst, lhs, rhs) {
        const ret4 = wasm$1.addi(dst, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function andi(dst, lhs, rhs) {
        const ret4 = wasm$1.andi(dst, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function divi(dst, lhs, rhs) {
        const ret4 = wasm$1.divi(dst, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function expi(dst, lhs, rhs) {
        const ret4 = wasm$1.expi(dst, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function modi(dst, lhs, rhs) {
        const ret4 = wasm$1.modi(dst, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function muli2(dst, lhs, rhs) {
        const ret4 = wasm$1.muli(dst, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function ori(dst, lhs, rhs) {
        const ret4 = wasm$1.ori(dst, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function slli(dst, lhs, rhs) {
        const ret4 = wasm$1.slli(dst, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function srli(dst, lhs, rhs) {
        const ret4 = wasm$1.srli(dst, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function subi(dst, lhs, rhs) {
        const ret4 = wasm$1.subi(dst, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function xori(dst, lhs, rhs) {
        const ret4 = wasm$1.xori(dst, lhs, rhs);
        return Instruction2.__wrap(ret4);
      }
      function jnei(cond_lhs, cond_rhs, abs_target) {
        const ret4 = wasm$1.jnei(cond_lhs, cond_rhs, abs_target);
        return Instruction2.__wrap(ret4);
      }
      function lb(dst, addr, offset) {
        const ret4 = wasm$1.lb(dst, addr, offset);
        return Instruction2.__wrap(ret4);
      }
      function lw3(dst, addr, offset) {
        const ret4 = wasm$1.lw(dst, addr, offset);
        return Instruction2.__wrap(ret4);
      }
      function sb(addr, value, offset) {
        const ret4 = wasm$1.sb(addr, value, offset);
        return Instruction2.__wrap(ret4);
      }
      function sw(addr, value, offset) {
        const ret4 = wasm$1.sw(addr, value, offset);
        return Instruction2.__wrap(ret4);
      }
      function mcpi(dst_addr, src_addr, len) {
        const ret4 = wasm$1.mcpi(dst_addr, src_addr, len);
        return Instruction2.__wrap(ret4);
      }
      function gtf2(dst, arg, selector) {
        const ret4 = wasm$1.gtf(dst, arg, selector);
        return Instruction2.__wrap(ret4);
      }
      function mcli(addr, count) {
        const ret4 = wasm$1.mcli(addr, count);
        return Instruction2.__wrap(ret4);
      }
      function gm(dst, selector) {
        const ret4 = wasm$1.gm(dst, selector);
        return Instruction2.__wrap(ret4);
      }
      function movi2(dst, val) {
        const ret4 = wasm$1.movi(dst, val);
        return Instruction2.__wrap(ret4);
      }
      function jnzi(cond_nz, abs_target) {
        const ret4 = wasm$1.jnzi(cond_nz, abs_target);
        return Instruction2.__wrap(ret4);
      }
      function jmpf(dynamic, fixed) {
        const ret4 = wasm$1.jmpf(dynamic, fixed);
        return Instruction2.__wrap(ret4);
      }
      function jmpb(dynamic, fixed) {
        const ret4 = wasm$1.jmpb(dynamic, fixed);
        return Instruction2.__wrap(ret4);
      }
      function jnzf(cond_nz, dynamic, fixed) {
        const ret4 = wasm$1.jnzf(cond_nz, dynamic, fixed);
        return Instruction2.__wrap(ret4);
      }
      function jnzb(cond_nz, dynamic, fixed) {
        const ret4 = wasm$1.jnzb(cond_nz, dynamic, fixed);
        return Instruction2.__wrap(ret4);
      }
      function jnef(cond_lhs, cond_rhs, dynamic, fixed) {
        const ret4 = wasm$1.jnef(cond_lhs, cond_rhs, dynamic, fixed);
        return Instruction2.__wrap(ret4);
      }
      function jneb(cond_lhs, cond_rhs, dynamic, fixed) {
        const ret4 = wasm$1.jneb(cond_lhs, cond_rhs, dynamic, fixed);
        return Instruction2.__wrap(ret4);
      }
      function ji(abs_target) {
        const ret4 = wasm$1.ji(abs_target);
        return Instruction2.__wrap(ret4);
      }
      function cfei(amount) {
        const ret4 = wasm$1.cfei(amount);
        return Instruction2.__wrap(ret4);
      }
      function cfsi(amount) {
        const ret4 = wasm$1.cfsi(amount);
        return Instruction2.__wrap(ret4);
      }
      function cfe(amount) {
        const ret4 = wasm$1.cfe(amount);
        return Instruction2.__wrap(ret4);
      }
      function cfs(amount) {
        const ret4 = wasm$1.cfs(amount);
        return Instruction2.__wrap(ret4);
      }
      function pshl(bitmask) {
        const ret4 = wasm$1.pshl(bitmask);
        return Instruction2.__wrap(ret4);
      }
      function pshh(bitmask) {
        const ret4 = wasm$1.pshh(bitmask);
        return Instruction2.__wrap(ret4);
      }
      function popl(bitmask) {
        const ret4 = wasm$1.popl(bitmask);
        return Instruction2.__wrap(ret4);
      }
      function poph(bitmask) {
        const ret4 = wasm$1.poph(bitmask);
        return Instruction2.__wrap(ret4);
      }
      function wdcm(dst, lhs, rhs, flags) {
        const ret4 = wasm$1.wdcm(dst, lhs, rhs, flags);
        return Instruction2.__wrap(ret4);
      }
      function wqcm(dst, lhs, rhs, flags) {
        const ret4 = wasm$1.wqcm(dst, lhs, rhs, flags);
        return Instruction2.__wrap(ret4);
      }
      function wdop(dst, lhs, rhs, flags) {
        const ret4 = wasm$1.wdop(dst, lhs, rhs, flags);
        return Instruction2.__wrap(ret4);
      }
      function wqop(dst, lhs, rhs, flags) {
        const ret4 = wasm$1.wqop(dst, lhs, rhs, flags);
        return Instruction2.__wrap(ret4);
      }
      function wdml(dst, lhs, rhs, flags) {
        const ret4 = wasm$1.wdml(dst, lhs, rhs, flags);
        return Instruction2.__wrap(ret4);
      }
      function wqml(dst, lhs, rhs, flags) {
        const ret4 = wasm$1.wqml(dst, lhs, rhs, flags);
        return Instruction2.__wrap(ret4);
      }
      function wddv(dst, lhs, rhs, flags) {
        const ret4 = wasm$1.wddv(dst, lhs, rhs, flags);
        return Instruction2.__wrap(ret4);
      }
      function wqdv(dst, lhs, rhs, flags) {
        const ret4 = wasm$1.wqdv(dst, lhs, rhs, flags);
        return Instruction2.__wrap(ret4);
      }
      function wdmd(dst, mul_lhs, mul_rhs, divisor) {
        const ret4 = wasm$1.wdmd(dst, mul_lhs, mul_rhs, divisor);
        return Instruction2.__wrap(ret4);
      }
      function wqmd(dst, mul_lhs, mul_rhs, divisor) {
        const ret4 = wasm$1.wqmd(dst, mul_lhs, mul_rhs, divisor);
        return Instruction2.__wrap(ret4);
      }
      function wdam(dst, add_lhs, add_rhs, modulo) {
        const ret4 = wasm$1.wdam(dst, add_lhs, add_rhs, modulo);
        return Instruction2.__wrap(ret4);
      }
      function wqam(dst, add_lhs, add_rhs, modulo) {
        const ret4 = wasm$1.wqam(dst, add_lhs, add_rhs, modulo);
        return Instruction2.__wrap(ret4);
      }
      function wdmm(dst, mul_lhs, mul_rhs, modulo) {
        const ret4 = wasm$1.wdmm(dst, mul_lhs, mul_rhs, modulo);
        return Instruction2.__wrap(ret4);
      }
      function wqmm(dst, mul_lhs, mul_rhs, modulo) {
        const ret4 = wasm$1.wqmm(dst, mul_lhs, mul_rhs, modulo);
        return Instruction2.__wrap(ret4);
      }
      function gm_args(ra, args) {
        const ret4 = wasm$1.gm_args(ra, args);
        return Instruction2.__wrap(ret4);
      }
      function gtf_args(ra, rb, args) {
        const ret4 = wasm$1.gtf_args(ra, rb, args);
        return Instruction2.__wrap(ret4);
      }
      function wdcm_args(ra, rb, rc, args) {
        _assertClass(args, CompareArgs);
        var ptr0 = args.__destroy_into_raw();
        const ret4 = wasm$1.wdcm_args(ra, rb, rc, ptr0);
        return Instruction2.__wrap(ret4);
      }
      function wqcm_args(ra, rb, rc, args) {
        _assertClass(args, CompareArgs);
        var ptr0 = args.__destroy_into_raw();
        const ret4 = wasm$1.wqcm_args(ra, rb, rc, ptr0);
        return Instruction2.__wrap(ret4);
      }
      function wdop_args(ra, rb, rc, args) {
        _assertClass(args, MathArgs);
        var ptr0 = args.__destroy_into_raw();
        const ret4 = wasm$1.wdop_args(ra, rb, rc, ptr0);
        return Instruction2.__wrap(ret4);
      }
      function wqop_args(ra, rb, rc, args) {
        _assertClass(args, MathArgs);
        var ptr0 = args.__destroy_into_raw();
        const ret4 = wasm$1.wqop_args(ra, rb, rc, ptr0);
        return Instruction2.__wrap(ret4);
      }
      function wdml_args(ra, rb, rc, args) {
        _assertClass(args, MulArgs);
        var ptr0 = args.__destroy_into_raw();
        const ret4 = wasm$1.wdml_args(ra, rb, rc, ptr0);
        return Instruction2.__wrap(ret4);
      }
      function wqml_args(ra, rb, rc, args) {
        _assertClass(args, MulArgs);
        var ptr0 = args.__destroy_into_raw();
        const ret4 = wasm$1.wqml_args(ra, rb, rc, ptr0);
        return Instruction2.__wrap(ret4);
      }
      function wddv_args(ra, rb, rc, args) {
        _assertClass(args, DivArgs);
        var ptr0 = args.__destroy_into_raw();
        const ret4 = wasm$1.wddv_args(ra, rb, rc, ptr0);
        return Instruction2.__wrap(ret4);
      }
      function wqdv_args(ra, rb, rc, args) {
        _assertClass(args, DivArgs);
        var ptr0 = args.__destroy_into_raw();
        const ret4 = wasm$1.wqdv_args(ra, rb, rc, ptr0);
        return Instruction2.__wrap(ret4);
      }
      var cachedInt32Memory0 = null;
      function getInt32Memory0() {
        if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
          cachedInt32Memory0 = new Int32Array(wasm$1.memory.buffer);
        }
        return cachedInt32Memory0;
      }
      function getArrayU8FromWasm0(ptr, len) {
        ptr = ptr >>> 0;
        return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
      }
      var GMArgs = Object.freeze({
        /**
        *r" Get if caller is external.
        */
        IsCallerExternal: 1,
        "1": "IsCallerExternal",
        /**
        *r" Get caller's contract ID.
        */
        GetCaller: 2,
        "2": "GetCaller",
        /**
        *r" Get index of current predicate.
        */
        GetVerifyingPredicate: 3,
        "3": "GetVerifyingPredicate",
        /**
        *r" Get the Chain ID this VM is operating within
        */
        GetChainId: 4,
        "4": "GetChainId"
      });
      var GTFArgs2 = Object.freeze({
        /**
        *r" Set `$rA` to `tx.type`
        */
        Type: 1,
        "1": "Type",
        /**
        *r" Set `$rA` to `tx.gasPrice`
        */
        ScriptGasPrice: 2,
        "2": "ScriptGasPrice",
        /**
        *r" Set `$rA` to `tx.gasLimit`
        */
        ScriptGasLimit: 3,
        "3": "ScriptGasLimit",
        /**
        *r" Set `$rA` to `tx.maturity`
        */
        ScriptMaturity: 4,
        "4": "ScriptMaturity",
        /**
        *r" Set `$rA` to `tx.scriptLength`
        */
        ScriptLength: 5,
        "5": "ScriptLength",
        /**
        *r" Set `$rA` to `tx.scriptDataLength`
        */
        ScriptDataLength: 6,
        "6": "ScriptDataLength",
        /**
        *r" Set `$rA` to `tx.inputsCount`
        */
        ScriptInputsCount: 7,
        "7": "ScriptInputsCount",
        /**
        *r" Set `$rA` to `tx.outputsCount`
        */
        ScriptOutputsCount: 8,
        "8": "ScriptOutputsCount",
        /**
        *r" Set `$rA` to `tx.witnessesCount`
        */
        ScriptWitnessesCound: 9,
        "9": "ScriptWitnessesCound",
        /**
        *r" Set `$rA` to `Memory address of tx.receiptsRoot`
        */
        ScriptReceiptsRoot: 10,
        "10": "ScriptReceiptsRoot",
        /**
        *r" Set `$rA` to `Memory address of tx.script`
        */
        Script: 11,
        "11": "Script",
        /**
        *r" Set `$rA` to `Memory address of tx.scriptData`
        */
        ScriptData: 12,
        "12": "ScriptData",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB]`
        */
        ScriptInputAtIndex: 13,
        "13": "ScriptInputAtIndex",
        /**
        *r" Set `$rA` to `Memory address of t.outputs[$rB]`
        */
        ScriptOutputAtIndex: 14,
        "14": "ScriptOutputAtIndex",
        /**
        *r" Set `$rA` to `Memory address of tx.witnesses[$rB]`
        */
        ScriptWitnessAtIndex: 15,
        "15": "ScriptWitnessAtIndex",
        /**
        *r" Set `$rA` to `tx.gasPrice`
        */
        CreateGasPrice: 16,
        "16": "CreateGasPrice",
        /**
        *r" Set `$rA` to `tx.gasLimit`
        */
        CreateGasLimit: 17,
        "17": "CreateGasLimit",
        /**
        *r" Set `$rA` to `tx.maturity`
        */
        CreateMaturity: 18,
        "18": "CreateMaturity",
        /**
        *r" Set `$rA` to `tx.bytecodeLength`
        */
        CreateBytecodeLength: 19,
        "19": "CreateBytecodeLength",
        /**
        *r" Set `$rA` to `tx.bytecodeWitnessIndex`
        */
        CreateBytecodeWitnessIndex: 20,
        "20": "CreateBytecodeWitnessIndex",
        /**
        *r" Set `$rA` to `tx.storageSlotsCount`
        */
        CreateStorageSlotsCount: 21,
        "21": "CreateStorageSlotsCount",
        /**
        *r" Set `$rA` to `tx.inputsCount`
        */
        CreateInputsCount: 22,
        "22": "CreateInputsCount",
        /**
        *r" Set `$rA` to `tx.outputsCount`
        */
        CreateOutputsCount: 23,
        "23": "CreateOutputsCount",
        /**
        *r" Set `$rA` to `tx.witnessesCount`
        */
        CreateWitnessesCount: 24,
        "24": "CreateWitnessesCount",
        /**
        *r" Set `$rA` to `Memory address of tx.salt`
        */
        CreateSalt: 25,
        "25": "CreateSalt",
        /**
        *r" Set `$rA` to `Memory address of tx.storageSlots[$rB]`
        */
        CreateStorageSlotAtIndex: 26,
        "26": "CreateStorageSlotAtIndex",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB]`
        */
        CreateInputAtIndex: 27,
        "27": "CreateInputAtIndex",
        /**
        *r" Set `$rA` to `Memory address of t.outputs[$rB]`
        */
        CreateOutputAtIndex: 28,
        "28": "CreateOutputAtIndex",
        /**
        *r" Set `$rA` to `Memory address of tx.witnesses[$rB]`
        */
        CreateWitnessAtIndex: 29,
        "29": "CreateWitnessAtIndex",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].type`
        */
        InputType: 257,
        "257": "InputType",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].txID`
        */
        InputCoinTxId: 258,
        "258": "InputCoinTxId",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].outputIndex`
        */
        InputCoinOutputIndex: 259,
        "259": "InputCoinOutputIndex",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].owner`
        */
        InputCoinOwner: 260,
        "260": "InputCoinOwner",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].amount`
        */
        InputCoinAmount: 261,
        "261": "InputCoinAmount",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].asset_id`
        */
        InputCoinAssetId: 262,
        "262": "InputCoinAssetId",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].txPointer`
        */
        InputCoinTxPointer: 263,
        "263": "InputCoinTxPointer",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].witnessIndex`
        */
        InputCoinWitnessIndex: 264,
        "264": "InputCoinWitnessIndex",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].maturity`
        */
        InputCoinMaturity: 265,
        "265": "InputCoinMaturity",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].predicateLength`
        */
        InputCoinPredicateLength: 266,
        "266": "InputCoinPredicateLength",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].predicateDataLength`
        */
        InputCoinPredicateDataLength: 267,
        "267": "InputCoinPredicateDataLength",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].predicate`
        */
        InputCoinPredicate: 268,
        "268": "InputCoinPredicate",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateData`
        */
        InputCoinPredicateData: 269,
        "269": "InputCoinPredicateData",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateGasUsed`
        */
        InputCoinPredicateGasUsed: 270,
        "270": "InputCoinPredicateGasUsed",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].txID`
        */
        InputContractTxId: 271,
        "271": "InputContractTxId",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].outputIndex`
        */
        InputContractOutputIndex: 272,
        "272": "InputContractOutputIndex",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].balanceRoot`
        */
        InputContractBalanceRoot: 273,
        "273": "InputContractBalanceRoot",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].stateRoot`
        */
        InputContractStateRoot: 274,
        "274": "InputContractStateRoot",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].txPointer`
        */
        InputContractTxPointer: 275,
        "275": "InputContractTxPointer",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].contractID`
        */
        InputContractId: 276,
        "276": "InputContractId",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].sender`
        */
        InputMessageSender: 277,
        "277": "InputMessageSender",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].recipient`
        */
        InputMessageRecipient: 278,
        "278": "InputMessageRecipient",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].amount`
        */
        InputMessageAmount: 279,
        "279": "InputMessageAmount",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].nonce`
        */
        InputMessageNonce: 280,
        "280": "InputMessageNonce",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].witnessIndex`
        */
        InputMessageWitnessIndex: 281,
        "281": "InputMessageWitnessIndex",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].dataLength`
        */
        InputMessageDataLength: 282,
        "282": "InputMessageDataLength",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].predicateLength`
        */
        InputMessagePredicateLength: 283,
        "283": "InputMessagePredicateLength",
        /**
        *r" Set `$rA` to `tx.inputs[$rB].predicateDataLength`
        */
        InputMessagePredicateDataLength: 284,
        "284": "InputMessagePredicateDataLength",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].data`
        */
        InputMessageData: 285,
        "285": "InputMessageData",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].predicate`
        */
        InputMessagePredicate: 286,
        "286": "InputMessagePredicate",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateData`
        */
        InputMessagePredicateData: 287,
        "287": "InputMessagePredicateData",
        /**
        *r" Set `$rA` to `Memory address of tx.inputs[$rB].predicateGasUsed`
        */
        InputMessagePredicateGasUsed: 288,
        "288": "InputMessagePredicateGasUsed",
        /**
        *r" Set `$rA` to `tx.outputs[$rB].type`
        */
        OutputType: 513,
        "513": "OutputType",
        /**
        *r" Set `$rA` to `Memory address of tx.outputs[$rB].to`
        */
        OutputCoinTo: 514,
        "514": "OutputCoinTo",
        /**
        *r" Set `$rA` to `tx.outputs[$rB].amount`
        */
        OutputCoinAmount: 515,
        "515": "OutputCoinAmount",
        /**
        *r" Set `$rA` to `Memory address of tx.outputs[$rB].asset_id`
        */
        OutputCoinAssetId: 516,
        "516": "OutputCoinAssetId",
        /**
        *r" Set `$rA` to `tx.outputs[$rB].inputIndex`
        */
        OutputContractInputIndex: 517,
        "517": "OutputContractInputIndex",
        /**
        *r" Set `$rA` to `Memory address of tx.outputs[$rB].balanceRoot`
        */
        OutputContractBalanceRoot: 518,
        "518": "OutputContractBalanceRoot",
        /**
        *r" Set `$rA` to `Memory address of tx.outputs[$rB].stateRoot`
        */
        OutputContractStateRoot: 519,
        "519": "OutputContractStateRoot",
        /**
        *r" Set `$rA` to `Memory address of tx.outputs[$rB].contractID`
        */
        OutputContractCreatedContractId: 520,
        "520": "OutputContractCreatedContractId",
        /**
        *r" Set `$rA` to `Memory address of tx.outputs[$rB].stateRoot`
        */
        OutputContractCreatedStateRoot: 521,
        "521": "OutputContractCreatedStateRoot",
        /**
        *r" Set `$rA` to `tx.witnesses[$rB].dataLength`
        */
        WitnessDataLength: 769,
        "769": "WitnessDataLength",
        /**
        *r" Set `$rA` to `Memory address of tx.witnesses[$rB].data`
        */
        WitnessData: 770,
        "770": "WitnessData"
      });
      var PanicReason = Object.freeze({
        /**
        *r" The byte can't be mapped to any known `PanicReason`.
        */
        UnknownPanicReason: 0,
        "0": "UnknownPanicReason",
        /**
        *r" Found `RVRT` instruction.
        */
        Revert: 1,
        "1": "Revert",
        /**
        *r" Execution ran out of gas.
        */
        OutOfGas: 2,
        "2": "OutOfGas",
        /**
        *r" The transaction validity is violated.
        */
        TransactionValidity: 3,
        "3": "TransactionValidity",
        /**
        *r" Attempt to write outside interpreter memory boundaries.
        */
        MemoryOverflow: 4,
        "4": "MemoryOverflow",
        /**
        *r" Overflow while executing arithmetic operation.
        *r" These errors are ignored using the WRAPPING flag.
        */
        ArithmeticOverflow: 5,
        "5": "ArithmeticOverflow",
        /**
        *r" Designed contract was not found in the storage.
        */
        ContractNotFound: 6,
        "6": "ContractNotFound",
        /**
        *r" Memory ownership rules are violated.
        */
        MemoryOwnership: 7,
        "7": "MemoryOwnership",
        /**
        *r" The asset ID balance isn't enough for the instruction.
        */
        NotEnoughBalance: 8,
        "8": "NotEnoughBalance",
        /**
        *r" The interpreter is expected to be in internal context.
        */
        ExpectedInternalContext: 9,
        "9": "ExpectedInternalContext",
        /**
        *r" The queried asset ID was not found in the state.
        */
        AssetIdNotFound: 10,
        "10": "AssetIdNotFound",
        /**
        *r" The provided input is not found in the transaction.
        */
        InputNotFound: 11,
        "11": "InputNotFound",
        /**
        *r" The provided output is not found in the transaction.
        */
        OutputNotFound: 12,
        "12": "OutputNotFound",
        /**
        *r" The provided witness is not found in the transaction.
        */
        WitnessNotFound: 13,
        "13": "WitnessNotFound",
        /**
        *r" The transaction maturity is not valid for this request.
        */
        TransactionMaturity: 14,
        "14": "TransactionMaturity",
        /**
        *r" The metadata identifier is invalid.
        */
        InvalidMetadataIdentifier: 15,
        "15": "InvalidMetadataIdentifier",
        /**
        *r" The call structure is not valid.
        */
        MalformedCallStructure: 16,
        "16": "MalformedCallStructure",
        /**
        *r" The provided register does not allow write operations.
        */
        ReservedRegisterNotWritable: 17,
        "17": "ReservedRegisterNotWritable",
        /**
        *r" The execution resulted in an erroneous state of the interpreter.
        */
        ErrorFlag: 18,
        "18": "ErrorFlag",
        /**
        *r" The provided immediate value is not valid for this instruction.
        */
        InvalidImmediateValue: 19,
        "19": "InvalidImmediateValue",
        /**
        *r" The provided transaction input is not of type `Coin`.
        */
        ExpectedCoinInput: 20,
        "20": "ExpectedCoinInput",
        /**
        *r" This entry is no longer used, and can be repurposed.
        */
        Unused0x15: 21,
        "21": "Unused0x15",
        /**
        *r" Two segments of the interpreter memory should not intersect for write operations.
        */
        MemoryWriteOverlap: 22,
        "22": "MemoryWriteOverlap",
        /**
        *r" The requested contract is not listed in the transaction inputs.
        */
        ContractNotInInputs: 23,
        "23": "ContractNotInInputs",
        /**
        *r" The internal asset ID balance overflowed with the provided instruction.
        */
        InternalBalanceOverflow: 24,
        "24": "InternalBalanceOverflow",
        /**
        *r" The maximum allowed contract size is violated.
        */
        ContractMaxSize: 25,
        "25": "ContractMaxSize",
        /**
        *r" This instruction expects the stack area to be unallocated for this call.
        */
        ExpectedUnallocatedStack: 26,
        "26": "ExpectedUnallocatedStack",
        /**
        *r" The maximum allowed number of static contracts was reached for this transaction.
        */
        MaxStaticContractsReached: 27,
        "27": "MaxStaticContractsReached",
        /**
        *r" The requested transfer amount cannot be zero.
        */
        TransferAmountCannotBeZero: 28,
        "28": "TransferAmountCannotBeZero",
        /**
        *r" The provided transaction output should be of type `Variable`.
        */
        ExpectedOutputVariable: 29,
        "29": "ExpectedOutputVariable",
        /**
        *r" The expected context of the stack parent is internal.
        */
        ExpectedParentInternalContext: 30,
        "30": "ExpectedParentInternalContext",
        /**
        *r" The jump instruction cannot move backwards in predicate verification.
        */
        IllegalJump: 31,
        "31": "IllegalJump",
        /**
        *r" The contract ID is already deployed and can't be overwritten.
        */
        ContractIdAlreadyDeployed: 32,
        "32": "ContractIdAlreadyDeployed",
        /**
        *r" The loaded contract mismatch expectations.
        */
        ContractMismatch: 33,
        "33": "ContractMismatch",
        /**
        *r" Attempting to send message data longer than `MAX_MESSAGE_DATA_LENGTH`
        */
        MessageDataTooLong: 34,
        "34": "MessageDataTooLong",
        /**
        *r" Mathimatically invalid arguments where given to an arithmetic instruction.
        *r" For instance, division by zero produces this.
        *r" These errors are ignored using the UNSAFEMATH flag.
        */
        ArithmeticError: 35,
        "35": "ArithmeticError",
        /**
        *r" The contract instruction is not allowed in predicates.
        */
        ContractInstructionNotAllowed: 36,
        "36": "ContractInstructionNotAllowed",
        /**
        *r" Transfer of zero coins is not allowed.
        */
        TransferZeroCoins: 37,
        "37": "TransferZeroCoins"
      });
      var CompareMode = Object.freeze({
        /**
        * Equality (`==`)
        */
        EQ: 0,
        "0": "EQ",
        /**
        * Inequality (`!=`)
        */
        NE: 1,
        "1": "NE",
        /**
        * Less than (`<`)
        */
        LT: 2,
        "2": "LT",
        /**
        * Greater than (`>`)
        */
        GT: 3,
        "3": "GT",
        /**
        * Less than or equals (`>=`)
        */
        LTE: 4,
        "4": "LTE",
        /**
        * Greater than or equals (`>=`)
        */
        GTE: 5,
        "5": "GTE",
        /**
        * Number of leading zeroes in lhs (`lzcnt`) (discards rhs)
        */
        LZC: 6,
        "6": "LZC"
      });
      var MathOp = Object.freeze({
        /**
        * Add
        */
        ADD: 0,
        "0": "ADD",
        /**
        * Subtract
        */
        SUB: 1,
        "1": "SUB",
        /**
        * Invert bits (discards rhs)
        */
        NOT: 2,
        "2": "NOT",
        /**
        * Bitwise or
        */
        OR: 3,
        "3": "OR",
        /**
        * Bitwise exclusive or
        */
        XOR: 4,
        "4": "XOR",
        /**
        * Bitwise and
        */
        AND: 5,
        "5": "AND",
        /**
        * Shift left
        */
        SHL: 6,
        "6": "SHL",
        /**
        * Shift right
        */
        SHR: 7,
        "7": "SHR"
      });
      var ADD = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(ADD.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_add_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return ADD.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var ADDI = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(ADDI.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_addi_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          return ADDI.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret4 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret4);
        }
      };
      var ALOC = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(ALOC.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_aloc_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} bytes
        */
        constructor(bytes3) {
          _assertClass(bytes3, RegId2);
          var ptr0 = bytes3.__destroy_into_raw();
          const ret4 = wasm$1.aloc_new_typescript(ptr0);
          return ALOC.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var AND = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(AND.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_and_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return AND.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var ANDI = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(ANDI.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_andi_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          return ANDI.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret4 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret4);
        }
      };
      var BAL = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(BAL.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_bal_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} asset_id_addr
        * @param {RegId} contract_id_addr
        */
        constructor(dst, asset_id_addr, contract_id_addr) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(asset_id_addr, RegId2);
          var ptr1 = asset_id_addr.__destroy_into_raw();
          _assertClass(contract_id_addr, RegId2);
          var ptr2 = contract_id_addr.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return BAL.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var BHEI = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(BHEI.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_bhei_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        */
        constructor(dst) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          const ret4 = wasm$1.aloc_new_typescript(ptr0);
          return BHEI.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var BHSH = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(BHSH.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_bhsh_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} heigth
        */
        constructor(dst, heigth) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(heigth, RegId2);
          var ptr1 = heigth.__destroy_into_raw();
          const ret4 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          return BHSH.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var BURN = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(BURN.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_burn_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} amount
        * @param {RegId} sub_id_addr
        */
        constructor(amount, sub_id_addr) {
          _assertClass(amount, RegId2);
          var ptr0 = amount.__destroy_into_raw();
          _assertClass(sub_id_addr, RegId2);
          var ptr1 = sub_id_addr.__destroy_into_raw();
          const ret4 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          return BURN.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var CALL = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(CALL.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_call_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} target_struct
        * @param {RegId} fwd_coins
        * @param {RegId} asset_id_addr
        * @param {RegId} fwd_gas
        */
        constructor(target_struct, fwd_coins, asset_id_addr, fwd_gas) {
          _assertClass(target_struct, RegId2);
          var ptr0 = target_struct.__destroy_into_raw();
          _assertClass(fwd_coins, RegId2);
          var ptr1 = fwd_coins.__destroy_into_raw();
          _assertClass(asset_id_addr, RegId2);
          var ptr2 = asset_id_addr.__destroy_into_raw();
          _assertClass(fwd_gas, RegId2);
          var ptr3 = fwd_gas.__destroy_into_raw();
          const ret4 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          return CALL.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret4 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var CB = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(CB.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_cb_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        */
        constructor(dst) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          const ret4 = wasm$1.aloc_new_typescript(ptr0);
          return CB.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var CCP = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(CCP.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_ccp_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} contract_id_addr
        * @param {RegId} offset
        * @param {RegId} len
        */
        constructor(dst_addr, contract_id_addr, offset, len) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(contract_id_addr, RegId2);
          var ptr1 = contract_id_addr.__destroy_into_raw();
          _assertClass(offset, RegId2);
          var ptr2 = offset.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr3 = len.__destroy_into_raw();
          const ret4 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          return CCP.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret4 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var CFE = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(CFE.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_cfe_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} amount
        */
        constructor(amount) {
          _assertClass(amount, RegId2);
          var ptr0 = amount.__destroy_into_raw();
          const ret4 = wasm$1.aloc_new_typescript(ptr0);
          return CFE.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var CFEI = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(CFEI.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_cfei_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {Imm24} amount
        */
        constructor(amount) {
          _assertClass(amount, Imm24);
          var ptr0 = amount.__destroy_into_raw();
          const ret4 = wasm$1.cfei_new_typescript(ptr0);
          return CFEI.__wrap(ret4);
        }
        /**
        * Access the 24-bit immediate value.
        * @returns {Imm24}
        */
        imm24() {
          const ret4 = wasm$1.cfei_imm24(this.__wbg_ptr);
          return Imm24.__wrap(ret4);
        }
      };
      var CFS = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(CFS.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_cfs_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} amount
        */
        constructor(amount) {
          _assertClass(amount, RegId2);
          var ptr0 = amount.__destroy_into_raw();
          const ret4 = wasm$1.aloc_new_typescript(ptr0);
          return CFS.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var CFSI = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(CFSI.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_cfsi_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {Imm24} amount
        */
        constructor(amount) {
          _assertClass(amount, Imm24);
          var ptr0 = amount.__destroy_into_raw();
          const ret4 = wasm$1.cfei_new_typescript(ptr0);
          return CFSI.__wrap(ret4);
        }
        /**
        * Access the 24-bit immediate value.
        * @returns {Imm24}
        */
        imm24() {
          const ret4 = wasm$1.cfei_imm24(this.__wbg_ptr);
          return Imm24.__wrap(ret4);
        }
      };
      var CROO = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(CROO.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_croo_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} contract_id_addr
        */
        constructor(dst_addr, contract_id_addr) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(contract_id_addr, RegId2);
          var ptr1 = contract_id_addr.__destroy_into_raw();
          const ret4 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          return CROO.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var CSIZ = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(CSIZ.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_csiz_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} contract_id_addr
        */
        constructor(dst, contract_id_addr) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(contract_id_addr, RegId2);
          var ptr1 = contract_id_addr.__destroy_into_raw();
          const ret4 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          return CSIZ.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var CompareArgs = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(CompareArgs.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_compareargs_free(ptr);
        }
        /**
        * Comparison mode
        * @returns {number}
        */
        get mode() {
          const ret4 = wasm$1.__wbg_get_compareargs_mode(this.__wbg_ptr);
          return ret4 >>> 0;
        }
        /**
        * Comparison mode
        * @param {number} arg0
        */
        set mode(arg0) {
          wasm$1.__wbg_set_compareargs_mode(this.__wbg_ptr, arg0);
        }
        /**
        * Load RHS from register if true, otherwise zero-extend register value
        * @returns {boolean}
        */
        get indirect_rhs() {
          const ret4 = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
          return ret4 !== 0;
        }
        /**
        * Load RHS from register if true, otherwise zero-extend register value
        * @param {boolean} arg0
        */
        set indirect_rhs(arg0) {
          wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
        }
        /**
        * Convert to immediate value.
        * @returns {Imm06}
        */
        to_imm() {
          const ptr = this.__destroy_into_raw();
          const ret4 = wasm$1.compareargs_to_imm(ptr);
          return Imm06.__wrap(ret4);
        }
        /**
        * Construct from `Imm06`. Returns `None` if the value has reserved flags set.
        * @param {Imm06} bits
        * @returns {CompareArgs | undefined}
        */
        static from_imm(bits) {
          _assertClass(bits, Imm06);
          var ptr0 = bits.__destroy_into_raw();
          const ret4 = wasm$1.compareargs_from_imm(ptr0);
          return ret4 === 0 ? void 0 : CompareArgs.__wrap(ret4);
        }
      };
      var DIV = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(DIV.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_div_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return DIV.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var DIVI = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(DIVI.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_divi_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          return DIVI.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret4 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret4);
        }
      };
      var DivArgs = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_divargs_free(ptr);
        }
        /**
        * Load RHS from register if true, otherwise zero-extend register value
        * @returns {boolean}
        */
        get indirect_rhs() {
          const ret4 = wasm$1.__wbg_get_divargs_indirect_rhs(this.__wbg_ptr);
          return ret4 !== 0;
        }
        /**
        * Load RHS from register if true, otherwise zero-extend register value
        * @param {boolean} arg0
        */
        set indirect_rhs(arg0) {
          wasm$1.__wbg_set_divargs_indirect_rhs(this.__wbg_ptr, arg0);
        }
      };
      var ECK1 = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(ECK1.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_eck1_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} sig_addr
        * @param {RegId} msg_hash_addr
        */
        constructor(dst_addr, sig_addr, msg_hash_addr) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(sig_addr, RegId2);
          var ptr1 = sig_addr.__destroy_into_raw();
          _assertClass(msg_hash_addr, RegId2);
          var ptr2 = msg_hash_addr.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return ECK1.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var ECR1 = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(ECR1.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_ecr1_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} sig_addr
        * @param {RegId} msg_hash_addr
        */
        constructor(dst_addr, sig_addr, msg_hash_addr) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(sig_addr, RegId2);
          var ptr1 = sig_addr.__destroy_into_raw();
          _assertClass(msg_hash_addr, RegId2);
          var ptr2 = msg_hash_addr.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return ECR1.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var ED19 = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(ED19.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_ed19_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} pub_key_addr
        * @param {RegId} sig_addr
        * @param {RegId} msg_hash_addr
        */
        constructor(pub_key_addr, sig_addr, msg_hash_addr) {
          _assertClass(pub_key_addr, RegId2);
          var ptr0 = pub_key_addr.__destroy_into_raw();
          _assertClass(sig_addr, RegId2);
          var ptr1 = sig_addr.__destroy_into_raw();
          _assertClass(msg_hash_addr, RegId2);
          var ptr2 = msg_hash_addr.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return ED19.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var EQ = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(EQ.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_eq_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return EQ.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var EXP = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(EXP.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_exp_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return EXP.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var EXPI = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(EXPI.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_expi_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          return EXPI.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret4 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret4);
        }
      };
      var FLAG = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(FLAG.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_flag_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} value
        */
        constructor(value) {
          _assertClass(value, RegId2);
          var ptr0 = value.__destroy_into_raw();
          const ret4 = wasm$1.aloc_new_typescript(ptr0);
          return FLAG.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var GM = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(GM.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_gm_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {Imm18} selector
        */
        constructor(dst, selector) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(selector, Imm18);
          var ptr1 = selector.__destroy_into_raw();
          const ret4 = wasm$1.gm_new_typescript(ptr0, ptr1);
          return GM.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 18-bit immediate value.
        * @returns {Imm18}
        */
        imm18() {
          const ret4 = wasm$1.gm_imm18(this.__wbg_ptr);
          return Imm18.__wrap(ret4);
        }
        /**
        * Construct a `GM` instruction from its arguments.
        * @param {RegId} ra
        * @param {number} args
        * @returns {GM}
        */
        static from_args(ra, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          const ret4 = wasm$1.gm_from_args(ptr0, args);
          return GM.__wrap(ret4);
        }
      };
      var GT = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(GT.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_gt_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return GT.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var GTF = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(GTF.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_gtf_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} arg
        * @param {Imm12} selector
        */
        constructor(dst, arg, selector) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(arg, RegId2);
          var ptr1 = arg.__destroy_into_raw();
          _assertClass(selector, Imm12);
          var ptr2 = selector.__destroy_into_raw();
          const ret4 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          return GTF.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret4 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret4);
        }
        /**
        * Construct a `GTF` instruction from its arguments.
        * @param {RegId} ra
        * @param {RegId} rb
        * @param {number} args
        * @returns {GTF}
        */
        static from_args(ra, rb, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          _assertClass(rb, RegId2);
          var ptr1 = rb.__destroy_into_raw();
          const ret4 = wasm$1.gtf_from_args(ptr0, ptr1, args);
          return GTF.__wrap(ret4);
        }
      };
      var Imm06 = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(Imm06.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_imm06_free(ptr);
        }
      };
      var Imm12 = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(Imm12.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_imm12_free(ptr);
        }
      };
      var Imm18 = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(Imm18.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_imm18_free(ptr);
        }
      };
      var Imm24 = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(Imm24.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_imm24_free(ptr);
        }
      };
      var Instruction2 = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(Instruction2.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_instruction_free(ptr);
        }
        /**
        * Convenience method for converting to bytes
        * @returns {Uint8Array}
        */
        to_bytes() {
          try {
            const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
            wasm$1.instruction_to_bytes(retptr, this.__wbg_ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v1 = getArrayU8FromWasm0(r0, r1).slice();
            wasm$1.__wbindgen_free(r0, r1 * 1);
            return v1;
          } finally {
            wasm$1.__wbindgen_add_to_stack_pointer(16);
          }
        }
        /**
        * Size of an instruction in bytes
        * @returns {number}
        */
        static size() {
          const ret4 = wasm$1.instruction_size();
          return ret4 >>> 0;
        }
      };
      var JI = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(JI.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_ji_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {Imm24} abs_target
        */
        constructor(abs_target) {
          _assertClass(abs_target, Imm24);
          var ptr0 = abs_target.__destroy_into_raw();
          const ret4 = wasm$1.cfei_new_typescript(ptr0);
          return JI.__wrap(ret4);
        }
        /**
        * Access the 24-bit immediate value.
        * @returns {Imm24}
        */
        imm24() {
          const ret4 = wasm$1.cfei_imm24(this.__wbg_ptr);
          return Imm24.__wrap(ret4);
        }
      };
      var JMP = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(JMP.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jmp_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} abs_target
        */
        constructor(abs_target) {
          _assertClass(abs_target, RegId2);
          var ptr0 = abs_target.__destroy_into_raw();
          const ret4 = wasm$1.aloc_new_typescript(ptr0);
          return JMP.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var JMPB = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(JMPB.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jmpb_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dynamic
        * @param {Imm18} fixed
        */
        constructor(dynamic, fixed) {
          _assertClass(dynamic, RegId2);
          var ptr0 = dynamic.__destroy_into_raw();
          _assertClass(fixed, Imm18);
          var ptr1 = fixed.__destroy_into_raw();
          const ret4 = wasm$1.gm_new_typescript(ptr0, ptr1);
          return JMPB.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 18-bit immediate value.
        * @returns {Imm18}
        */
        imm18() {
          const ret4 = wasm$1.gm_imm18(this.__wbg_ptr);
          return Imm18.__wrap(ret4);
        }
      };
      var JMPF = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(JMPF.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jmpf_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dynamic
        * @param {Imm18} fixed
        */
        constructor(dynamic, fixed) {
          _assertClass(dynamic, RegId2);
          var ptr0 = dynamic.__destroy_into_raw();
          _assertClass(fixed, Imm18);
          var ptr1 = fixed.__destroy_into_raw();
          const ret4 = wasm$1.gm_new_typescript(ptr0, ptr1);
          return JMPF.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 18-bit immediate value.
        * @returns {Imm18}
        */
        imm18() {
          const ret4 = wasm$1.gm_imm18(this.__wbg_ptr);
          return Imm18.__wrap(ret4);
        }
      };
      var JNE = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(JNE.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jne_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} abs_target
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(abs_target, lhs, rhs) {
          _assertClass(abs_target, RegId2);
          var ptr0 = abs_target.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return JNE.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var JNEB = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(JNEB.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jneb_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} cond_lhs
        * @param {RegId} cond_rhs
        * @param {RegId} dynamic
        * @param {Imm06} fixed
        */
        constructor(cond_lhs, cond_rhs, dynamic, fixed) {
          _assertClass(cond_lhs, RegId2);
          var ptr0 = cond_lhs.__destroy_into_raw();
          _assertClass(cond_rhs, RegId2);
          var ptr1 = cond_rhs.__destroy_into_raw();
          _assertClass(dynamic, RegId2);
          var ptr2 = dynamic.__destroy_into_raw();
          _assertClass(fixed, Imm06);
          var ptr3 = fixed.__destroy_into_raw();
          const ret4 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          return JNEB.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret4 = wasm$1.call_rd(this.__wbg_ptr);
          return Imm06.__wrap(ret4);
        }
      };
      var JNEF = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(JNEF.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jnef_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} cond_lhs
        * @param {RegId} cond_rhs
        * @param {RegId} dynamic
        * @param {Imm06} fixed
        */
        constructor(cond_lhs, cond_rhs, dynamic, fixed) {
          _assertClass(cond_lhs, RegId2);
          var ptr0 = cond_lhs.__destroy_into_raw();
          _assertClass(cond_rhs, RegId2);
          var ptr1 = cond_rhs.__destroy_into_raw();
          _assertClass(dynamic, RegId2);
          var ptr2 = dynamic.__destroy_into_raw();
          _assertClass(fixed, Imm06);
          var ptr3 = fixed.__destroy_into_raw();
          const ret4 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          return JNEF.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret4 = wasm$1.call_rd(this.__wbg_ptr);
          return Imm06.__wrap(ret4);
        }
      };
      var JNEI = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(JNEI.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jnei_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} cond_lhs
        * @param {RegId} cond_rhs
        * @param {Imm12} abs_target
        */
        constructor(cond_lhs, cond_rhs, abs_target) {
          _assertClass(cond_lhs, RegId2);
          var ptr0 = cond_lhs.__destroy_into_raw();
          _assertClass(cond_rhs, RegId2);
          var ptr1 = cond_rhs.__destroy_into_raw();
          _assertClass(abs_target, Imm12);
          var ptr2 = abs_target.__destroy_into_raw();
          const ret4 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          return JNEI.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret4 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret4);
        }
      };
      var JNZB = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(JNZB.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jnzb_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} cond_nz
        * @param {RegId} dynamic
        * @param {Imm12} fixed
        */
        constructor(cond_nz, dynamic, fixed) {
          _assertClass(cond_nz, RegId2);
          var ptr0 = cond_nz.__destroy_into_raw();
          _assertClass(dynamic, RegId2);
          var ptr1 = dynamic.__destroy_into_raw();
          _assertClass(fixed, Imm12);
          var ptr2 = fixed.__destroy_into_raw();
          const ret4 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          return JNZB.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret4 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret4);
        }
      };
      var JNZF = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(JNZF.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jnzf_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} cond_nz
        * @param {RegId} dynamic
        * @param {Imm12} fixed
        */
        constructor(cond_nz, dynamic, fixed) {
          _assertClass(cond_nz, RegId2);
          var ptr0 = cond_nz.__destroy_into_raw();
          _assertClass(dynamic, RegId2);
          var ptr1 = dynamic.__destroy_into_raw();
          _assertClass(fixed, Imm12);
          var ptr2 = fixed.__destroy_into_raw();
          const ret4 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          return JNZF.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret4 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret4);
        }
      };
      var JNZI = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(JNZI.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_jnzi_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} cond_nz
        * @param {Imm18} abs_target
        */
        constructor(cond_nz, abs_target) {
          _assertClass(cond_nz, RegId2);
          var ptr0 = cond_nz.__destroy_into_raw();
          _assertClass(abs_target, Imm18);
          var ptr1 = abs_target.__destroy_into_raw();
          const ret4 = wasm$1.gm_new_typescript(ptr0, ptr1);
          return JNZI.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 18-bit immediate value.
        * @returns {Imm18}
        */
        imm18() {
          const ret4 = wasm$1.gm_imm18(this.__wbg_ptr);
          return Imm18.__wrap(ret4);
        }
      };
      var K256 = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(K256.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_k256_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} src_addr
        * @param {RegId} len
        */
        constructor(dst_addr, src_addr, len) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(src_addr, RegId2);
          var ptr1 = src_addr.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr2 = len.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return K256.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var LB = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(LB.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_lb_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} addr
        * @param {Imm12} offset
        */
        constructor(dst, addr, offset) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(addr, RegId2);
          var ptr1 = addr.__destroy_into_raw();
          _assertClass(offset, Imm12);
          var ptr2 = offset.__destroy_into_raw();
          const ret4 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          return LB.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret4 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret4);
        }
      };
      var LDC = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(LDC.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_ldc_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} contract_id_addr
        * @param {RegId} offset
        * @param {RegId} len
        */
        constructor(contract_id_addr, offset, len) {
          _assertClass(contract_id_addr, RegId2);
          var ptr0 = contract_id_addr.__destroy_into_raw();
          _assertClass(offset, RegId2);
          var ptr1 = offset.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr2 = len.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return LDC.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var LOG = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(LOG.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_log_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} a
        * @param {RegId} b
        * @param {RegId} c
        * @param {RegId} d
        */
        constructor(a, b, c, d) {
          _assertClass(a, RegId2);
          var ptr0 = a.__destroy_into_raw();
          _assertClass(b, RegId2);
          var ptr1 = b.__destroy_into_raw();
          _assertClass(c, RegId2);
          var ptr2 = c.__destroy_into_raw();
          _assertClass(d, RegId2);
          var ptr3 = d.__destroy_into_raw();
          const ret4 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          return LOG.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret4 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var LOGD = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(LOGD.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_logd_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} a
        * @param {RegId} b
        * @param {RegId} addr
        * @param {RegId} len
        */
        constructor(a, b, addr, len) {
          _assertClass(a, RegId2);
          var ptr0 = a.__destroy_into_raw();
          _assertClass(b, RegId2);
          var ptr1 = b.__destroy_into_raw();
          _assertClass(addr, RegId2);
          var ptr2 = addr.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr3 = len.__destroy_into_raw();
          const ret4 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          return LOGD.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret4 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var LT = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(LT.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_lt_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return LT.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var LW = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(LW.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_lw_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} addr
        * @param {Imm12} offset
        */
        constructor(dst, addr, offset) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(addr, RegId2);
          var ptr1 = addr.__destroy_into_raw();
          _assertClass(offset, Imm12);
          var ptr2 = offset.__destroy_into_raw();
          const ret4 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          return LW.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret4 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret4);
        }
      };
      var MCL = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(MCL.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mcl_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} len
        */
        constructor(dst_addr, len) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr1 = len.__destroy_into_raw();
          const ret4 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          return MCL.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var MCLI = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(MCLI.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mcli_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} addr
        * @param {Imm18} count
        */
        constructor(addr, count) {
          _assertClass(addr, RegId2);
          var ptr0 = addr.__destroy_into_raw();
          _assertClass(count, Imm18);
          var ptr1 = count.__destroy_into_raw();
          const ret4 = wasm$1.gm_new_typescript(ptr0, ptr1);
          return MCLI.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 18-bit immediate value.
        * @returns {Imm18}
        */
        imm18() {
          const ret4 = wasm$1.gm_imm18(this.__wbg_ptr);
          return Imm18.__wrap(ret4);
        }
      };
      var MCP = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(MCP.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mcp_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} src_addr
        * @param {RegId} len
        */
        constructor(dst_addr, src_addr, len) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(src_addr, RegId2);
          var ptr1 = src_addr.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr2 = len.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return MCP.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var MCPI = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(MCPI.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mcpi_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} src_addr
        * @param {Imm12} len
        */
        constructor(dst_addr, src_addr, len) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(src_addr, RegId2);
          var ptr1 = src_addr.__destroy_into_raw();
          _assertClass(len, Imm12);
          var ptr2 = len.__destroy_into_raw();
          const ret4 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          return MCPI.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret4 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret4);
        }
      };
      var MEQ = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(MEQ.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_meq_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} result
        * @param {RegId} lhs_addr
        * @param {RegId} rhs_addr
        * @param {RegId} len
        */
        constructor(result, lhs_addr, rhs_addr, len) {
          _assertClass(result, RegId2);
          var ptr0 = result.__destroy_into_raw();
          _assertClass(lhs_addr, RegId2);
          var ptr1 = lhs_addr.__destroy_into_raw();
          _assertClass(rhs_addr, RegId2);
          var ptr2 = rhs_addr.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr3 = len.__destroy_into_raw();
          const ret4 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          return MEQ.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret4 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var MINT = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(MINT.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mint_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} amount
        * @param {RegId} sub_id_addr
        */
        constructor(amount, sub_id_addr) {
          _assertClass(amount, RegId2);
          var ptr0 = amount.__destroy_into_raw();
          _assertClass(sub_id_addr, RegId2);
          var ptr1 = sub_id_addr.__destroy_into_raw();
          const ret4 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          return MINT.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var MLDV = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(MLDV.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mldv_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} mul_lhs
        * @param {RegId} mul_rhs
        * @param {RegId} divisor
        */
        constructor(dst, mul_lhs, mul_rhs, divisor) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(mul_lhs, RegId2);
          var ptr1 = mul_lhs.__destroy_into_raw();
          _assertClass(mul_rhs, RegId2);
          var ptr2 = mul_rhs.__destroy_into_raw();
          _assertClass(divisor, RegId2);
          var ptr3 = divisor.__destroy_into_raw();
          const ret4 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          return MLDV.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret4 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var MLOG = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(MLOG.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mlog_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return MLOG.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var MOD = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(MOD.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mod_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return MOD.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var MODI = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(MODI.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_modi_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          return MODI.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret4 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret4);
        }
      };
      var MOVE = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(MOVE.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_move_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} src
        */
        constructor(dst, src) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(src, RegId2);
          var ptr1 = src.__destroy_into_raw();
          const ret4 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          return MOVE.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var MOVI = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(MOVI.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_movi_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {Imm18} val
        */
        constructor(dst, val) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(val, Imm18);
          var ptr1 = val.__destroy_into_raw();
          const ret4 = wasm$1.gm_new_typescript(ptr0, ptr1);
          return MOVI.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 18-bit immediate value.
        * @returns {Imm18}
        */
        imm18() {
          const ret4 = wasm$1.gm_imm18(this.__wbg_ptr);
          return Imm18.__wrap(ret4);
        }
      };
      var MROO = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(MROO.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mroo_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return MROO.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var MUL = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(MUL.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mul_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return MUL.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var MULI = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(MULI.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_muli_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          return MULI.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret4 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret4);
        }
      };
      var MathArgs = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mathargs_free(ptr);
        }
        /**
        * The operation to perform
        * @returns {number}
        */
        get op() {
          const ret4 = wasm$1.__wbg_get_mathargs_op(this.__wbg_ptr);
          return ret4 >>> 0;
        }
        /**
        * The operation to perform
        * @param {number} arg0
        */
        set op(arg0) {
          wasm$1.__wbg_set_mathargs_op(this.__wbg_ptr, arg0);
        }
        /**
        * Load RHS from register if true, otherwise zero-extend register value
        * @returns {boolean}
        */
        get indirect_rhs() {
          const ret4 = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
          return ret4 !== 0;
        }
        /**
        * Load RHS from register if true, otherwise zero-extend register value
        * @param {boolean} arg0
        */
        set indirect_rhs(arg0) {
          wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
        }
      };
      var MulArgs = class {
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_mulargs_free(ptr);
        }
        /**
        * Load LHSS from register if true, otherwise zero-extend register value
        * @returns {boolean}
        */
        get indirect_lhs() {
          const ret4 = wasm$1.__wbg_get_divargs_indirect_rhs(this.__wbg_ptr);
          return ret4 !== 0;
        }
        /**
        * Load LHSS from register if true, otherwise zero-extend register value
        * @param {boolean} arg0
        */
        set indirect_lhs(arg0) {
          wasm$1.__wbg_set_divargs_indirect_rhs(this.__wbg_ptr, arg0);
        }
        /**
        * Load RHS from register if true, otherwise zero-extend register value
        * @returns {boolean}
        */
        get indirect_rhs() {
          const ret4 = wasm$1.__wbg_get_compareargs_indirect_rhs(this.__wbg_ptr);
          return ret4 !== 0;
        }
        /**
        * Load RHS from register if true, otherwise zero-extend register value
        * @param {boolean} arg0
        */
        set indirect_rhs(arg0) {
          wasm$1.__wbg_set_compareargs_indirect_rhs(this.__wbg_ptr, arg0);
        }
      };
      var NOOP = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(NOOP.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_noop_free(ptr);
        }
        /**
        * Construct the instruction.
        */
        constructor() {
          const ret4 = wasm$1.noop_new_typescript();
          return NOOP.__wrap(ret4);
        }
      };
      var NOT = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(NOT.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_not_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} arg
        */
        constructor(dst, arg) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(arg, RegId2);
          var ptr1 = arg.__destroy_into_raw();
          const ret4 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          return NOT.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var OR = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(OR.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_or_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return OR.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var ORI = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(ORI.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_ori_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          return ORI.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret4 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret4);
        }
      };
      var POPH = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(POPH.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_poph_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {Imm24} bitmask
        */
        constructor(bitmask) {
          _assertClass(bitmask, Imm24);
          var ptr0 = bitmask.__destroy_into_raw();
          const ret4 = wasm$1.cfei_new_typescript(ptr0);
          return POPH.__wrap(ret4);
        }
        /**
        * Access the 24-bit immediate value.
        * @returns {Imm24}
        */
        imm24() {
          const ret4 = wasm$1.cfei_imm24(this.__wbg_ptr);
          return Imm24.__wrap(ret4);
        }
      };
      var POPL = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(POPL.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_popl_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {Imm24} bitmask
        */
        constructor(bitmask) {
          _assertClass(bitmask, Imm24);
          var ptr0 = bitmask.__destroy_into_raw();
          const ret4 = wasm$1.cfei_new_typescript(ptr0);
          return POPL.__wrap(ret4);
        }
        /**
        * Access the 24-bit immediate value.
        * @returns {Imm24}
        */
        imm24() {
          const ret4 = wasm$1.cfei_imm24(this.__wbg_ptr);
          return Imm24.__wrap(ret4);
        }
      };
      var PSHH = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(PSHH.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_pshh_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {Imm24} bitmask
        */
        constructor(bitmask) {
          _assertClass(bitmask, Imm24);
          var ptr0 = bitmask.__destroy_into_raw();
          const ret4 = wasm$1.cfei_new_typescript(ptr0);
          return PSHH.__wrap(ret4);
        }
        /**
        * Access the 24-bit immediate value.
        * @returns {Imm24}
        */
        imm24() {
          const ret4 = wasm$1.cfei_imm24(this.__wbg_ptr);
          return Imm24.__wrap(ret4);
        }
      };
      var PSHL = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(PSHL.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_pshl_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {Imm24} bitmask
        */
        constructor(bitmask) {
          _assertClass(bitmask, Imm24);
          var ptr0 = bitmask.__destroy_into_raw();
          const ret4 = wasm$1.cfei_new_typescript(ptr0);
          return PSHL.__wrap(ret4);
        }
        /**
        * Access the 24-bit immediate value.
        * @returns {Imm24}
        */
        imm24() {
          const ret4 = wasm$1.cfei_imm24(this.__wbg_ptr);
          return Imm24.__wrap(ret4);
        }
      };
      var PanicInstruction = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(PanicInstruction.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_panicinstruction_free(ptr);
        }
        /**
        * Represents an error described by a reason and an instruction.
        * @param {number} reason
        * @param {number} instruction
        */
        constructor(reason, instruction) {
          const ret4 = wasm$1.panicinstruction_error_typescript(reason, instruction);
          return PanicInstruction.__wrap(ret4);
        }
        /**
        * Underlying panic reason
        * @returns {number}
        */
        reason() {
          const ret4 = wasm$1.panicinstruction_reason(this.__wbg_ptr);
          return ret4 >>> 0;
        }
        /**
        * Underlying instruction
        * @returns {number}
        */
        instruction() {
          const ret4 = wasm$1.panicinstruction_instruction(this.__wbg_ptr);
          return ret4 >>> 0;
        }
      };
      var RET = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(RET.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_ret_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} value
        */
        constructor(value) {
          _assertClass(value, RegId2);
          var ptr0 = value.__destroy_into_raw();
          const ret4 = wasm$1.aloc_new_typescript(ptr0);
          return RET.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var RETD = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(RETD.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_retd_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} addr
        * @param {RegId} len
        */
        constructor(addr, len) {
          _assertClass(addr, RegId2);
          var ptr0 = addr.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr1 = len.__destroy_into_raw();
          const ret4 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          return RETD.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var RVRT = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(RVRT.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_rvrt_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} value
        */
        constructor(value) {
          _assertClass(value, RegId2);
          var ptr0 = value.__destroy_into_raw();
          const ret4 = wasm$1.aloc_new_typescript(ptr0);
          return RVRT.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var RegId2 = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(RegId2.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_regid_free(ptr);
        }
        /**
        * Construct a register ID from the given value.
        *
        * Returns `None` if the value is outside the 6-bit value range.
        * @param {number} u
        * @returns {RegId | undefined}
        */
        static new_checked(u) {
          const ret4 = wasm$1.regid_new_checked(u);
          return ret4 === 0 ? void 0 : RegId2.__wrap(ret4);
        }
        /**
        * Received balance for this context.
        * @returns {RegId}
        */
        static bal() {
          const ret4 = wasm$1.regid_bal();
          return RegId2.__wrap(ret4);
        }
        /**
        * Remaining gas in the context.
        * @returns {RegId}
        */
        static cgas() {
          const ret4 = wasm$1.regid_cgas();
          return RegId2.__wrap(ret4);
        }
        /**
        * Error codes for particular operations.
        * @returns {RegId}
        */
        static err() {
          const ret4 = wasm$1.regid_err();
          return RegId2.__wrap(ret4);
        }
        /**
        * Flags register.
        * @returns {RegId}
        */
        static flag() {
          const ret4 = wasm$1.regid_flag();
          return RegId2.__wrap(ret4);
        }
        /**
        * Frame pointer. Memory address of beginning of current call frame.
        * @returns {RegId}
        */
        static fp() {
          const ret4 = wasm$1.regid_fp();
          return RegId2.__wrap(ret4);
        }
        /**
        * Remaining gas globally.
        * @returns {RegId}
        */
        static ggas() {
          const ret4 = wasm$1.regid_ggas();
          return RegId2.__wrap(ret4);
        }
        /**
        * Heap pointer. Memory address below the current bottom of the heap (points to free
        * memory).
        * @returns {RegId}
        */
        static hp() {
          const ret4 = wasm$1.regid_hp();
          return RegId2.__wrap(ret4);
        }
        /**
        * Instructions start. Pointer to the start of the currently-executing code.
        * @returns {RegId}
        */
        static is() {
          const ret4 = wasm$1.regid_is();
          return RegId2.__wrap(ret4);
        }
        /**
        * Contains overflow/underflow of addition, subtraction, and multiplication.
        * @returns {RegId}
        */
        static of() {
          const ret4 = wasm$1.regid_of();
          return RegId2.__wrap(ret4);
        }
        /**
        * Contains one (1), for convenience.
        * @returns {RegId}
        */
        static one() {
          const ret4 = wasm$1.regid_one();
          return RegId2.__wrap(ret4);
        }
        /**
        * The program counter. Memory address of the current instruction.
        * @returns {RegId}
        */
        static pc() {
          const ret4 = wasm$1.regid_pc();
          return RegId2.__wrap(ret4);
        }
        /**
        * Return value or pointer.
        * @returns {RegId}
        */
        static ret() {
          const ret4 = wasm$1.regid_ret();
          return RegId2.__wrap(ret4);
        }
        /**
        * Return value length in bytes.
        * @returns {RegId}
        */
        static retl() {
          const ret4 = wasm$1.regid_retl();
          return RegId2.__wrap(ret4);
        }
        /**
        * Stack pointer. Memory address on top of current writable stack area (points to
        * free memory).
        * @returns {RegId}
        */
        static sp() {
          const ret4 = wasm$1.regid_sp();
          return RegId2.__wrap(ret4);
        }
        /**
        * Stack start pointer. Memory address of bottom of current writable stack area.
        * @returns {RegId}
        */
        static spp() {
          const ret4 = wasm$1.regid_spp();
          return RegId2.__wrap(ret4);
        }
        /**
        * Smallest writable register.
        * @returns {RegId}
        */
        static writable() {
          const ret4 = wasm$1.regid_writable();
          return RegId2.__wrap(ret4);
        }
        /**
        * Contains zero (0), for convenience.
        * @returns {RegId}
        */
        static zero() {
          const ret4 = wasm$1.regid_zero();
          return RegId2.__wrap(ret4);
        }
        /**
        * Construct a register ID from the given value.
        *
        * The given value will be masked to 6 bits.
        * @param {number} u
        */
        constructor(u) {
          const ret4 = wasm$1.regid_new_typescript(u);
          return RegId2.__wrap(ret4);
        }
        /**
        * A const alternative to the `Into<u8>` implementation.
        * @returns {number}
        */
        to_u8() {
          const ptr = this.__destroy_into_raw();
          const ret4 = wasm$1.regid_to_u8(ptr);
          return ret4;
        }
      };
      var S256 = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(S256.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_s256_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} src_addr
        * @param {RegId} len
        */
        constructor(dst_addr, src_addr, len) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(src_addr, RegId2);
          var ptr1 = src_addr.__destroy_into_raw();
          _assertClass(len, RegId2);
          var ptr2 = len.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return S256.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var SB = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(SB.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_sb_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} addr
        * @param {RegId} value
        * @param {Imm12} offset
        */
        constructor(addr, value, offset) {
          _assertClass(addr, RegId2);
          var ptr0 = addr.__destroy_into_raw();
          _assertClass(value, RegId2);
          var ptr1 = value.__destroy_into_raw();
          _assertClass(offset, Imm12);
          var ptr2 = offset.__destroy_into_raw();
          const ret4 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          return SB.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret4 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret4);
        }
      };
      var SCWQ = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(SCWQ.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_scwq_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} key_addr
        * @param {RegId} status
        * @param {RegId} lenq
        */
        constructor(key_addr, status, lenq) {
          _assertClass(key_addr, RegId2);
          var ptr0 = key_addr.__destroy_into_raw();
          _assertClass(status, RegId2);
          var ptr1 = status.__destroy_into_raw();
          _assertClass(lenq, RegId2);
          var ptr2 = lenq.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return SCWQ.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var SLL = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(SLL.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_sll_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return SLL.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var SLLI = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(SLLI.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_slli_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          return SLLI.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret4 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret4);
        }
      };
      var SMO = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(SMO.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_smo_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} recipient_addr
        * @param {RegId} data_addr
        * @param {RegId} data_len
        * @param {RegId} coins
        */
        constructor(recipient_addr, data_addr, data_len, coins) {
          _assertClass(recipient_addr, RegId2);
          var ptr0 = recipient_addr.__destroy_into_raw();
          _assertClass(data_addr, RegId2);
          var ptr1 = data_addr.__destroy_into_raw();
          _assertClass(data_len, RegId2);
          var ptr2 = data_len.__destroy_into_raw();
          _assertClass(coins, RegId2);
          var ptr3 = coins.__destroy_into_raw();
          const ret4 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          return SMO.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret4 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var SRL = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(SRL.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_srl_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return SRL.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var SRLI = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(SRLI.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_srli_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          return SRLI.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret4 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret4);
        }
      };
      var SRW = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(SRW.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_srw_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} status
        * @param {RegId} key_addr
        */
        constructor(dst, status, key_addr) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(status, RegId2);
          var ptr1 = status.__destroy_into_raw();
          _assertClass(key_addr, RegId2);
          var ptr2 = key_addr.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return SRW.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var SRWQ = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(SRWQ.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_srwq_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst_addr
        * @param {RegId} status
        * @param {RegId} key_addr
        * @param {RegId} lenq
        */
        constructor(dst_addr, status, key_addr, lenq) {
          _assertClass(dst_addr, RegId2);
          var ptr0 = dst_addr.__destroy_into_raw();
          _assertClass(status, RegId2);
          var ptr1 = status.__destroy_into_raw();
          _assertClass(key_addr, RegId2);
          var ptr2 = key_addr.__destroy_into_raw();
          _assertClass(lenq, RegId2);
          var ptr3 = lenq.__destroy_into_raw();
          const ret4 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          return SRWQ.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret4 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var SUB = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(SUB.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_sub_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return SUB.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var SUBI = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(SUBI.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_subi_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          return SUBI.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret4 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret4);
        }
      };
      var SW = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(SW.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_sw_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} addr
        * @param {RegId} value
        * @param {Imm12} offset
        */
        constructor(addr, value, offset) {
          _assertClass(addr, RegId2);
          var ptr0 = addr.__destroy_into_raw();
          _assertClass(value, RegId2);
          var ptr1 = value.__destroy_into_raw();
          _assertClass(offset, Imm12);
          var ptr2 = offset.__destroy_into_raw();
          const ret4 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          return SW.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret4 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret4);
        }
      };
      var SWW = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(SWW.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_sww_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} key_addr
        * @param {RegId} status
        * @param {RegId} value
        */
        constructor(key_addr, status, value) {
          _assertClass(key_addr, RegId2);
          var ptr0 = key_addr.__destroy_into_raw();
          _assertClass(status, RegId2);
          var ptr1 = status.__destroy_into_raw();
          _assertClass(value, RegId2);
          var ptr2 = value.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return SWW.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var SWWQ = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(SWWQ.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_swwq_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} key_addr
        * @param {RegId} status
        * @param {RegId} src_addr
        * @param {RegId} lenq
        */
        constructor(key_addr, status, src_addr, lenq) {
          _assertClass(key_addr, RegId2);
          var ptr0 = key_addr.__destroy_into_raw();
          _assertClass(status, RegId2);
          var ptr1 = status.__destroy_into_raw();
          _assertClass(src_addr, RegId2);
          var ptr2 = src_addr.__destroy_into_raw();
          _assertClass(lenq, RegId2);
          var ptr3 = lenq.__destroy_into_raw();
          const ret4 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          return SWWQ.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret4 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var TIME = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(TIME.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_time_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} heigth
        */
        constructor(dst, heigth) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(heigth, RegId2);
          var ptr1 = heigth.__destroy_into_raw();
          const ret4 = wasm$1.bhsh_new_typescript(ptr0, ptr1);
          return TIME.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var TR = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(TR.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_tr_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} contract_id_addr
        * @param {RegId} amount
        * @param {RegId} asset_id_addr
        */
        constructor(contract_id_addr, amount, asset_id_addr) {
          _assertClass(contract_id_addr, RegId2);
          var ptr0 = contract_id_addr.__destroy_into_raw();
          _assertClass(amount, RegId2);
          var ptr1 = amount.__destroy_into_raw();
          _assertClass(asset_id_addr, RegId2);
          var ptr2 = asset_id_addr.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return TR.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var TRO = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(TRO.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_tro_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} contract_id_addr
        * @param {RegId} output_index
        * @param {RegId} amount
        * @param {RegId} asset_id_addr
        */
        constructor(contract_id_addr, output_index, amount, asset_id_addr) {
          _assertClass(contract_id_addr, RegId2);
          var ptr0 = contract_id_addr.__destroy_into_raw();
          _assertClass(output_index, RegId2);
          var ptr1 = output_index.__destroy_into_raw();
          _assertClass(amount, RegId2);
          var ptr2 = amount.__destroy_into_raw();
          _assertClass(asset_id_addr, RegId2);
          var ptr3 = asset_id_addr.__destroy_into_raw();
          const ret4 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          return TRO.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret4 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var WDAM = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WDAM.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wdam_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} add_lhs
        * @param {RegId} add_rhs
        * @param {RegId} modulo
        */
        constructor(dst, add_lhs, add_rhs, modulo) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(add_lhs, RegId2);
          var ptr1 = add_lhs.__destroy_into_raw();
          _assertClass(add_rhs, RegId2);
          var ptr2 = add_rhs.__destroy_into_raw();
          _assertClass(modulo, RegId2);
          var ptr3 = modulo.__destroy_into_raw();
          const ret4 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          return WDAM.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret4 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var WDCM = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WDCM.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wdcm_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        * @param {Imm06} flags
        */
        constructor(dst, lhs, rhs, flags) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          _assertClass(flags, Imm06);
          var ptr3 = flags.__destroy_into_raw();
          const ret4 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          return WDCM.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret4 = wasm$1.call_rd(this.__wbg_ptr);
          return Imm06.__wrap(ret4);
        }
        /**
        * Construct a `WDCM` instruction from its arguments.
        * @param {RegId} ra
        * @param {RegId} rb
        * @param {RegId} rc
        * @param {CompareArgs} args
        * @returns {WDCM}
        */
        static from_args(ra, rb, rc, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          _assertClass(rb, RegId2);
          var ptr1 = rb.__destroy_into_raw();
          _assertClass(rc, RegId2);
          var ptr2 = rc.__destroy_into_raw();
          _assertClass(args, CompareArgs);
          var ptr3 = args.__destroy_into_raw();
          const ret4 = wasm$1.wdcm_from_args(ptr0, ptr1, ptr2, ptr3);
          return WDCM.__wrap(ret4);
        }
      };
      var WDDV = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WDDV.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wddv_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        * @param {Imm06} flags
        */
        constructor(dst, lhs, rhs, flags) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          _assertClass(flags, Imm06);
          var ptr3 = flags.__destroy_into_raw();
          const ret4 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          return WDDV.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret4 = wasm$1.call_rd(this.__wbg_ptr);
          return Imm06.__wrap(ret4);
        }
        /**
        * Construct a `WDDV` instruction from its arguments.
        * @param {RegId} ra
        * @param {RegId} rb
        * @param {RegId} rc
        * @param {DivArgs} args
        * @returns {WDDV}
        */
        static from_args(ra, rb, rc, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          _assertClass(rb, RegId2);
          var ptr1 = rb.__destroy_into_raw();
          _assertClass(rc, RegId2);
          var ptr2 = rc.__destroy_into_raw();
          _assertClass(args, DivArgs);
          var ptr3 = args.__destroy_into_raw();
          const ret4 = wasm$1.wddv_from_args(ptr0, ptr1, ptr2, ptr3);
          return WDDV.__wrap(ret4);
        }
      };
      var WDMD = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WDMD.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wdmd_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} mul_lhs
        * @param {RegId} mul_rhs
        * @param {RegId} divisor
        */
        constructor(dst, mul_lhs, mul_rhs, divisor) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(mul_lhs, RegId2);
          var ptr1 = mul_lhs.__destroy_into_raw();
          _assertClass(mul_rhs, RegId2);
          var ptr2 = mul_rhs.__destroy_into_raw();
          _assertClass(divisor, RegId2);
          var ptr3 = divisor.__destroy_into_raw();
          const ret4 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          return WDMD.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret4 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var WDML = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WDML.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wdml_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        * @param {Imm06} flags
        */
        constructor(dst, lhs, rhs, flags) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          _assertClass(flags, Imm06);
          var ptr3 = flags.__destroy_into_raw();
          const ret4 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          return WDML.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret4 = wasm$1.call_rd(this.__wbg_ptr);
          return Imm06.__wrap(ret4);
        }
        /**
        * Construct a `WDML` instruction from its arguments.
        * @param {RegId} ra
        * @param {RegId} rb
        * @param {RegId} rc
        * @param {MulArgs} args
        * @returns {WDML}
        */
        static from_args(ra, rb, rc, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          _assertClass(rb, RegId2);
          var ptr1 = rb.__destroy_into_raw();
          _assertClass(rc, RegId2);
          var ptr2 = rc.__destroy_into_raw();
          _assertClass(args, MulArgs);
          var ptr3 = args.__destroy_into_raw();
          const ret4 = wasm$1.wdml_from_args(ptr0, ptr1, ptr2, ptr3);
          return WDML.__wrap(ret4);
        }
      };
      var WDMM = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WDMM.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wdmm_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} mul_lhs
        * @param {RegId} mul_rhs
        * @param {RegId} modulo
        */
        constructor(dst, mul_lhs, mul_rhs, modulo) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(mul_lhs, RegId2);
          var ptr1 = mul_lhs.__destroy_into_raw();
          _assertClass(mul_rhs, RegId2);
          var ptr2 = mul_rhs.__destroy_into_raw();
          _assertClass(modulo, RegId2);
          var ptr3 = modulo.__destroy_into_raw();
          const ret4 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          return WDMM.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret4 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var WDOP = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WDOP.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wdop_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        * @param {Imm06} flags
        */
        constructor(dst, lhs, rhs, flags) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          _assertClass(flags, Imm06);
          var ptr3 = flags.__destroy_into_raw();
          const ret4 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          return WDOP.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret4 = wasm$1.call_rd(this.__wbg_ptr);
          return Imm06.__wrap(ret4);
        }
        /**
        * Construct a `WDOP` instruction from its arguments.
        * @param {RegId} ra
        * @param {RegId} rb
        * @param {RegId} rc
        * @param {MathArgs} args
        * @returns {WDOP}
        */
        static from_args(ra, rb, rc, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          _assertClass(rb, RegId2);
          var ptr1 = rb.__destroy_into_raw();
          _assertClass(rc, RegId2);
          var ptr2 = rc.__destroy_into_raw();
          _assertClass(args, MathArgs);
          var ptr3 = args.__destroy_into_raw();
          const ret4 = wasm$1.wdop_from_args(ptr0, ptr1, ptr2, ptr3);
          return WDOP.__wrap(ret4);
        }
      };
      var WQAM = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WQAM.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wqam_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} add_lhs
        * @param {RegId} add_rhs
        * @param {RegId} modulo
        */
        constructor(dst, add_lhs, add_rhs, modulo) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(add_lhs, RegId2);
          var ptr1 = add_lhs.__destroy_into_raw();
          _assertClass(add_rhs, RegId2);
          var ptr2 = add_rhs.__destroy_into_raw();
          _assertClass(modulo, RegId2);
          var ptr3 = modulo.__destroy_into_raw();
          const ret4 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          return WQAM.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret4 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var WQCM = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WQCM.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wqcm_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        * @param {Imm06} flags
        */
        constructor(dst, lhs, rhs, flags) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          _assertClass(flags, Imm06);
          var ptr3 = flags.__destroy_into_raw();
          const ret4 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          return WQCM.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret4 = wasm$1.call_rd(this.__wbg_ptr);
          return Imm06.__wrap(ret4);
        }
        /**
        * Construct a `WQCM` instruction from its arguments.
        * @param {RegId} ra
        * @param {RegId} rb
        * @param {RegId} rc
        * @param {CompareArgs} args
        * @returns {WQCM}
        */
        static from_args(ra, rb, rc, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          _assertClass(rb, RegId2);
          var ptr1 = rb.__destroy_into_raw();
          _assertClass(rc, RegId2);
          var ptr2 = rc.__destroy_into_raw();
          _assertClass(args, CompareArgs);
          var ptr3 = args.__destroy_into_raw();
          const ret4 = wasm$1.wdcm_from_args(ptr0, ptr1, ptr2, ptr3);
          return WQCM.__wrap(ret4);
        }
      };
      var WQDV = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WQDV.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wqdv_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        * @param {Imm06} flags
        */
        constructor(dst, lhs, rhs, flags) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          _assertClass(flags, Imm06);
          var ptr3 = flags.__destroy_into_raw();
          const ret4 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          return WQDV.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret4 = wasm$1.call_rd(this.__wbg_ptr);
          return Imm06.__wrap(ret4);
        }
        /**
        * Construct a `WQDV` instruction from its arguments.
        * @param {RegId} ra
        * @param {RegId} rb
        * @param {RegId} rc
        * @param {DivArgs} args
        * @returns {WQDV}
        */
        static from_args(ra, rb, rc, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          _assertClass(rb, RegId2);
          var ptr1 = rb.__destroy_into_raw();
          _assertClass(rc, RegId2);
          var ptr2 = rc.__destroy_into_raw();
          _assertClass(args, DivArgs);
          var ptr3 = args.__destroy_into_raw();
          const ret4 = wasm$1.wddv_from_args(ptr0, ptr1, ptr2, ptr3);
          return WQDV.__wrap(ret4);
        }
      };
      var WQMD = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WQMD.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wqmd_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} mul_lhs
        * @param {RegId} mul_rhs
        * @param {RegId} divisor
        */
        constructor(dst, mul_lhs, mul_rhs, divisor) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(mul_lhs, RegId2);
          var ptr1 = mul_lhs.__destroy_into_raw();
          _assertClass(mul_rhs, RegId2);
          var ptr2 = mul_rhs.__destroy_into_raw();
          _assertClass(divisor, RegId2);
          var ptr3 = divisor.__destroy_into_raw();
          const ret4 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          return WQMD.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret4 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var WQML = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WQML.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wqml_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        * @param {Imm06} flags
        */
        constructor(dst, lhs, rhs, flags) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          _assertClass(flags, Imm06);
          var ptr3 = flags.__destroy_into_raw();
          const ret4 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          return WQML.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret4 = wasm$1.call_rd(this.__wbg_ptr);
          return Imm06.__wrap(ret4);
        }
        /**
        * Construct a `WQML` instruction from its arguments.
        * @param {RegId} ra
        * @param {RegId} rb
        * @param {RegId} rc
        * @param {MulArgs} args
        * @returns {WQML}
        */
        static from_args(ra, rb, rc, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          _assertClass(rb, RegId2);
          var ptr1 = rb.__destroy_into_raw();
          _assertClass(rc, RegId2);
          var ptr2 = rc.__destroy_into_raw();
          _assertClass(args, MulArgs);
          var ptr3 = args.__destroy_into_raw();
          const ret4 = wasm$1.wdml_from_args(ptr0, ptr1, ptr2, ptr3);
          return WQML.__wrap(ret4);
        }
      };
      var WQMM = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WQMM.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wqmm_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} mul_lhs
        * @param {RegId} mul_rhs
        * @param {RegId} modulo
        */
        constructor(dst, mul_lhs, mul_rhs, modulo) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(mul_lhs, RegId2);
          var ptr1 = mul_lhs.__destroy_into_raw();
          _assertClass(mul_rhs, RegId2);
          var ptr2 = mul_rhs.__destroy_into_raw();
          _assertClass(modulo, RegId2);
          var ptr3 = modulo.__destroy_into_raw();
          const ret4 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          return WQMM.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register D.
        * @returns {RegId}
        */
        rd() {
          const ret4 = wasm$1.call_rd(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var WQOP = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(WQOP.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_wqop_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        * @param {Imm06} flags
        */
        constructor(dst, lhs, rhs, flags) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          _assertClass(flags, Imm06);
          var ptr3 = flags.__destroy_into_raw();
          const ret4 = wasm$1.call_new_typescript(ptr0, ptr1, ptr2, ptr3);
          return WQOP.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 6-bit immediate value.
        * @returns {Imm06}
        */
        imm06() {
          const ret4 = wasm$1.call_rd(this.__wbg_ptr);
          return Imm06.__wrap(ret4);
        }
        /**
        * Construct a `WQOP` instruction from its arguments.
        * @param {RegId} ra
        * @param {RegId} rb
        * @param {RegId} rc
        * @param {MathArgs} args
        * @returns {WQOP}
        */
        static from_args(ra, rb, rc, args) {
          _assertClass(ra, RegId2);
          var ptr0 = ra.__destroy_into_raw();
          _assertClass(rb, RegId2);
          var ptr1 = rb.__destroy_into_raw();
          _assertClass(rc, RegId2);
          var ptr2 = rc.__destroy_into_raw();
          _assertClass(args, MathArgs);
          var ptr3 = args.__destroy_into_raw();
          const ret4 = wasm$1.wdop_from_args(ptr0, ptr1, ptr2, ptr3);
          return WQOP.__wrap(ret4);
        }
      };
      var XOR = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(XOR.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_xor_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {RegId} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, RegId2);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.add_new_typescript(ptr0, ptr1, ptr2);
          return XOR.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register C.
        * @returns {RegId}
        */
        rc() {
          const ret4 = wasm$1.add_rc(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
      };
      var XORI = class {
        static __wrap(ptr) {
          ptr = ptr >>> 0;
          const obj = Object.create(XORI.prototype);
          obj.__wbg_ptr = ptr;
          return obj;
        }
        __destroy_into_raw() {
          const ptr = this.__wbg_ptr;
          this.__wbg_ptr = 0;
          return ptr;
        }
        free() {
          const ptr = this.__destroy_into_raw();
          wasm$1.__wbg_xori_free(ptr);
        }
        /**
        * Construct the instruction from its parts.
        * @param {RegId} dst
        * @param {RegId} lhs
        * @param {Imm12} rhs
        */
        constructor(dst, lhs, rhs) {
          _assertClass(dst, RegId2);
          var ptr0 = dst.__destroy_into_raw();
          _assertClass(lhs, RegId2);
          var ptr1 = lhs.__destroy_into_raw();
          _assertClass(rhs, Imm12);
          var ptr2 = rhs.__destroy_into_raw();
          const ret4 = wasm$1.addi_new_typescript(ptr0, ptr1, ptr2);
          return XORI.__wrap(ret4);
        }
        /**
        * Access the ID for register A.
        * @returns {RegId}
        */
        ra() {
          const ret4 = wasm$1.add_ra(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the ID for register B.
        * @returns {RegId}
        */
        rb() {
          const ret4 = wasm$1.add_rb(this.__wbg_ptr);
          return RegId2.__wrap(ret4);
        }
        /**
        * Access the 12-bit immediate value.
        * @returns {Imm12}
        */
        imm12() {
          const ret4 = wasm$1.addi_imm12(this.__wbg_ptr);
          return Imm12.__wrap(ret4);
        }
      };
      async function __wbg_load(module3, imports) {
        if (typeof Response === "function" && module3 instanceof Response) {
          if (typeof WebAssembly.instantiateStreaming === "function") {
            try {
              return await WebAssembly.instantiateStreaming(module3, imports);
            } catch (e) {
              if (module3.headers.get("Content-Type") != "application/wasm") {
                console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
              } else {
                throw e;
              }
            }
          }
          const bytes3 = await module3.arrayBuffer();
          return await WebAssembly.instantiate(bytes3, imports);
        } else {
          const instance = await WebAssembly.instantiate(module3, imports);
          if (instance instanceof WebAssembly.Instance) {
            return { instance, module: module3 };
          } else {
            return instance;
          }
        }
      }
      function __wbg_get_imports() {
        const imports = {};
        imports.wbg = {};
        imports.wbg.__wbindgen_throw = function(arg0, arg1) {
          throw new Error(getStringFromWasm0(arg0, arg1));
        };
        return imports;
      }
      function __wbg_finalize_init(instance, module3) {
        wasm$1 = instance.exports;
        __wbg_init.__wbindgen_wasm_module = module3;
        cachedInt32Memory0 = null;
        cachedUint8Memory0 = null;
        return wasm$1;
      }
      function initSync(module3) {
        if (wasm$1 !== void 0)
          return wasm$1;
        const imports = __wbg_get_imports();
        if (!(module3 instanceof WebAssembly.Module)) {
          module3 = new WebAssembly.Module(module3);
        }
        const instance = new WebAssembly.Instance(module3, imports);
        return __wbg_finalize_init(instance, module3);
      }
      async function __wbg_init(input) {
        if (wasm$1 !== void 0)
          return wasm$1;
        const imports = __wbg_get_imports();
        const { instance, module: module3 } = await __wbg_load(await input, imports);
        return __wbg_finalize_init(instance, module3);
      }
      function _loadWasmModule(sync2, filepath, src, imports) {
        function _instantiateOrCompile(source, imports2, stream2) {
          var instantiateFunc = stream2 ? WebAssembly.instantiateStreaming : WebAssembly.instantiate;
          var compileFunc = stream2 ? WebAssembly.compileStreaming : WebAssembly.compile;
          if (imports2) {
            return instantiateFunc(source, imports2);
          } else {
            return compileFunc(source);
          }
        }
        var buf = null;
        var isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
        if (isNode) {
          buf = Buffer.from(src, "base64");
        } else {
          var raw = globalThis.atob(src);
          var rawLength = raw.length;
          buf = new Uint8Array(new ArrayBuffer(rawLength));
          for (var i = 0; i < rawLength; i++) {
            buf[i] = raw.charCodeAt(i);
          }
        }
        if (sync2) {
          var mod = new WebAssembly.Module(buf);
          return imports ? new WebAssembly.Instance(mod, imports) : mod;
        } else {
          return _instantiateOrCompile(buf, imports, false);
        }
      }
      function wasm(imports) {
        return _loadWasmModule(1, null, "AGFzbQEAAAABVA5gA39/fwF/YAF/AX9gAn9/AX9gBH9/f38Bf2ACf38AYAABf2ABfwBgBX9/f39/AX9gA39/fwBgAABgAX8BfmACfn8Bf2AFf39/f38AYAR/f39/AAIYAQN3YmcQX193YmluZGdlbl90aHJvdwAEA4AC/gEBBgIEAQIDAwMDAwMDAwMDAgsAAAAAAAAAAAAAAAAAAAAAAAAAAAYEAwMDAwMDBQMDAgICAgICAwMDAwMDAwMDAwMDAwMDAwMDBAMDAQEBAQEBAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAwAAg0CAgQCAgICAgICAgICAQIBAQEBAQEEBAEBAQEBAQEBAQEBAQIBBgUAAgkBBAQEAwQGBAEEAQEBBAYFBQUFBQUFBQUFBQUFBQUFBQEBBggFBAYBAQQCCAECBAECAQEEAQICAgIJAQQJCQEBAQEEAAICAQEFCgoKBgIIAgMDAgcABwABAgcHBwQFAXABFhYFAwEAEQYJAX8BQYCAwAALB5JNugUGbWVtb3J5AgAOX193YmdfYWRkX2ZyZWUAsQESYWRkX25ld190eXBlc2NyaXB0AHEGYWRkX3JhAJEBBmFkZF9yYgCLAQZhZGRfcmMAjAEDYWRkAHADYW5kAFQDZGl2AFUCZXEAVgNleHAAVwJndABYAmx0AFkEbWxvZwBaBG1yb28AWwRtb2RfAFwFbW92ZV8AfANtdWwAXQNub3QAfQJvcgBeA3NsbABfA3NybABgA3N1YgBhA3hvcgBiBG1sZHYAOgNyZXQAkgEEcmV0ZAB+E2Fsb2NfbmV3X3R5cGVzY3JpcHQAnQEEYWxvYwCTAQNtY2wAfwNtY3AAYwNtZXEAOxNiaHNoX25ld190eXBlc2NyaXB0AIcBBGJoc2gAgAEEYmhlaQCUAQRidXJuAIEBE2NhbGxfbmV3X3R5cGVzY3JpcHQATAdjYWxsX3JkAJUBBGNhbGwAPANjY3AAPQRjcm9vAIIBBGNzaXoAgwECY2IAlgEDbGRjAGQDbG9nAD4EbG9nZAA/BG1pbnQAhAEEcnZydACXAQRzY3dxAGUDc3J3AGYEc3J3cQBAA3N3dwBnBHN3d3EAQQJ0cgBoA3RybwBCBGVjazEAaQRlY3IxAGoEZWQxOQBrBGsyNTYAbARzMjU2AG0EdGltZQCFARNub29wX25ld190eXBlc2NyaXB0AMcBBG5vb3AAnwEEZmxhZwCYAQNiYWwAbgNqbXAAmQEDam5lAG8Dc21vAEMTYWRkaV9uZXdfdHlwZXNjcmlwdABzCmFkZGlfaW1tMTIAjQEEYWRkaQATBGFuZGkAFARkaXZpABUEZXhwaQAWBG1vZGkAFwRtdWxpABgDb3JpABkEc2xsaQAaBHNybGkAGwRzdWJpABwEeG9yaQAdBGpuZWkAHgJsYgAfAmx3ACACc2IAIQJzdwAiBG1jcGkAIwNndGYAJARtY2xpADIRZ21fbmV3X3R5cGVzY3JpcHQAeQhnbV9pbW0xOACJAQJnbQAzBG1vdmkANARqbnppADUEam1wZgA2BGptcGIANwRqbnpmACUEam56YgAmBGpuZWYABwRqbmViAAgCamkATRNjZmVpX25ld190eXBlc2NyaXB0AIgBCmNmZWlfaW1tMjQAigEEY2ZlaQBOBGNmc2kATwNjZmUAmgEDY2ZzAJsBBHBzaGwAUARwc2hoAFEEcG9wbABSBHBvcGgAUwR3ZGNtAAkEd3FjbQAKBHdkb3AACwR3cW9wAAwEd2RtbAANBHdxbWwADgR3ZGR2AA8Ed3FkdgAQBHdkbWQARAR3cW1kAEUEd2RhbQBGBHdxYW0ARwR3ZG1tAEgEd3FtbQBJCm1jbGlfaW1tMTgAiQEKbW92aV9pbW0xOACJAQpqbnppX2ltbTE4AIkBCmptcGZfaW1tMTgAiQEKam1wYl9pbW0xOACJAQhqaV9pbW0yNACKAQpjZnNpX2ltbTI0AIoBCnBzaGxfaW1tMjQAigEKcHNoaF9pbW0yNACKAQpwb3BsX2ltbTI0AIoBCnBvcGhfaW1tMjQAigETbWNsaV9uZXdfdHlwZXNjcmlwdAB5E21vdmlfbmV3X3R5cGVzY3JpcHQAeRNqbnppX25ld190eXBlc2NyaXB0AHkTam1wZl9uZXdfdHlwZXNjcmlwdAB5E2ptcGJfbmV3X3R5cGVzY3JpcHQAeRJub3RfbmV3X3R5cGVzY3JpcHQAhwETcmV0ZF9uZXdfdHlwZXNjcmlwdACHARNtb3ZlX25ld190eXBlc2NyaXB0AIcBEm1jbF9uZXdfdHlwZXNjcmlwdACHARNidXJuX25ld190eXBlc2NyaXB0AIcBE2Nyb29fbmV3X3R5cGVzY3JpcHQAhwETY3Npel9uZXdfdHlwZXNjcmlwdACHARNtaW50X25ld190eXBlc2NyaXB0AIcBE3RpbWVfbmV3X3R5cGVzY3JpcHQAhwERamlfbmV3X3R5cGVzY3JpcHQAiAETY2ZzaV9uZXdfdHlwZXNjcmlwdACIARNwc2hsX25ld190eXBlc2NyaXB0AIgBE3BzaGhfbmV3X3R5cGVzY3JpcHQAiAETcG9wbF9uZXdfdHlwZXNjcmlwdACIARNwb3BoX25ld190eXBlc2NyaXB0AIgBE2FuZGlfbmV3X3R5cGVzY3JpcHQAcxNkaXZpX25ld190eXBlc2NyaXB0AHMTZXhwaV9uZXdfdHlwZXNjcmlwdABzE21vZGlfbmV3X3R5cGVzY3JpcHQAcxNtdWxpX25ld190eXBlc2NyaXB0AHMSb3JpX25ld190eXBlc2NyaXB0AHMTc2xsaV9uZXdfdHlwZXNjcmlwdABzE3NybGlfbmV3X3R5cGVzY3JpcHQAcxNzdWJpX25ld190eXBlc2NyaXB0AHMTeG9yaV9uZXdfdHlwZXNjcmlwdABzE2puZWlfbmV3X3R5cGVzY3JpcHQAcxFsYl9uZXdfdHlwZXNjcmlwdABzEWx3X25ld190eXBlc2NyaXB0AHMRc2JfbmV3X3R5cGVzY3JpcHQAcxFzd19uZXdfdHlwZXNjcmlwdABzE21jcGlfbmV3X3R5cGVzY3JpcHQAcxJndGZfbmV3X3R5cGVzY3JpcHQAcxNqbnpmX25ld190eXBlc2NyaXB0AHMTam56Yl9uZXdfdHlwZXNjcmlwdABzCmFuZGlfaW1tMTIAjQEKZGl2aV9pbW0xMgCNAQpleHBpX2ltbTEyAI0BCm1vZGlfaW1tMTIAjQEKbXVsaV9pbW0xMgCNAQlvcmlfaW1tMTIAjQEKc2xsaV9pbW0xMgCNAQpzcmxpX2ltbTEyAI0BCnN1YmlfaW1tMTIAjQEKeG9yaV9pbW0xMgCNAQpqbmVpX2ltbTEyAI0BCGxiX2ltbTEyAI0BCGx3X2ltbTEyAI0BCHNiX2ltbTEyAI0BCHN3X2ltbTEyAI0BCm1jcGlfaW1tMTIAjQEJZ3RmX2ltbTEyAI0BCmpuemZfaW1tMTIAjQEKam56Yl9pbW0xMgCNARJhbmRfbmV3X3R5cGVzY3JpcHQAcRJkaXZfbmV3X3R5cGVzY3JpcHQAcRFlcV9uZXdfdHlwZXNjcmlwdABxEmV4cF9uZXdfdHlwZXNjcmlwdABxEWd0X25ld190eXBlc2NyaXB0AHERbHRfbmV3X3R5cGVzY3JpcHQAcRNtbG9nX25ld190eXBlc2NyaXB0AHETbXJvb19uZXdfdHlwZXNjcmlwdABxEm1vZF9uZXdfdHlwZXNjcmlwdABxEm11bF9uZXdfdHlwZXNjcmlwdABxEW9yX25ld190eXBlc2NyaXB0AHESc2xsX25ld190eXBlc2NyaXB0AHESc3JsX25ld190eXBlc2NyaXB0AHESc3ViX25ld190eXBlc2NyaXB0AHESeG9yX25ld190eXBlc2NyaXB0AHESbWNwX25ld190eXBlc2NyaXB0AHESbGRjX25ld190eXBlc2NyaXB0AHETc2N3cV9uZXdfdHlwZXNjcmlwdABxEnNyd19uZXdfdHlwZXNjcmlwdABxEnN3d19uZXdfdHlwZXNjcmlwdABxEXRyX25ld190eXBlc2NyaXB0AHETZWNrMV9uZXdfdHlwZXNjcmlwdABxE2VjcjFfbmV3X3R5cGVzY3JpcHQAcRNlZDE5X25ld190eXBlc2NyaXB0AHETazI1Nl9uZXdfdHlwZXNjcmlwdABxE3MyNTZfbmV3X3R5cGVzY3JpcHQAcRJiYWxfbmV3X3R5cGVzY3JpcHQAcRJqbmVfbmV3X3R5cGVzY3JpcHQAcRJyZXRfbmV3X3R5cGVzY3JpcHQAnQETYmhlaV9uZXdfdHlwZXNjcmlwdACdARFjYl9uZXdfdHlwZXNjcmlwdACdARNydnJ0X25ld190eXBlc2NyaXB0AJ0BE2ZsYWdfbmV3X3R5cGVzY3JpcHQAnQESam1wX25ld190eXBlc2NyaXB0AJ0BEmNmZV9uZXdfdHlwZXNjcmlwdACdARJjZnNfbmV3X3R5cGVzY3JpcHQAnQEGYW5kX3JiAIsBBmRpdl9yYgCLAQVlcV9yYgCLAQZleHBfcmIAiwEFZ3RfcmIAiwEFbHRfcmIAiwEHbWxvZ19yYgCLAQdtcm9vX3JiAIsBBm1vZF9yYgCLAQdtb3ZlX3JiAIsBBm11bF9yYgCLAQZub3RfcmIAiwEFb3JfcmIAiwEGc2xsX3JiAIsBBnNybF9yYgCLAQZzdWJfcmIAiwEGeG9yX3JiAIsBB21sZHZfcmIAiwEHcmV0ZF9yYgCLAQZtY2xfcmIAiwEGbWNwX3JiAIsBBm1lcV9yYgCLAQdiaHNoX3JiAIsBB2J1cm5fcmIAiwEHY2FsbF9yYgCLAQZjY3BfcmIAiwEHY3Jvb19yYgCLAQdjc2l6X3JiAIsBBmxkY19yYgCLAQZsb2dfcmIAiwEHbG9nZF9yYgCLAQdtaW50X3JiAIsBB3Njd3FfcmIAiwEGc3J3X3JiAIsBB3Nyd3FfcmIAiwEGc3d3X3JiAIsBB3N3d3FfcmIAiwEFdHJfcmIAiwEGdHJvX3JiAIsBB2VjazFfcmIAiwEHZWNyMV9yYgCLAQdlZDE5X3JiAIsBB2syNTZfcmIAiwEHczI1Nl9yYgCLAQd0aW1lX3JiAIsBBmJhbF9yYgCLAQZqbmVfcmIAiwEGc21vX3JiAIsBB2FkZGlfcmIAiwEHYW5kaV9yYgCLAQdkaXZpX3JiAIsBB2V4cGlfcmIAiwEHbW9kaV9yYgCLAQdtdWxpX3JiAIsBBm9yaV9yYgCLAQdzbGxpX3JiAIsBB3NybGlfcmIAiwEHc3ViaV9yYgCLAQd4b3JpX3JiAIsBB2puZWlfcmIAiwEFbGJfcmIAiwEFbHdfcmIAiwEFc2JfcmIAiwEFc3dfcmIAiwEHbWNwaV9yYgCLAQZndGZfcmIAiwEHam56Zl9yYgCLAQdqbnpiX3JiAIsBB2puZWZfcmIAiwEHam5lYl9yYgCLAQd3ZGNtX3JiAIsBB3dxY21fcmIAiwEHd2RvcF9yYgCLAQd3cW9wX3JiAIsBB3dkbWxfcmIAiwEHd3FtbF9yYgCLAQd3ZGR2X3JiAIsBB3dxZHZfcmIAiwEHd2RtZF9yYgCLAQd3cW1kX3JiAIsBB3dkYW1fcmIAiwEHd3FhbV9yYgCLAQd3ZG1tX3JiAIsBB3dxbW1fcmIAiwEGYW5kX3JhAJEBBmRpdl9yYQCRAQVlcV9yYQCRAQZleHBfcmEAkQEFZ3RfcmEAkQEFbHRfcmEAkQEHbWxvZ19yYQCRAQdtcm9vX3JhAJEBBm1vZF9yYQCRAQdtb3ZlX3JhAJEBBm11bF9yYQCRAQZub3RfcmEAkQEFb3JfcmEAkQEGc2xsX3JhAJEBBnNybF9yYQCRAQZzdWJfcmEAkQEGeG9yX3JhAJEBB21sZHZfcmEAkQEGcmV0X3JhAJEBB3JldGRfcmEAkQEHYWxvY19yYQCRAQZtY2xfcmEAkQEGbWNwX3JhAJEBBm1lcV9yYQCRAQdiaHNoX3JhAJEBB2JoZWlfcmEAkQEHYnVybl9yYQCRAQdjYWxsX3JhAJEBBmNjcF9yYQCRAQdjcm9vX3JhAJEBB2NzaXpfcmEAkQEFY2JfcmEAkQEGbGRjX3JhAJEBBmxvZ19yYQCRAQdsb2dkX3JhAJEBB21pbnRfcmEAkQEHcnZydF9yYQCRAQdzY3dxX3JhAJEBBnNyd19yYQCRAQdzcndxX3JhAJEBBnN3d19yYQCRAQdzd3dxX3JhAJEBBXRyX3JhAJEBBnRyb19yYQCRAQdlY2sxX3JhAJEBB2VjcjFfcmEAkQEHZWQxOV9yYQCRAQdrMjU2X3JhAJEBB3MyNTZfcmEAkQEHdGltZV9yYQCRAQdmbGFnX3JhAJEBBmJhbF9yYQCRAQZqbXBfcmEAkQEGam5lX3JhAJEBBnNtb19yYQCRAQdhZGRpX3JhAJEBB2FuZGlfcmEAkQEHZGl2aV9yYQCRAQdleHBpX3JhAJEBB21vZGlfcmEAkQEHbXVsaV9yYQCRAQZvcmlfcmEAkQEHc2xsaV9yYQCRAQdzcmxpX3JhAJEBB3N1YmlfcmEAkQEHeG9yaV9yYQCRAQdqbmVpX3JhAJEBBWxiX3JhAJEBBWx3X3JhAJEBBXNiX3JhAJEBBXN3X3JhAJEBB21jcGlfcmEAkQEGZ3RmX3JhAJEBB21jbGlfcmEAkQEFZ21fcmEAkQEHbW92aV9yYQCRAQdqbnppX3JhAJEBB2ptcGZfcmEAkQEHam1wYl9yYQCRAQdqbnpmX3JhAJEBB2puemJfcmEAkQEHam5lZl9yYQCRAQdqbmViX3JhAJEBBmNmZV9yYQCRAQZjZnNfcmEAkQEHd2RjbV9yYQCRAQd3cWNtX3JhAJEBB3dkb3BfcmEAkQEHd3FvcF9yYQCRAQd3ZG1sX3JhAJEBB3dxbWxfcmEAkQEHd2Rkdl9yYQCRAQd3cWR2X3JhAJEBB3dkbWRfcmEAkQEHd3FtZF9yYQCRAQd3ZGFtX3JhAJEBB3dxYW1fcmEAkQEHd2RtbV9yYQCRAQd3cW1tX3JhAJEBE21sZHZfbmV3X3R5cGVzY3JpcHQATBJtZXFfbmV3X3R5cGVzY3JpcHQATBJjY3BfbmV3X3R5cGVzY3JpcHQATBJsb2dfbmV3X3R5cGVzY3JpcHQATBNsb2dkX25ld190eXBlc2NyaXB0AEwTc3J3cV9uZXdfdHlwZXNjcmlwdABME3N3d3FfbmV3X3R5cGVzY3JpcHQATBJ0cm9fbmV3X3R5cGVzY3JpcHQATBJzbW9fbmV3X3R5cGVzY3JpcHQATBNqbmVmX25ld190eXBlc2NyaXB0AEwTam5lYl9uZXdfdHlwZXNjcmlwdABME3dkY21fbmV3X3R5cGVzY3JpcHQATBN3cWNtX25ld190eXBlc2NyaXB0AEwTd2RvcF9uZXdfdHlwZXNjcmlwdABME3dxb3BfbmV3X3R5cGVzY3JpcHQATBN3ZG1sX25ld190eXBlc2NyaXB0AEwTd3FtbF9uZXdfdHlwZXNjcmlwdABME3dkZHZfbmV3X3R5cGVzY3JpcHQATBN3cWR2X25ld190eXBlc2NyaXB0AEwTd2RtZF9uZXdfdHlwZXNjcmlwdABME3dxbWRfbmV3X3R5cGVzY3JpcHQATBN3ZGFtX25ld190eXBlc2NyaXB0AEwTd3FhbV9uZXdfdHlwZXNjcmlwdABME3dkbW1fbmV3X3R5cGVzY3JpcHQATBN3cW1tX25ld190eXBlc2NyaXB0AEwHbWxkdl9yZACVAQZtZXFfcmQAlQEGY2NwX3JkAJUBBmxvZ19yZACVAQdsb2dkX3JkAJUBB3Nyd3FfcmQAlQEHc3d3cV9yZACVAQZ0cm9fcmQAlQEGc21vX3JkAJUBCmpuZWZfaW1tMDYAlQEKam5lYl9pbW0wNgCVAQp3ZGNtX2ltbTA2AJUBCndxY21faW1tMDYAlQEKd2RvcF9pbW0wNgCVAQp3cW9wX2ltbTA2AJUBCndkbWxfaW1tMDYAlQEKd3FtbF9pbW0wNgCVAQp3ZGR2X2ltbTA2AJUBCndxZHZfaW1tMDYAlQEHd2RtZF9yZACVAQd3cW1kX3JkAJUBB3dkYW1fcmQAlQEHd3FhbV9yZACVAQd3ZG1tX3JkAJUBB3dxbW1fcmQAlQEOX193YmdfYW5kX2ZyZWUAsQEOX193YmdfZGl2X2ZyZWUAsQENX193YmdfZXFfZnJlZQCxAQ5fX3diZ19leHBfZnJlZQCxAQ1fX3diZ19ndF9mcmVlALEBDV9fd2JnX2x0X2ZyZWUAsQEPX193YmdfbWxvZ19mcmVlALEBD19fd2JnX21yb29fZnJlZQCxAQ5fX3diZ19tb2RfZnJlZQCxAQ9fX3diZ19tb3ZlX2ZyZWUAsQEOX193YmdfbXVsX2ZyZWUAsQEOX193Ymdfbm90X2ZyZWUAsQENX193Ymdfb3JfZnJlZQCxAQ5fX3diZ19zbGxfZnJlZQCxAQ5fX3diZ19zcmxfZnJlZQCxAQ5fX3diZ19zdWJfZnJlZQCxAQ5fX3diZ194b3JfZnJlZQCxAQ9fX3diZ19tbGR2X2ZyZWUAsQEOX193YmdfcmV0X2ZyZWUAsQEPX193YmdfcmV0ZF9mcmVlALEBD19fd2JnX2Fsb2NfZnJlZQCxAQ5fX3diZ19tY2xfZnJlZQCxAQ5fX3diZ19tY3BfZnJlZQCxAQ5fX3diZ19tZXFfZnJlZQCxAQ9fX3diZ19iaHNoX2ZyZWUAsQEPX193YmdfYmhlaV9mcmVlALEBD19fd2JnX2J1cm5fZnJlZQCxAQ9fX3diZ19jYWxsX2ZyZWUAsQEOX193YmdfY2NwX2ZyZWUAsQEPX193YmdfY3Jvb19mcmVlALEBD19fd2JnX2NzaXpfZnJlZQCxAQ1fX3diZ19jYl9mcmVlALEBDl9fd2JnX2xkY19mcmVlALEBDl9fd2JnX2xvZ19mcmVlALEBD19fd2JnX2xvZ2RfZnJlZQCxAQ9fX3diZ19taW50X2ZyZWUAsQEPX193YmdfcnZydF9mcmVlALEBD19fd2JnX3Njd3FfZnJlZQCxAQ5fX3diZ19zcndfZnJlZQCxAQ9fX3diZ19zcndxX2ZyZWUAsQEOX193Ymdfc3d3X2ZyZWUAsQEPX193Ymdfc3d3cV9mcmVlALEBDV9fd2JnX3RyX2ZyZWUAsQEOX193YmdfdHJvX2ZyZWUAsQEPX193YmdfZWNrMV9mcmVlALEBD19fd2JnX2VjcjFfZnJlZQCxAQ9fX3diZ19lZDE5X2ZyZWUAsQEPX193YmdfazI1Nl9mcmVlALEBD19fd2JnX3MyNTZfZnJlZQCxAQ9fX3diZ190aW1lX2ZyZWUAsQEPX193Ymdfbm9vcF9mcmVlALEBD19fd2JnX2ZsYWdfZnJlZQCxAQ5fX3diZ19iYWxfZnJlZQCxAQ5fX3diZ19qbXBfZnJlZQCxAQ5fX3diZ19qbmVfZnJlZQCxAQ5fX3diZ19zbW9fZnJlZQCxAQ9fX3diZ19hZGRpX2ZyZWUAsQEPX193YmdfYW5kaV9mcmVlALEBD19fd2JnX2RpdmlfZnJlZQCxAQ9fX3diZ19leHBpX2ZyZWUAsQEPX193YmdfbW9kaV9mcmVlALEBD19fd2JnX211bGlfZnJlZQCxAQ5fX3diZ19vcmlfZnJlZQCxAQ9fX3diZ19zbGxpX2ZyZWUAsQEPX193Ymdfc3JsaV9mcmVlALEBD19fd2JnX3N1YmlfZnJlZQCxAQ9fX3diZ194b3JpX2ZyZWUAsQEPX193Ymdfam5laV9mcmVlALEBDV9fd2JnX2xiX2ZyZWUAsQENX193YmdfbHdfZnJlZQCxAQ1fX3diZ19zYl9mcmVlALEBDV9fd2JnX3N3X2ZyZWUAsQEPX193YmdfbWNwaV9mcmVlALEBDl9fd2JnX2d0Zl9mcmVlALEBD19fd2JnX21jbGlfZnJlZQCxAQ1fX3diZ19nbV9mcmVlALEBD19fd2JnX21vdmlfZnJlZQCxAQ9fX3diZ19qbnppX2ZyZWUAsQEPX193Ymdfam1wZl9mcmVlALEBD19fd2JnX2ptcGJfZnJlZQCxAQ9fX3diZ19qbnpmX2ZyZWUAsQEPX193Ymdfam56Yl9mcmVlALEBD19fd2JnX2puZWZfZnJlZQCxAQ9fX3diZ19qbmViX2ZyZWUAsQENX193YmdfamlfZnJlZQCxAQ9fX3diZ19jZmVpX2ZyZWUAsQEPX193YmdfY2ZzaV9mcmVlALEBDl9fd2JnX2NmZV9mcmVlALEBDl9fd2JnX2Nmc19mcmVlALEBD19fd2JnX3BzaGxfZnJlZQCxAQ9fX3diZ19wc2hoX2ZyZWUAsQEPX193YmdfcG9wbF9mcmVlALEBD19fd2JnX3BvcGhfZnJlZQCxAQ9fX3diZ193ZGNtX2ZyZWUAsQEPX193Ymdfd3FjbV9mcmVlALEBD19fd2JnX3dkb3BfZnJlZQCxAQ9fX3diZ193cW9wX2ZyZWUAsQEPX193Ymdfd2RtbF9mcmVlALEBD19fd2JnX3dxbWxfZnJlZQCxAQ9fX3diZ193ZGR2X2ZyZWUAsQEPX193Ymdfd3Fkdl9mcmVlALEBD19fd2JnX3dkbWRfZnJlZQCxAQ9fX3diZ193cW1kX2ZyZWUAsQEPX193Ymdfd2RhbV9mcmVlALEBD19fd2JnX3dxYW1fZnJlZQCxAQ9fX3diZ193ZG1tX2ZyZWUAsQEPX193Ymdfd3FtbV9mcmVlALEBBmFuZF9yYwCMAQZkaXZfcmMAjAEFZXFfcmMAjAEGZXhwX3JjAIwBBWd0X3JjAIwBBWx0X3JjAIwBB21sb2dfcmMAjAEHbXJvb19yYwCMAQZtb2RfcmMAjAEGbXVsX3JjAIwBBW9yX3JjAIwBBnNsbF9yYwCMAQZzcmxfcmMAjAEGc3ViX3JjAIwBBnhvcl9yYwCMAQdtbGR2X3JjAIwBBm1jcF9yYwCMAQZtZXFfcmMAjAEHY2FsbF9yYwCMAQZjY3BfcmMAjAEGbGRjX3JjAIwBBmxvZ19yYwCMAQdsb2dkX3JjAIwBB3Njd3FfcmMAjAEGc3J3X3JjAIwBB3Nyd3FfcmMAjAEGc3d3X3JjAIwBB3N3d3FfcmMAjAEFdHJfcmMAjAEGdHJvX3JjAIwBB2VjazFfcmMAjAEHZWNyMV9yYwCMAQdlZDE5X3JjAIwBB2syNTZfcmMAjAEHczI1Nl9yYwCMAQZiYWxfcmMAjAEGam5lX3JjAIwBBnNtb19yYwCMAQdqbmVmX3JjAIwBB2puZWJfcmMAjAEHd2RjbV9yYwCMAQd3cWNtX3JjAIwBB3dkb3BfcmMAjAEHd3FvcF9yYwCMAQd3ZG1sX3JjAIwBB3dxbWxfcmMAjAEHd2Rkdl9yYwCMAQd3cWR2X3JjAIwBB3dkbWRfcmMAjAEHd3FtZF9yYwCMAQd3ZGFtX3JjAIwBB3dxYW1fcmMAjAEHd2RtbV9yYwCMAQd3cW1tX3JjAIwBEF9fd2JnX2ltbTA2X2ZyZWUAsQERcmVnaWRfbmV3X2NoZWNrZWQAowEJcmVnaWRfYmFsALIBCnJlZ2lkX2NnYXMAswEJcmVnaWRfZXJyALQBCnJlZ2lkX2ZsYWcAtQEIcmVnaWRfZnAAtgEKcmVnaWRfZ2dhcwC3AQhyZWdpZF9ocAC4AQhyZWdpZF9pcwC5AQhyZWdpZF9vZgC6AQlyZWdpZF9vbmUAuwEIcmVnaWRfcGMAvAEJcmVnaWRfcmV0AL0BCnJlZ2lkX3JldGwAvgEIcmVnaWRfc3AAvwEJcmVnaWRfc3BwAMABDnJlZ2lkX3dyaXRhYmxlAMEBCnJlZ2lkX3plcm8AwgEUcmVnaWRfbmV3X3R5cGVzY3JpcHQArQELcmVnaWRfdG9fdTgAqwEQX193YmdfcmVnaWRfZnJlZQCxARBfX3diZ19pbW0xMl9mcmVlALEBEF9fd2JnX2ltbTE4X2ZyZWUAsQEQX193YmdfaW1tMjRfZnJlZQCxARZfX3diZ19jb21wYXJlYXJnc19mcmVlALEBGl9fd2JnX2dldF9jb21wYXJlYXJnc19tb2RlAMMBGl9fd2JnX3NldF9jb21wYXJlYXJnc19tb2RlAKQBIl9fd2JnX2dldF9jb21wYXJlYXJnc19pbmRpcmVjdF9yaHMArgEiX193Ymdfc2V0X2NvbXBhcmVhcmdzX2luZGlyZWN0X3JocwCqARJjb21wYXJlYXJnc190b19pbW0AkAEUY29tcGFyZWFyZ3NfZnJvbV9pbW0AhgEVX193YmdfZ2V0X21hdGhhcmdzX29wAMMBFV9fd2JnX3NldF9tYXRoYXJnc19vcAClAR5fX3diZ19nZXRfZGl2YXJnc19pbmRpcmVjdF9yaHMAwwEeX193Ymdfc2V0X2RpdmFyZ3NfaW5kaXJlY3RfcmhzAKwBH19fd2JnX2dldF9tYXRoYXJnc19pbmRpcmVjdF9yaHMArgEeX193YmdfZ2V0X211bGFyZ3NfaW5kaXJlY3RfcmhzAK4BHl9fd2JnX2dldF9tdWxhcmdzX2luZGlyZWN0X2xocwDDAR9fX3diZ19zZXRfbWF0aGFyZ3NfaW5kaXJlY3RfcmhzAKoBHl9fd2JnX3NldF9tdWxhcmdzX2luZGlyZWN0X3JocwCqAR5fX3diZ19zZXRfbXVsYXJnc19pbmRpcmVjdF9saHMArAETX193YmdfbWF0aGFyZ3NfZnJlZQCxARJfX3diZ19tdWxhcmdzX2ZyZWUAsQESX193YmdfZGl2YXJnc19mcmVlALEBDGdtX2Zyb21fYXJncwB6DWd0Zl9mcm9tX2FyZ3MAdgdnbV9hcmdzAHcIZ3RmX2FyZ3MAcg53ZGNtX2Zyb21fYXJncwA4Dndkb3BfZnJvbV9hcmdzADgOd2RtbF9mcm9tX2FyZ3MAOQ53ZGR2X2Zyb21fYXJncwBLCXdkY21fYXJncwApCXdxY21fYXJncwAqCXdkb3BfYXJncwArCXdxb3BfYXJncwAsCXdkbWxfYXJncwAtCXdxbWxfYXJncwAuCXdkZHZfYXJncwAwCXdxZHZfYXJncwAxDndxbWxfZnJvbV9hcmdzADkOd3Fkdl9mcm9tX2FyZ3MASw53cWNtX2Zyb21fYXJncwA4Dndxb3BfZnJvbV9hcmdzADgbX193YmdfcGFuaWNpbnN0cnVjdGlvbl9mcmVlALEBIXBhbmljaW5zdHJ1Y3Rpb25fZXJyb3JfdHlwZXNjcmlwdAChARdwYW5pY2luc3RydWN0aW9uX3JlYXNvbgCvARxwYW5pY2luc3RydWN0aW9uX2luc3RydWN0aW9uAMQBFl9fd2JnX2luc3RydWN0aW9uX2ZyZWUAqQEUaW5zdHJ1Y3Rpb25fdG9fYnl0ZXMAjgEQaW5zdHJ1Y3Rpb25fc2l6ZQDrAR9fX3diaW5kZ2VuX2FkZF90b19zdGFja19wb2ludGVyAN0BD19fd2JpbmRnZW5fZnJlZQDOAQktAQBBAQsV2wHZAdoBjwHvAaABEZwByQHtAe4BxQFKe6YB0QHsAdgB0wHvAewBCorBAf4B7SECD38BfiMAQRBrIgskAAJAAkACQAJAAkACQCAAQfUBTwRAQQhBCBDNASEGQRRBCBDNASEFQRBBCBDNASEBQQBBEEEIEM0BQQJ0ayICQYCAfCABIAUgBmpqa0F3cUEDayIBIAEgAksbIABNDQYgAEEEakEIEM0BIQRBwJDAACgCAEUNBUEAIARrIQMCf0EAIARBgAJJDQAaQR8gBEH///8HSw0AGiAEQQYgBEEIdmciAGt2QQFxIABBAXRrQT5qCyIGQQJ0QaSNwABqKAIAIgENAUEAIQBBACEFDAILQRAgAEEEakEQQQgQzQFBBWsgAEsbQQgQzQEhBAJAAkACQAJ/AkACQEG8kMAAKAIAIgEgBEEDdiIAdiICQQNxRQRAIARBxJDAACgCAE0NCyACDQFBwJDAACgCACIARQ0LIAAQ1AFoQQJ0QaSNwABqKAIAIgEQ4QEgBGshAyABEMoBIgAEQANAIAAQ4QEgBGsiAiADIAIgA0kiAhshAyAAIAEgAhshASAAEMoBIgANAAsLIAEgBBDnASEFIAEQJ0EQQQgQzQEgA0sNBSABIAQQ1gEgBSADEMwBQcSQwAAoAgAiAEUNBCAAQXhxQbSOwABqIQdBzJDAACgCACEGQbyQwAAoAgAiAkEBIABBA3Z0IgBxRQ0CIAcoAggMAwsCQCACQX9zQQFxIABqIgNBA3QiAEG8jsAAaigCACIFQQhqKAIAIgIgAEG0jsAAaiIARwRAIAIgADYCDCAAIAI2AggMAQtBvJDAACABQX4gA3dxNgIACyAFIANBA3QQyAEgBRDpASEDDAsLAkBBASAAQR9xIgB0EM8BIAIgAHRxENQBaCICQQN0IgBBvI7AAGooAgAiA0EIaigCACIBIABBtI7AAGoiAEcEQCABIAA2AgwgACABNgIIDAELQbyQwABBvJDAACgCAEF+IAJ3cTYCAAsgAyAEENYBIAMgBBDnASIFIAJBA3QgBGsiAhDMAUHEkMAAKAIAIgAEQCAAQXhxQbSOwABqIQdBzJDAACgCACEGAn9BvJDAACgCACIBQQEgAEEDdnQiAHEEQCAHKAIIDAELQbyQwAAgACABcjYCACAHCyEAIAcgBjYCCCAAIAY2AgwgBiAHNgIMIAYgADYCCAtBzJDAACAFNgIAQcSQwAAgAjYCACADEOkBIQMMCgtBvJDAACAAIAJyNgIAIAcLIQAgByAGNgIIIAAgBjYCDCAGIAc2AgwgBiAANgIIC0HMkMAAIAU2AgBBxJDAACADNgIADAELIAEgAyAEahDIAQsgARDpASIDDQUMBAsgBCAGEMsBdCEHQQAhAEEAIQUDQAJAIAEQ4QEiAiAESQ0AIAIgBGsiAiADTw0AIAEhBSACIgMNAEEAIQMgASEADAMLIAFBFGooAgAiAiAAIAIgASAHQR12QQRxakEQaigCACIBRxsgACACGyEAIAdBAXQhByABDQALCyAAIAVyRQRAQQAhBUEBIAZ0EM8BQcCQwAAoAgBxIgBFDQMgABDUAWhBAnRBpI3AAGooAgAhAAsgAEUNAQsDQCAAIAUgABDhASIBIARPIAEgBGsiAiADSXEiARshBSACIAMgARshAyAAEMoBIgANAAsLIAVFDQAgBEHEkMAAKAIAIgBNIAMgACAEa09xDQAgBSAEEOcBIQYgBRAnAkBBEEEIEM0BIANNBEAgBSAEENYBIAYgAxDMASADQYACTwRAIAYgAxAoDAILIANBeHFBtI7AAGohAgJ/QbyQwAAoAgAiAUEBIANBA3Z0IgBxBEAgAigCCAwBC0G8kMAAIAAgAXI2AgAgAgshACACIAY2AgggACAGNgIMIAYgAjYCDCAGIAA2AggMAQsgBSADIARqEMgBCyAFEOkBIgMNAQsCQAJAAkACQAJAAkACQCAEQcSQwAAoAgAiAEsEQEHIkMAAKAIAIgAgBEsNAkEIQQgQzQEgBGpBFEEIEM0BakEQQQgQzQFqQYCABBDNASIAQRB2QAAhASALQQA2AgggC0EAIABBgIB8cSABQX9GIgAbNgIEIAtBACABQRB0IAAbNgIAIAsoAgAiCA0BQQAhAwwIC0HMkMAAKAIAIQJBEEEIEM0BIAAgBGsiAUsEQEHMkMAAQQA2AgBBxJDAACgCACEAQcSQwABBADYCACACIAAQyAEgAhDpASEDDAgLIAIgBBDnASEAQcSQwAAgATYCAEHMkMAAIAA2AgAgACABEMwBIAIgBBDWASACEOkBIQMMBwsgCygCCCEMQdSQwAAgCygCBCIKQdSQwAAoAgBqIgE2AgBB2JDAAEHYkMAAKAIAIgAgASAAIAFLGzYCAAJAAkACQEHQkMAAKAIABEBBpI7AACEAA0AgABDXASAIRg0CIAAoAggiAA0ACwwCC0HgkMAAKAIAIgBFIAAgCEtyDQUMBwsgABDjAQ0AIAAQ5AEgDEcNACAAKAIAIgJB0JDAACgCACIBTQR/IAIgACgCBGogAUsFQQALDQELQeCQwABB4JDAACgCACIAIAggACAISRs2AgAgCCAKaiEBQaSOwAAhAAJAAkADQCABIAAoAgBHBEAgACgCCCIADQEMAgsLIAAQ4wENACAAEOQBIAxGDQELQdCQwAAoAgAhCUGkjsAAIQACQANAIAkgACgCAE8EQCAAENcBIAlLDQILIAAoAggiAA0AC0EAIQALIAkgABDXASIGQRRBCBDNASIPa0EXayIBEOkBIgBBCBDNASAAayABaiIAIABBEEEIEM0BIAlqSRsiDRDpASEOIA0gDxDnASEAQQhBCBDNASEDQRRBCBDNASEFQRBBCBDNASECQdCQwAAgCCAIEOkBIgFBCBDNASABayIBEOcBIgc2AgBByJDAACAKQQhqIAIgAyAFamogAWprIgM2AgAgByADQQFyNgIEQQhBCBDNASEFQRRBCBDNASECQRBBCBDNASEBIAcgAxDnASABIAIgBUEIa2pqNgIEQdyQwABBgICAATYCACANIA8Q1gFBpI7AACkCACEQIA5BCGpBrI7AACkCADcCACAOIBA3AgBBsI7AACAMNgIAQaiOwAAgCjYCAEGkjsAAIAg2AgBBrI7AACAONgIAA0AgAEEEEOcBIABBBzYCBCIAQQRqIAZJDQALIAkgDUYNByAJIA0gCWsiACAJIAAQ5wEQxgEgAEGAAk8EQCAJIAAQKAwICyAAQXhxQbSOwABqIQICf0G8kMAAKAIAIgFBASAAQQN2dCIAcQRAIAIoAggMAQtBvJDAACAAIAFyNgIAIAILIQAgAiAJNgIIIAAgCTYCDCAJIAI2AgwgCSAANgIIDAcLIAAoAgAhAyAAIAg2AgAgACAAKAIEIApqNgIEIAgQ6QEiBUEIEM0BIQIgAxDpASIBQQgQzQEhACAIIAIgBWtqIgYgBBDnASEHIAYgBBDWASADIAAgAWtqIgAgBCAGamshBEHQkMAAKAIAIABHBEAgAEHMkMAAKAIARg0DIAAoAgRBA3FBAUcNBQJAIAAQ4QEiBUGAAk8EQCAAECcMAQsgAEEMaigCACICIABBCGooAgAiAUcEQCABIAI2AgwgAiABNgIIDAELQbyQwABBvJDAACgCAEF+IAVBA3Z3cTYCAAsgBCAFaiEEIAAgBRDnASEADAULQdCQwAAgBzYCAEHIkMAAQciQwAAoAgAgBGoiADYCACAHIABBAXI2AgQgBhDpASEDDAcLIAAgACgCBCAKajYCBEHIkMAAKAIAIApqIQFB0JDAACgCACIAIAAQ6QEiAEEIEM0BIABrIgAQ5wEhA0HIkMAAIAEgAGsiBTYCAEHQkMAAIAM2AgAgAyAFQQFyNgIEQQhBCBDNASECQRRBCBDNASEBQRBBCBDNASEAIAMgBRDnASAAIAEgAkEIa2pqNgIEQdyQwABBgICAATYCAAwFC0HIkMAAIAAgBGsiATYCAEHQkMAAQdCQwAAoAgAiAiAEEOcBIgA2AgAgACABQQFyNgIEIAIgBBDWASACEOkBIQMMBQtBzJDAACAHNgIAQcSQwABBxJDAACgCACAEaiIANgIAIAcgABDMASAGEOkBIQMMBAtB4JDAACAINgIADAELIAcgBCAAEMYBIARBgAJPBEAgByAEECggBhDpASEDDAMLIARBeHFBtI7AAGohAgJ/QbyQwAAoAgAiAUEBIARBA3Z0IgBxBEAgAigCCAwBC0G8kMAAIAAgAXI2AgAgAgshACACIAc2AgggACAHNgIMIAcgAjYCDCAHIAA2AgggBhDpASEDDAILQeSQwABB/x82AgBBsI7AACAMNgIAQaiOwAAgCjYCAEGkjsAAIAg2AgBBwI7AAEG0jsAANgIAQciOwABBvI7AADYCAEG8jsAAQbSOwAA2AgBB0I7AAEHEjsAANgIAQcSOwABBvI7AADYCAEHYjsAAQcyOwAA2AgBBzI7AAEHEjsAANgIAQeCOwABB1I7AADYCAEHUjsAAQcyOwAA2AgBB6I7AAEHcjsAANgIAQdyOwABB1I7AADYCAEHwjsAAQeSOwAA2AgBB5I7AAEHcjsAANgIAQfiOwABB7I7AADYCAEHsjsAAQeSOwAA2AgBBgI/AAEH0jsAANgIAQfSOwABB7I7AADYCAEH8jsAAQfSOwAA2AgBBiI/AAEH8jsAANgIAQYSPwABB/I7AADYCAEGQj8AAQYSPwAA2AgBBjI/AAEGEj8AANgIAQZiPwABBjI/AADYCAEGUj8AAQYyPwAA2AgBBoI/AAEGUj8AANgIAQZyPwABBlI/AADYCAEGoj8AAQZyPwAA2AgBBpI/AAEGcj8AANgIAQbCPwABBpI/AADYCAEGsj8AAQaSPwAA2AgBBuI/AAEGsj8AANgIAQbSPwABBrI/AADYCAEHAj8AAQbSPwAA2AgBByI/AAEG8j8AANgIAQbyPwABBtI/AADYCAEHQj8AAQcSPwAA2AgBBxI/AAEG8j8AANgIAQdiPwABBzI/AADYCAEHMj8AAQcSPwAA2AgBB4I/AAEHUj8AANgIAQdSPwABBzI/AADYCAEHoj8AAQdyPwAA2AgBB3I/AAEHUj8AANgIAQfCPwABB5I/AADYCAEHkj8AAQdyPwAA2AgBB+I/AAEHsj8AANgIAQeyPwABB5I/AADYCAEGAkMAAQfSPwAA2AgBB9I/AAEHsj8AANgIAQYiQwABB/I/AADYCAEH8j8AAQfSPwAA2AgBBkJDAAEGEkMAANgIAQYSQwABB/I/AADYCAEGYkMAAQYyQwAA2AgBBjJDAAEGEkMAANgIAQaCQwABBlJDAADYCAEGUkMAAQYyQwAA2AgBBqJDAAEGckMAANgIAQZyQwABBlJDAADYCAEGwkMAAQaSQwAA2AgBBpJDAAEGckMAANgIAQbiQwABBrJDAADYCAEGskMAAQaSQwAA2AgBBtJDAAEGskMAANgIAQQhBCBDNASEFQRRBCBDNASECQRBBCBDNASEBQdCQwAAgCCAIEOkBIgBBCBDNASAAayIAEOcBIgM2AgBByJDAACAKQQhqIAEgAiAFamogAGprIgU2AgAgAyAFQQFyNgIEQQhBCBDNASECQRRBCBDNASEBQRBBCBDNASEAIAMgBRDnASAAIAEgAkEIa2pqNgIEQdyQwABBgICAATYCAAtBACEDQciQwAAoAgAiACAETQ0AQciQwAAgACAEayIBNgIAQdCQwABB0JDAACgCACICIAQQ5wEiADYCACAAIAFBAXI2AgQgAiAEENYBIAIQ6QEhAwsgC0EQaiQAIAMLkQcBBX8gABDqASIAIAAQ4QEiAhDnASEBAkACQAJAIAAQ4gENACAAKAIAIQMCQCAAENUBRQRAIAIgA2ohAiAAIAMQ6AEiAEHMkMAAKAIARw0BIAEoAgRBA3FBA0cNAkHEkMAAIAI2AgAgACACIAEQxgEPCyACIANqQRBqIQAMAgsgA0GAAk8EQCAAECcMAQsgAEEMaigCACIEIABBCGooAgAiBUcEQCAFIAQ2AgwgBCAFNgIIDAELQbyQwABBvJDAACgCAEF+IANBA3Z3cTYCAAsCQCABENIBBEAgACACIAEQxgEMAQsCQAJAAkBB0JDAACgCACABRwRAIAFBzJDAACgCAEcNAUHMkMAAIAA2AgBBxJDAAEHEkMAAKAIAIAJqIgE2AgAgACABEMwBDwtB0JDAACAANgIAQciQwABByJDAACgCACACaiIBNgIAIAAgAUEBcjYCBCAAQcyQwAAoAgBGDQEMAgsgARDhASIDIAJqIQICQCADQYACTwRAIAEQJwwBCyABQQxqKAIAIgQgAUEIaigCACIBRwRAIAEgBDYCDCAEIAE2AggMAQtBvJDAAEG8kMAAKAIAQX4gA0EDdndxNgIACyAAIAIQzAEgAEHMkMAAKAIARw0CQcSQwAAgAjYCAAwDC0HEkMAAQQA2AgBBzJDAAEEANgIAC0HckMAAKAIAIAFPDQFBCEEIEM0BIQBBFEEIEM0BIQFBEEEIEM0BIQNBAEEQQQgQzQFBAnRrIgJBgIB8IAMgACABamprQXdxQQNrIgAgACACSxtFDQFB0JDAACgCAEUNAUEIQQgQzQEhAEEUQQgQzQEhAUEQQQgQzQEhAkEAAkBByJDAACgCACIEIAIgASAAQQhramoiAk0NAEHQkMAAKAIAIQFBpI7AACEAAkADQCABIAAoAgBPBEAgABDXASABSw0CCyAAKAIIIgANAAtBACEACyAAEOMBDQAgAEEMaigCABoMAAtBABAva0cNAUHIkMAAKAIAQdyQwAAoAgBNDQFB3JDAAEF/NgIADwsgAkGAAkkNASAAIAIQKEHkkMAAQeSQwAAoAgBBAWsiADYCACAADQAQLxoPCw8LIAJBeHFBtI7AAGohAQJ/QbyQwAAoAgAiA0EBIAJBA3Z0IgJxBEAgASgCCAwBC0G8kMAAIAIgA3I2AgAgAQshAyABIAA2AgggAyAANgIMIAAgATYCDCAAIAM2AggL+gQBC38jAEEwayICJAAgAkEDOgAoIAJCgICAgIAENwMgIAJBADYCGCACQQA2AhAgAkGMiMAANgIMIAIgADYCCAJ/AkACQCABKAIAIgpFBEAgAUEUaigCACIARQ0BIAEoAhAhAyAAQQN0IQUgAEEBa0H/////AXFBAWohByABKAIIIQADQCAAQQRqKAIAIgQEQCACKAIIIAAoAgAgBCACKAIMKAIMEQAADQQLIAMoAgAgAkEIaiADQQRqKAIAEQIADQMgA0EIaiEDIABBCGohACAFQQhrIgUNAAsMAQsgASgCBCIARQ0AIABBBXQhCyAAQQFrQf///z9xQQFqIQcgASgCCCEAA0AgAEEEaigCACIDBEAgAigCCCAAKAIAIAMgAigCDCgCDBEAAA0DCyACIAUgCmoiBEEcai0AADoAKCACIARBFGopAgA3AyAgBEEQaigCACEGIAEoAhAhCEEAIQlBACEDAkACQAJAIARBDGooAgBBAWsOAgACAQsgBkEDdCAIaiIMQQRqKAIAQRJHDQEgDCgCACgCACEGC0EBIQMLIAIgBjYCFCACIAM2AhAgBEEIaigCACEDAkACQAJAIARBBGooAgBBAWsOAgACAQsgA0EDdCAIaiIGQQRqKAIAQRJHDQEgBigCACgCACEDC0EBIQkLIAIgAzYCHCACIAk2AhggCCAEKAIAQQN0aiIDKAIAIAJBCGogAygCBBECAA0CIABBCGohACALIAVBIGoiBUcNAAsLIAFBDGooAgAgB0sEQCACKAIIIAEoAgggB0EDdGoiACgCACAAKAIEIAIoAgwoAgwRAAANAQtBAAwBC0EBCyACQTBqJAAL1QQBBH8gACABEOcBIQICQAJAAkAgABDiAQ0AIAAoAgAhAwJAIAAQ1QFFBEAgASADaiEBIAAgAxDoASIAQcyQwAAoAgBHDQEgAigCBEEDcUEDRw0CQcSQwAAgATYCACAAIAEgAhDGAQ8LIAEgA2pBEGohAAwCCyADQYACTwRAIAAQJwwBCyAAQQxqKAIAIgQgAEEIaigCACIFRwRAIAUgBDYCDCAEIAU2AggMAQtBvJDAAEG8kMAAKAIAQX4gA0EDdndxNgIACyACENIBBEAgACABIAIQxgEMAgsCQEHQkMAAKAIAIAJHBEAgAkHMkMAAKAIARw0BQcyQwAAgADYCAEHEkMAAQcSQwAAoAgAgAWoiATYCACAAIAEQzAEPC0HQkMAAIAA2AgBByJDAAEHIkMAAKAIAIAFqIgE2AgAgACABQQFyNgIEIABBzJDAACgCAEcNAUHEkMAAQQA2AgBBzJDAAEEANgIADwsgAhDhASIDIAFqIQECQCADQYACTwRAIAIQJwwBCyACQQxqKAIAIgQgAkEIaigCACICRwRAIAIgBDYCDCAEIAI2AggMAQtBvJDAAEG8kMAAKAIAQX4gA0EDdndxNgIACyAAIAEQzAEgAEHMkMAAKAIARw0BQcSQwAAgATYCAAsPCyABQYACTwRAIAAgARAoDwsgAUF4cUG0jsAAaiECAn9BvJDAACgCACIDQQEgAUEDdnQiAXEEQCACKAIIDAELQbyQwAAgASADcjYCACACCyEBIAIgADYCCCABIAA2AgwgACACNgIMIAAgATYCCAuRCAEBf0EBIQECQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABBAWsOiQRJAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHEdHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6OzxHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHR0dHRz0+P0BBQkNERQALIABBgQZrDgJFR0YLQQIPC0EDDwtBBA8LQQUPC0EGDwtBBw8LQQgPC0EJDwtBCg8LQQsPC0EMDwtBDQ8LQQ4PC0EPDwtBEA8LQREPC0ESDwtBEw8LQRQPC0EVDwtBFg8LQRcPC0EYDwtBGQ8LQRoPC0EbDwtBHA8LQR0PC0GBAg8LQYICDwtBgwIPC0GEAg8LQYUCDwtBhgIPC0GHAg8LQYgCDwtBiQIPC0GKAg8LQYsCDwtBjAIPC0GNAg8LQY4CDwtBjwIPC0GQAg8LQZECDwtBkgIPC0GTAg8LQZQCDwtBlQIPC0GWAg8LQZcCDwtBmAIPC0GZAg8LQZoCDwtBmwIPC0GcAg8LQZ0CDwtBngIPC0GfAg8LQaACDwtBgQQPC0GCBA8LQYMEDwtBhAQPC0GFBA8LQYYEDwtBhwQPC0GIBA8LQYkEDwtBgQYPC0HwhsAAQRkQ3gEAC0GCBiEBCyABC48DAQV/AkACQAJAAkAgAUEJTwRAQRBBCBDNASABSw0BDAILIAAQASEEDAILQRBBCBDNASEBC0EIQQgQzQEhA0EUQQgQzQEhAkEQQQgQzQEhBUEAQRBBCBDNAUECdGsiBkGAgHwgBSACIANqamtBd3FBA2siAyADIAZLGyABayAATQ0AIAFBECAAQQRqQRBBCBDNAUEFayAASxtBCBDNASIDakEQQQgQzQFqQQRrEAEiAkUNACACEOoBIQACQCABQQFrIgQgAnFFBEAgACEBDAELIAIgBGpBACABa3EQ6gEhAkEQQQgQzQEhBCAAEOEBIAIgAUEAIAIgAGsgBE0baiIBIABrIgJrIQQgABDVAUUEQCABIAQQsAEgACACELABIAAgAhAEDAELIAAoAgAhACABIAQ2AgQgASAAIAJqNgIACyABENUBDQEgARDhASICQRBBCBDNASADak0NASABIAMQ5wEhACABIAMQsAEgACACIANrIgMQsAEgACADEAQMAQsgBA8LIAEQ6QEgARDVARoLEAAgACABIAIgA0HTABD2AQsQACAAIAEgAiADQdQAEPYBCxAAIAAgASACIANB3gAQ9gELEAAgACABIAIgA0HfABD2AQsQACAAIAEgAiADQeAAEPYBCxAAIAAgASACIANB4QAQ9gELEAAgACABIAIgA0HiABD2AQsQACAAIAEgAiADQeMAEPYBCxAAIAAgASACIANB5AAQ9gELEAAgACABIAIgA0HlABD2AQuQBAEFfyMAQRBrIgMkACAAKAIAIQACQCABQf8ATQRAIAAoAggiAiAAKAIARgRAIwBBIGsiBCQAAkACQCACQQFqIgJFDQBBCCAAKAIAIgVBAXQiBiACIAIgBkkbIgIgAkEITRsiAkF/c0EfdiEGAkAgBQRAIARBATYCGCAEIAU2AhQgBCAAQQRqKAIANgIQDAELIARBADYCGAsgBCACIAYgBEEQahB4IAQoAgQhBSAEKAIARQRAIAAgAjYCACAAIAU2AgQMAgsgBEEIaigCACICQYGAgIB4Rg0BIAJFDQAgBSACEOUBAAsQogEACyAEQSBqJAAgACgCCCECCyAAIAJBAWo2AgggACgCBCACaiABOgAADAELIANBADYCDAJ/IAFBgBBPBEAgAUGAgARPBEAgAyABQT9xQYABcjoADyADIAFBBnZBP3FBgAFyOgAOIAMgAUEMdkE/cUGAAXI6AA0gAyABQRJ2QQdxQfABcjoADEEEDAILIAMgAUE/cUGAAXI6AA4gAyABQQx2QeABcjoADCADIAFBBnZBP3FBgAFyOgANQQMMAQsgAyABQT9xQYABcjoADSADIAFBBnZBwAFyOgAMQQILIQEgASAAKAIAIAAoAggiAmtLBEAgACACIAEQdCAAKAIIIQILIAAoAgQgAmogA0EMaiABEOYBGiAAIAEgAmo2AggLIANBEGokAEEAC9oGAgx/AX4jAEEwayIFJABBJyEDAkAgAEKQzgBUBEAgACEODAELA0AgBUEJaiADaiICQQRrIAAgAEKQzgCAIg5CkM4Afn2nIgRB//8DcUHkAG4iBkEBdEGgi8AAai8AADsAACACQQJrIAQgBkHkAGxrQf//A3FBAXRBoIvAAGovAAA7AAAgA0EEayEDIABC/8HXL1YgDiEADQALCyAOpyICQeMASwRAIANBAmsiAyAFQQlqaiAOpyICIAJB//8DcUHkAG4iAkHkAGxrQf//A3FBAXRBoIvAAGovAAA7AAALAkAgAkEKTwRAIANBAmsiAyAFQQlqaiACQQF0QaCLwABqLwAAOwAADAELIANBAWsiAyAFQQlqaiACQTBqOgAACwJ/IAVBCWogA2ohCUErQYCAxAAgASICKAIYIgFBAXEiBBshBiAEQScgA2siCmohA0GIi8AAQQAgAUEEcRshCAJAAkAgAigCCEUEQEEBIQEgAigCACIEIAJBBGooAgAiAiAGIAgQpwENAQwCCwJAAkACQAJAIAMgAkEMaigCACIESQRAIAFBCHENBCAEIANrIgMhBEEBIAItACAiASABQQNGG0EDcSIBQQFrDgIBAgMLQQEhASACKAIAIgQgAkEEaigCACICIAYgCBCnAQ0EDAULQQAhBCADIQEMAQsgA0EBdiEBIANBAWpBAXYhBAsgAUEBaiEBIAJBBGooAgAhAyACKAIcIQcgAigCACECAkADQCABQQFrIgFFDQEgAiAHIAMoAhARAgBFDQALQQEMBAtBASEBIAdBgIDEAEYNASACIAMgBiAIEKcBDQEgAiAJIAogAygCDBEAAA0BQQAhAQJ/A0AgBCABIARGDQEaIAFBAWohASACIAcgAygCEBECAEUNAAsgAUEBawsgBEkhAQwBCyACKAIcIQwgAkEwNgIcIAItACAhDUEBIQEgAkEBOgAgIAIoAgAiByACQQRqKAIAIgsgBiAIEKcBDQAgBCADa0EBaiEBAkADQCABQQFrIgFFDQEgB0EwIAsoAhARAgBFDQALQQEMAwtBASEBIAcgCSAKIAsoAgwRAAANACACIA06ACAgAiAMNgIcQQAMAgsgAQwBCyAEIAkgCiACKAIMEQAACyAFQTBqJAALDQAgACABIAJBORDzAQsNACAAIAEgAkE6EPMBCw0AIAAgASACQTsQ8wELDQAgACABIAJBPBDzAQsNACAAIAEgAkE9EPMBCw0AIAAgASACQT4Q8wELDQAgACABIAJBPxDzAQsOACAAIAEgAkHAABDzAQsOACAAIAEgAkHBABDzAQsOACAAIAEgAkHCABDzAQsOACAAIAEgAkHDABDzAQsOACAAIAEgAkHEABDzAQsOACAAIAEgAkHFABDzAQsOACAAIAEgAkHGABDzAQsOACAAIAEgAkHHABDzAQsOACAAIAEgAkHIABDzAQsOACAAIAEgAkHJABDzAQsOACAAIAEgAkHKABDzAQsOACAAIAEgAkHRABDzAQsOACAAIAEgAkHSABDzAQu8AgEFfyAAKAIYIQMCQAJAIAAgACgCDEYEQCAAQRRBECAAQRRqIgEoAgAiBBtqKAIAIgINAUEAIQEMAgsgACgCCCICIAAoAgwiATYCDCABIAI2AggMAQsgASAAQRBqIAQbIQQDQCAEIQUgAiIBQRRqIgIgAUEQaiACKAIAIgIbIQQgAUEUQRAgAhtqKAIAIgINAAsgBUEANgIACwJAIANFDQACQCAAIAAoAhxBAnRBpI3AAGoiAigCAEcEQCADQRBBFCADKAIQIABGG2ogATYCACABRQ0CDAELIAIgATYCACABDQBBwJDAAEHAkMAAKAIAQX4gACgCHHdxNgIADwsgASADNgIYIAAoAhAiAgRAIAEgAjYCECACIAE2AhgLIABBFGooAgAiAEUNACABQRRqIAA2AgAgACABNgIYCwuuAgEEfyAAQgA3AhAgAAJ/QQAgAUGAAkkNABpBHyABQf///wdLDQAaIAFBBiABQQh2ZyICa3ZBAXEgAkEBdGtBPmoLIgI2AhwgAkECdEGkjcAAaiEEIAAhAwJAAkACQAJAQcCQwAAoAgAiAEEBIAJ0IgVxBEAgBCgCACEAIAIQywEhAiAAEOEBIAFHDQEgACECDAILQcCQwAAgACAFcjYCACAEIAM2AgAgAyAENgIYDAMLIAEgAnQhBANAIAAgBEEddkEEcWpBEGoiBSgCACICRQ0CIARBAXQhBCACIgAQ4QEgAUcNAAsLIAIoAggiACADNgIMIAIgAzYCCCADIAI2AgwgAyAANgIIIANBADYCGA8LIAUgAzYCACADIAA2AhgLIAMgAzYCCCADIAM2AgwLEAAgACABIAIgA0HeABD8AQsQACAAIAEgAiADQd8AEPwBCxAAIAAgASACIANB4AAQ/AELEAAgACABIAIgA0HhABD8AQsQACAAIAEgAiADQeIAEP4BCxAAIAAgASACIANB4wAQ/gELYAEMf0GsjsAAKAIAIgIEQEGkjsAAIQYDQCACIgEoAgghAiABKAIEIQMgASgCACEEIAFBDGooAgAaIAEhBiAFQQFqIQUgAg0ACwtB5JDAAEH/HyAFIAVB/x9NGzYCAEEACxAAIAAgASACIANB5AAQ/QELEAAgACABIAIgA0HlABD9AQsMACAAIAFBywAQ9wELDAAgACABQcwAEPcBCwwAIAAgAUHNABD3AQsMACAAIAFBzgAQ9wELDAAgACABQc8AEPcBCwwAIAAgAUHQABD3AQv7AQIBfgJ/AkACQAJAIABFDQAgACgCAA0BIAAtAAQhBSAAEAIgAUUNACABKAIADQEgAS0ABCEGIAEQAiACRQ0AIAIoAgANASACLQAEIQEgAhACIANFDQAgAygCAA0BIANBADYCACADKQIAIQQgAxACQQhBBBDQASIARQ0CIAAgBkEMdCAFQRJ0ciABQQZ0ciICIARCIIinIARCI4inQSBxckH/AXFyIgFBGHQgAkEIdEGAgPwHcXIgAUEIdkGA/gNxIAFBGHZyciIBQQh2QYCA/AdxIAFBgP7/B3FBCHZyrUIghjcCACAADwsQ3wEACxDgAQALQQhBBBDlAQAL+gECAX4CfwJAAkACQCAARQ0AIAAoAgANASAALQAEIQUgABACIAFFDQAgASgCAA0BIAEtAAQhBiABEAIgAkUNACACKAIADQEgAi0ABCEBIAIQAiADRQ0AIAMoAgANASADQQA2AgAgAykCACEEIAMQAkEIQQQQ0AEiAEUNAiAAIARCI4inQSBxIAZBDHQgBUESdHIgAUEGdHIiAiAEQhyIp0EQcXJyIgFBGHQgAkEIdEGAgPwHcXIgAUEIdkGA/gNxIAFBGHZyciIBQQh2QYCA/AdxIAFBgP7/B3FBCHZyrUIghjcCACAADwsQ3wEACxDgAQALQQhBBBDlAQALDwAgACABIAIgA0ESEPgBCw8AIAAgASACIANBGBD4AQsPACAAIAEgAiADQRwQ+AELDwAgACABIAIgA0EdEPgBCw8AIAAgASACIANBIhD4AQsPACAAIAEgAiADQSMQ+AELDwAgACABIAIgA0EoEPgBCw8AIAAgASACIANBKhD4AQsPACAAIAEgAiADQSwQ+AELDwAgACABIAIgA0E4EPgBCxAAIAAgASACIANB5gAQ+AELEAAgACABIAIgA0HnABD4AQsQACAAIAEgAiADQegAEPgBCxAAIAAgASACIANB6QAQ+AELEAAgACABIAIgA0HqABD4AQsQACAAIAEgAiADQesAEPgBC4YCAgN/AX4jAEEwayICJAAgASgCBEUEQCABKAIMIQMgAkEQaiIEQQA2AgAgAkKAgICAEDcDCCACIAJBCGo2AhQgAkEoaiADQRBqKQIANwMAIAJBIGogA0EIaikCADcDACACIAMpAgA3AxggAkEUaiACQRhqEAMaIAFBCGogBCgCADYCACABIAIpAwg3AgALIAEpAgAhBSABQoCAgIAQNwIAIAJBIGoiAyABQQhqIgEoAgA2AgAgAUEANgIAIAIgBTcDGEEMQQQQ0AEiAUUEQEEMQQQQ5QEACyABIAIpAxg3AgAgAUEIaiADKAIANgIAIABB6InAADYCBCAAIAE2AgAgAkEwaiQAC+YBAQJ/AkACQAJAIABFDQAgACgCAA0BIAAtAAQhBCAAEAIgAUUNACABKAIADQEgAS0ABCEFIAEQAiACRQ0AIAIoAgANASACLQAEIQEgAhACIANFDQAgAygCAA0BIAMtAAQhAiADEAJBCEEEENABIgBFDQIgACAFQQx0IARBEnRyIAFBBnRyIgMgAkEFdEEgcXIiAUEYdCADQQh0QYCA/AdxciABQQh2QYD+A3EgAUEYdnJyIgFBCHZBgICAB3EgAUGA/v8HcUEIdnKtQiCGNwIAIAAPCxDfAQALEOABAAtBCEEEEOUBAAvgAQECfwJAAkACQCAARQ0AIAAoAgANASAALQAEIQQgABACIAFFDQAgASgCAA0BIAEtAAQhBSABEAIgAkUNACACKAIADQEgAi0ABCEBIAIQAiADRQ0AIAMoAgANASADLQAEIQIgAxACQQhBBBDQASIARQ0CIAAgAiAFQQx0IARBEnRyIAFBBnRyIgNyIgFBGHQgA0EIdEGAgPwHcXIgAUEIdkGA/gNxIAFBGHZyciIBQQh2QYCA/AdxIAFBgP7/B3FBCHZyrUIghjcCACAADwsQ3wEACxDgAQALQQhBBBDlAQALCgAgAEHVABD1AQsKACAAQdYAEPUBCwoAIABB1wAQ9QELCgAgAEHaABD1AQsKACAAQdsAEPUBCwoAIABB3AAQ9QELCgAgAEHdABD1AQsNACAAIAEgAkEBEPQBCw0AIAAgASACQQIQ9AELDQAgACABIAJBAxD0AQsNACAAIAEgAkEEEPQBCw0AIAAgASACQQUQ9AELDQAgACABIAJBBhD0AQsNACAAIAEgAkEHEPQBCw0AIAAgASACQQgQ9AELDQAgACABIAJBCRD0AQsNACAAIAEgAkELEPQBCw0AIAAgASACQQ0Q9AELDQAgACABIAJBDhD0AQsNACAAIAEgAkEPEPQBCw0AIAAgASACQRAQ9AELDQAgACABIAJBERD0AQsNACAAIAEgAkEXEPQBCw0AIAAgASACQSEQ9AELDQAgACABIAJBJhD0AQsNACAAIAEgAkEnEPQBCw0AIAAgASACQSkQ9AELDQAgACABIAJBKxD0AQsNACAAIAEgAkEtEPQBCw0AIAAgASACQS4Q9AELDQAgACABIAJBLxD0AQsNACAAIAEgAkEwEPQBCw0AIAAgASACQTEQ9AELDQAgACABIAJBNRD0AQsNACAAIAEgAkE3EPQBC8cBAQF/AkACQAJAIABBwAFxRQRAIAFBwAFxIAJBwAFxcg0DQQRBARDQASIDRQ0BIAMgAkEGdEHA/wBxIAFBDHRBgOA/cSAAQRJ0QYCA8B9xcnIiAEEIdEGAgPwHcSACQR50ciAAQQh2QYD+A3EgAEEYdnJyIgBBCHZBgICABnEgAEGA/v8HcUEIdnJBCHQ2AABBCEEEENABIgBFDQIgACADNgIEIABBADYCACAADwsMAgtBBEEBEOUBAAtBCEEEEOUBAAsQ3AEAC8QBAQJ/AkACQAJAIABFDQAgACgCAA0BIAAtAAQhAyAAEAIgAUUNACABKAIADQEgAS0ABCEEIAEQAiACRQ0AIAIoAgANASACLQAEIQAgAhACQQhBBBDQASIBRQ0CIAEgBEEMdCADQRJ0ciAAQQZ0ciICQQh0QYCA/AdxIABBHnRyIAJBCHZBgP4DcSACQRh2cnIiAEEIdkGAgIAGcSAAQYD+/wdxQQh2cq1CIIY3AgAgAQ8LEN8BAAsQ4AEAC0EIQQQQ5QEAC8kBAQF/IAIQBSECAkACQAJAIABBwAFxRQRAIAFBwAFxDQFBBEEBENABIgNFDQIgAyACQf//A3EgAUEMdEGA4D9xIABBEnRBgIDwH3FyciIAQQh0QYCA/AdxIAJBGHRyIABBCHZBgP4DcSAAQRh2cnIiAEEIdkGAgPwHcSAAQYD+/wdxQQh2ckEIdEHKAHI2AABBCEEEENABIgBFDQMgACADNgIEIABBADYCACAADwsQ3AEACxDcAQALQQRBARDlAQALQQhBBBDlAQALwQEBAn8CQAJAAkAgAEUNACAAKAIADQEgAC0ABCEDIAAQAiABRQ0AIAEoAgANASABLQAEIQQgARACIAJFDQAgAigCAA0BIAIvAQQhACACEAJBCEEEENABIgFFDQIgASAEQQx0IANBEnRyIAByIgJBCHRBgID8B3EgAEEYdHIgAkEIdkGA/gNxIAJBGHZyciIAQQh2QYCA/AdxIABBgP7/B3FBCHZyrUIghjcCACABDwsQ3wEACxDgAQALQQhBBBDlAQALywEBAn8jAEEgayIDJAACQAJAIAEgASACaiIBSw0AQQggACgCACICQQF0IgQgASABIARJGyIBIAFBCE0bIgFBf3NBH3YhBAJAIAIEQCADQQE2AhggAyACNgIUIAMgAEEEaigCADYCEAwBCyADQQA2AhgLIAMgASAEIANBEGoQeCADKAIEIQIgAygCAEUEQCAAIAE2AgAgACACNgIEDAILIANBCGooAgAiAEGBgICAeEYNASAARQ0AIAIgABDlAQALEKIBAAsgA0EgaiQAC4gCAQJ/IwBBIGsiBSQAQaCNwABBoI3AACgCACIGQQFqNgIAAkACQCAGQQBIDQBB6JDAAEHokMAAKAIAQQFqIgY2AgAgBkECSw0AIAUgBDoAGCAFIAM2AhQgBSACNgIQIAVBsIrAADYCDCAFQaSIwAA2AghBkI3AACgCACICQQBIDQBBkI3AACACQQFqIgI2AgBBkI3AAEGYjcAAKAIABH8gBSAAIAEoAhARBAAgBSAFKQMANwMIQZiNwAAoAgAgBUEIakGcjcAAKAIAKAIUEQQAQZCNwAAoAgAFIAILQQFrNgIAIAZBAUsNACAEDQELAAsjAEEQayICJAAgAiABNgIMIAIgADYCCAALtQEBAX8CQAJAAkAgAEUNACAAKAIADQEgAC0ABCEDIAAQAiABRQ0AIAEoAgANASABLQAEIQAgARACIAIQBSECQQhBBBDQASIBRQ0CIAEgAkH//wNxIABBDHQgA0ESdHJyIgBBCHRBgID8B3EgAkEYdHIgAEEIdkGA/gNxIABBGHZyciIAQQh2QYCA/AdxIABBgP7/B3FBCHZyrUIghjcCACABDwsQ3wEACxDgAQALQQhBBBDlAQALuwEBAX8CQAJAAkAgAUEBa0EESQRAIABBwAFxDQFBBEEBENABIgJFDQIgAiABQQh0QYCA/AdxIAFBGHRyIABBEnRBgIDwH3EgAXIiAEEIdkGA/gNxIABBGHZyciIAQQh2QYCA/AdxIABBgP7/B3FBCHZyQQh0QcwAcjYAAEEIQQQQ0AEiAEUNAyAAIAI2AgQgAEEANgIAIAAPC0HwhsAAQRkQ3gEACxDcAQALQQRBARDlAQALQQhBBBDlAQALowcBCX8CQCACBEACfwJAAkACQCABQQBOBEAgAygCCEUNAiADKAIEIgYNASABDQMgAgwECyAAQQhqQQA2AgAMBQsCfyADKAIAIQkCQAJAAkAgAkEJTwRAIAEgAhAGIgsNAUEADAQLQQhBCBDNASEKQRRBCBDNASEHQRBBCBDNASEDQQBBEEEIEM0BQQJ0ayIGQYCAfCADIAcgCmpqa0F3cUEDayIDIAMgBksbIAFNDQFBECABQQRqQRBBCBDNAUEFayABSxtBCBDNASEEIAkQ6gEiBSAFEOEBIgMQ5wEhCAJAAkACQAJAAkACQAJAIAUQ1QFFBEAgAyAETw0BIAhB0JDAACgCAEYNAiAIQcyQwAAoAgBGDQMgCBDSAQ0HIAgQ4QEiCiADaiIHIARJDQcgByAEayEMIApBgAJJDQQgCBAnDAULIAUQ4QEhAyAEQYACSQ0GIAMgBGtBgYAISSAEQQRqIANNcQ0FIAUoAgAaIARBH2pBgIAEEM0BGgwGC0EQQQgQzQEgAyAEayIGSw0EIAUgBBDnASEDIAUgBBCwASADIAYQsAEgAyAGEAQMBAtByJDAACgCACADaiIDIARNDQQgBSAEEOcBIQYgBSAEELABIAYgAyAEayIDQQFyNgIEQciQwAAgAzYCAEHQkMAAIAY2AgAMAwtBxJDAACgCACADaiIDIARJDQMCQEEQQQgQzQEgAyAEayIHSwRAIAUgAxCwAUEAIQdBACEGDAELIAUgBBDnASIGIAcQ5wEhAyAFIAQQsAEgBiAHEMwBIAMgAygCBEF+cTYCBAtBzJDAACAGNgIAQcSQwAAgBzYCAAwCCyAIQQxqKAIAIgYgCEEIaigCACIDRwRAIAMgBjYCDCAGIAM2AggMAQtBvJDAAEG8kMAAKAIAQX4gCkEDdndxNgIAC0EQQQgQzQEgDE0EQCAFIAQQ5wEhAyAFIAQQsAEgAyAMELABIAMgDBAEDAELIAUgBxCwAQsgBQ0DCyABEAEiA0UNASADIAkgBRDhAUF4QXwgBRDVARtqIgMgASABIANLGxDmASAJEAIMAwsgCyAJIAYgASABIAZLGxDmARogCRACCyALDAELIAUQ1QEaIAUQ6QELDAILIAENACACDAELIAEgAhDQAQsiAwRAIAAgAzYCBCAAQQhqIAE2AgAgAEEANgIADwsgACABNgIEIABBCGogAjYCAAwBCyAAIAE2AgQgAEEIakEANgIACyAAQQE2AgALpAEBAX8CQAJAAkAgAEUNACAAKAIADQEgAC0ABCECIAAQAiABRQ0AIAEoAgANASABKAIEIQAgARACQQhBBBDQASIBRQ0CIAEgAEEIdEGAgPwHcSAAQRh0ciAAIAJBEnRyIgBBCHZBgP4DcSAAQRh2cnIiAEEIdkGAgPwHcSAAQYD+/wdxQQh2cq1CIIY3AgAgAQ8LEN8BAAsQ4AEAC0EIQQQQ5QEAC6IBAQF/AkACQAJAIAAEQCAAKAIADQEgAC0ABCECIAAQAiABQQFrQQRPDQJBCEEEENABIgBFDQMgACABQQh0QYCA/AdxIAFBGHRyIAJBEnQgAXIiAUEIdkGA/gNxIAFBGHZyciIBQQh2QYCA/AdxIAFBgP7/B3FBCHZyrUIghjcCACAADwsQ3wEACxDgAQALQfCGwABBGRDeAQALQQhBBBDlAQALpAEBA38jAEEwayICJAAgASgCBEUEQCABKAIMIQMgAkEQaiIEQQA2AgAgAkKAgICAEDcDCCACIAJBCGo2AhQgAkEoaiADQRBqKQIANwMAIAJBIGogA0EIaikCADcDACACIAMpAgA3AxggAkEUaiACQRhqEAMaIAFBCGogBCgCADYCACABIAIpAwg3AgALIABB6InAADYCBCAAIAE2AgAgAkEwaiQACwsAIAAgAUEKEPkBCwsAIAAgAUEMEPkBCwsAIAAgAUEUEPkBCwsAIAAgAUEWEPkBCwsAIAAgAUEZEPkBCwsAIAAgAUEbEPkBCwsAIAAgAUEeEPkBCwsAIAAgAUEfEPkBCwsAIAAgAUEkEPkBCwsAIAAgAUEyEPkBC4IBAQJ/AkACQCAABEAgACgCAA0BIAAtAAQhASAAEAJBACEAAkAgAUEYcQ0AQfcBIAFBBHNBB3EiAnZBAXFFDQBBCEEEENABIgBFDQMgACACQQN0QbCGwABqKQMAIAFBBXZBAXGtQiiGhDcCAAsgAA8LEN8BAAsQ4AEAC0EIQQQQ5QEAC4ABAQF/AkACQAJAIABFDQAgACgCAA0BIAAtAAQhAiAAEAIgAUUNACABKAIADQEgAS0ABCEAIAEQAkEIQQQQ0AEiAUUNAiABIABBFHQgAEEMdCACQRJ0ckEIdnJBgP7DB3FBCHatQiCGNwIAIAEPCxDfAQALEOABAAtBCEEEEOUBAAuCAQEBfwJAAkAgAARAIAAoAgANASAAKAIEIQEgABACQQhBBBDQASIARQ0CIAAgAUEIdEGAgPwHcSABQRh0ciABQQh2QYD+A3EgAUEYdnJyIgFBCHZBgID8B3EgAUGA/v8HcUEIdnKtQiCGNwIAIAAPCxDfAQALEOABAAtBCEEEEOUBAAuCAQECfwJAAkAgAARAIAAoAgBBf0YNASAAQQZqLQAAIQEgAC8ABCECQQhBBBDQASIARQ0CIABBADYCACAAIAIgAUEQdHIiAUEQdEGAgAxxIAFBCHRBgIZ8cSIBQQh2QYD+A3EgAUEYdnJyNgIEIAAPCxDfAQALEOABAAtBCEEEEOUBAAt8AQJ/AkACQCAABEAgACgCAEF/Rg0BIABBBmotAAAhASAALwAEIQJBCEEEENABIgBFDQIgAEEANgIAIAAgAiABQRB0ciIBQRh0IAFBCHRBgID8B3FyIAFBCHZBgP4DcXJBCHY2AgQgAA8LEN8BAAsQ4AEAC0EIQQQQ5QEAC3QBAn8CQAJAIAAEQCAAKAIAQX9GDQEgAEEGai0AACEBIAAvAAQhAkEIQQQQ0AEiAEUNAiAAQQA2AgAgACACIAFBEHRyIgFBGHQgAUEIdEGAgMAHcXJBFHZBP3E6AAQgAA8LEN8BAAsQ4AEAC0EIQQQQ5QEAC3QBAn8CQAJAIAAEQCAAKAIAQX9GDQEgAEEGai0AACEBIAAvAAQhAkEIQQQQ0AEiAEUNAiAAQQA2AgAgACACIAFBEHRyQQh0QYCAvHhxIgFBCHYgAUEYdnJBBnY6AAQgAA8LEN8BAAsQ4AEAC0EIQQQQ5QEAC3EBAn8CQAJAIAAEQCAAKAIAQX9GDQEgAEEGai0AACEBIAAvAAQhAkEIQQQQ0AEiAEUNAiAAQQA2AgAgACACIAFBEHRyQQh0QYCAvHhxIgFBCHYgAUEYdnI7AQQgAA8LEN8BAAsQ4AEAC0EIQQQQ5QEAC4YBAQJ/AkACQCABBEAgASgCACICQX9GDQEgASACQQFqNgIAIAEoAgQoAAAiAkEYdEEWdUHggsAAaigCACACQYB+cXIhA0EEQQEQ0AEiAkUNAiACIAM2AAAgASABKAIAQQFrNgIAIABBBDYCBCAAIAI2AgAPCxDfAQALEOABAAtBBEEBEOUBAAtyACMAQTBrIgEkAEHojMAALQAABEAgAUEUakECNgIAIAFBHGpBATYCACABQfSIwAA2AhAgAUEANgIIIAFBAjYCJCABIAA2AiwgASABQSBqNgIYIAEgAUEsajYCICABQQhqQZyJwAAQqAEACyABQTBqJAALYwEBfgJAAkAgAARAIAAoAgANASAAQQA2AgAgACkCACEBIAAQAkEIQQQQ0AEiAEUNAiAAQQA2AgAgACABQiCIpyABQiOIp0EgcXI6AAQgAA8LEN8BAAsQ4AEAC0EIQQQQ5QEACwkAIABBAhDyAQsJACAAQRMQ+wELCQAgAEEVEPsBCwkAIABBGhD7AQsJACAAQRAQ8gELCQAgAEEgEPsBCwkAIABBJRD7AQsJACAAQTQQ+wELCQAgAEE2EPsBCwoAIABB2AAQ+wELCgAgAEHZABD7AQtUAQF/IwBBIGsiAiQAIAIgACgCADYCBCACQRhqIAFBEGopAgA3AwAgAkEQaiABQQhqKQIANwMAIAIgASkCADcDCCACQQRqIAJBCGoQAyACQSBqJAALUgEBfwJAAkAgAARAIAAoAgANASAALQAEIQEgABACQQhBBBDQASIARQ0CIAAgAUECdEH8AXGtQiCGNwIAIAAPCxDfAQALEOABAAtBCEEEEOUBAAtVAQF/IwBBIGsiASQAIAFBDGpBATYCACABQRRqQQA2AgAgAUGIi8AANgIQIAFBADYCACABQSs2AhwgAUGkiMAANgIYIAEgAUEYajYCCCABIAAQqAEAC0cBAn8CQEEEQQEQ0AEiAQRAIAFBMzYAAEEIQQQQ0AEiAEUNASAAIAE2AgQgAEEANgIAIAAPC0EEQQEQ5QEAC0EIQQQQ5QEAC0cBAX8gAiAAKAIAIgAoAgAgACgCCCIDa0sEQCAAIAMgAhB0IAAoAgghAwsgACgCBCADaiABIAIQ5gEaIAAgAiADajYCCEEAC0YBAX8CQCAAQSZJBEBBDEEEENABIgJFDQEgAiAAOgAIIAIgATYCBCACQQA2AgAgAg8LQYmHwABBGRDeAQALQQxBBBDlAQALSgEBfyMAQSBrIgAkACAAQRRqQQE2AgAgAEEcakEANgIAIABB8IrAADYCECAAQcCKwAA2AhggAEEANgIIIABBCGpB+IrAABCoAQALOAEBfwJAIABB/wFxQT9NBEBBCEEEENABIgFFDQEgASAAOgAEIAFBADYCAAsgAQ8LQQhBBBDlAQALCwAgACABQQcQ8QELCwAgACABQQgQ8QELRgECfyABKAIEIQIgASgCACEDQQhBBBDQASIBRQRAQQhBBBDlAQALIAEgAjYCBCABIAM2AgAgAEH4icAANgIEIAAgATYCAAs5AAJAAn8gAkGAgMQARwRAQQEgACACIAEoAhARAgANARoLIAMNAUEACw8LIAAgA0EAIAEoAgwRAAALsQIBAn8jAEEgayICJAAgAkEBOgAYIAIgATYCFCACIAA2AhAgAkGQi8AANgIMIAJBiIvAADYCCCMAQRBrIgAkAAJAIAJBCGoiASgCDCICBEAgASgCCCIDRQ0BIAAgAjYCCCAAIAE2AgQgACADNgIAIwBBEGsiASQAIAAoAgAiAkEUaigCACEDAkACfwJAAkAgAkEMaigCAA4CAAEDCyADDQJBACECQaSIwAAMAQsgAw0BIAIoAggiAygCBCECIAMoAgALIQMgASACNgIEIAEgAzYCACABQZyKwAAgACgCBCIBKAIIIAAoAgggAS0AEBB1AAsgAUEANgIEIAEgAjYCDCABQYiKwAAgACgCBCIBKAIIIAAoAgggAS0AEBB1AAtB2InAABCeAQALQciJwAAQngEACycBAX8CQCAABEAgACgCAA0BIAAoAgQgABACEAIPCxDfAQALEOABAAsuAAJAIAAEQCAAKAIADQEgAEEANgIAIABBBWogAUEARzoAAA8LEN8BAAsQ4AEACyUBAX8CQCAABEAgACgCAA0BIAAtAAQgABACDwsQ3wEACxDgAQALKwACQCAABEAgACgCAA0BIABBADYCACAAIAFBAEc6AAQPCxDfAQALEOABAAssAQF/QQhBBBDQASIBRQRAQQhBBBDlAQALIAFBADYCACABIABBP3E6AAQgAQsJACAAQQUQ8AELCQAgAEEIEPABCycAIAAgACgCBEEBcSABckECcjYCBCAAIAFqIgAgACgCBEEBcjYCBAseAAJAIAAEQCAAKAIADQEgABACDwsQ3wEACxDgAQALBwBBCxD6AQsHAEEKEPoBCwcAQQgQ+gELBwBBDxD6AQsHAEEGEPoBCwcAQQkQ+gELBwBBBxD6AQsHAEEMEPoBCwcAQQIQ+gELBwBBARD6AQsHAEEDEPoBCwcAQQ0Q+gELBwBBDhD6AQsHAEEFEPoBCwcAQQQQ+gELBwBBEBD6AQsHAEEAEPoBCyIAAkAgAARAIAAoAgBBf0YNASAALQAEDwsQ3wEACxDgAQALIgACQCAABEAgACgCAEF/Rg0BIAAoAgQPCxDfAQALEOABAAsgAQF/AkAgAEEEaigCACIBRQ0AIAAoAgBFDQAgARACCwsjACACIAIoAgRBfnE2AgQgACABQQFyNgIEIAAgAWogATYCAAsiAQF/QQhBBBDQASIARQRAQQhBBBDlAQALIABCADcCACAACx4AIAAgAUEDcjYCBCAAIAFqIgAgACgCBEEBcjYCBAsUACAAKAIABEAgAEEEaigCABACCwsZAQF/IAAoAhAiAQR/IAEFIABBFGooAgALCxIAQRkgAEEBdmtBACAAQR9HGwsWACAAIAFBAXI2AgQgACABaiABNgIACxAAIAAgAWpBAWtBACABa3ELCwAgAQRAIAAQAgsLDwAgAEEBdCIAQQAgAGtyCwgAIAAgARAGCxMAIABB+InAADYCBCAAIAE2AgALDQAgAC0ABEECcUEBdguHDwENfwJ/IAAoAgAhCSAAKAIEIQUCQAJAIAEiBigCCCIKQQFHIAEoAhAiAEEBR3FFBEACQCAAQQFHDQAgBSAJaiEHIAZBFGooAgBBAWohAyAJIQEDQAJAIAEhACADQQFrIgNFDQAgACAHRg0CAn8gACwAACIBQQBOBEAgAUH/AXEhAiAAQQFqDAELIAAtAAFBP3EhCCABQR9xIQIgAUFfTQRAIAJBBnQgCHIhAiAAQQJqDAELIAAtAAJBP3EgCEEGdHIhCCABQXBJBEAgCCACQQx0ciECIABBA2oMAQsgAkESdEGAgPAAcSAALQADQT9xIAhBBnRyciICQYCAxABGDQMgAEEEagsiASAEIABraiEEIAJBgIDEAEcNAQwCCwsgACAHRg0AIAAsAAAiAUEATiABQWBJciABQXBJckUEQCABQf8BcUESdEGAgPAAcSAALQADQT9xIAAtAAJBP3FBBnQgAC0AAUE/cUEMdHJyckGAgMQARg0BCwJAAkAgBEUNACAEIAVPBEBBACEAIAQgBUYNAQwCC0EAIQAgBCAJaiwAAEFASA0BCyAJIQALIAQgBSAAGyEFIAAgCSAAGyEJCyAKRQ0CIAZBDGooAgAhDAJAIAVBEE8EQAJ/QQAhAkEAIQQCQAJAIAkiAEEDakF8cSIBIABrIgcgBUsgB0EES3INACAFIAdrIgpBBEkNACAKQQNxIQtBACEDAkAgACABRg0AIAdBA3EhAgJAIAEgAEF/c2pBA0kEQCAAIQEMAQsgB0F8cSEIIAAhAQNAIAMgASwAAEG/f0pqIAEsAAFBv39KaiABLAACQb9/SmogASwAA0G/f0pqIQMgAUEEaiEBIAhBBGsiCA0ACwsgAkUNAANAIAMgASwAAEG/f0pqIQMgAUEBaiEBIAJBAWsiAg0ACwsgACAHaiEAAkAgC0UNACAAIApBfHFqIgEsAABBv39KIQQgC0EBRg0AIAQgASwAAUG/f0pqIQQgC0ECRg0AIAQgASwAAkG/f0pqIQQLIApBAnYhByADIARqIQIDQCAAIQMgB0UNAkHAASAHIAdBwAFPGyIEQQNxIQggBEECdCELAkAgBEH8AXEiCkUEQEEAIQEMAQsgAyAKQQJ0aiENQQAhAQNAIABFDQEgASAAKAIAIg5Bf3NBB3YgDkEGdnJBgYKECHFqIABBBGooAgAiAUF/c0EHdiABQQZ2ckGBgoQIcWogAEEIaigCACIBQX9zQQd2IAFBBnZyQYGChAhxaiAAQQxqKAIAIgFBf3NBB3YgAUEGdnJBgYKECHFqIQEgAEEQaiIAIA1HDQALCyAHIARrIQcgAyALaiEAIAFBCHZB/4H8B3EgAUH/gfwHcWpBgYAEbEEQdiACaiECIAhFDQALAkAgA0UEQEEAIQEMAQsgAyAKQQJ0aiEAIAhBAWtB/////wNxIgFBAWoiBEEDcSEDAkAgAUEDSQRAQQAhAQwBCyAEQfz///8HcSEIQQAhAQNAIAEgACgCACIEQX9zQQd2IARBBnZyQYGChAhxaiAAQQRqKAIAIgFBf3NBB3YgAUEGdnJBgYKECHFqIABBCGooAgAiAUF/c0EHdiABQQZ2ckGBgoQIcWogAEEMaigCACIBQX9zQQd2IAFBBnZyQYGChAhxaiEBIABBEGohACAIQQRrIggNAAsLIANFDQADQCABIAAoAgAiBEF/c0EHdiAEQQZ2ckGBgoQIcWohASAAQQRqIQAgA0EBayIDDQALCyABQQh2Qf+B/AdxIAFB/4H8B3FqQYGABGxBEHYgAmoMAgtBACAFRQ0BGiAFQQNxIQEgBUEBa0EDTwRAIAVBfHEhAwNAIAIgACwAAEG/f0pqIAAsAAFBv39KaiAALAACQb9/SmogACwAA0G/f0pqIQIgAEEEaiEAIANBBGsiAw0ACwsgAUUNAANAIAIgACwAAEG/f0pqIQIgAEEBaiEAIAFBAWsiAQ0ACwsgAgshAQwBCyAFRQRAQQAhAQwBCyAFQQNxIQICQCAFQQFrQQNJBEBBACEBIAkhAAwBCyAFQXxxIQNBACEBIAkhAANAIAEgACwAAEG/f0pqIAAsAAFBv39KaiAALAACQb9/SmogACwAA0G/f0pqIQEgAEEEaiEAIANBBGsiAw0ACwsgAkUNAANAIAEgACwAAEG/f0pqIQEgAEEBaiEAIAJBAWsiAg0ACwsgASAMSQRAIAwgAWsiASEDAkACQAJAIAYtACAiAEEAIABBA0cbQQNxIgBBAWsOAgABAgtBACEDIAEhAAwBCyABQQF2IQAgAUEBakEBdiEDCyAAQQFqIQAgBkEEaigCACEBIAYoAhwhAiAGKAIAIQYCQANAIABBAWsiAEUNASAGIAIgASgCEBECAEUNAAtBAQwFC0EBIQAgAkGAgMQARg0CIAYgCSAFIAEoAgwRAAANAkEAIQADQEEAIAAgA0YNBRogAEEBaiEAIAYgAiABKAIQEQIARQ0ACyAAQQFrIANJDAQLDAILIAYoAgAgCSAFIAYoAgQoAgwRAAAhAAsgAAwBCyAGKAIAIAkgBSAGKAIEKAIMEQAACwsKAEEAIABrIABxCwsAIAAtAARBA3FFCwwAIAAgAUEDcjYCBAsNACAAKAIAIAAoAgRqCw4AIAAoAgAaA0AMAAsACwsAIAA1AgAgARASCwsAIAAxAAAgARASCwsAIAAzAQAgARASC3IBAn8jAEEQayIBJAAgAUEiNgIMIAFBgIDAADYCCCMAQSBrIgAkACAAQQxqQQE2AgAgAEEUakEBNgIAIABBiIvAADYCCCAAQQA2AgAgAEETNgIcIAAgAUEIajYCGCAAIABBGGo2AhAgAEG4gMAAEKgBAAsLACAAIwBqJAAjAAsJACAAIAEQAAALDQBBoofAAEEbEN4BAAsOAEG9h8AAQc8AEN4BAAsKACAAKAIEQXhxCwoAIAAoAgRBAXELCgAgACgCDEEBcQsKACAAKAIMQQF2CxkAIAAgAUGMjcAAKAIAIgBBBCAAGxEEAAALswIBB38CQCACIgRBD00EQCAAIQIMAQsgAEEAIABrQQNxIgNqIQUgAwRAIAAhAiABIQYDQCACIAYtAAA6AAAgBkEBaiEGIAJBAWoiAiAFSQ0ACwsgBSAEIANrIghBfHEiB2ohAgJAIAEgA2oiA0EDcSIEBEAgB0EATA0BIANBfHEiBkEEaiEBQQAgBEEDdCIJa0EYcSEEIAYoAgAhBgNAIAUgBiAJdiABKAIAIgYgBHRyNgIAIAFBBGohASAFQQRqIgUgAkkNAAsMAQsgB0EATA0AIAMhAQNAIAUgASgCADYCACABQQRqIQEgBUEEaiIFIAJJDQALCyAIQQNxIQQgAyAHaiEBCyAEBEAgAiAEaiEDA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgIgA0kNAAsLIAALBwAgACABagsHACAAIAFrCwcAIABBCGoLBwAgAEEIawsEAEEECwwAQtbkq/72/7CeagsNAELKvdvazqCx5od/Cw0AQsi14M/KhtvTiX8LAgALJQACQCAABEAgACgCAEF/Rg0BIAAgAWotAAAPCxDfAQALEOABAAs9AAJAAkAgAARAIAEgAk8NASAAKAIADQIgAEEANgIAIAAgAToABA8LEN8BAAtBkIbAAEEZEN4BAAsQ4AEAC2MBAn8CQAJAIAAEQCAAKAIAQX9GDQEgAEEGai0AACECIAAvAAQhA0EIQQQQ0AEiAEUNAiAAQQA2AgAgACADIAJBEHRyIAF2QT9xOgAEIAAPCxDfAQALEOABAAtBCEEEEOUBAAu3AgECfyMAQTBrIgQkAAJAAkACQAJAIABBwAFxRQRAIAFBwAFxDQEgBCACOwEOIAJB//8DcUGAIE8NAkEEQQEQ0AEiBUUNAyAFIAJB//8DcSABQQx0QYDgP3EgAEESdEGAgPAfcXJyIgBBCHRBgID8B3EgAkEYdHIgAEEIdkGA/gNxIABBGHZyciIAQQh2QYCA/AdxIABBgP7/B3FBCHZyQQh0IANyNgAAQQhBBBDQASIARQ0EIAAgBTYCBCAAQQA2AgAgBEEwaiQAIAAPCxDcAQALENwBAAsgBEEcakECNgIAIARBJGpBATYCACAEQbiBwAA2AhggBEEANgIQIARBATYCLCAEIARBKGo2AiAgBCAEQQ5qNgIoIARBEGpByIHAABCoAQALQQRBARDlAQALQQhBBBDlAQALygEBAX8CQAJAAkAgAEHAAXFFBEAgAUHAAXEgAkHAAXFyDQNBBEEBENABIgRFDQEgBCACQQZ0QcD/AHEgAUEMdEGA4D9xIABBEnRBgIDwH3FyciIAQQh0QYCA/AdxIAJBHnRyIABBCHZBgP4DcSAAQRh2cnIiAEEIdkGAgIAGcSAAQYD+/wdxQQh2ckEIdCADcjYAAEEIQQQQ0AEiAEUNAiAAIAQ2AgQgAEEANgIAIAAPCwwCC0EEQQEQ5QEAC0EIQQQQ5QEACxDcAQAL9wEBAn8jAEEwayICJAAgAiAANgIMAkACQCAAQYCAgAhJBEBBBEEBENABIgNFDQEgAyAAQQh0QYCA/AdxIABBGHRyIABBCHZBgP4DcSAAQRh2cnIiAEEIdkGAgPwHcSAAQYD+/wdxQQh2ckEIdCABcjYAAEEIQQQQ0AEiAEUNAiAAIAM2AgQgAEEANgIAIAJBMGokACAADwsgAkEcakECNgIAIAJBJGpBATYCACACQcCCwAA2AhggAkEANgIQIAJBAjYCLCACIAJBKGo2AiAgAiACQQxqNgIoIAJBEGpB0ILAABCoAQALQQRBARDlAQALQQhBBBDlAQALxwIBAn8jAEEwayIFJAACQAJAAkACQCAAQcABcUUEQCABQcABcSACQcABcXINBCAFIAM6AA8gA0H/AXFBwABPDQFBBEEBENABIgZFDQIgBiACQQZ0QcD/AHEgAUEMdEGA4D9xIABBEnRBgIDwH3FyciIBIANB/wFxciIAQRh0IAFBCHRBgID8B3FyIABBCHZBgP4DcSAAQRh2cnIiAEEIdkGAgPwHcSAAQYD+/wdxQQh2ckEIdCAEcjYAAEEIQQQQ0AEiAEUNAyAAIAY2AgQgAEEANgIAIAVBMGokACAADwsMAwsgBUEcakECNgIAIAVBJGpBATYCACAFQfSAwAA2AhggBUEANgIQIAVBAzYCLCAFIAVBKGo2AiAgBSAFQQ9qNgIoIAVBEGpBhIHAABCoAQALQQRBARDlAQALQQhBBBDlAQALENwBAAuUAgECfyMAQTBrIgMkAAJAAkACQCAAQcABcUUEQCADIAE2AgwgAUGAgBBPDQFBBEEBENABIgRFDQIgBCABQQh0QYCA/AdxIAFBGHRyIABBEnRBgIDwH3EgAXIiAEEIdkGA/gNxIABBGHZyciIAQQh2QYCA/AdxIABBgP7/B3FBCHZyQQh0IAJyNgAAQQhBBBDQASIARQ0DIAAgBDYCBCAAQQA2AgAgA0EwaiQAIAAPCxDcAQALIANBHGpBAjYCACADQSRqQQE2AgAgA0H8gcAANgIYIANBADYCECADQQI2AiwgAyADQShqNgIgIAMgA0EMajYCKCADQRBqQYyCwAAQqAEAC0EEQQEQ5QEAC0EIQQQQ5QEAC9sBAQF/AkACQAJAIABBwAFxRQRAIAFBwAFxIAJBwAFxcg0DIANBwAFxDQNBBEEBENABIgVFDQEgBSACQQZ0QcD/AHEgAUEMdEGA4D9xIABBEnRBgIDwH3FyciIBIANB/wFxciIAQRh0IAFBCHRBgID8B3FyIABBCHZBgP4DcSAAQRh2cnIiAEEIdkGAgPwHcSAAQYD+/wdxQQh2ckEIdCAEcjYAAEEIQQQQ0AEiAEUNAiAAIAU2AgQgAEEANgIAIAAPCwwCC0EEQQEQ5QEAC0EIQQQQ5QEACxDcAQALjQEBAX8CQAJAAkAgAEHAAXFFBEAgAUHAAXENAUEEQQEQ0AEiA0UNAiADIAFBFHRBgIDAB3EgAEESdEGAgPAHcSABQQx0QYCAPHFyQQh2ciACcjYAAEEIQQQQ0AEiAEUNAyAAIAM2AgQgAEEANgIAIAAPCxDcAQALENwBAAtBBEEBEOUBAAtBCEEEEOUBAAspAQF/QQhBBBDQASIBRQRAQQhBBBDlAQALIAEgADoABCABQQA2AgAgAQtjAQF/AkACQCAAQcABcUUEQEEEQQEQ0AEiAkUNASACIABBCnRBgPgDcSABcjYAAEEIQQQQ0AEiAEUNAiAAIAI2AgQgAEEANgIAIAAPCxDcAQALQQRBARDlAQALQQhBBBDlAQALhQIBAX4CQAJAAkACQCADBEAgAygCAA0BIANBADYCACADKQIAIQUgAxACIAJBwAFxIABBwAFxIAFBwAFxcnINBEEEQQEQ0AEiA0UNAiADIAJBBnRBwP8AcSABQQx0QYDgP3EgAEESdEGAgPAfcXJyIgEgBUIgiKcgBUIjiKdBIHFyQf8BcXIiAEEYdCABQQh0QYCA/AdxciAAQQh2QYD+A3EgAEEYdnJyIgBBCHZBgID8B3EgAEGA/v8HcUEIdnJBCHQgBHI2AABBCEEEENABIgBFDQMgACADNgIEIABBADYCACAADwsQ3wEACxDgAQALQQRBARDlAQALQQhBBBDlAQALENwBAAvyAQEBfwJAAkACQAJAIAMEQCADKAIADQEgAy0ABCEFIAMQAiACQcABcSAAQcABcSABQcABcXJyDQRBBEEBENABIgNFDQIgAyACQQZ0QcD/AHEgAUEMdEGA4D9xIABBEnRBgIDwH3FyciIBIAVBBXRBIHFyIgBBGHQgAUEIdEGAgPwHcXIgAEEIdkGA/gNxIABBGHZyciIAQQh2QYCAgAdxIABBgP7/B3FBCHZyQQh0IARyNgAAQQhBBBDQASIARQ0DIAAgAzYCBCAAQQA2AgAgAA8LEN8BAAsQ4AEAC0EEQQEQ5QEAC0EIQQQQ5QEACxDcAQALhAIBAX4CQAJAAkACQCADBEAgAygCAA0BIANBADYCACADKQIAIQUgAxACIAJBwAFxIABBwAFxIAFBwAFxcnINBEEEQQEQ0AEiA0UNAiADIAVCI4inQSBxIAJBBnRBwP8AcSABQQx0QYDgP3EgAEESdEGAgPAfcXJyIgEgBUIciKdBEHFyciIAQRh0IAFBCHRBgID8B3FyIABBCHZBgP4DcSAAQRh2cnIiAEEIdkGAgPwHcSAAQYD+/wdxQQh2ckEIdCAEcjYAAEEIQQQQ0AEiAEUNAyAAIAM2AgQgAEEANgIAIAAPCxDfAQALEOABAAtBBEEBEOUBAAtBCEEEEOUBAAsQ3AEACwvhDAMAQYCAwAALqQZDaGVja1JlZ0lkIHdhcyBnaXZlbiBpbnZhbGlkIFJlZ0lkZnVlbC1hc20vc3JjL2xpYi5ycwAAACIAEAATAAAAbAAAACIAAABWYWx1ZSBgYCBvdXQgb2YgcmFuZ2UgZm9yIDYtYml0IGltbWVkaWF0ZQAAAEgAEAAHAAAATwAQACIAAAAiABAAEwAAAKQDAAAcAAAAYCBvdXQgb2YgcmFuZ2UgZm9yIDEyLWJpdCBpbW1lZGlhdGUASAAQAAcAAACUABAAIwAAACIAEAATAAAAqQMAABwAAABgIG91dCBvZiByYW5nZSBmb3IgMTgtYml0IGltbWVkaWF0ZQBIABAABwAAANgAEAAjAAAAIgAQABMAAACuAwAAHAAAAGAgb3V0IG9mIHJhbmdlIGZvciAyNC1iaXQgaW1tZWRpYXRlAEgAEAAHAAAAHAEQACMAAAAiABAAEwAAALMDAAAcAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAACAAAAAhAAAAIgAAACQAAAAlAAAAJgAAACcAAAAoAAAAKQAAACoAAAArAAAALAAAAC0AAAAuAAAALwAAADAAAAAxAAAAMgAAADMAAAA0AAAANQAAADYAAAA3AAAAOAAAADkAAAA6AAAAOwAAADwAAAA9AAAAPgAAAD8AAABAAAAAQQAAAEIAAABDAAAARwAAAEgAAABJAAAASgAAAEsAAABMAAAAUAAAAFEAAABSAAAAUwAAAFQAAABVAAAAVgAAAFcAAABYAAAAWQAAAFoAAABbAAAAXAAAAF0AAABeAAAAXwAAAGAAAABhAAAAcAAAAHEAAAByAAAAcwAAAHQAAAB1AAAAdgAAAHcAAAB4AAAAeQAAAJAAAACRAAAAkgAAAJMAAACUAAAAlQAAAJYAAACXAAAAmAAAAKAAAAChAAAAogAAAKMAAACkAAAApQAAAKYAAACnAAAAqAAAAKkAAACqAAAAqwAAAKwAAACtAAAAaW52YWxpZCBlbnVtIHZhbHVlIHBhc3NlZABBtIbAAAsRBAAAAAAAAAAFAAAAAAAAAAYAQdyGwAALjAYBAAAAAAAAAAIAAAAAAAAAAwAAAGludmFsaWQgZW51bSB2YWx1ZSBwYXNzZWRpbnZhbGlkIGVudW0gdmFsdWUgcGFzc2VkbnVsbCBwb2ludGVyIHBhc3NlZCB0byBydXN0cmVjdXJzaXZlIHVzZSBvZiBhbiBvYmplY3QgZGV0ZWN0ZWQgd2hpY2ggd291bGQgbGVhZCB0byB1bnNhZmUgYWxpYXNpbmcgaW4gcnVzdAUAAAAEAAAABAAAAAYAAAAHAAAACAAAAGNhbGxlZCBgT3B0aW9uOjp1bndyYXAoKWAgb24gYSBgTm9uZWAgdmFsdWVtZW1vcnkgYWxsb2NhdGlvbiBvZiAgYnl0ZXMgZmFpbGVkAAAATwQQABUAAABkBBAADQAAAGxpYnJhcnkvc3RkL3NyYy9hbGxvYy5yc4QEEAAYAAAAVQEAAAkAAABsaWJyYXJ5L3N0ZC9zcmMvcGFuaWNraW5nLnJzrAQQABwAAABCAgAAHgAAAKwEEAAcAAAAQQIAAB8AAAAJAAAADAAAAAQAAAAKAAAABQAAAAgAAAAEAAAACwAAAAwAAAAQAAAABAAAAA0AAAAOAAAABQAAAAgAAAAEAAAADwAAABAAAAAFAAAAAAAAAAEAAAARAAAAbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc2NhcGFjaXR5IG92ZXJmbG93AAAAXAUQABEAAABABRAAHAAAAA0CAAAFAAAAiAUQAAAAAAAUAAAAAAAAAAEAAAAVAAAAMDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTkAbwlwcm9kdWNlcnMCCGxhbmd1YWdlAQRSdXN0AAxwcm9jZXNzZWQtYnkDBXJ1c3RjHTEuNjkuMCAoODRjODk4ZDY1IDIwMjMtMDQtMTYpBndhbHJ1cwYwLjE5LjAMd2FzbS1iaW5kZ2VuBjAuMi44Nw==", imports);
      }
      async function initWasm3() {
        return await __wbg_init(wasm());
      }
      initWasm3();
      exports.ADD = ADD;
      exports.ADDI = ADDI;
      exports.ALOC = ALOC;
      exports.AND = AND;
      exports.ANDI = ANDI;
      exports.BAL = BAL;
      exports.BHEI = BHEI;
      exports.BHSH = BHSH;
      exports.BURN = BURN;
      exports.CALL = CALL;
      exports.CB = CB;
      exports.CCP = CCP;
      exports.CFE = CFE;
      exports.CFEI = CFEI;
      exports.CFS = CFS;
      exports.CFSI = CFSI;
      exports.CROO = CROO;
      exports.CSIZ = CSIZ;
      exports.CompareArgs = CompareArgs;
      exports.CompareMode = CompareMode;
      exports.DIV = DIV;
      exports.DIVI = DIVI;
      exports.DivArgs = DivArgs;
      exports.ECK1 = ECK1;
      exports.ECR1 = ECR1;
      exports.ED19 = ED19;
      exports.EQ = EQ;
      exports.EXP = EXP;
      exports.EXPI = EXPI;
      exports.FLAG = FLAG;
      exports.GM = GM;
      exports.GMArgs = GMArgs;
      exports.GT = GT;
      exports.GTF = GTF;
      exports.GTFArgs = GTFArgs2;
      exports.Imm06 = Imm06;
      exports.Imm12 = Imm12;
      exports.Imm18 = Imm18;
      exports.Imm24 = Imm24;
      exports.Instruction = Instruction2;
      exports.JI = JI;
      exports.JMP = JMP;
      exports.JMPB = JMPB;
      exports.JMPF = JMPF;
      exports.JNE = JNE;
      exports.JNEB = JNEB;
      exports.JNEF = JNEF;
      exports.JNEI = JNEI;
      exports.JNZB = JNZB;
      exports.JNZF = JNZF;
      exports.JNZI = JNZI;
      exports.K256 = K256;
      exports.LB = LB;
      exports.LDC = LDC;
      exports.LOG = LOG;
      exports.LOGD = LOGD;
      exports.LT = LT;
      exports.LW = LW;
      exports.MCL = MCL;
      exports.MCLI = MCLI;
      exports.MCP = MCP;
      exports.MCPI = MCPI;
      exports.MEQ = MEQ;
      exports.MINT = MINT;
      exports.MLDV = MLDV;
      exports.MLOG = MLOG;
      exports.MOD = MOD;
      exports.MODI = MODI;
      exports.MOVE = MOVE;
      exports.MOVI = MOVI;
      exports.MROO = MROO;
      exports.MUL = MUL;
      exports.MULI = MULI;
      exports.MathArgs = MathArgs;
      exports.MathOp = MathOp;
      exports.MulArgs = MulArgs;
      exports.NOOP = NOOP;
      exports.NOT = NOT;
      exports.OR = OR;
      exports.ORI = ORI;
      exports.POPH = POPH;
      exports.POPL = POPL;
      exports.PSHH = PSHH;
      exports.PSHL = PSHL;
      exports.PanicInstruction = PanicInstruction;
      exports.PanicReason = PanicReason;
      exports.RET = RET;
      exports.RETD = RETD;
      exports.RVRT = RVRT;
      exports.RegId = RegId2;
      exports.S256 = S256;
      exports.SB = SB;
      exports.SCWQ = SCWQ;
      exports.SLL = SLL;
      exports.SLLI = SLLI;
      exports.SMO = SMO;
      exports.SRL = SRL;
      exports.SRLI = SRLI;
      exports.SRW = SRW;
      exports.SRWQ = SRWQ;
      exports.SUB = SUB;
      exports.SUBI = SUBI;
      exports.SW = SW;
      exports.SWW = SWW;
      exports.SWWQ = SWWQ;
      exports.TIME = TIME;
      exports.TR = TR;
      exports.TRO = TRO;
      exports.WDAM = WDAM;
      exports.WDCM = WDCM;
      exports.WDDV = WDDV;
      exports.WDMD = WDMD;
      exports.WDML = WDML;
      exports.WDMM = WDMM;
      exports.WDOP = WDOP;
      exports.WQAM = WQAM;
      exports.WQCM = WQCM;
      exports.WQDV = WQDV;
      exports.WQMD = WQMD;
      exports.WQML = WQML;
      exports.WQMM = WQMM;
      exports.WQOP = WQOP;
      exports.XOR = XOR;
      exports.XORI = XORI;
      exports.add = add3;
      exports.addi = addi2;
      exports.aloc = aloc;
      exports.and = and;
      exports.andi = andi;
      exports.bal = bal;
      exports.bhei = bhei;
      exports.bhsh = bhsh;
      exports.burn = burn;
      exports.call = call2;
      exports.cb = cb;
      exports.ccp = ccp;
      exports.cfe = cfe;
      exports.cfei = cfei;
      exports.cfs = cfs;
      exports.cfsi = cfsi;
      exports.croo = croo;
      exports.csiz = csiz;
      exports.div = div;
      exports.divi = divi;
      exports.eck1 = eck1;
      exports.ecr1 = ecr1;
      exports.ed19 = ed19;
      exports.eq = eq;
      exports.exp = exp;
      exports.expi = expi;
      exports.flag = flag;
      exports.gm = gm;
      exports.gm_args = gm_args;
      exports.gt = gt;
      exports.gtf = gtf2;
      exports.gtf_args = gtf_args;
      exports.initSync = initSync;
      exports.initWasm = initWasm3;
      exports.ji = ji;
      exports.jmp = jmp;
      exports.jmpb = jmpb;
      exports.jmpf = jmpf;
      exports.jne = jne;
      exports.jneb = jneb;
      exports.jnef = jnef;
      exports.jnei = jnei;
      exports.jnzb = jnzb;
      exports.jnzf = jnzf;
      exports.jnzi = jnzi;
      exports.k256 = k256;
      exports.lb = lb;
      exports.ldc = ldc;
      exports.log = log2;
      exports.logd = logd;
      exports.lt = lt;
      exports.lw = lw3;
      exports.mcl = mcl;
      exports.mcli = mcli;
      exports.mcp = mcp;
      exports.mcpi = mcpi;
      exports.meq = meq;
      exports.mint = mint;
      exports.mldv = mldv;
      exports.mlog = mlog;
      exports.mod_ = mod_;
      exports.modi = modi;
      exports.move_ = move_;
      exports.movi = movi2;
      exports.mroo = mroo;
      exports.mul = mul;
      exports.muli = muli2;
      exports.noop = noop;
      exports.not = not;
      exports.or = or;
      exports.ori = ori;
      exports.poph = poph;
      exports.popl = popl;
      exports.pshh = pshh;
      exports.pshl = pshl;
      exports.ret = ret3;
      exports.retd = retd2;
      exports.rvrt = rvrt;
      exports.s256 = s256;
      exports.sb = sb;
      exports.scwq = scwq;
      exports.sll = sll;
      exports.slli = slli;
      exports.smo = smo;
      exports.srl = srl;
      exports.srli = srli;
      exports.srw = srw;
      exports.srwq = srwq;
      exports.sub = sub;
      exports.subi = subi;
      exports.sw = sw;
      exports.sww = sww;
      exports.swwq = swwq;
      exports.time = time;
      exports.tr = tr2;
      exports.tro = tro;
      exports.wdam = wdam;
      exports.wdcm = wdcm;
      exports.wdcm_args = wdcm_args;
      exports.wddv = wddv;
      exports.wddv_args = wddv_args;
      exports.wdmd = wdmd;
      exports.wdml = wdml;
      exports.wdml_args = wdml_args;
      exports.wdmm = wdmm;
      exports.wdop = wdop;
      exports.wdop_args = wdop_args;
      exports.wqam = wqam;
      exports.wqcm = wqcm;
      exports.wqcm_args = wqcm_args;
      exports.wqdv = wqdv;
      exports.wqdv_args = wqdv_args;
      exports.wqmd = wqmd;
      exports.wqml = wqml;
      exports.wqml_args = wqml_args;
      exports.wqmm = wqmm;
      exports.wqop = wqop;
      exports.wqop_args = wqop_args;
      exports.xor = xor;
      exports.xori = xori;
    }
  });

  // ../../node_modules/.pnpm/async@2.6.4/node_modules/async/dist/async.js
  var require_async2 = __commonJS({
    "../../node_modules/.pnpm/async@2.6.4/node_modules/async/dist/async.js"(exports, module2) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module2 !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.async = global2.async || {});
      })(exports, function(exports2) {
        "use strict";
        function slice(arrayLike, start) {
          start = start | 0;
          var newLen = Math.max(arrayLike.length - start, 0);
          var newArr = Array(newLen);
          for (var idx = 0; idx < newLen; idx++) {
            newArr[idx] = arrayLike[start + idx];
          }
          return newArr;
        }
        var apply = function(fn) {
          var args = slice(arguments, 1);
          return function() {
            var callArgs = slice(arguments);
            return fn.apply(null, args.concat(callArgs));
          };
        };
        var initialParams = function(fn) {
          return function() {
            var args = slice(arguments);
            var callback = args.pop();
            fn.call(this, args, callback);
          };
        };
        function isObject2(value) {
          var type3 = typeof value;
          return value != null && (type3 == "object" || type3 == "function");
        }
        var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
        var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
        function fallback(fn) {
          setTimeout(fn, 0);
        }
        function wrap(defer2) {
          return function(fn) {
            var args = slice(arguments, 1);
            defer2(function() {
              fn.apply(null, args);
            });
          };
        }
        var _defer;
        if (hasSetImmediate) {
          _defer = setImmediate;
        } else if (hasNextTick) {
          _defer = process.nextTick;
        } else {
          _defer = fallback;
        }
        var setImmediate$1 = wrap(_defer);
        function asyncify(func) {
          return initialParams(function(args, callback) {
            var result;
            try {
              result = func.apply(this, args);
            } catch (e) {
              return callback(e);
            }
            if (isObject2(result) && typeof result.then === "function") {
              result.then(function(value) {
                invokeCallback(callback, null, value);
              }, function(err) {
                invokeCallback(callback, err.message ? err : new Error(err));
              });
            } else {
              callback(null, result);
            }
          });
        }
        function invokeCallback(callback, error2, value) {
          try {
            callback(error2, value);
          } catch (e) {
            setImmediate$1(rethrow, e);
          }
        }
        function rethrow(error2) {
          throw error2;
        }
        var supportsSymbol = typeof Symbol === "function";
        function isAsync(fn) {
          return supportsSymbol && fn[Symbol.toStringTag] === "AsyncFunction";
        }
        function wrapAsync(asyncFn) {
          return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
        }
        function applyEach$1(eachfn) {
          return function(fns) {
            var args = slice(arguments, 1);
            var go = initialParams(function(args2, callback) {
              var that = this;
              return eachfn(fns, function(fn, cb) {
                wrapAsync(fn).apply(that, args2.concat(cb));
              }, callback);
            });
            if (args.length) {
              return go.apply(this, args);
            } else {
              return go;
            }
          };
        }
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        var Symbol$1 = root.Symbol;
        var objectProto = Object.prototype;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var nativeObjectToString = objectProto.toString;
        var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag$1), tag = value[symToStringTag$1];
          try {
            value[symToStringTag$1] = void 0;
            var unmasked = true;
          } catch (e) {
          }
          var result = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag$1] = tag;
            } else {
              delete value[symToStringTag$1];
            }
          }
          return result;
        }
        var objectProto$1 = Object.prototype;
        var nativeObjectToString$1 = objectProto$1.toString;
        function objectToString(value) {
          return nativeObjectToString$1.call(value);
        }
        var nullTag = "[object Null]";
        var undefinedTag = "[object Undefined]";
        var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
        function baseGetTag(value) {
          if (value == null) {
            return value === void 0 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
        }
        var asyncTag = "[object AsyncFunction]";
        var funcTag = "[object Function]";
        var genTag = "[object GeneratorFunction]";
        var proxyTag = "[object Proxy]";
        function isFunction(value) {
          if (!isObject2(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        var MAX_SAFE_INTEGER = 9007199254740991;
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        var breakLoop = {};
        function noop() {
        }
        function once2(fn) {
          return function() {
            if (fn === null)
              return;
            var callFn = fn;
            fn = null;
            callFn.apply(this, arguments);
          };
        }
        var iteratorSymbol = typeof Symbol === "function" && Symbol.iterator;
        var getIterator = function(coll) {
          return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
        };
        function baseTimes(n, iteratee) {
          var index2 = -1, result = Array(n);
          while (++index2 < n) {
            result[index2] = iteratee(index2);
          }
          return result;
        }
        function isObjectLike2(value) {
          return value != null && typeof value == "object";
        }
        var argsTag = "[object Arguments]";
        function baseIsArguments(value) {
          return isObjectLike2(value) && baseGetTag(value) == argsTag;
        }
        var objectProto$3 = Object.prototype;
        var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
        var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike2(value) && hasOwnProperty$2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array.isArray;
        function stubFalse() {
          return false;
        }
        var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
        var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var Buffer2 = moduleExports ? root.Buffer : void 0;
        var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
        var isBuffer = nativeIsBuffer || stubFalse;
        var MAX_SAFE_INTEGER$1 = 9007199254740991;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        function isIndex(value, length) {
          var type3 = typeof value;
          length = length == null ? MAX_SAFE_INTEGER$1 : length;
          return !!length && (type3 == "number" || type3 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        var argsTag$1 = "[object Arguments]";
        var arrayTag = "[object Array]";
        var boolTag = "[object Boolean]";
        var dateTag = "[object Date]";
        var errorTag = "[object Error]";
        var funcTag$1 = "[object Function]";
        var mapTag = "[object Map]";
        var numberTag = "[object Number]";
        var objectTag = "[object Object]";
        var regexpTag = "[object RegExp]";
        var setTag = "[object Set]";
        var stringTag = "[object String]";
        var weakMapTag = "[object WeakMap]";
        var arrayBufferTag = "[object ArrayBuffer]";
        var dataViewTag = "[object DataView]";
        var float32Tag = "[object Float32Array]";
        var float64Tag = "[object Float64Array]";
        var int8Tag = "[object Int8Array]";
        var int16Tag = "[object Int16Array]";
        var int32Tag = "[object Int32Array]";
        var uint8Tag = "[object Uint8Array]";
        var uint8ClampedTag = "[object Uint8ClampedArray]";
        var uint16Tag = "[object Uint16Array]";
        var uint32Tag = "[object Uint32Array]";
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        function baseIsTypedArray(value) {
          return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        var freeExports$1 = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
        var freeModule$1 = freeExports$1 && typeof module2 == "object" && module2 && !module2.nodeType && module2;
        var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
        var freeProcess = moduleExports$1 && freeGlobal.process;
        var nodeUtil = function() {
          try {
            var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
            if (types2) {
              return types2;
            }
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
          } catch (e) {
          }
        }();
        var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        var objectProto$2 = Object.prototype;
        var hasOwnProperty$1 = objectProto$2.hasOwnProperty;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType2, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty$1.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result.push(key);
            }
          }
          return result;
        }
        var objectProto$5 = Object.prototype;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$5;
          return value === proto;
        }
        function overArg(func, transform2) {
          return function(arg) {
            return func(transform2(arg));
          };
        }
        var nativeKeys = overArg(Object.keys, Object);
        var objectProto$4 = Object.prototype;
        var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
        function baseKeys(object2) {
          if (!isPrototype(object2)) {
            return nativeKeys(object2);
          }
          var result = [];
          for (var key in Object(object2)) {
            if (hasOwnProperty$3.call(object2, key) && key != "constructor") {
              result.push(key);
            }
          }
          return result;
        }
        function keys4(object2) {
          return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
        }
        function createArrayIterator(coll) {
          var i = -1;
          var len = coll.length;
          return function next() {
            return ++i < len ? { value: coll[i], key: i } : null;
          };
        }
        function createES2015Iterator(iterator2) {
          var i = -1;
          return function next() {
            var item = iterator2.next();
            if (item.done)
              return null;
            i++;
            return { value: item.value, key: i };
          };
        }
        function createObjectIterator(obj) {
          var okeys = keys4(obj);
          var i = -1;
          var len = okeys.length;
          return function next() {
            var key = okeys[++i];
            if (key === "__proto__") {
              return next();
            }
            return i < len ? { value: obj[key], key } : null;
          };
        }
        function iterator(coll) {
          if (isArrayLike(coll)) {
            return createArrayIterator(coll);
          }
          var iterator2 = getIterator(coll);
          return iterator2 ? createES2015Iterator(iterator2) : createObjectIterator(coll);
        }
        function onlyOnce(fn) {
          return function() {
            if (fn === null)
              throw new Error("Callback was already called.");
            var callFn = fn;
            fn = null;
            callFn.apply(this, arguments);
          };
        }
        function _eachOfLimit(limit) {
          return function(obj, iteratee, callback) {
            callback = once2(callback || noop);
            if (limit <= 0 || !obj) {
              return callback(null);
            }
            var nextElem = iterator(obj);
            var done = false;
            var running = 0;
            var looping = false;
            function iterateeCallback(err, value) {
              running -= 1;
              if (err) {
                done = true;
                callback(err);
              } else if (value === breakLoop || done && running <= 0) {
                done = true;
                return callback(null);
              } else if (!looping) {
                replenish();
              }
            }
            function replenish() {
              looping = true;
              while (running < limit && !done) {
                var elem = nextElem();
                if (elem === null) {
                  done = true;
                  if (running <= 0) {
                    callback(null);
                  }
                  return;
                }
                running += 1;
                iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
              }
              looping = false;
            }
            replenish();
          };
        }
        function eachOfLimit(coll, limit, iteratee, callback) {
          _eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
        }
        function doLimit(fn, limit) {
          return function(iterable, iteratee, callback) {
            return fn(iterable, limit, iteratee, callback);
          };
        }
        function eachOfArrayLike(coll, iteratee, callback) {
          callback = once2(callback || noop);
          var index2 = 0, completed = 0, length = coll.length;
          if (length === 0) {
            callback(null);
          }
          function iteratorCallback(err, value) {
            if (err) {
              callback(err);
            } else if (++completed === length || value === breakLoop) {
              callback(null);
            }
          }
          for (; index2 < length; index2++) {
            iteratee(coll[index2], index2, onlyOnce(iteratorCallback));
          }
        }
        var eachOfGeneric = doLimit(eachOfLimit, Infinity);
        var eachOf = function(coll, iteratee, callback) {
          var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
          eachOfImplementation(coll, wrapAsync(iteratee), callback);
        };
        function doParallel(fn) {
          return function(obj, iteratee, callback) {
            return fn(eachOf, obj, wrapAsync(iteratee), callback);
          };
        }
        function _asyncMap(eachfn, arr, iteratee, callback) {
          callback = callback || noop;
          arr = arr || [];
          var results = [];
          var counter = 0;
          var _iteratee = wrapAsync(iteratee);
          eachfn(arr, function(value, _, callback2) {
            var index2 = counter++;
            _iteratee(value, function(err, v) {
              results[index2] = v;
              callback2(err);
            });
          }, function(err) {
            callback(err, results);
          });
        }
        var map2 = doParallel(_asyncMap);
        var applyEach = applyEach$1(map2);
        function doParallelLimit(fn) {
          return function(obj, limit, iteratee, callback) {
            return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
          };
        }
        var mapLimit = doParallelLimit(_asyncMap);
        var mapSeries = doLimit(mapLimit, 1);
        var applyEachSeries = applyEach$1(mapSeries);
        function arrayEach(array2, iteratee) {
          var index2 = -1, length = array2 == null ? 0 : array2.length;
          while (++index2 < length) {
            if (iteratee(array2[index2], index2, array2) === false) {
              break;
            }
          }
          return array2;
        }
        function createBaseFor(fromRight) {
          return function(object2, iteratee, keysFunc) {
            var index2 = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index2];
              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object2;
          };
        }
        var baseFor = createBaseFor();
        function baseForOwn(object2, iteratee) {
          return object2 && baseFor(object2, iteratee, keys4);
        }
        function baseFindIndex(array2, predicate, fromIndex, fromRight) {
          var length = array2.length, index2 = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index2-- : ++index2 < length) {
            if (predicate(array2[index2], index2, array2)) {
              return index2;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function strictIndexOf(array2, value, fromIndex) {
          var index2 = fromIndex - 1, length = array2.length;
          while (++index2 < length) {
            if (array2[index2] === value) {
              return index2;
            }
          }
          return -1;
        }
        function baseIndexOf(array2, value, fromIndex) {
          return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
        }
        var auto = function(tasks, concurrency, callback) {
          if (typeof concurrency === "function") {
            callback = concurrency;
            concurrency = null;
          }
          callback = once2(callback || noop);
          var keys$$1 = keys4(tasks);
          var numTasks = keys$$1.length;
          if (!numTasks) {
            return callback(null);
          }
          if (!concurrency) {
            concurrency = numTasks;
          }
          var results = {};
          var runningTasks = 0;
          var hasError = false;
          var listeners = /* @__PURE__ */ Object.create(null);
          var readyTasks = [];
          var readyToCheck = [];
          var uncheckedDependencies = {};
          baseForOwn(tasks, function(task, key) {
            if (!isArray(task)) {
              enqueueTask(key, [task]);
              readyToCheck.push(key);
              return;
            }
            var dependencies = task.slice(0, task.length - 1);
            var remainingDependencies = dependencies.length;
            if (remainingDependencies === 0) {
              enqueueTask(key, task);
              readyToCheck.push(key);
              return;
            }
            uncheckedDependencies[key] = remainingDependencies;
            arrayEach(dependencies, function(dependencyName) {
              if (!tasks[dependencyName]) {
                throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
              }
              addListener(dependencyName, function() {
                remainingDependencies--;
                if (remainingDependencies === 0) {
                  enqueueTask(key, task);
                }
              });
            });
          });
          checkForDeadlocks();
          processQueue();
          function enqueueTask(key, task) {
            readyTasks.push(function() {
              runTask(key, task);
            });
          }
          function processQueue() {
            if (readyTasks.length === 0 && runningTasks === 0) {
              return callback(null, results);
            }
            while (readyTasks.length && runningTasks < concurrency) {
              var run2 = readyTasks.shift();
              run2();
            }
          }
          function addListener(taskName, fn) {
            var taskListeners = listeners[taskName];
            if (!taskListeners) {
              taskListeners = listeners[taskName] = [];
            }
            taskListeners.push(fn);
          }
          function taskComplete(taskName) {
            var taskListeners = listeners[taskName] || [];
            arrayEach(taskListeners, function(fn) {
              fn();
            });
            processQueue();
          }
          function runTask(key, task) {
            if (hasError)
              return;
            var taskCallback = onlyOnce(function(err, result) {
              runningTasks--;
              if (arguments.length > 2) {
                result = slice(arguments, 1);
              }
              if (err) {
                var safeResults = {};
                baseForOwn(results, function(val, rkey) {
                  safeResults[rkey] = val;
                });
                safeResults[key] = result;
                hasError = true;
                listeners = /* @__PURE__ */ Object.create(null);
                callback(err, safeResults);
              } else {
                results[key] = result;
                taskComplete(key);
              }
            });
            runningTasks++;
            var taskFn = wrapAsync(task[task.length - 1]);
            if (task.length > 1) {
              taskFn(results, taskCallback);
            } else {
              taskFn(taskCallback);
            }
          }
          function checkForDeadlocks() {
            var currentTask;
            var counter = 0;
            while (readyToCheck.length) {
              currentTask = readyToCheck.pop();
              counter++;
              arrayEach(getDependents(currentTask), function(dependent) {
                if (--uncheckedDependencies[dependent] === 0) {
                  readyToCheck.push(dependent);
                }
              });
            }
            if (counter !== numTasks) {
              throw new Error(
                "async.auto cannot execute tasks due to a recursive dependency"
              );
            }
          }
          function getDependents(taskName) {
            var result = [];
            baseForOwn(tasks, function(task, key) {
              if (isArray(task) && baseIndexOf(task, taskName, 0) >= 0) {
                result.push(key);
              }
            });
            return result;
          }
        };
        function arrayMap(array2, iteratee) {
          var index2 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
          while (++index2 < length) {
            result[index2] = iteratee(array2[index2], index2, array2);
          }
          return result;
        }
        var symbolTag = "[object Symbol]";
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike2(value) && baseGetTag(value) == symbolTag;
        }
        var INFINITY = 1 / 0;
        var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0;
        var symbolToString2 = symbolProto ? symbolProto.toString : void 0;
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString2 ? symbolToString2.call(value) : "";
          }
          var result = value + "";
          return result == "0" && 1 / value == -INFINITY ? "-0" : result;
        }
        function baseSlice(array2, start, end) {
          var index2 = -1, length = array2.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result = Array(length);
          while (++index2 < length) {
            result[index2] = array2[index2 + start];
          }
          return result;
        }
        function castSlice(array2, start, end) {
          var length = array2.length;
          end = end === void 0 ? length : end;
          return !start && end >= length ? array2 : baseSlice(array2, start, end);
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index2 = strSymbols.length;
          while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
          }
          return index2;
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index2 = -1, length = strSymbols.length;
          while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
          }
          return index2;
        }
        function asciiToArray(string2) {
          return string2.split("");
        }
        var rsAstralRange = "\\ud800-\\udfff";
        var rsComboMarksRange = "\\u0300-\\u036f";
        var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
        var rsComboSymbolsRange = "\\u20d0-\\u20ff";
        var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
        var rsVarRange = "\\ufe0e\\ufe0f";
        var rsZWJ = "\\u200d";
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        function hasUnicode(string2) {
          return reHasUnicode.test(string2);
        }
        var rsAstralRange$1 = "\\ud800-\\udfff";
        var rsComboMarksRange$1 = "\\u0300-\\u036f";
        var reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f";
        var rsComboSymbolsRange$1 = "\\u20d0-\\u20ff";
        var rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;
        var rsVarRange$1 = "\\ufe0e\\ufe0f";
        var rsAstral = "[" + rsAstralRange$1 + "]";
        var rsCombo = "[" + rsComboRange$1 + "]";
        var rsFitz = "\\ud83c[\\udffb-\\udfff]";
        var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
        var rsNonAstral = "[^" + rsAstralRange$1 + "]";
        var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
        var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
        var rsZWJ$1 = "\\u200d";
        var reOptMod = rsModifier + "?";
        var rsOptVar = "[" + rsVarRange$1 + "]?";
        var rsOptJoin = "(?:" + rsZWJ$1 + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
        var rsSeq = rsOptVar + reOptMod + rsOptJoin;
        var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        function unicodeToArray(string2) {
          return string2.match(reUnicode) || [];
        }
        function stringToArray(string2) {
          return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
        }
        function toString3(value) {
          return value == null ? "" : baseToString(value);
        }
        var reTrim = /^\s+|\s+$/g;
        function trim2(string2, chars, guard) {
          string2 = toString3(string2);
          if (string2 && (guard || chars === void 0)) {
            return string2.replace(reTrim, "");
          }
          if (!string2 || !(chars = baseToString(chars))) {
            return string2;
          }
          var strSymbols = stringToArray(string2), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        var FN_ARGS = /^(?:async\s+)?(function)?\s*[^\(]*\(\s*([^\)]*)\)/m;
        var FN_ARG_SPLIT = /,/;
        var FN_ARG = /(=.+)?(\s*)$/;
        var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
        function parseParams(func) {
          func = func.toString().replace(STRIP_COMMENTS, "");
          func = func.match(FN_ARGS)[2].replace(" ", "");
          func = func ? func.split(FN_ARG_SPLIT) : [];
          func = func.map(function(arg) {
            return trim2(arg.replace(FN_ARG, ""));
          });
          return func;
        }
        function autoInject(tasks, callback) {
          var newTasks = {};
          baseForOwn(tasks, function(taskFn, key) {
            var params;
            var fnIsAsync = isAsync(taskFn);
            var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
            if (isArray(taskFn)) {
              params = taskFn.slice(0, -1);
              taskFn = taskFn[taskFn.length - 1];
              newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
            } else if (hasNoDeps) {
              newTasks[key] = taskFn;
            } else {
              params = parseParams(taskFn);
              if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
                throw new Error("autoInject task functions require explicit parameters.");
              }
              if (!fnIsAsync)
                params.pop();
              newTasks[key] = params.concat(newTask);
            }
            function newTask(results, taskCb) {
              var newArgs = arrayMap(params, function(name) {
                return results[name];
              });
              newArgs.push(taskCb);
              wrapAsync(taskFn).apply(null, newArgs);
            }
          });
          auto(newTasks, callback);
        }
        function DLL() {
          this.head = this.tail = null;
          this.length = 0;
        }
        function setInitial(dll, node) {
          dll.length = 1;
          dll.head = dll.tail = node;
        }
        DLL.prototype.removeLink = function(node) {
          if (node.prev)
            node.prev.next = node.next;
          else
            this.head = node.next;
          if (node.next)
            node.next.prev = node.prev;
          else
            this.tail = node.prev;
          node.prev = node.next = null;
          this.length -= 1;
          return node;
        };
        DLL.prototype.empty = function() {
          while (this.head)
            this.shift();
          return this;
        };
        DLL.prototype.insertAfter = function(node, newNode) {
          newNode.prev = node;
          newNode.next = node.next;
          if (node.next)
            node.next.prev = newNode;
          else
            this.tail = newNode;
          node.next = newNode;
          this.length += 1;
        };
        DLL.prototype.insertBefore = function(node, newNode) {
          newNode.prev = node.prev;
          newNode.next = node;
          if (node.prev)
            node.prev.next = newNode;
          else
            this.head = newNode;
          node.prev = newNode;
          this.length += 1;
        };
        DLL.prototype.unshift = function(node) {
          if (this.head)
            this.insertBefore(this.head, node);
          else
            setInitial(this, node);
        };
        DLL.prototype.push = function(node) {
          if (this.tail)
            this.insertAfter(this.tail, node);
          else
            setInitial(this, node);
        };
        DLL.prototype.shift = function() {
          return this.head && this.removeLink(this.head);
        };
        DLL.prototype.pop = function() {
          return this.tail && this.removeLink(this.tail);
        };
        DLL.prototype.toArray = function() {
          var arr = Array(this.length);
          var curr = this.head;
          for (var idx = 0; idx < this.length; idx++) {
            arr[idx] = curr.data;
            curr = curr.next;
          }
          return arr;
        };
        DLL.prototype.remove = function(testFn) {
          var curr = this.head;
          while (!!curr) {
            var next = curr.next;
            if (testFn(curr)) {
              this.removeLink(curr);
            }
            curr = next;
          }
          return this;
        };
        function queue(worker, concurrency, payload) {
          if (concurrency == null) {
            concurrency = 1;
          } else if (concurrency === 0) {
            throw new Error("Concurrency must not be zero");
          }
          var _worker = wrapAsync(worker);
          var numRunning = 0;
          var workersList = [];
          var processingScheduled = false;
          function _insert(data, insertAtFront, callback) {
            if (callback != null && typeof callback !== "function") {
              throw new Error("task callback must be a function");
            }
            q.started = true;
            if (!isArray(data)) {
              data = [data];
            }
            if (data.length === 0 && q.idle()) {
              return setImmediate$1(function() {
                q.drain();
              });
            }
            for (var i = 0, l = data.length; i < l; i++) {
              var item = {
                data: data[i],
                callback: callback || noop
              };
              if (insertAtFront) {
                q._tasks.unshift(item);
              } else {
                q._tasks.push(item);
              }
            }
            if (!processingScheduled) {
              processingScheduled = true;
              setImmediate$1(function() {
                processingScheduled = false;
                q.process();
              });
            }
          }
          function _next(tasks) {
            return function(err) {
              numRunning -= 1;
              for (var i = 0, l = tasks.length; i < l; i++) {
                var task = tasks[i];
                var index2 = baseIndexOf(workersList, task, 0);
                if (index2 === 0) {
                  workersList.shift();
                } else if (index2 > 0) {
                  workersList.splice(index2, 1);
                }
                task.callback.apply(task, arguments);
                if (err != null) {
                  q.error(err, task.data);
                }
              }
              if (numRunning <= q.concurrency - q.buffer) {
                q.unsaturated();
              }
              if (q.idle()) {
                q.drain();
              }
              q.process();
            };
          }
          var isProcessing = false;
          var q = {
            _tasks: new DLL(),
            concurrency,
            payload,
            saturated: noop,
            unsaturated: noop,
            buffer: concurrency / 4,
            empty: noop,
            drain: noop,
            error: noop,
            started: false,
            paused: false,
            push: function(data, callback) {
              _insert(data, false, callback);
            },
            kill: function() {
              q.drain = noop;
              q._tasks.empty();
            },
            unshift: function(data, callback) {
              _insert(data, true, callback);
            },
            remove: function(testFn) {
              q._tasks.remove(testFn);
            },
            process: function() {
              if (isProcessing) {
                return;
              }
              isProcessing = true;
              while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
                var tasks = [], data = [];
                var l = q._tasks.length;
                if (q.payload)
                  l = Math.min(l, q.payload);
                for (var i = 0; i < l; i++) {
                  var node = q._tasks.shift();
                  tasks.push(node);
                  workersList.push(node);
                  data.push(node.data);
                }
                numRunning += 1;
                if (q._tasks.length === 0) {
                  q.empty();
                }
                if (numRunning === q.concurrency) {
                  q.saturated();
                }
                var cb = onlyOnce(_next(tasks));
                _worker(data, cb);
              }
              isProcessing = false;
            },
            length: function() {
              return q._tasks.length;
            },
            running: function() {
              return numRunning;
            },
            workersList: function() {
              return workersList;
            },
            idle: function() {
              return q._tasks.length + numRunning === 0;
            },
            pause: function() {
              q.paused = true;
            },
            resume: function() {
              if (q.paused === false) {
                return;
              }
              q.paused = false;
              setImmediate$1(q.process);
            }
          };
          return q;
        }
        function cargo(worker, payload) {
          return queue(worker, 1, payload);
        }
        var eachOfSeries = doLimit(eachOfLimit, 1);
        function reduce(coll, memo, iteratee, callback) {
          callback = once2(callback || noop);
          var _iteratee = wrapAsync(iteratee);
          eachOfSeries(coll, function(x, i, callback2) {
            _iteratee(memo, x, function(err, v) {
              memo = v;
              callback2(err);
            });
          }, function(err) {
            callback(err, memo);
          });
        }
        function seq() {
          var _functions = arrayMap(arguments, wrapAsync);
          return function() {
            var args = slice(arguments);
            var that = this;
            var cb = args[args.length - 1];
            if (typeof cb == "function") {
              args.pop();
            } else {
              cb = noop;
            }
            reduce(
              _functions,
              args,
              function(newargs, fn, cb2) {
                fn.apply(that, newargs.concat(function(err) {
                  var nextargs = slice(arguments, 1);
                  cb2(err, nextargs);
                }));
              },
              function(err, results) {
                cb.apply(that, [err].concat(results));
              }
            );
          };
        }
        var compose2 = function() {
          return seq.apply(null, slice(arguments).reverse());
        };
        var _concat2 = Array.prototype.concat;
        var concatLimit = function(coll, limit, iteratee, callback) {
          callback = callback || noop;
          var _iteratee = wrapAsync(iteratee);
          mapLimit(coll, limit, function(val, callback2) {
            _iteratee(val, function(err) {
              if (err)
                return callback2(err);
              return callback2(null, slice(arguments, 1));
            });
          }, function(err, mapResults) {
            var result = [];
            for (var i = 0; i < mapResults.length; i++) {
              if (mapResults[i]) {
                result = _concat2.apply(result, mapResults[i]);
              }
            }
            return callback(err, result);
          });
        };
        var concat3 = doLimit(concatLimit, Infinity);
        var concatSeries = doLimit(concatLimit, 1);
        var constant = function() {
          var values = slice(arguments);
          var args = [null].concat(values);
          return function() {
            var callback = arguments[arguments.length - 1];
            return callback.apply(this, args);
          };
        };
        function identity2(value) {
          return value;
        }
        function _createTester(check, getResult) {
          return function(eachfn, arr, iteratee, cb) {
            cb = cb || noop;
            var testPassed = false;
            var testResult;
            eachfn(arr, function(value, _, callback) {
              iteratee(value, function(err, result) {
                if (err) {
                  callback(err);
                } else if (check(result) && !testResult) {
                  testPassed = true;
                  testResult = getResult(true, value);
                  callback(null, breakLoop);
                } else {
                  callback();
                }
              });
            }, function(err) {
              if (err) {
                cb(err);
              } else {
                cb(null, testPassed ? testResult : getResult(false));
              }
            });
          };
        }
        function _findGetResult(v, x) {
          return x;
        }
        var detect = doParallel(_createTester(identity2, _findGetResult));
        var detectLimit = doParallelLimit(_createTester(identity2, _findGetResult));
        var detectSeries = doLimit(detectLimit, 1);
        function consoleFunc(name) {
          return function(fn) {
            var args = slice(arguments, 1);
            args.push(function(err) {
              var args2 = slice(arguments, 1);
              if (typeof console === "object") {
                if (err) {
                  if (console.error) {
                    console.error(err);
                  }
                } else if (console[name]) {
                  arrayEach(args2, function(x) {
                    console[name](x);
                  });
                }
              }
            });
            wrapAsync(fn).apply(null, args);
          };
        }
        var dir = consoleFunc("dir");
        function doDuring(fn, test, callback) {
          callback = onlyOnce(callback || noop);
          var _fn = wrapAsync(fn);
          var _test = wrapAsync(test);
          function next(err) {
            if (err)
              return callback(err);
            var args = slice(arguments, 1);
            args.push(check);
            _test.apply(this, args);
          }
          function check(err, truth) {
            if (err)
              return callback(err);
            if (!truth)
              return callback(null);
            _fn(next);
          }
          check(null, true);
        }
        function doWhilst(iteratee, test, callback) {
          callback = onlyOnce(callback || noop);
          var _iteratee = wrapAsync(iteratee);
          var next = function(err) {
            if (err)
              return callback(err);
            var args = slice(arguments, 1);
            if (test.apply(this, args))
              return _iteratee(next);
            callback.apply(null, [null].concat(args));
          };
          _iteratee(next);
        }
        function doUntil(iteratee, test, callback) {
          doWhilst(iteratee, function() {
            return !test.apply(this, arguments);
          }, callback);
        }
        function during(test, fn, callback) {
          callback = onlyOnce(callback || noop);
          var _fn = wrapAsync(fn);
          var _test = wrapAsync(test);
          function next(err) {
            if (err)
              return callback(err);
            _test(check);
          }
          function check(err, truth) {
            if (err)
              return callback(err);
            if (!truth)
              return callback(null);
            _fn(next);
          }
          _test(check);
        }
        function _withoutIndex(iteratee) {
          return function(value, index2, callback) {
            return iteratee(value, callback);
          };
        }
        function eachLimit(coll, iteratee, callback) {
          eachOf(coll, _withoutIndex(wrapAsync(iteratee)), callback);
        }
        function eachLimit$1(coll, limit, iteratee, callback) {
          _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
        }
        var eachSeries = doLimit(eachLimit$1, 1);
        function ensureAsync(fn) {
          if (isAsync(fn))
            return fn;
          return initialParams(function(args, callback) {
            var sync2 = true;
            args.push(function() {
              var innerArgs = arguments;
              if (sync2) {
                setImmediate$1(function() {
                  callback.apply(null, innerArgs);
                });
              } else {
                callback.apply(null, innerArgs);
              }
            });
            fn.apply(this, args);
            sync2 = false;
          });
        }
        function notId(v) {
          return !v;
        }
        var every = doParallel(_createTester(notId, notId));
        var everyLimit = doParallelLimit(_createTester(notId, notId));
        var everySeries = doLimit(everyLimit, 1);
        function baseProperty(key) {
          return function(object2) {
            return object2 == null ? void 0 : object2[key];
          };
        }
        function filterArray(eachfn, arr, iteratee, callback) {
          var truthValues = new Array(arr.length);
          eachfn(arr, function(x, index2, callback2) {
            iteratee(x, function(err, v) {
              truthValues[index2] = !!v;
              callback2(err);
            });
          }, function(err) {
            if (err)
              return callback(err);
            var results = [];
            for (var i = 0; i < arr.length; i++) {
              if (truthValues[i])
                results.push(arr[i]);
            }
            callback(null, results);
          });
        }
        function filterGeneric(eachfn, coll, iteratee, callback) {
          var results = [];
          eachfn(coll, function(x, index2, callback2) {
            iteratee(x, function(err, v) {
              if (err) {
                callback2(err);
              } else {
                if (v) {
                  results.push({ index: index2, value: x });
                }
                callback2();
              }
            });
          }, function(err) {
            if (err) {
              callback(err);
            } else {
              callback(null, arrayMap(results.sort(function(a, b) {
                return a.index - b.index;
              }), baseProperty("value")));
            }
          });
        }
        function _filter2(eachfn, coll, iteratee, callback) {
          var filter3 = isArrayLike(coll) ? filterArray : filterGeneric;
          filter3(eachfn, coll, wrapAsync(iteratee), callback || noop);
        }
        var filter2 = doParallel(_filter2);
        var filterLimit = doParallelLimit(_filter2);
        var filterSeries = doLimit(filterLimit, 1);
        function forever(fn, errback) {
          var done = onlyOnce(errback || noop);
          var task = wrapAsync(ensureAsync(fn));
          function next(err) {
            if (err)
              return done(err);
            task(next);
          }
          next();
        }
        var groupByLimit = function(coll, limit, iteratee, callback) {
          callback = callback || noop;
          var _iteratee = wrapAsync(iteratee);
          mapLimit(coll, limit, function(val, callback2) {
            _iteratee(val, function(err, key) {
              if (err)
                return callback2(err);
              return callback2(null, { key, val });
            });
          }, function(err, mapResults) {
            var result = {};
            var hasOwnProperty2 = Object.prototype.hasOwnProperty;
            for (var i = 0; i < mapResults.length; i++) {
              if (mapResults[i]) {
                var key = mapResults[i].key;
                var val = mapResults[i].val;
                if (hasOwnProperty2.call(result, key)) {
                  result[key].push(val);
                } else {
                  result[key] = [val];
                }
              }
            }
            return callback(err, result);
          });
        };
        var groupBy = doLimit(groupByLimit, Infinity);
        var groupBySeries = doLimit(groupByLimit, 1);
        var log2 = consoleFunc("log");
        function mapValuesLimit(obj, limit, iteratee, callback) {
          callback = once2(callback || noop);
          var newObj = {};
          var _iteratee = wrapAsync(iteratee);
          eachOfLimit(obj, limit, function(val, key, next) {
            _iteratee(val, key, function(err, result) {
              if (err)
                return next(err);
              newObj[key] = result;
              next();
            });
          }, function(err) {
            callback(err, newObj);
          });
        }
        var mapValues3 = doLimit(mapValuesLimit, Infinity);
        var mapValuesSeries = doLimit(mapValuesLimit, 1);
        function has4(obj, key) {
          return key in obj;
        }
        function memoize(fn, hasher) {
          var memo = /* @__PURE__ */ Object.create(null);
          var queues = /* @__PURE__ */ Object.create(null);
          hasher = hasher || identity2;
          var _fn = wrapAsync(fn);
          var memoized = initialParams(function memoized2(args, callback) {
            var key = hasher.apply(null, args);
            if (has4(memo, key)) {
              setImmediate$1(function() {
                callback.apply(null, memo[key]);
              });
            } else if (has4(queues, key)) {
              queues[key].push(callback);
            } else {
              queues[key] = [callback];
              _fn.apply(null, args.concat(function() {
                var args2 = slice(arguments);
                memo[key] = args2;
                var q = queues[key];
                delete queues[key];
                for (var i = 0, l = q.length; i < l; i++) {
                  q[i].apply(null, args2);
                }
              }));
            }
          });
          memoized.memo = memo;
          memoized.unmemoized = fn;
          return memoized;
        }
        var _defer$1;
        if (hasNextTick) {
          _defer$1 = process.nextTick;
        } else if (hasSetImmediate) {
          _defer$1 = setImmediate;
        } else {
          _defer$1 = fallback;
        }
        var nextTick = wrap(_defer$1);
        function _parallel(eachfn, tasks, callback) {
          callback = callback || noop;
          var results = isArrayLike(tasks) ? [] : {};
          eachfn(tasks, function(task, key, callback2) {
            wrapAsync(task)(function(err, result) {
              if (arguments.length > 2) {
                result = slice(arguments, 1);
              }
              results[key] = result;
              callback2(err);
            });
          }, function(err) {
            callback(err, results);
          });
        }
        function parallelLimit(tasks, callback) {
          _parallel(eachOf, tasks, callback);
        }
        function parallelLimit$1(tasks, limit, callback) {
          _parallel(_eachOfLimit(limit), tasks, callback);
        }
        var queue$1 = function(worker, concurrency) {
          var _worker = wrapAsync(worker);
          return queue(function(items, cb) {
            _worker(items[0], cb);
          }, concurrency, 1);
        };
        var priorityQueue = function(worker, concurrency) {
          var q = queue$1(worker, concurrency);
          q.push = function(data, priority, callback) {
            if (callback == null)
              callback = noop;
            if (typeof callback !== "function") {
              throw new Error("task callback must be a function");
            }
            q.started = true;
            if (!isArray(data)) {
              data = [data];
            }
            if (data.length === 0) {
              return setImmediate$1(function() {
                q.drain();
              });
            }
            priority = priority || 0;
            var nextNode = q._tasks.head;
            while (nextNode && priority >= nextNode.priority) {
              nextNode = nextNode.next;
            }
            for (var i = 0, l = data.length; i < l; i++) {
              var item = {
                data: data[i],
                priority,
                callback
              };
              if (nextNode) {
                q._tasks.insertBefore(nextNode, item);
              } else {
                q._tasks.push(item);
              }
            }
            setImmediate$1(q.process);
          };
          delete q.unshift;
          return q;
        };
        function race(tasks, callback) {
          callback = once2(callback || noop);
          if (!isArray(tasks))
            return callback(new TypeError("First argument to race must be an array of functions"));
          if (!tasks.length)
            return callback();
          for (var i = 0, l = tasks.length; i < l; i++) {
            wrapAsync(tasks[i])(callback);
          }
        }
        function reduceRight(array2, memo, iteratee, callback) {
          var reversed = slice(array2).reverse();
          reduce(reversed, memo, iteratee, callback);
        }
        function reflect(fn) {
          var _fn = wrapAsync(fn);
          return initialParams(function reflectOn(args, reflectCallback) {
            args.push(function callback(error2, cbArg) {
              if (error2) {
                reflectCallback(null, { error: error2 });
              } else {
                var value;
                if (arguments.length <= 2) {
                  value = cbArg;
                } else {
                  value = slice(arguments, 1);
                }
                reflectCallback(null, { value });
              }
            });
            return _fn.apply(this, args);
          });
        }
        function reflectAll(tasks) {
          var results;
          if (isArray(tasks)) {
            results = arrayMap(tasks, reflect);
          } else {
            results = {};
            baseForOwn(tasks, function(task, key) {
              results[key] = reflect.call(this, task);
            });
          }
          return results;
        }
        function reject$1(eachfn, arr, iteratee, callback) {
          _filter2(eachfn, arr, function(value, cb) {
            iteratee(value, function(err, v) {
              cb(err, !v);
            });
          }, callback);
        }
        var reject = doParallel(reject$1);
        var rejectLimit = doParallelLimit(reject$1);
        var rejectSeries = doLimit(rejectLimit, 1);
        function constant$1(value) {
          return function() {
            return value;
          };
        }
        function retry(opts, task, callback) {
          var DEFAULT_TIMES = 5;
          var DEFAULT_INTERVAL = 0;
          var options = {
            times: DEFAULT_TIMES,
            intervalFunc: constant$1(DEFAULT_INTERVAL)
          };
          function parseTimes(acc, t) {
            if (typeof t === "object") {
              acc.times = +t.times || DEFAULT_TIMES;
              acc.intervalFunc = typeof t.interval === "function" ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL);
              acc.errorFilter = t.errorFilter;
            } else if (typeof t === "number" || typeof t === "string") {
              acc.times = +t || DEFAULT_TIMES;
            } else {
              throw new Error("Invalid arguments for async.retry");
            }
          }
          if (arguments.length < 3 && typeof opts === "function") {
            callback = task || noop;
            task = opts;
          } else {
            parseTimes(options, opts);
            callback = callback || noop;
          }
          if (typeof task !== "function") {
            throw new Error("Invalid arguments for async.retry");
          }
          var _task = wrapAsync(task);
          var attempt = 1;
          function retryAttempt() {
            _task(function(err) {
              if (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err))) {
                setTimeout(retryAttempt, options.intervalFunc(attempt));
              } else {
                callback.apply(null, arguments);
              }
            });
          }
          retryAttempt();
        }
        var retryable = function(opts, task) {
          if (!task) {
            task = opts;
            opts = null;
          }
          var _task = wrapAsync(task);
          return initialParams(function(args, callback) {
            function taskFn(cb) {
              _task.apply(null, args.concat(cb));
            }
            if (opts)
              retry(opts, taskFn, callback);
            else
              retry(taskFn, callback);
          });
        };
        function series(tasks, callback) {
          _parallel(eachOfSeries, tasks, callback);
        }
        var some = doParallel(_createTester(Boolean, identity2));
        var someLimit = doParallelLimit(_createTester(Boolean, identity2));
        var someSeries = doLimit(someLimit, 1);
        function sortBy(coll, iteratee, callback) {
          var _iteratee = wrapAsync(iteratee);
          map2(coll, function(x, callback2) {
            _iteratee(x, function(err, criteria) {
              if (err)
                return callback2(err);
              callback2(null, { value: x, criteria });
            });
          }, function(err, results) {
            if (err)
              return callback(err);
            callback(null, arrayMap(results.sort(comparator), baseProperty("value")));
          });
          function comparator(left, right) {
            var a = left.criteria, b = right.criteria;
            return a < b ? -1 : a > b ? 1 : 0;
          }
        }
        function timeout(asyncFn, milliseconds, info) {
          var fn = wrapAsync(asyncFn);
          return initialParams(function(args, callback) {
            var timedOut = false;
            var timer;
            function timeoutCallback() {
              var name = asyncFn.name || "anonymous";
              var error2 = new Error('Callback function "' + name + '" timed out.');
              error2.code = "ETIMEDOUT";
              if (info) {
                error2.info = info;
              }
              timedOut = true;
              callback(error2);
            }
            args.push(function() {
              if (!timedOut) {
                callback.apply(null, arguments);
                clearTimeout(timer);
              }
            });
            timer = setTimeout(timeoutCallback, milliseconds);
            fn.apply(null, args);
          });
        }
        var nativeCeil = Math.ceil;
        var nativeMax = Math.max;
        function baseRange(start, end, step, fromRight) {
          var index2 = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
          while (length--) {
            result[fromRight ? length : ++index2] = start;
            start += step;
          }
          return result;
        }
        function timeLimit(count, limit, iteratee, callback) {
          var _iteratee = wrapAsync(iteratee);
          mapLimit(baseRange(0, count, 1), limit, _iteratee, callback);
        }
        var times = doLimit(timeLimit, Infinity);
        var timesSeries = doLimit(timeLimit, 1);
        function transform(coll, accumulator, iteratee, callback) {
          if (arguments.length <= 3) {
            callback = iteratee;
            iteratee = accumulator;
            accumulator = isArray(coll) ? [] : {};
          }
          callback = once2(callback || noop);
          var _iteratee = wrapAsync(iteratee);
          eachOf(coll, function(v, k, cb) {
            _iteratee(accumulator, v, k, cb);
          }, function(err) {
            callback(err, accumulator);
          });
        }
        function tryEach(tasks, callback) {
          var error2 = null;
          var result;
          callback = callback || noop;
          eachSeries(tasks, function(task, callback2) {
            wrapAsync(task)(function(err, res) {
              if (arguments.length > 2) {
                result = slice(arguments, 1);
              } else {
                result = res;
              }
              error2 = err;
              callback2(!err);
            });
          }, function() {
            callback(error2, result);
          });
        }
        function unmemoize(fn) {
          return function() {
            return (fn.unmemoized || fn).apply(null, arguments);
          };
        }
        function whilst(test, iteratee, callback) {
          callback = onlyOnce(callback || noop);
          var _iteratee = wrapAsync(iteratee);
          if (!test())
            return callback(null);
          var next = function(err) {
            if (err)
              return callback(err);
            if (test())
              return _iteratee(next);
            var args = slice(arguments, 1);
            callback.apply(null, [null].concat(args));
          };
          _iteratee(next);
        }
        function until(test, iteratee, callback) {
          whilst(function() {
            return !test.apply(this, arguments);
          }, iteratee, callback);
        }
        var waterfall = function(tasks, callback) {
          callback = once2(callback || noop);
          if (!isArray(tasks))
            return callback(new Error("First argument to waterfall must be an array of functions"));
          if (!tasks.length)
            return callback();
          var taskIndex = 0;
          function nextTask(args) {
            var task = wrapAsync(tasks[taskIndex++]);
            args.push(onlyOnce(next));
            task.apply(null, args);
          }
          function next(err) {
            if (err || taskIndex === tasks.length) {
              return callback.apply(null, arguments);
            }
            nextTask(slice(arguments, 1));
          }
          nextTask([]);
        };
        var index = {
          apply,
          applyEach,
          applyEachSeries,
          asyncify,
          auto,
          autoInject,
          cargo,
          compose: compose2,
          concat: concat3,
          concatLimit,
          concatSeries,
          constant,
          detect,
          detectLimit,
          detectSeries,
          dir,
          doDuring,
          doUntil,
          doWhilst,
          during,
          each: eachLimit,
          eachLimit: eachLimit$1,
          eachOf,
          eachOfLimit,
          eachOfSeries,
          eachSeries,
          ensureAsync,
          every,
          everyLimit,
          everySeries,
          filter: filter2,
          filterLimit,
          filterSeries,
          forever,
          groupBy,
          groupByLimit,
          groupBySeries,
          log: log2,
          map: map2,
          mapLimit,
          mapSeries,
          mapValues: mapValues3,
          mapValuesLimit,
          mapValuesSeries,
          memoize,
          nextTick,
          parallel: parallelLimit,
          parallelLimit: parallelLimit$1,
          priorityQueue,
          queue: queue$1,
          race,
          reduce,
          reduceRight,
          reflect,
          reflectAll,
          reject,
          rejectLimit,
          rejectSeries,
          retry,
          retryable,
          seq,
          series,
          setImmediate: setImmediate$1,
          some,
          someLimit,
          someSeries,
          sortBy,
          timeout,
          times,
          timesLimit: timeLimit,
          timesSeries,
          transform,
          tryEach,
          unmemoize,
          until,
          waterfall,
          whilst,
          // aliases
          all: every,
          allLimit: everyLimit,
          allSeries: everySeries,
          any: some,
          anyLimit: someLimit,
          anySeries: someSeries,
          find: detect,
          findLimit: detectLimit,
          findSeries: detectSeries,
          forEach: eachLimit,
          forEachSeries: eachSeries,
          forEachLimit: eachLimit$1,
          forEachOf: eachOf,
          forEachOfSeries: eachOfSeries,
          forEachOfLimit: eachOfLimit,
          inject: reduce,
          foldl: reduce,
          foldr: reduceRight,
          select: filter2,
          selectLimit: filterLimit,
          selectSeries: filterSeries,
          wrapSync: asyncify
        };
        exports2["default"] = index;
        exports2.apply = apply;
        exports2.applyEach = applyEach;
        exports2.applyEachSeries = applyEachSeries;
        exports2.asyncify = asyncify;
        exports2.auto = auto;
        exports2.autoInject = autoInject;
        exports2.cargo = cargo;
        exports2.compose = compose2;
        exports2.concat = concat3;
        exports2.concatLimit = concatLimit;
        exports2.concatSeries = concatSeries;
        exports2.constant = constant;
        exports2.detect = detect;
        exports2.detectLimit = detectLimit;
        exports2.detectSeries = detectSeries;
        exports2.dir = dir;
        exports2.doDuring = doDuring;
        exports2.doUntil = doUntil;
        exports2.doWhilst = doWhilst;
        exports2.during = during;
        exports2.each = eachLimit;
        exports2.eachLimit = eachLimit$1;
        exports2.eachOf = eachOf;
        exports2.eachOfLimit = eachOfLimit;
        exports2.eachOfSeries = eachOfSeries;
        exports2.eachSeries = eachSeries;
        exports2.ensureAsync = ensureAsync;
        exports2.every = every;
        exports2.everyLimit = everyLimit;
        exports2.everySeries = everySeries;
        exports2.filter = filter2;
        exports2.filterLimit = filterLimit;
        exports2.filterSeries = filterSeries;
        exports2.forever = forever;
        exports2.groupBy = groupBy;
        exports2.groupByLimit = groupByLimit;
        exports2.groupBySeries = groupBySeries;
        exports2.log = log2;
        exports2.map = map2;
        exports2.mapLimit = mapLimit;
        exports2.mapSeries = mapSeries;
        exports2.mapValues = mapValues3;
        exports2.mapValuesLimit = mapValuesLimit;
        exports2.mapValuesSeries = mapValuesSeries;
        exports2.memoize = memoize;
        exports2.nextTick = nextTick;
        exports2.parallel = parallelLimit;
        exports2.parallelLimit = parallelLimit$1;
        exports2.priorityQueue = priorityQueue;
        exports2.queue = queue$1;
        exports2.race = race;
        exports2.reduce = reduce;
        exports2.reduceRight = reduceRight;
        exports2.reflect = reflect;
        exports2.reflectAll = reflectAll;
        exports2.reject = reject;
        exports2.rejectLimit = rejectLimit;
        exports2.rejectSeries = rejectSeries;
        exports2.retry = retry;
        exports2.retryable = retryable;
        exports2.seq = seq;
        exports2.series = series;
        exports2.setImmediate = setImmediate$1;
        exports2.some = some;
        exports2.someLimit = someLimit;
        exports2.someSeries = someSeries;
        exports2.sortBy = sortBy;
        exports2.timeout = timeout;
        exports2.times = times;
        exports2.timesLimit = timeLimit;
        exports2.timesSeries = timesSeries;
        exports2.transform = transform;
        exports2.tryEach = tryEach;
        exports2.unmemoize = unmemoize;
        exports2.until = until;
        exports2.waterfall = waterfall;
        exports2.whilst = whilst;
        exports2.all = every;
        exports2.allLimit = everyLimit;
        exports2.allSeries = everySeries;
        exports2.any = some;
        exports2.anyLimit = someLimit;
        exports2.anySeries = someSeries;
        exports2.find = detect;
        exports2.findLimit = detectLimit;
        exports2.findSeries = detectSeries;
        exports2.forEach = eachLimit;
        exports2.forEachSeries = eachSeries;
        exports2.forEachLimit = eachLimit$1;
        exports2.forEachOf = eachOf;
        exports2.forEachOfSeries = eachOfSeries;
        exports2.forEachOfLimit = eachOfLimit;
        exports2.inject = reduce;
        exports2.foldl = reduce;
        exports2.foldr = reduceRight;
        exports2.select = filter2;
        exports2.selectLimit = filterLimit;
        exports2.selectSeries = filterSeries;
        exports2.wrapSync = asyncify;
        Object.defineProperty(exports2, "__esModule", { value: true });
      });
    }
  });

  // ../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js
  var require_ms = __commonJS({
    "../../node_modules/.pnpm/ms@2.1.3/node_modules/ms/index.js"(exports, module2) {
      var s = 1e3;
      var m = s * 60;
      var h = m * 60;
      var d = h * 24;
      var w = d * 7;
      var y = d * 365.25;
      module2.exports = function(val, options) {
        options = options || {};
        var type3 = typeof val;
        if (type3 === "string" && val.length > 0) {
          return parse3(val);
        } else if (type3 === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error(
          "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
        );
      };
      function parse3(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match3 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str
        );
        if (!match3) {
          return;
        }
        var n = parseFloat(match3[1]);
        var type3 = (match3[2] || "ms").toLowerCase();
        switch (type3) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "weeks":
          case "week":
          case "w":
            return n * w;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return void 0;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return Math.round(ms / d) + "d";
        }
        if (msAbs >= h) {
          return Math.round(ms / h) + "h";
        }
        if (msAbs >= m) {
          return Math.round(ms / m) + "m";
        }
        if (msAbs >= s) {
          return Math.round(ms / s) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return plural(ms, msAbs, d, "day");
        }
        if (msAbs >= h) {
          return plural(ms, msAbs, h, "hour");
        }
        if (msAbs >= m) {
          return plural(ms, msAbs, m, "minute");
        }
        if (msAbs >= s) {
          return plural(ms, msAbs, s, "second");
        }
        return ms + " ms";
      }
      function plural(ms, msAbs, n, name) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
      }
    }
  });

  // ../../node_modules/.pnpm/debug@3.2.7_supports-color@5.5.0/node_modules/debug/src/common.js
  var require_common4 = __commonJS({
    "../../node_modules/.pnpm/debug@3.2.7_supports-color@5.5.0/node_modules/debug/src/common.js"(exports, module2) {
      "use strict";
      function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        Object.keys(env).forEach(function(key) {
          createDebug[key] = env[key];
        });
        createDebug.instances = [];
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          var hash5 = 0;
          for (var i = 0; i < namespace.length; i++) {
            hash5 = (hash5 << 5) - hash5 + namespace.charCodeAt(i);
            hash5 |= 0;
          }
          return createDebug.colors[Math.abs(hash5) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          var prevTime;
          function debug2() {
            if (!debug2.enabled) {
              return;
            }
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            var self2 = debug2;
            var curr = Number(/* @__PURE__ */ new Date());
            var ms = curr - (prevTime || curr);
            self2.diff = ms;
            self2.prev = prevTime;
            self2.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            var index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match3, format) {
              if (match3 === "%%") {
                return match3;
              }
              index++;
              var formatter = createDebug.formatters[format];
              if (typeof formatter === "function") {
                var val = args[index];
                match3 = formatter.call(self2, val);
                args.splice(index, 1);
                index--;
              }
              return match3;
            });
            createDebug.formatArgs.call(self2, args);
            var logFn = self2.log || createDebug.log;
            logFn.apply(self2, args);
          }
          debug2.namespace = namespace;
          debug2.enabled = createDebug.enabled(namespace);
          debug2.useColors = createDebug.useColors();
          debug2.color = selectColor(namespace);
          debug2.destroy = destroy;
          debug2.extend = extend;
          if (typeof createDebug.init === "function") {
            createDebug.init(debug2);
          }
          createDebug.instances.push(debug2);
          return debug2;
        }
        function destroy() {
          var index = createDebug.instances.indexOf(this);
          if (index !== -1) {
            createDebug.instances.splice(index, 1);
            return true;
          }
          return false;
        }
        function extend(namespace, delimiter) {
          return createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.names = [];
          createDebug.skips = [];
          var i;
          var split4 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
          var len = split4.length;
          for (i = 0; i < len; i++) {
            if (!split4[i]) {
              continue;
            }
            namespaces = split4[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
            } else {
              createDebug.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
          for (i = 0; i < createDebug.instances.length; i++) {
            var instance = createDebug.instances[i];
            instance.enabled = createDebug.enabled(instance.namespace);
          }
        }
        function disable() {
          createDebug.enable("");
        }
        function enabled(name) {
          if (name[name.length - 1] === "*") {
            return true;
          }
          var i;
          var len;
          for (i = 0, len = createDebug.skips.length; i < len; i++) {
            if (createDebug.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = createDebug.names.length; i < len; i++) {
            if (createDebug.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }
        function coerce(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module2.exports = setup;
    }
  });

  // ../../node_modules/.pnpm/debug@3.2.7_supports-color@5.5.0/node_modules/debug/src/browser.js
  var require_browser = __commonJS({
    "../../node_modules/.pnpm/debug@3.2.7_supports-color@5.5.0/node_modules/debug/src/browser.js"(exports, module2) {
      "use strict";
      function _typeof(obj) {
        if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
          _typeof = function _typeof2(obj2) {
            return typeof obj2;
          };
        } else {
          _typeof = function _typeof2(obj2) {
            return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
          };
        }
        return _typeof(obj);
      }
      exports.log = log2;
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = localstorage();
      exports.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
        typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        var c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        var index = 0;
        var lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, function(match3) {
          if (match3 === "%%") {
            return;
          }
          index++;
          if (match3 === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }
      function log2() {
        var _console;
        return (typeof console === "undefined" ? "undefined" : _typeof(console)) === "object" && console.log && (_console = console).log.apply(_console, arguments);
      }
      function save(namespaces) {
        try {
          if (namespaces) {
            exports.storage.setItem("debug", namespaces);
          } else {
            exports.storage.removeItem("debug");
          }
        } catch (error2) {
        }
      }
      function load() {
        var r;
        try {
          r = exports.storage.getItem("debug");
        } catch (error2) {
        }
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }
        return r;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error2) {
        }
      }
      module2.exports = require_common4()(exports);
      var formatters = module2.exports.formatters;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error2) {
          return "[UnexpectedJSONParseError]: " + error2.message;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/has-flag@3.0.0/node_modules/has-flag/index.js
  var require_has_flag2 = __commonJS({
    "../../node_modules/.pnpm/has-flag@3.0.0/node_modules/has-flag/index.js"(exports, module2) {
      "use strict";
      module2.exports = (flag, argv) => {
        argv = argv || process.argv;
        const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
        const pos = argv.indexOf(prefix + flag);
        const terminatorPos = argv.indexOf("--");
        return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
      };
    }
  });

  // ../../node_modules/.pnpm/supports-color@5.5.0/node_modules/supports-color/index.js
  var require_supports_color2 = __commonJS({
    "../../node_modules/.pnpm/supports-color@5.5.0/node_modules/supports-color/index.js"(exports, module2) {
      "use strict";
      var os = __require2("os");
      var hasFlag = require_has_flag2();
      var env = process.env;
      var forceColor;
      if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
        forceColor = false;
      } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
        forceColor = true;
      }
      if ("FORCE_COLOR" in env) {
        forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
      }
      function translateLevel(level) {
        if (level === 0) {
          return false;
        }
        return {
          level,
          hasBasic: true,
          has256: level >= 2,
          has16m: level >= 3
        };
      }
      function supportsColor(stream2) {
        if (forceColor === false) {
          return 0;
        }
        if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
          return 3;
        }
        if (hasFlag("color=256")) {
          return 2;
        }
        if (stream2 && !stream2.isTTY && forceColor !== true) {
          return 0;
        }
        const min = forceColor ? 1 : 0;
        if (process.platform === "win32") {
          const osRelease = os.release().split(".");
          if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
            return Number(osRelease[2]) >= 14931 ? 3 : 2;
          }
          return 1;
        }
        if ("CI" in env) {
          if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
            return 1;
          }
          return min;
        }
        if ("TEAMCITY_VERSION" in env) {
          return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
        }
        if (env.COLORTERM === "truecolor") {
          return 3;
        }
        if ("TERM_PROGRAM" in env) {
          const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
          switch (env.TERM_PROGRAM) {
            case "iTerm.app":
              return version2 >= 3 ? 3 : 2;
            case "Apple_Terminal":
              return 2;
          }
        }
        if (/-256(color)?$/i.test(env.TERM)) {
          return 2;
        }
        if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
          return 1;
        }
        if ("COLORTERM" in env) {
          return 1;
        }
        if (env.TERM === "dumb") {
          return min;
        }
        return min;
      }
      function getSupportLevel(stream2) {
        const level = supportsColor(stream2);
        return translateLevel(level);
      }
      module2.exports = {
        supportsColor: getSupportLevel,
        stdout: getSupportLevel(process.stdout),
        stderr: getSupportLevel(process.stderr)
      };
    }
  });

  // ../../node_modules/.pnpm/debug@3.2.7_supports-color@5.5.0/node_modules/debug/src/node.js
  var require_node2 = __commonJS({
    "../../node_modules/.pnpm/debug@3.2.7_supports-color@5.5.0/node_modules/debug/src/node.js"(exports, module2) {
      "use strict";
      var tty = __require2("tty");
      var util = __require2("util");
      exports.init = init2;
      exports.log = log2;
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.colors = [6, 2, 3, 4, 5, 1];
      try {
        supportsColor = require_supports_color2();
        if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
          exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];
        }
      } catch (error2) {
      }
      var supportsColor;
      exports.inspectOpts = Object.keys(process.env).filter(function(key) {
        return /^debug_/i.test(key);
      }).reduce(function(obj, key) {
        var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
          return k.toUpperCase();
        });
        var val = process.env[key];
        if (/^(yes|on|true|enabled)$/i.test(val)) {
          val = true;
        } else if (/^(no|off|false|disabled)$/i.test(val)) {
          val = false;
        } else if (val === "null") {
          val = null;
        } else {
          val = Number(val);
        }
        obj[prop] = val;
        return obj;
      }, {});
      function useColors() {
        return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
      }
      function formatArgs(args) {
        var name = this.namespace, useColors2 = this.useColors;
        if (useColors2) {
          var c = this.color;
          var colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
          var prefix = "  ".concat(colorCode, ";1m").concat(name, " \x1B[0m");
          args[0] = prefix + args[0].split("\n").join("\n" + prefix);
          args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
        } else {
          args[0] = getDate() + name + " " + args[0];
        }
      }
      function getDate() {
        if (exports.inspectOpts.hideDate) {
          return "";
        }
        return (/* @__PURE__ */ new Date()).toISOString() + " ";
      }
      function log2() {
        return process.stderr.write(util.format.apply(util, arguments) + "\n");
      }
      function save(namespaces) {
        if (namespaces) {
          process.env.DEBUG = namespaces;
        } else {
          delete process.env.DEBUG;
        }
      }
      function load() {
        return process.env.DEBUG;
      }
      function init2(debug2) {
        debug2.inspectOpts = {};
        var keys4 = Object.keys(exports.inspectOpts);
        for (var i = 0; i < keys4.length; i++) {
          debug2.inspectOpts[keys4[i]] = exports.inspectOpts[keys4[i]];
        }
      }
      module2.exports = require_common4()(exports);
      var formatters = module2.exports.formatters;
      formatters.o = function(v) {
        this.inspectOpts.colors = this.useColors;
        return util.inspect(v, this.inspectOpts).split("\n").map(function(str) {
          return str.trim();
        }).join(" ");
      };
      formatters.O = function(v) {
        this.inspectOpts.colors = this.useColors;
        return util.inspect(v, this.inspectOpts);
      };
    }
  });

  // ../../node_modules/.pnpm/debug@3.2.7_supports-color@5.5.0/node_modules/debug/src/index.js
  var require_src = __commonJS({
    "../../node_modules/.pnpm/debug@3.2.7_supports-color@5.5.0/node_modules/debug/src/index.js"(exports, module2) {
      "use strict";
      if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
        module2.exports = require_browser();
      } else {
        module2.exports = require_node2();
      }
    }
  });

  // ../../node_modules/.pnpm/mkdirp@0.5.6/node_modules/mkdirp/index.js
  var require_mkdirp2 = __commonJS({
    "../../node_modules/.pnpm/mkdirp@0.5.6/node_modules/mkdirp/index.js"(exports, module2) {
      var path4 = __require2("path");
      var fs4 = __require2("fs");
      var _0777 = parseInt("0777", 8);
      module2.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
      function mkdirP(p, opts, f2, made) {
        if (typeof opts === "function") {
          f2 = opts;
          opts = {};
        } else if (!opts || typeof opts !== "object") {
          opts = { mode: opts };
        }
        var mode = opts.mode;
        var xfs = opts.fs || fs4;
        if (mode === void 0) {
          mode = _0777;
        }
        if (!made)
          made = null;
        var cb = f2 || /* istanbul ignore next */
        function() {
        };
        p = path4.resolve(p);
        xfs.mkdir(p, mode, function(er) {
          if (!er) {
            made = made || p;
            return cb(null, made);
          }
          switch (er.code) {
            case "ENOENT":
              if (path4.dirname(p) === p)
                return cb(er);
              mkdirP(path4.dirname(p), opts, function(er2, made2) {
                if (er2)
                  cb(er2, made2);
                else
                  mkdirP(p, opts, cb, made2);
              });
              break;
            default:
              xfs.stat(p, function(er2, stat) {
                if (er2 || !stat.isDirectory())
                  cb(er, made);
                else
                  cb(null, made);
              });
              break;
          }
        });
      }
      mkdirP.sync = function sync2(p, opts, made) {
        if (!opts || typeof opts !== "object") {
          opts = { mode: opts };
        }
        var mode = opts.mode;
        var xfs = opts.fs || fs4;
        if (mode === void 0) {
          mode = _0777;
        }
        if (!made)
          made = null;
        p = path4.resolve(p);
        try {
          xfs.mkdirSync(p, mode);
          made = made || p;
        } catch (err0) {
          switch (err0.code) {
            case "ENOENT":
              made = sync2(path4.dirname(p), opts, made);
              sync2(p, opts, made);
              break;
            default:
              var stat;
              try {
                stat = xfs.statSync(p);
              } catch (err1) {
                throw err0;
              }
              if (!stat.isDirectory())
                throw err0;
              break;
          }
        }
        return made;
      };
    }
  });

  // ../../node_modules/.pnpm/portfinder@1.0.32/node_modules/portfinder/lib/portfinder.js
  var require_portfinder = __commonJS({
    "../../node_modules/.pnpm/portfinder@1.0.32/node_modules/portfinder/lib/portfinder.js"(exports) {
      "use strict";
      var fs4 = __require2("fs");
      var os = __require2("os");
      var net = __require2("net");
      var path4 = __require2("path");
      var _async = require_async2();
      var debug2 = require_src();
      var mkdirp3 = require_mkdirp2().mkdirp;
      var debugTestPort = debug2("portfinder:testPort");
      var debugGetPort = debug2("portfinder:getPort");
      var debugDefaultHosts = debug2("portfinder:defaultHosts");
      var internals = {};
      internals.testPort = function(options, callback) {
        if (!callback) {
          callback = options;
          options = {};
        }
        options.server = options.server || net.createServer(function() {
        });
        debugTestPort("entered testPort(): trying", options.host, "port", options.port);
        function onListen() {
          debugTestPort("done w/ testPort(): OK", options.host, "port", options.port);
          options.server.removeListener("error", onError);
          options.server.close();
          callback(null, options.port);
        }
        function onError(err) {
          debugTestPort("done w/ testPort(): failed", options.host, "w/ port", options.port, "with error", err.code);
          options.server.removeListener("listening", onListen);
          if (!(err.code == "EADDRINUSE" || err.code == "EACCES")) {
            return callback(err);
          }
          var nextPort = exports.nextPort(options.port);
          if (nextPort > exports.highestPort) {
            return callback(new Error("No open ports available"));
          }
          internals.testPort({
            port: nextPort,
            host: options.host,
            server: options.server
          }, callback);
        }
        options.server.once("error", onError);
        options.server.once("listening", onListen);
        if (options.host) {
          options.server.listen(options.port, options.host);
        } else {
          options.server.listen(options.port);
        }
      };
      exports.basePort = 8e3;
      exports.setBasePort = function(port) {
        exports.basePort = port;
      };
      exports.highestPort = 65535;
      exports.setHighestPort = function(port) {
        exports.highestPort = port;
      };
      exports.basePath = "/tmp/portfinder";
      exports.getPort = function(options, callback) {
        if (!callback) {
          callback = options;
          options = {};
        }
        options.port = Number(options.port) || Number(exports.basePort);
        options.host = options.host || null;
        options.stopPort = Number(options.stopPort) || Number(exports.highestPort);
        if (!options.startPort) {
          options.startPort = Number(options.port);
          if (options.startPort < 0) {
            throw Error("Provided options.startPort(" + options.startPort + ") is less than 0, which are cannot be bound.");
          }
          if (options.stopPort < options.startPort) {
            throw Error("Provided options.stopPort(" + options.stopPort + "is less than options.startPort (" + options.startPort + ")");
          }
        }
        if (options.host) {
          if (exports._defaultHosts.indexOf(options.host) !== -1) {
            exports._defaultHosts.push(options.host);
          }
        }
        var openPorts = [], currentHost;
        return _async.eachSeries(exports._defaultHosts, function(host, next) {
          debugGetPort("in eachSeries() iteration callback: host is", host);
          return internals.testPort({ host, port: options.port }, function(err, port) {
            if (err) {
              debugGetPort("in eachSeries() iteration callback testPort() callback", "with an err:", err.code);
              currentHost = host;
              return next(err);
            } else {
              debugGetPort(
                "in eachSeries() iteration callback testPort() callback",
                "with a success for port",
                port
              );
              openPorts.push(port);
              return next();
            }
          });
        }, function(err) {
          if (err) {
            debugGetPort("in eachSeries() result callback: err is", err);
            if (err.code === "EADDRNOTAVAIL" || err.code === "EINVAL") {
              if (options.host === currentHost) {
                var msg = "Provided host " + options.host + " could NOT be bound. Please provide a different host address or hostname";
                return callback(Error(msg));
              } else {
                var idx = exports._defaultHosts.indexOf(currentHost);
                exports._defaultHosts.splice(idx, 1);
                return exports.getPort(options, callback);
              }
            } else {
              return callback(err);
            }
          }
          openPorts.sort(function(a, b) {
            return a - b;
          });
          debugGetPort("in eachSeries() result callback: openPorts is", openPorts);
          if (openPorts[0] === openPorts[openPorts.length - 1]) {
            if (openPorts[0] <= options.stopPort) {
              return callback(null, openPorts[0]);
            } else {
              var msg = "No open ports found in between " + options.startPort + " and " + options.stopPort;
              return callback(Error(msg));
            }
          } else {
            return exports.getPort({ port: openPorts.pop(), host: options.host, startPort: options.startPort, stopPort: options.stopPort }, callback);
          }
        });
      };
      exports.getPortPromise = function(options) {
        if (typeof Promise !== "function") {
          throw Error("Native promise support is not available in this version of node.Please install a polyfill and assign Promise to global.Promise before calling this method");
        }
        if (!options) {
          options = {};
        }
        return new Promise(function(resolve4, reject) {
          exports.getPort(options, function(err, port) {
            if (err) {
              return reject(err);
            }
            resolve4(port);
          });
        });
      };
      exports.getPorts = function(count, options, callback) {
        if (!callback) {
          callback = options;
          options = {};
        }
        var lastPort = null;
        _async.timesSeries(count, function(index, asyncCallback) {
          if (lastPort) {
            options.port = exports.nextPort(lastPort);
          }
          exports.getPort(options, function(err, port) {
            if (err) {
              asyncCallback(err);
            } else {
              lastPort = port;
              asyncCallback(null, port);
            }
          });
        }, callback);
      };
      exports.getSocket = function(options, callback) {
        if (!callback) {
          callback = options;
          options = {};
        }
        options.mod = options.mod || parseInt(755, 8);
        options.path = options.path || exports.basePath + ".sock";
        function testSocket() {
          fs4.stat(options.path, function(err) {
            if (err) {
              if (err.code == "ENOENT") {
                callback(null, options.path);
              } else {
                callback(err);
              }
            } else {
              options.path = exports.nextSocket(options.path);
              exports.getSocket(options, callback);
            }
          });
        }
        function createAndTestSocket(dir) {
          mkdirp3(dir, options.mod, function(err) {
            if (err) {
              return callback(err);
            }
            options.exists = true;
            testSocket();
          });
        }
        function checkAndTestSocket() {
          var dir = path4.dirname(options.path);
          fs4.stat(dir, function(err, stats) {
            if (err || !stats.isDirectory()) {
              return createAndTestSocket(dir);
            }
            options.exists = true;
            testSocket();
          });
        }
        return options.exists ? testSocket() : checkAndTestSocket();
      };
      exports.nextPort = function(port) {
        return port + 1;
      };
      exports.nextSocket = function(socketPath) {
        var dir = path4.dirname(socketPath), name = path4.basename(socketPath, ".sock"), match3 = name.match(/^([a-zA-z]+)(\d*)$/i), index = parseInt(match3[2]), base = match3[1];
        if (isNaN(index)) {
          index = 0;
        }
        index += 1;
        return path4.join(dir, base + index + ".sock");
      };
      exports._defaultHosts = function() {
        var interfaces = {};
        try {
          interfaces = os.networkInterfaces();
        } catch (e) {
          if (e.syscall === "uv_interface_addresses") {
          } else {
            throw e;
          }
        }
        var interfaceNames = Object.keys(interfaces), hiddenButImportantHost = "0.0.0.0", results = [hiddenButImportantHost];
        for (var i = 0; i < interfaceNames.length; i++) {
          var _interface = interfaces[interfaceNames[i]];
          for (var j = 0; j < _interface.length; j++) {
            var curr = _interface[j];
            results.push(curr.address);
          }
        }
        results.push(null);
        debugDefaultHosts("exports._defaultHosts is: %o", results);
        return results;
      }();
    }
  });

  // ../../node_modules/.pnpm/tree-kill@1.2.2/node_modules/tree-kill/index.js
  var require_tree_kill = __commonJS({
    "../../node_modules/.pnpm/tree-kill@1.2.2/node_modules/tree-kill/index.js"(exports, module2) {
      "use strict";
      var childProcess = __require2("child_process");
      var spawn3 = childProcess.spawn;
      var exec = childProcess.exec;
      module2.exports = function(pid, signal, callback) {
        if (typeof signal === "function" && callback === void 0) {
          callback = signal;
          signal = void 0;
        }
        pid = parseInt(pid);
        if (Number.isNaN(pid)) {
          if (callback) {
            return callback(new Error("pid must be a number"));
          } else {
            throw new Error("pid must be a number");
          }
        }
        var tree = {};
        var pidsToProcess = {};
        tree[pid] = [];
        pidsToProcess[pid] = 1;
        switch (process.platform) {
          case "win32":
            exec("taskkill /pid " + pid + " /T /F", callback);
            break;
          case "darwin":
            buildProcessTree(pid, tree, pidsToProcess, function(parentPid) {
              return spawn3("pgrep", ["-P", parentPid]);
            }, function() {
              killAll(tree, signal, callback);
            });
            break;
          default:
            buildProcessTree(pid, tree, pidsToProcess, function(parentPid) {
              return spawn3("ps", ["-o", "pid", "--no-headers", "--ppid", parentPid]);
            }, function() {
              killAll(tree, signal, callback);
            });
            break;
        }
      };
      function killAll(tree, signal, callback) {
        var killed = {};
        try {
          Object.keys(tree).forEach(function(pid) {
            tree[pid].forEach(function(pidpid) {
              if (!killed[pidpid]) {
                killPid(pidpid, signal);
                killed[pidpid] = 1;
              }
            });
            if (!killed[pid]) {
              killPid(pid, signal);
              killed[pid] = 1;
            }
          });
        } catch (err) {
          if (callback) {
            return callback(err);
          } else {
            throw err;
          }
        }
        if (callback) {
          return callback();
        }
      }
      function killPid(pid, signal) {
        try {
          process.kill(parseInt(pid, 10), signal);
        } catch (err) {
          if (err.code !== "ESRCH")
            throw err;
        }
      }
      function buildProcessTree(parentPid, tree, pidsToProcess, spawnChildProcessesList, cb) {
        var ps = spawnChildProcessesList(parentPid);
        var allData = "";
        ps.stdout.on("data", function(data) {
          var data = data.toString("ascii");
          allData += data;
        });
        var onClose = function(code) {
          delete pidsToProcess[parentPid];
          if (code != 0) {
            if (Object.keys(pidsToProcess).length == 0) {
              cb();
            }
            return;
          }
          allData.match(/\d+/g).forEach(function(pid) {
            pid = parseInt(pid, 10);
            tree[parentPid].push(pid);
            tree[pid] = [];
            pidsToProcess[pid] = 1;
            buildProcessTree(pid, tree, pidsToProcess, spawnChildProcessesList, cb);
          });
        };
        ps.on("close", onClose);
      }
    }
  });

  // ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js
  var require_windows = __commonJS({
    "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/windows.js"(exports, module2) {
      module2.exports = isexe;
      isexe.sync = sync2;
      var fs4 = __require2("fs");
      function checkPathExt(path4, options) {
        var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
        if (!pathext) {
          return true;
        }
        pathext = pathext.split(";");
        if (pathext.indexOf("") !== -1) {
          return true;
        }
        for (var i = 0; i < pathext.length; i++) {
          var p = pathext[i].toLowerCase();
          if (p && path4.substr(-p.length).toLowerCase() === p) {
            return true;
          }
        }
        return false;
      }
      function checkStat(stat, path4, options) {
        if (!stat.isSymbolicLink() && !stat.isFile()) {
          return false;
        }
        return checkPathExt(path4, options);
      }
      function isexe(path4, options, cb) {
        fs4.stat(path4, function(er, stat) {
          cb(er, er ? false : checkStat(stat, path4, options));
        });
      }
      function sync2(path4, options) {
        return checkStat(fs4.statSync(path4), path4, options);
      }
    }
  });

  // ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js
  var require_mode = __commonJS({
    "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/mode.js"(exports, module2) {
      module2.exports = isexe;
      isexe.sync = sync2;
      var fs4 = __require2("fs");
      function isexe(path4, options, cb) {
        fs4.stat(path4, function(er, stat) {
          cb(er, er ? false : checkStat(stat, options));
        });
      }
      function sync2(path4, options) {
        return checkStat(fs4.statSync(path4), options);
      }
      function checkStat(stat, options) {
        return stat.isFile() && checkMode(stat, options);
      }
      function checkMode(stat, options) {
        var mod = stat.mode;
        var uid = stat.uid;
        var gid = stat.gid;
        var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
        var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
        var u = parseInt("100", 8);
        var g = parseInt("010", 8);
        var o = parseInt("001", 8);
        var ug = u | g;
        var ret3 = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
        return ret3;
      }
    }
  });

  // ../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js
  var require_isexe = __commonJS({
    "../../node_modules/.pnpm/isexe@2.0.0/node_modules/isexe/index.js"(exports, module2) {
      var fs4 = __require2("fs");
      var core;
      if (process.platform === "win32" || global.TESTING_WINDOWS) {
        core = require_windows();
      } else {
        core = require_mode();
      }
      module2.exports = isexe;
      isexe.sync = sync2;
      function isexe(path4, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (!cb) {
          if (typeof Promise !== "function") {
            throw new TypeError("callback not provided");
          }
          return new Promise(function(resolve4, reject) {
            isexe(path4, options || {}, function(er, is) {
              if (er) {
                reject(er);
              } else {
                resolve4(is);
              }
            });
          });
        }
        core(path4, options || {}, function(er, is) {
          if (er) {
            if (er.code === "EACCES" || options && options.ignoreErrors) {
              er = null;
              is = false;
            }
          }
          cb(er, is);
        });
      }
      function sync2(path4, options) {
        try {
          return core.sync(path4, options || {});
        } catch (er) {
          if (options && options.ignoreErrors || er.code === "EACCES") {
            return false;
          } else {
            throw er;
          }
        }
      }
    }
  });

  // ../../node_modules/.pnpm/which@1.3.1/node_modules/which/which.js
  var require_which = __commonJS({
    "../../node_modules/.pnpm/which@1.3.1/node_modules/which/which.js"(exports, module2) {
      module2.exports = which;
      which.sync = whichSync;
      var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
      var path4 = __require2("path");
      var COLON = isWindows ? ";" : ":";
      var isexe = require_isexe();
      function getNotFoundError(cmd) {
        var er = new Error("not found: " + cmd);
        er.code = "ENOENT";
        return er;
      }
      function getPathInfo(cmd, opt) {
        var colon = opt.colon || COLON;
        var pathEnv = opt.path || process.env.PATH || "";
        var pathExt = [""];
        pathEnv = pathEnv.split(colon);
        var pathExtExe = "";
        if (isWindows) {
          pathEnv.unshift(process.cwd());
          pathExtExe = opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM";
          pathExt = pathExtExe.split(colon);
          if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
            pathExt.unshift("");
        }
        if (cmd.match(/\//) || isWindows && cmd.match(/\\/))
          pathEnv = [""];
        return {
          env: pathEnv,
          ext: pathExt,
          extExe: pathExtExe
        };
      }
      function which(cmd, opt, cb) {
        if (typeof opt === "function") {
          cb = opt;
          opt = {};
        }
        var info = getPathInfo(cmd, opt);
        var pathEnv = info.env;
        var pathExt = info.ext;
        var pathExtExe = info.extExe;
        var found = [];
        (function F(i, l) {
          if (i === l) {
            if (opt.all && found.length)
              return cb(null, found);
            else
              return cb(getNotFoundError(cmd));
          }
          var pathPart = pathEnv[i];
          if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
            pathPart = pathPart.slice(1, -1);
          var p = path4.join(pathPart, cmd);
          if (!pathPart && /^\.[\\\/]/.test(cmd)) {
            p = cmd.slice(0, 2) + p;
          }
          ;
          (function E(ii, ll) {
            if (ii === ll)
              return F(i + 1, l);
            var ext2 = pathExt[ii];
            isexe(p + ext2, { pathExt: pathExtExe }, function(er, is) {
              if (!er && is) {
                if (opt.all)
                  found.push(p + ext2);
                else
                  return cb(null, p + ext2);
              }
              return E(ii + 1, ll);
            });
          })(0, pathExt.length);
        })(0, pathEnv.length);
      }
      function whichSync(cmd, opt) {
        opt = opt || {};
        var info = getPathInfo(cmd, opt);
        var pathEnv = info.env;
        var pathExt = info.ext;
        var pathExtExe = info.extExe;
        var found = [];
        for (var i = 0, l = pathEnv.length; i < l; i++) {
          var pathPart = pathEnv[i];
          if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
            pathPart = pathPart.slice(1, -1);
          var p = path4.join(pathPart, cmd);
          if (!pathPart && /^\.[\\\/]/.test(cmd)) {
            p = cmd.slice(0, 2) + p;
          }
          for (var j = 0, ll = pathExt.length; j < ll; j++) {
            var cur = p + pathExt[j];
            var is;
            try {
              is = isexe.sync(cur, { pathExt: pathExtExe });
              if (is) {
                if (opt.all)
                  found.push(cur);
                else
                  return cur;
              }
            } catch (ex) {
            }
          }
        }
        if (opt.all && found.length)
          return found;
        if (opt.nothrow)
          return null;
        throw getNotFoundError(cmd);
      }
    }
  });

  // ../../node_modules/.pnpm/npm-path@2.0.4/node_modules/npm-path/find-prefix.js
  var require_find_prefix = __commonJS({
    "../../node_modules/.pnpm/npm-path@2.0.4/node_modules/npm-path/find-prefix.js"(exports, module2) {
      "use strict";
      var fs4 = __require2("fs");
      var path4 = __require2("path");
      module2.exports = function(options, cb) {
        return findPrefix(options.cwd, options.isSync, cb);
      };
      function readdir2(p, isSync, fn) {
        var val = null;
        if (isSync) {
          try {
            val = fs4.readdirSync(p);
          } catch (err) {
            return fn(err);
          }
          return fn(null, val);
        }
        return fs4.readdir(p, fn);
      }
      function findPrefix(p, isSync, cb_) {
        function cb(err, p2) {
          if (isSync)
            return cb_(err, p2);
          process.nextTick(function() {
            cb_(err, p2);
          });
        }
        p = path4.resolve(p);
        var walkedUp = false;
        while (path4.basename(p) === "node_modules") {
          p = path4.dirname(p);
          walkedUp = true;
        }
        if (walkedUp)
          return cb(null, p);
        findPrefix_(p, p, isSync, cb);
      }
      function findPrefix_(p, original, isSync, cb) {
        if (p === "/" || process.platform === "win32" && p.match(/^[a-zA-Z]:(\\|\/)?$/)) {
          return cb(null, original);
        }
        readdir2(p, isSync, function(err, files) {
          if (err && p === original) {
            if (err.code === "ENOENT")
              return cb(null, original);
            return cb(err);
          }
          if (err)
            return cb(null, original);
          if (files.indexOf("node_modules") !== -1 || files.indexOf("package.json") !== -1) {
            return cb(null, p);
          }
          var d = path4.dirname(p);
          if (d === p)
            return cb(null, original);
          return findPrefix_(d, original, isSync, cb);
        });
      }
    }
  });

  // ../../node_modules/.pnpm/npm-path@2.0.4/node_modules/npm-path/index.js
  var require_npm_path = __commonJS({
    "../../node_modules/.pnpm/npm-path@2.0.4/node_modules/npm-path/index.js"(exports, module2) {
      "use strict";
      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        } else {
          return Array.from(arr);
        }
      }
      var fs4 = __require2("fs");
      var path4 = __require2("path");
      var which = require_which();
      var findPrefix = require_find_prefix();
      var PATH = getPATHKey();
      var SEPARATOR = getPATHSeparator();
      function getPath(options, fn) {
        options.cwd = options.cwd || process.cwd();
        var env = options.env = options.env || process.env;
        var pathArr = getPathArr(options);
        findPrefix(options, function(err, prefixPath) {
          if (!err && prefixPath) {
            pathArr.unshift(path4.join(prefixPath, "node_modules", ".bin"));
          }
          whichNpm(options, function(err2, npmPath) {
            if (err2 || !npmPath) {
              if (options.npm) {
                return fn(err2 || new Error("Cannot find " + options.npm));
              }
            } else {
              pathArr.unshift(path4.join(path4.dirname(npmPath), "node-gyp-bin"));
            }
            if (env[PATH])
              pathArr = pathArr.concat(env[PATH].split(SEPARATOR));
            pathArr = [].concat(_toConsumableArray(new Set(pathArr)));
            fn(null, pathArr.join(SEPARATOR));
          });
        });
      }
      function getPathAsync(options, fn) {
        if (typeof options === "function") {
          fn = options;
          options = {};
        }
        if (typeof fn !== "function")
          return getPathSync(options);
        options = options || {};
        options.isSync = false;
        return getPath(options, fn);
      }
      function getPathSync(options) {
        options = options || {};
        options.isSync = true;
        var thePath = null;
        getPath(options, function(err, foundPath) {
          if (err)
            throw err;
          thePath = foundPath;
        });
        return thePath;
      }
      function setPathAsync(options, fn) {
        if (typeof options === "function") {
          fn = options;
          options = {};
        }
        if (typeof fn !== "function")
          return setPathSync(options);
        getPathAsync(options, function(err, newPath) {
          if (err)
            return fn(err);
          fn(null, options.env[PATH] = newPath);
        });
      }
      function setPathSync(options) {
        options = options || {};
        var newPath = getPathSync(options);
        options.env[PATH] = newPath;
        return newPath;
      }
      function getPathArr(options) {
        var wd = options.cwd;
        var pathArr = [];
        var p = wd.split(path4.sep + "node_modules" + path4.sep);
        var acc = path4.resolve(p.shift());
        pathArr.unshift(path4.dirname(process.execPath));
        p.forEach(function(pp) {
          pathArr.unshift(path4.join(acc, "node_modules", ".bin"));
          acc = path4.join(acc, "node_modules", pp);
        });
        pathArr.unshift(path4.join(acc, "node_modules", ".bin"));
        return pathArr;
      }
      function whichNpm(options, fn) {
        var npmCli = options.npm && path4.join(options.npm, "bin", "npm-cli.js");
        if (options.isSync) {
          var npmPath = null;
          try {
            npmPath = fs4.realpathSync(npmCli || which.sync("npm"));
          } catch (err) {
            return fn(err);
          }
          fn(null, npmPath);
          return;
        }
        if (options.npm) {
          fs4.realpath(npmCli, fn);
          return;
        }
        which("npm", function(err, npmPath2) {
          if (err)
            return fn(err);
          fs4.realpath(npmPath2, fn);
        });
      }
      function getPATHKey() {
        var PATH2 = "PATH";
        if (process.platform === "win32") {
          PATH2 = "Path";
          Object.keys(process.env).forEach(function(e) {
            if (e.match(/^PATH$/i)) {
              PATH2 = e;
            }
          });
        }
        return PATH2;
      }
      function getPATHSeparator() {
        return process.platform === "win32" ? ";" : ":";
      }
      module2.exports = setPathAsync;
      module2.exports.get = getPathAsync;
      module2.exports.get.sync = getPathSync;
      module2.exports.getSync = getPathSync;
      module2.exports.set = setPathAsync;
      module2.exports.set.sync = setPathSync;
      module2.exports.setSync = setPathSync;
      module2.exports.PATH = PATH;
      module2.exports.SEPARATOR = SEPARATOR;
    }
  });

  // ../../node_modules/.pnpm/npm-which@3.0.1/node_modules/npm-which/index.js
  var require_npm_which = __commonJS({
    "../../node_modules/.pnpm/npm-which@3.0.1/node_modules/npm-which/index.js"(exports, module2) {
      "use strict";
      var which = require_which();
      var npmPath = require_npm_path();
      module2.exports = function(cwd) {
        function npmWhich2(cmd, options, fn) {
          if (options instanceof Function)
            fn = options, options = null;
          options = options || {};
          options.cwd = options.cwd || cwd;
          options.env = options.env || process.env;
          function curryWhich(opts, fn2) {
            if (opts instanceof Function)
              fn2 = opts, opts = null;
            opts = opts || {};
            return npmWhich2(cmd, mixin(opts, options), fn2);
          }
          curryWhich.sync = function(opts) {
            opts = opts || {};
            return npmWhich2.sync(cmd, mixin(opts, options));
          };
          if (!(typeof fn === "function"))
            return curryWhich;
          if (!options.cwd)
            return fn(new Error("You must specify a cwd."));
          npmPath.get(options, function(err, newPath) {
            if (err)
              return fn(err);
            var oldPath = process.env[npmPath.PATH];
            process.env[npmPath.PATH] = newPath;
            which(cmd, function(err2, result) {
              process.env[npmPath.PATH] = oldPath;
              fn(err2, result);
            });
          });
        }
        npmWhich2.sync = function(cmd, options) {
          options = options || {};
          options.cwd = options.cwd || cwd;
          options.env = options.env || process.env;
          if (!options.cwd)
            throw new Error("You must specify a cwd.");
          var err = null;
          try {
            var oldPath = process.env[npmPath.PATH];
            var newPath = npmPath.getSync(options);
            process.env[npmPath.PATH] = newPath;
            var result = which.sync(cmd);
            return result;
          } catch (e) {
            err = e;
          } finally {
            process.env[npmPath.PATH] = oldPath;
            if (err)
              throw err;
          }
          return result;
        };
        if (arguments.length <= 1)
          return npmWhich2;
        return module2.exports().apply(this, arguments);
      };
      module2.exports.sync = function(cmd, options) {
        options = options || {};
        return module2.exports(options.cwd).sync(cmd, options);
      };
      function mixin(a, b) {
        for (var key in b) {
          a[key] = b[key];
        }
        return a;
      }
    }
  });

  // ../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/constants.js
  var require_constants3 = __commonJS({
    "../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/constants.js"(exports, module2) {
      "use strict";
      var path4 = __require2("path");
      var WIN_SLASH = "\\\\/";
      var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
      var DOT_LITERAL = "\\.";
      var PLUS_LITERAL = "\\+";
      var QMARK_LITERAL = "\\?";
      var SLASH_LITERAL = "\\/";
      var ONE_CHAR = "(?=.)";
      var QMARK = "[^/]";
      var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
      var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
      var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
      var NO_DOT = `(?!${DOT_LITERAL})`;
      var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
      var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
      var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
      var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
      var STAR = `${QMARK}*?`;
      var POSIX_CHARS = {
        DOT_LITERAL,
        PLUS_LITERAL,
        QMARK_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        QMARK,
        END_ANCHOR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      };
      var WINDOWS_CHARS = {
        ...POSIX_CHARS,
        SLASH_LITERAL: `[${WIN_SLASH}]`,
        QMARK: WIN_NO_SLASH,
        STAR: `${WIN_NO_SLASH}*?`,
        DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
        NO_DOT: `(?!${DOT_LITERAL})`,
        NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
        NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
        NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
        QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
        START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
        END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
      };
      var POSIX_REGEX_SOURCE = {
        alnum: "a-zA-Z0-9",
        alpha: "a-zA-Z",
        ascii: "\\x00-\\x7F",
        blank: " \\t",
        cntrl: "\\x00-\\x1F\\x7F",
        digit: "0-9",
        graph: "\\x21-\\x7E",
        lower: "a-z",
        print: "\\x20-\\x7E ",
        punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
        space: " \\t\\r\\n\\v\\f",
        upper: "A-Z",
        word: "A-Za-z0-9_",
        xdigit: "A-Fa-f0-9"
      };
      module2.exports = {
        MAX_LENGTH: 1024 * 64,
        POSIX_REGEX_SOURCE,
        // regular expressions
        REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
        REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
        REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
        REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
        REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
        REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
        // Replace globs with equivalent patterns to reduce parsing time.
        REPLACEMENTS: {
          "***": "*",
          "**/**": "**",
          "**/**/**": "**"
        },
        // Digits
        CHAR_0: 48,
        /* 0 */
        CHAR_9: 57,
        /* 9 */
        // Alphabet chars.
        CHAR_UPPERCASE_A: 65,
        /* A */
        CHAR_LOWERCASE_A: 97,
        /* a */
        CHAR_UPPERCASE_Z: 90,
        /* Z */
        CHAR_LOWERCASE_Z: 122,
        /* z */
        CHAR_LEFT_PARENTHESES: 40,
        /* ( */
        CHAR_RIGHT_PARENTHESES: 41,
        /* ) */
        CHAR_ASTERISK: 42,
        /* * */
        // Non-alphabetic chars.
        CHAR_AMPERSAND: 38,
        /* & */
        CHAR_AT: 64,
        /* @ */
        CHAR_BACKWARD_SLASH: 92,
        /* \ */
        CHAR_CARRIAGE_RETURN: 13,
        /* \r */
        CHAR_CIRCUMFLEX_ACCENT: 94,
        /* ^ */
        CHAR_COLON: 58,
        /* : */
        CHAR_COMMA: 44,
        /* , */
        CHAR_DOT: 46,
        /* . */
        CHAR_DOUBLE_QUOTE: 34,
        /* " */
        CHAR_EQUAL: 61,
        /* = */
        CHAR_EXCLAMATION_MARK: 33,
        /* ! */
        CHAR_FORM_FEED: 12,
        /* \f */
        CHAR_FORWARD_SLASH: 47,
        /* / */
        CHAR_GRAVE_ACCENT: 96,
        /* ` */
        CHAR_HASH: 35,
        /* # */
        CHAR_HYPHEN_MINUS: 45,
        /* - */
        CHAR_LEFT_ANGLE_BRACKET: 60,
        /* < */
        CHAR_LEFT_CURLY_BRACE: 123,
        /* { */
        CHAR_LEFT_SQUARE_BRACKET: 91,
        /* [ */
        CHAR_LINE_FEED: 10,
        /* \n */
        CHAR_NO_BREAK_SPACE: 160,
        /* \u00A0 */
        CHAR_PERCENT: 37,
        /* % */
        CHAR_PLUS: 43,
        /* + */
        CHAR_QUESTION_MARK: 63,
        /* ? */
        CHAR_RIGHT_ANGLE_BRACKET: 62,
        /* > */
        CHAR_RIGHT_CURLY_BRACE: 125,
        /* } */
        CHAR_RIGHT_SQUARE_BRACKET: 93,
        /* ] */
        CHAR_SEMICOLON: 59,
        /* ; */
        CHAR_SINGLE_QUOTE: 39,
        /* ' */
        CHAR_SPACE: 32,
        /*   */
        CHAR_TAB: 9,
        /* \t */
        CHAR_UNDERSCORE: 95,
        /* _ */
        CHAR_VERTICAL_LINE: 124,
        /* | */
        CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
        /* \uFEFF */
        SEP: path4.sep,
        /**
         * Create EXTGLOB_CHARS
         */
        extglobChars(chars) {
          return {
            "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
            "?": { type: "qmark", open: "(?:", close: ")?" },
            "+": { type: "plus", open: "(?:", close: ")+" },
            "*": { type: "star", open: "(?:", close: ")*" },
            "@": { type: "at", open: "(?:", close: ")" }
          };
        },
        /**
         * Create GLOB_CHARS
         */
        globChars(win322) {
          return win322 === true ? WINDOWS_CHARS : POSIX_CHARS;
        }
      };
    }
  });

  // ../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/utils.js
  var require_utils7 = __commonJS({
    "../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/utils.js"(exports) {
      "use strict";
      var path4 = __require2("path");
      var win322 = process.platform === "win32";
      var {
        REGEX_BACKSLASH,
        REGEX_REMOVE_BACKSLASH,
        REGEX_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_GLOBAL
      } = require_constants3();
      exports.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
      exports.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
      exports.isRegexChar = (str) => str.length === 1 && exports.hasRegexChars(str);
      exports.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
      exports.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
      exports.removeBackslashes = (str) => {
        return str.replace(REGEX_REMOVE_BACKSLASH, (match3) => {
          return match3 === "\\" ? "" : match3;
        });
      };
      exports.supportsLookbehinds = () => {
        const segs = process.version.slice(1).split(".").map(Number);
        if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
          return true;
        }
        return false;
      };
      exports.isWindows = (options) => {
        if (options && typeof options.windows === "boolean") {
          return options.windows;
        }
        return win322 === true || path4.sep === "\\";
      };
      exports.escapeLast = (input, char, lastIdx) => {
        const idx = input.lastIndexOf(char, lastIdx);
        if (idx === -1)
          return input;
        if (input[idx - 1] === "\\")
          return exports.escapeLast(input, char, idx - 1);
        return `${input.slice(0, idx)}\\${input.slice(idx)}`;
      };
      exports.removePrefix = (input, state = {}) => {
        let output3 = input;
        if (output3.startsWith("./")) {
          output3 = output3.slice(2);
          state.prefix = "./";
        }
        return output3;
      };
      exports.wrapOutput = (input, state = {}, options = {}) => {
        const prepend = options.contains ? "" : "^";
        const append = options.contains ? "" : "$";
        let output3 = `${prepend}(?:${input})${append}`;
        if (state.negated === true) {
          output3 = `(?:^(?!${output3}).*$)`;
        }
        return output3;
      };
    }
  });

  // ../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/scan.js
  var require_scan = __commonJS({
    "../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/scan.js"(exports, module2) {
      "use strict";
      var utils = require_utils7();
      var {
        CHAR_ASTERISK,
        /* * */
        CHAR_AT,
        /* @ */
        CHAR_BACKWARD_SLASH,
        /* \ */
        CHAR_COMMA,
        /* , */
        CHAR_DOT,
        /* . */
        CHAR_EXCLAMATION_MARK,
        /* ! */
        CHAR_FORWARD_SLASH,
        /* / */
        CHAR_LEFT_CURLY_BRACE,
        /* { */
        CHAR_LEFT_PARENTHESES,
        /* ( */
        CHAR_LEFT_SQUARE_BRACKET,
        /* [ */
        CHAR_PLUS,
        /* + */
        CHAR_QUESTION_MARK,
        /* ? */
        CHAR_RIGHT_CURLY_BRACE,
        /* } */
        CHAR_RIGHT_PARENTHESES,
        /* ) */
        CHAR_RIGHT_SQUARE_BRACKET
        /* ] */
      } = require_constants3();
      var isPathSeparator = (code) => {
        return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
      };
      var depth = (token) => {
        if (token.isPrefix !== true) {
          token.depth = token.isGlobstar ? Infinity : 1;
        }
      };
      var scan = (input, options) => {
        const opts = options || {};
        const length = input.length - 1;
        const scanToEnd = opts.parts === true || opts.scanToEnd === true;
        const slashes = [];
        const tokens = [];
        const parts = [];
        let str = input;
        let index = -1;
        let start = 0;
        let lastIndex = 0;
        let isBrace = false;
        let isBracket = false;
        let isGlob = false;
        let isExtglob = false;
        let isGlobstar = false;
        let braceEscaped = false;
        let backslashes = false;
        let negated = false;
        let negatedExtglob = false;
        let finished = false;
        let braces = 0;
        let prev;
        let code;
        let token = { value: "", depth: 0, isGlob: false };
        const eos = () => index >= length;
        const peek = () => str.charCodeAt(index + 1);
        const advance = () => {
          prev = code;
          return str.charCodeAt(++index);
        };
        while (index < length) {
          code = advance();
          let next;
          if (code === CHAR_BACKWARD_SLASH) {
            backslashes = token.backslashes = true;
            code = advance();
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braceEscaped = true;
            }
            continue;
          }
          if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
            braces++;
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_BACKWARD_SLASH) {
                backslashes = token.backslashes = true;
                advance();
                continue;
              }
              if (code === CHAR_LEFT_CURLY_BRACE) {
                braces++;
                continue;
              }
              if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
                isBrace = token.isBrace = true;
                isGlob = token.isGlob = true;
                finished = true;
                if (scanToEnd === true) {
                  continue;
                }
                break;
              }
              if (braceEscaped !== true && code === CHAR_COMMA) {
                isBrace = token.isBrace = true;
                isGlob = token.isGlob = true;
                finished = true;
                if (scanToEnd === true) {
                  continue;
                }
                break;
              }
              if (code === CHAR_RIGHT_CURLY_BRACE) {
                braces--;
                if (braces === 0) {
                  braceEscaped = false;
                  isBrace = token.isBrace = true;
                  finished = true;
                  break;
                }
              }
            }
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_FORWARD_SLASH) {
            slashes.push(index);
            tokens.push(token);
            token = { value: "", depth: 0, isGlob: false };
            if (finished === true)
              continue;
            if (prev === CHAR_DOT && index === start + 1) {
              start += 2;
              continue;
            }
            lastIndex = index + 1;
            continue;
          }
          if (opts.noext !== true) {
            const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
            if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
              isGlob = token.isGlob = true;
              isExtglob = token.isExtglob = true;
              finished = true;
              if (code === CHAR_EXCLAMATION_MARK && index === start) {
                negatedExtglob = true;
              }
              if (scanToEnd === true) {
                while (eos() !== true && (code = advance())) {
                  if (code === CHAR_BACKWARD_SLASH) {
                    backslashes = token.backslashes = true;
                    code = advance();
                    continue;
                  }
                  if (code === CHAR_RIGHT_PARENTHESES) {
                    isGlob = token.isGlob = true;
                    finished = true;
                    break;
                  }
                }
                continue;
              }
              break;
            }
          }
          if (code === CHAR_ASTERISK) {
            if (prev === CHAR_ASTERISK)
              isGlobstar = token.isGlobstar = true;
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_QUESTION_MARK) {
            isGlob = token.isGlob = true;
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (code === CHAR_LEFT_SQUARE_BRACKET) {
            while (eos() !== true && (next = advance())) {
              if (next === CHAR_BACKWARD_SLASH) {
                backslashes = token.backslashes = true;
                advance();
                continue;
              }
              if (next === CHAR_RIGHT_SQUARE_BRACKET) {
                isBracket = token.isBracket = true;
                isGlob = token.isGlob = true;
                finished = true;
                break;
              }
            }
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
          if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
            negated = token.negated = true;
            start++;
            continue;
          }
          if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_LEFT_PARENTHESES) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
          if (isGlob === true) {
            finished = true;
            if (scanToEnd === true) {
              continue;
            }
            break;
          }
        }
        if (opts.noext === true) {
          isExtglob = false;
          isGlob = false;
        }
        let base = str;
        let prefix = "";
        let glob2 = "";
        if (start > 0) {
          prefix = str.slice(0, start);
          str = str.slice(start);
          lastIndex -= start;
        }
        if (base && isGlob === true && lastIndex > 0) {
          base = str.slice(0, lastIndex);
          glob2 = str.slice(lastIndex);
        } else if (isGlob === true) {
          base = "";
          glob2 = str;
        } else {
          base = str;
        }
        if (base && base !== "" && base !== "/" && base !== str) {
          if (isPathSeparator(base.charCodeAt(base.length - 1))) {
            base = base.slice(0, -1);
          }
        }
        if (opts.unescape === true) {
          if (glob2)
            glob2 = utils.removeBackslashes(glob2);
          if (base && backslashes === true) {
            base = utils.removeBackslashes(base);
          }
        }
        const state = {
          prefix,
          input,
          start,
          base,
          glob: glob2,
          isBrace,
          isBracket,
          isGlob,
          isExtglob,
          isGlobstar,
          negated,
          negatedExtglob
        };
        if (opts.tokens === true) {
          state.maxDepth = 0;
          if (!isPathSeparator(code)) {
            tokens.push(token);
          }
          state.tokens = tokens;
        }
        if (opts.parts === true || opts.tokens === true) {
          let prevIndex;
          for (let idx = 0; idx < slashes.length; idx++) {
            const n = prevIndex ? prevIndex + 1 : start;
            const i = slashes[idx];
            const value = input.slice(n, i);
            if (opts.tokens) {
              if (idx === 0 && start !== 0) {
                tokens[idx].isPrefix = true;
                tokens[idx].value = prefix;
              } else {
                tokens[idx].value = value;
              }
              depth(tokens[idx]);
              state.maxDepth += tokens[idx].depth;
            }
            if (idx !== 0 || value !== "") {
              parts.push(value);
            }
            prevIndex = i;
          }
          if (prevIndex && prevIndex + 1 < input.length) {
            const value = input.slice(prevIndex + 1);
            parts.push(value);
            if (opts.tokens) {
              tokens[tokens.length - 1].value = value;
              depth(tokens[tokens.length - 1]);
              state.maxDepth += tokens[tokens.length - 1].depth;
            }
          }
          state.slashes = slashes;
          state.parts = parts;
        }
        return state;
      };
      module2.exports = scan;
    }
  });

  // ../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/parse.js
  var require_parse3 = __commonJS({
    "../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/parse.js"(exports, module2) {
      "use strict";
      var constants = require_constants3();
      var utils = require_utils7();
      var {
        MAX_LENGTH,
        POSIX_REGEX_SOURCE,
        REGEX_NON_SPECIAL_CHARS,
        REGEX_SPECIAL_CHARS_BACKREF,
        REPLACEMENTS
      } = constants;
      var expandRange = (args, options) => {
        if (typeof options.expandRange === "function") {
          return options.expandRange(...args, options);
        }
        args.sort();
        const value = `[${args.join("-")}]`;
        try {
          new RegExp(value);
        } catch (ex) {
          return args.map((v) => utils.escapeRegex(v)).join("..");
        }
        return value;
      };
      var syntaxError2 = (type3, char) => {
        return `Missing ${type3}: "${char}" - use "\\\\${char}" to match literal characters`;
      };
      var parse3 = (input, options) => {
        if (typeof input !== "string") {
          throw new TypeError("Expected a string");
        }
        input = REPLACEMENTS[input] || input;
        const opts = { ...options };
        const max2 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
        let len = input.length;
        if (len > max2) {
          throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max2}`);
        }
        const bos = { type: "bos", value: "", output: opts.prepend || "" };
        const tokens = [bos];
        const capture = opts.capture ? "" : "?:";
        const win322 = utils.isWindows(options);
        const PLATFORM_CHARS = constants.globChars(win322);
        const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
        const {
          DOT_LITERAL,
          PLUS_LITERAL,
          SLASH_LITERAL,
          ONE_CHAR,
          DOTS_SLASH,
          NO_DOT,
          NO_DOT_SLASH,
          NO_DOTS_SLASH,
          QMARK,
          QMARK_NO_DOT,
          STAR,
          START_ANCHOR
        } = PLATFORM_CHARS;
        const globstar = (opts2) => {
          return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
        };
        const nodot = opts.dot ? "" : NO_DOT;
        const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
        let star3 = opts.bash === true ? globstar(opts) : STAR;
        if (opts.capture) {
          star3 = `(${star3})`;
        }
        if (typeof opts.noext === "boolean") {
          opts.noextglob = opts.noext;
        }
        const state = {
          input,
          index: -1,
          start: 0,
          dot: opts.dot === true,
          consumed: "",
          output: "",
          prefix: "",
          backtrack: false,
          negated: false,
          brackets: 0,
          braces: 0,
          parens: 0,
          quotes: 0,
          globstar: false,
          tokens
        };
        input = utils.removePrefix(input, state);
        len = input.length;
        const extglobs = [];
        const braces = [];
        const stack = [];
        let prev = bos;
        let value;
        const eos = () => state.index === len - 1;
        const peek = state.peek = (n = 1) => input[state.index + n];
        const advance = state.advance = () => input[++state.index] || "";
        const remaining = () => input.slice(state.index + 1);
        const consume = (value2 = "", num = 0) => {
          state.consumed += value2;
          state.index += num;
        };
        const append = (token) => {
          state.output += token.output != null ? token.output : token.value;
          consume(token.value);
        };
        const negate = () => {
          let count = 1;
          while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
            advance();
            state.start++;
            count++;
          }
          if (count % 2 === 0) {
            return false;
          }
          state.negated = true;
          state.start++;
          return true;
        };
        const increment = (type3) => {
          state[type3]++;
          stack.push(type3);
        };
        const decrement = (type3) => {
          state[type3]--;
          stack.pop();
        };
        const push = (tok) => {
          if (prev.type === "globstar") {
            const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
            const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
            if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
              state.output = state.output.slice(0, -prev.output.length);
              prev.type = "star";
              prev.value = "*";
              prev.output = star3;
              state.output += prev.output;
            }
          }
          if (extglobs.length && tok.type !== "paren") {
            extglobs[extglobs.length - 1].inner += tok.value;
          }
          if (tok.value || tok.output)
            append(tok);
          if (prev && prev.type === "text" && tok.type === "text") {
            prev.value += tok.value;
            prev.output = (prev.output || "") + tok.value;
            return;
          }
          tok.prev = prev;
          tokens.push(tok);
          prev = tok;
        };
        const extglobOpen = (type3, value2) => {
          const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
          token.prev = prev;
          token.parens = state.parens;
          token.output = state.output;
          const output3 = (opts.capture ? "(" : "") + token.open;
          increment("parens");
          push({ type: type3, value: value2, output: state.output ? "" : ONE_CHAR });
          push({ type: "paren", extglob: true, value: advance(), output: output3 });
          extglobs.push(token);
        };
        const extglobClose = (token) => {
          let output3 = token.close + (opts.capture ? ")" : "");
          let rest;
          if (token.type === "negate") {
            let extglobStar = star3;
            if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
              extglobStar = globstar(opts);
            }
            if (extglobStar !== star3 || eos() || /^\)+$/.test(remaining())) {
              output3 = token.close = `)$))${extglobStar}`;
            }
            if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
              const expression = parse3(rest, { ...options, fastpaths: false }).output;
              output3 = token.close = `)${expression})${extglobStar})`;
            }
            if (token.prev.type === "bos") {
              state.negatedExtglob = true;
            }
          }
          push({ type: "paren", extglob: true, value, output: output3 });
          decrement("parens");
        };
        if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
          let backslashes = false;
          let output3 = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
            if (first === "\\") {
              backslashes = true;
              return m;
            }
            if (first === "?") {
              if (esc) {
                return esc + first + (rest ? QMARK.repeat(rest.length) : "");
              }
              if (index === 0) {
                return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
              }
              return QMARK.repeat(chars.length);
            }
            if (first === ".") {
              return DOT_LITERAL.repeat(chars.length);
            }
            if (first === "*") {
              if (esc) {
                return esc + first + (rest ? star3 : "");
              }
              return star3;
            }
            return esc ? m : `\\${m}`;
          });
          if (backslashes === true) {
            if (opts.unescape === true) {
              output3 = output3.replace(/\\/g, "");
            } else {
              output3 = output3.replace(/\\+/g, (m) => {
                return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
              });
            }
          }
          if (output3 === input && opts.contains === true) {
            state.output = input;
            return state;
          }
          state.output = utils.wrapOutput(output3, state, options);
          return state;
        }
        while (!eos()) {
          value = advance();
          if (value === "\0") {
            continue;
          }
          if (value === "\\") {
            const next = peek();
            if (next === "/" && opts.bash !== true) {
              continue;
            }
            if (next === "." || next === ";") {
              continue;
            }
            if (!next) {
              value += "\\";
              push({ type: "text", value });
              continue;
            }
            const match3 = /^\\+/.exec(remaining());
            let slashes = 0;
            if (match3 && match3[0].length > 2) {
              slashes = match3[0].length;
              state.index += slashes;
              if (slashes % 2 !== 0) {
                value += "\\";
              }
            }
            if (opts.unescape === true) {
              value = advance();
            } else {
              value += advance();
            }
            if (state.brackets === 0) {
              push({ type: "text", value });
              continue;
            }
          }
          if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
            if (opts.posix !== false && value === ":") {
              const inner = prev.value.slice(1);
              if (inner.includes("[")) {
                prev.posix = true;
                if (inner.includes(":")) {
                  const idx = prev.value.lastIndexOf("[");
                  const pre = prev.value.slice(0, idx);
                  const rest2 = prev.value.slice(idx + 2);
                  const posix2 = POSIX_REGEX_SOURCE[rest2];
                  if (posix2) {
                    prev.value = pre + posix2;
                    state.backtrack = true;
                    advance();
                    if (!bos.output && tokens.indexOf(prev) === 1) {
                      bos.output = ONE_CHAR;
                    }
                    continue;
                  }
                }
              }
            }
            if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
              value = `\\${value}`;
            }
            if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
              value = `\\${value}`;
            }
            if (opts.posix === true && value === "!" && prev.value === "[") {
              value = "^";
            }
            prev.value += value;
            append({ value });
            continue;
          }
          if (state.quotes === 1 && value !== '"') {
            value = utils.escapeRegex(value);
            prev.value += value;
            append({ value });
            continue;
          }
          if (value === '"') {
            state.quotes = state.quotes === 1 ? 0 : 1;
            if (opts.keepQuotes === true) {
              push({ type: "text", value });
            }
            continue;
          }
          if (value === "(") {
            increment("parens");
            push({ type: "paren", value });
            continue;
          }
          if (value === ")") {
            if (state.parens === 0 && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError2("opening", "("));
            }
            const extglob = extglobs[extglobs.length - 1];
            if (extglob && state.parens === extglob.parens + 1) {
              extglobClose(extglobs.pop());
              continue;
            }
            push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
            decrement("parens");
            continue;
          }
          if (value === "[") {
            if (opts.nobracket === true || !remaining().includes("]")) {
              if (opts.nobracket !== true && opts.strictBrackets === true) {
                throw new SyntaxError(syntaxError2("closing", "]"));
              }
              value = `\\${value}`;
            } else {
              increment("brackets");
            }
            push({ type: "bracket", value });
            continue;
          }
          if (value === "]") {
            if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
              push({ type: "text", value, output: `\\${value}` });
              continue;
            }
            if (state.brackets === 0) {
              if (opts.strictBrackets === true) {
                throw new SyntaxError(syntaxError2("opening", "["));
              }
              push({ type: "text", value, output: `\\${value}` });
              continue;
            }
            decrement("brackets");
            const prevValue = prev.value.slice(1);
            if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
              value = `/${value}`;
            }
            prev.value += value;
            append({ value });
            if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
              continue;
            }
            const escaped = utils.escapeRegex(prev.value);
            state.output = state.output.slice(0, -prev.value.length);
            if (opts.literalBrackets === true) {
              state.output += escaped;
              prev.value = escaped;
              continue;
            }
            prev.value = `(${capture}${escaped}|${prev.value})`;
            state.output += prev.value;
            continue;
          }
          if (value === "{" && opts.nobrace !== true) {
            increment("braces");
            const open = {
              type: "brace",
              value,
              output: "(",
              outputIndex: state.output.length,
              tokensIndex: state.tokens.length
            };
            braces.push(open);
            push(open);
            continue;
          }
          if (value === "}") {
            const brace = braces[braces.length - 1];
            if (opts.nobrace === true || !brace) {
              push({ type: "text", value, output: value });
              continue;
            }
            let output3 = ")";
            if (brace.dots === true) {
              const arr = tokens.slice();
              const range = [];
              for (let i = arr.length - 1; i >= 0; i--) {
                tokens.pop();
                if (arr[i].type === "brace") {
                  break;
                }
                if (arr[i].type !== "dots") {
                  range.unshift(arr[i].value);
                }
              }
              output3 = expandRange(range, opts);
              state.backtrack = true;
            }
            if (brace.comma !== true && brace.dots !== true) {
              const out = state.output.slice(0, brace.outputIndex);
              const toks = state.tokens.slice(brace.tokensIndex);
              brace.value = brace.output = "\\{";
              value = output3 = "\\}";
              state.output = out;
              for (const t of toks) {
                state.output += t.output || t.value;
              }
            }
            push({ type: "brace", value, output: output3 });
            decrement("braces");
            braces.pop();
            continue;
          }
          if (value === "|") {
            if (extglobs.length > 0) {
              extglobs[extglobs.length - 1].conditions++;
            }
            push({ type: "text", value });
            continue;
          }
          if (value === ",") {
            let output3 = value;
            const brace = braces[braces.length - 1];
            if (brace && stack[stack.length - 1] === "braces") {
              brace.comma = true;
              output3 = "|";
            }
            push({ type: "comma", value, output: output3 });
            continue;
          }
          if (value === "/") {
            if (prev.type === "dot" && state.index === state.start + 1) {
              state.start = state.index + 1;
              state.consumed = "";
              state.output = "";
              tokens.pop();
              prev = bos;
              continue;
            }
            push({ type: "slash", value, output: SLASH_LITERAL });
            continue;
          }
          if (value === ".") {
            if (state.braces > 0 && prev.type === "dot") {
              if (prev.value === ".")
                prev.output = DOT_LITERAL;
              const brace = braces[braces.length - 1];
              prev.type = "dots";
              prev.output += value;
              prev.value += value;
              brace.dots = true;
              continue;
            }
            if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
              push({ type: "text", value, output: DOT_LITERAL });
              continue;
            }
            push({ type: "dot", value, output: DOT_LITERAL });
            continue;
          }
          if (value === "?") {
            const isGroup = prev && prev.value === "(";
            if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
              extglobOpen("qmark", value);
              continue;
            }
            if (prev && prev.type === "paren") {
              const next = peek();
              let output3 = value;
              if (next === "<" && !utils.supportsLookbehinds()) {
                throw new Error("Node.js v10 or higher is required for regex lookbehinds");
              }
              if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
                output3 = `\\${value}`;
              }
              push({ type: "text", value, output: output3 });
              continue;
            }
            if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
              push({ type: "qmark", value, output: QMARK_NO_DOT });
              continue;
            }
            push({ type: "qmark", value, output: QMARK });
            continue;
          }
          if (value === "!") {
            if (opts.noextglob !== true && peek() === "(") {
              if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
                extglobOpen("negate", value);
                continue;
              }
            }
            if (opts.nonegate !== true && state.index === 0) {
              negate();
              continue;
            }
          }
          if (value === "+") {
            if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
              extglobOpen("plus", value);
              continue;
            }
            if (prev && prev.value === "(" || opts.regex === false) {
              push({ type: "plus", value, output: PLUS_LITERAL });
              continue;
            }
            if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
              push({ type: "plus", value });
              continue;
            }
            push({ type: "plus", value: PLUS_LITERAL });
            continue;
          }
          if (value === "@") {
            if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
              push({ type: "at", extglob: true, value, output: "" });
              continue;
            }
            push({ type: "text", value });
            continue;
          }
          if (value !== "*") {
            if (value === "$" || value === "^") {
              value = `\\${value}`;
            }
            const match3 = REGEX_NON_SPECIAL_CHARS.exec(remaining());
            if (match3) {
              value += match3[0];
              state.index += match3[0].length;
            }
            push({ type: "text", value });
            continue;
          }
          if (prev && (prev.type === "globstar" || prev.star === true)) {
            prev.type = "star";
            prev.star = true;
            prev.value += value;
            prev.output = star3;
            state.backtrack = true;
            state.globstar = true;
            consume(value);
            continue;
          }
          let rest = remaining();
          if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
            extglobOpen("star", value);
            continue;
          }
          if (prev.type === "star") {
            if (opts.noglobstar === true) {
              consume(value);
              continue;
            }
            const prior = prev.prev;
            const before = prior.prev;
            const isStart = prior.type === "slash" || prior.type === "bos";
            const afterStar = before && (before.type === "star" || before.type === "globstar");
            if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
              push({ type: "star", value, output: "" });
              continue;
            }
            const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
            const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
            if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
              push({ type: "star", value, output: "" });
              continue;
            }
            while (rest.slice(0, 3) === "/**") {
              const after = input[state.index + 4];
              if (after && after !== "/") {
                break;
              }
              rest = rest.slice(3);
              consume("/**", 3);
            }
            if (prior.type === "bos" && eos()) {
              prev.type = "globstar";
              prev.value += value;
              prev.output = globstar(opts);
              state.output = prev.output;
              state.globstar = true;
              consume(value);
              continue;
            }
            if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
              state.output = state.output.slice(0, -(prior.output + prev.output).length);
              prior.output = `(?:${prior.output}`;
              prev.type = "globstar";
              prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
              prev.value += value;
              state.globstar = true;
              state.output += prior.output + prev.output;
              consume(value);
              continue;
            }
            if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
              const end = rest[1] !== void 0 ? "|$" : "";
              state.output = state.output.slice(0, -(prior.output + prev.output).length);
              prior.output = `(?:${prior.output}`;
              prev.type = "globstar";
              prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
              prev.value += value;
              state.output += prior.output + prev.output;
              state.globstar = true;
              consume(value + advance());
              push({ type: "slash", value: "/", output: "" });
              continue;
            }
            if (prior.type === "bos" && rest[0] === "/") {
              prev.type = "globstar";
              prev.value += value;
              prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
              state.output = prev.output;
              state.globstar = true;
              consume(value + advance());
              push({ type: "slash", value: "/", output: "" });
              continue;
            }
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "globstar";
            prev.output = globstar(opts);
            prev.value += value;
            state.output += prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          const token = { type: "star", value, output: star3 };
          if (opts.bash === true) {
            token.output = ".*?";
            if (prev.type === "bos" || prev.type === "slash") {
              token.output = nodot + token.output;
            }
            push(token);
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
            token.output = value;
            push(token);
            continue;
          }
          if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
            if (prev.type === "dot") {
              state.output += NO_DOT_SLASH;
              prev.output += NO_DOT_SLASH;
            } else if (opts.dot === true) {
              state.output += NO_DOTS_SLASH;
              prev.output += NO_DOTS_SLASH;
            } else {
              state.output += nodot;
              prev.output += nodot;
            }
            if (peek() !== "*") {
              state.output += ONE_CHAR;
              prev.output += ONE_CHAR;
            }
          }
          push(token);
        }
        while (state.brackets > 0) {
          if (opts.strictBrackets === true)
            throw new SyntaxError(syntaxError2("closing", "]"));
          state.output = utils.escapeLast(state.output, "[");
          decrement("brackets");
        }
        while (state.parens > 0) {
          if (opts.strictBrackets === true)
            throw new SyntaxError(syntaxError2("closing", ")"));
          state.output = utils.escapeLast(state.output, "(");
          decrement("parens");
        }
        while (state.braces > 0) {
          if (opts.strictBrackets === true)
            throw new SyntaxError(syntaxError2("closing", "}"));
          state.output = utils.escapeLast(state.output, "{");
          decrement("braces");
        }
        if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
          push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
        }
        if (state.backtrack === true) {
          state.output = "";
          for (const token of state.tokens) {
            state.output += token.output != null ? token.output : token.value;
            if (token.suffix) {
              state.output += token.suffix;
            }
          }
        }
        return state;
      };
      parse3.fastpaths = (input, options) => {
        const opts = { ...options };
        const max2 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
        const len = input.length;
        if (len > max2) {
          throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max2}`);
        }
        input = REPLACEMENTS[input] || input;
        const win322 = utils.isWindows(options);
        const {
          DOT_LITERAL,
          SLASH_LITERAL,
          ONE_CHAR,
          DOTS_SLASH,
          NO_DOT,
          NO_DOTS,
          NO_DOTS_SLASH,
          STAR,
          START_ANCHOR
        } = constants.globChars(win322);
        const nodot = opts.dot ? NO_DOTS : NO_DOT;
        const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
        const capture = opts.capture ? "" : "?:";
        const state = { negated: false, prefix: "" };
        let star3 = opts.bash === true ? ".*?" : STAR;
        if (opts.capture) {
          star3 = `(${star3})`;
        }
        const globstar = (opts2) => {
          if (opts2.noglobstar === true)
            return star3;
          return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
        };
        const create10 = (str) => {
          switch (str) {
            case "*":
              return `${nodot}${ONE_CHAR}${star3}`;
            case ".*":
              return `${DOT_LITERAL}${ONE_CHAR}${star3}`;
            case "*.*":
              return `${nodot}${star3}${DOT_LITERAL}${ONE_CHAR}${star3}`;
            case "*/*":
              return `${nodot}${star3}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star3}`;
            case "**":
              return nodot + globstar(opts);
            case "**/*":
              return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star3}`;
            case "**/*.*":
              return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star3}${DOT_LITERAL}${ONE_CHAR}${star3}`;
            case "**/.*":
              return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star3}`;
            default: {
              const match3 = /^(.*?)\.(\w+)$/.exec(str);
              if (!match3)
                return;
              const source2 = create10(match3[1]);
              if (!source2)
                return;
              return source2 + DOT_LITERAL + match3[2];
            }
          }
        };
        const output3 = utils.removePrefix(input, state);
        let source = create10(output3);
        if (source && opts.strictSlashes !== true) {
          source += `${SLASH_LITERAL}?`;
        }
        return source;
      };
      module2.exports = parse3;
    }
  });

  // ../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/picomatch.js
  var require_picomatch = __commonJS({
    "../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/lib/picomatch.js"(exports, module2) {
      "use strict";
      var path4 = __require2("path");
      var scan = require_scan();
      var parse3 = require_parse3();
      var utils = require_utils7();
      var constants = require_constants3();
      var isObject2 = (val) => val && typeof val === "object" && !Array.isArray(val);
      var picomatch = (glob2, options, returnState = false) => {
        if (Array.isArray(glob2)) {
          const fns = glob2.map((input) => picomatch(input, options, returnState));
          const arrayMatcher = (str) => {
            for (const isMatch of fns) {
              const state2 = isMatch(str);
              if (state2)
                return state2;
            }
            return false;
          };
          return arrayMatcher;
        }
        const isState = isObject2(glob2) && glob2.tokens && glob2.input;
        if (glob2 === "" || typeof glob2 !== "string" && !isState) {
          throw new TypeError("Expected pattern to be a non-empty string");
        }
        const opts = options || {};
        const posix2 = utils.isWindows(options);
        const regex = isState ? picomatch.compileRe(glob2, options) : picomatch.makeRe(glob2, options, false, true);
        const state = regex.state;
        delete regex.state;
        let isIgnored = () => false;
        if (opts.ignore) {
          const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
          isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
        }
        const matcher = (input, returnObject = false) => {
          const { isMatch, match: match3, output: output3 } = picomatch.test(input, regex, options, { glob: glob2, posix: posix2 });
          const result = { glob: glob2, state, regex, posix: posix2, input, output: output3, match: match3, isMatch };
          if (typeof opts.onResult === "function") {
            opts.onResult(result);
          }
          if (isMatch === false) {
            result.isMatch = false;
            return returnObject ? result : false;
          }
          if (isIgnored(input)) {
            if (typeof opts.onIgnore === "function") {
              opts.onIgnore(result);
            }
            result.isMatch = false;
            return returnObject ? result : false;
          }
          if (typeof opts.onMatch === "function") {
            opts.onMatch(result);
          }
          return returnObject ? result : true;
        };
        if (returnState) {
          matcher.state = state;
        }
        return matcher;
      };
      picomatch.test = (input, regex, options, { glob: glob2, posix: posix2 } = {}) => {
        if (typeof input !== "string") {
          throw new TypeError("Expected input to be a string");
        }
        if (input === "") {
          return { isMatch: false, output: "" };
        }
        const opts = options || {};
        const format = opts.format || (posix2 ? utils.toPosixSlashes : null);
        let match3 = input === glob2;
        let output3 = match3 && format ? format(input) : input;
        if (match3 === false) {
          output3 = format ? format(input) : input;
          match3 = output3 === glob2;
        }
        if (match3 === false || opts.capture === true) {
          if (opts.matchBase === true || opts.basename === true) {
            match3 = picomatch.matchBase(input, regex, options, posix2);
          } else {
            match3 = regex.exec(output3);
          }
        }
        return { isMatch: Boolean(match3), match: match3, output: output3 };
      };
      picomatch.matchBase = (input, glob2, options, posix2 = utils.isWindows(options)) => {
        const regex = glob2 instanceof RegExp ? glob2 : picomatch.makeRe(glob2, options);
        return regex.test(path4.basename(input));
      };
      picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
      picomatch.parse = (pattern, options) => {
        if (Array.isArray(pattern))
          return pattern.map((p) => picomatch.parse(p, options));
        return parse3(pattern, { ...options, fastpaths: false });
      };
      picomatch.scan = (input, options) => scan(input, options);
      picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
        if (returnOutput === true) {
          return state.output;
        }
        const opts = options || {};
        const prepend = opts.contains ? "" : "^";
        const append = opts.contains ? "" : "$";
        let source = `${prepend}(?:${state.output})${append}`;
        if (state && state.negated === true) {
          source = `^(?!${source}).*$`;
        }
        const regex = picomatch.toRegex(source, options);
        if (returnState === true) {
          regex.state = state;
        }
        return regex;
      };
      picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
        if (!input || typeof input !== "string") {
          throw new TypeError("Expected a non-empty string");
        }
        let parsed = { negated: false, fastpaths: true };
        if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
          parsed.output = parse3.fastpaths(input, options);
        }
        if (!parsed.output) {
          parsed = parse3(input, options);
        }
        return picomatch.compileRe(parsed, options, returnOutput, returnState);
      };
      picomatch.toRegex = (source, options) => {
        try {
          const opts = options || {};
          return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
        } catch (err) {
          if (options && options.debug === true)
            throw err;
          return /$^/;
        }
      };
      picomatch.constants = constants;
      module2.exports = picomatch;
    }
  });

  // ../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/index.js
  var require_picomatch2 = __commonJS({
    "../../node_modules/.pnpm/picomatch@2.3.1/node_modules/picomatch/index.js"(exports, module2) {
      "use strict";
      module2.exports = require_picomatch();
    }
  });

  // ../../node_modules/.pnpm/readdirp@3.6.0/node_modules/readdirp/index.js
  var require_readdirp = __commonJS({
    "../../node_modules/.pnpm/readdirp@3.6.0/node_modules/readdirp/index.js"(exports, module2) {
      "use strict";
      var fs4 = __require2("fs");
      var { Readable: Readable2 } = __require2("stream");
      var sysPath = __require2("path");
      var { promisify } = __require2("util");
      var picomatch = require_picomatch2();
      var readdir2 = promisify(fs4.readdir);
      var stat = promisify(fs4.stat);
      var lstat2 = promisify(fs4.lstat);
      var realpath2 = promisify(fs4.realpath);
      var BANG = "!";
      var RECURSIVE_ERROR_CODE = "READDIRP_RECURSIVE_ERROR";
      var NORMAL_FLOW_ERRORS = /* @__PURE__ */ new Set(["ENOENT", "EPERM", "EACCES", "ELOOP", RECURSIVE_ERROR_CODE]);
      var FILE_TYPE = "files";
      var DIR_TYPE = "directories";
      var FILE_DIR_TYPE = "files_directories";
      var EVERYTHING_TYPE = "all";
      var ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];
      var isNormalFlowError = (error2) => NORMAL_FLOW_ERRORS.has(error2.code);
      var [maj, min] = process.versions.node.split(".").slice(0, 2).map((n) => Number.parseInt(n, 10));
      var wantBigintFsStats = process.platform === "win32" && (maj > 10 || maj === 10 && min >= 5);
      var normalizeFilter = (filter2) => {
        if (filter2 === void 0)
          return;
        if (typeof filter2 === "function")
          return filter2;
        if (typeof filter2 === "string") {
          const glob2 = picomatch(filter2.trim());
          return (entry) => glob2(entry.basename);
        }
        if (Array.isArray(filter2)) {
          const positive = [];
          const negative = [];
          for (const item of filter2) {
            const trimmed = item.trim();
            if (trimmed.charAt(0) === BANG) {
              negative.push(picomatch(trimmed.slice(1)));
            } else {
              positive.push(picomatch(trimmed));
            }
          }
          if (negative.length > 0) {
            if (positive.length > 0) {
              return (entry) => positive.some((f2) => f2(entry.basename)) && !negative.some((f2) => f2(entry.basename));
            }
            return (entry) => !negative.some((f2) => f2(entry.basename));
          }
          return (entry) => positive.some((f2) => f2(entry.basename));
        }
      };
      var ReaddirpStream = class extends Readable2 {
        static get defaultOptions() {
          return {
            root: ".",
            /* eslint-disable no-unused-vars */
            fileFilter: (path4) => true,
            directoryFilter: (path4) => true,
            /* eslint-enable no-unused-vars */
            type: FILE_TYPE,
            lstat: false,
            depth: 2147483648,
            alwaysStat: false
          };
        }
        constructor(options = {}) {
          super({
            objectMode: true,
            autoDestroy: true,
            highWaterMark: options.highWaterMark || 4096
          });
          const opts = { ...ReaddirpStream.defaultOptions, ...options };
          const { root, type: type3 } = opts;
          this._fileFilter = normalizeFilter(opts.fileFilter);
          this._directoryFilter = normalizeFilter(opts.directoryFilter);
          const statMethod = opts.lstat ? lstat2 : stat;
          if (wantBigintFsStats) {
            this._stat = (path4) => statMethod(path4, { bigint: true });
          } else {
            this._stat = statMethod;
          }
          this._maxDepth = opts.depth;
          this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type3);
          this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type3);
          this._wantsEverything = type3 === EVERYTHING_TYPE;
          this._root = sysPath.resolve(root);
          this._isDirent = "Dirent" in fs4 && !opts.alwaysStat;
          this._statsProp = this._isDirent ? "dirent" : "stats";
          this._rdOptions = { encoding: "utf8", withFileTypes: this._isDirent };
          this.parents = [this._exploreDir(root, 1)];
          this.reading = false;
          this.parent = void 0;
        }
        async _read(batch) {
          if (this.reading)
            return;
          this.reading = true;
          try {
            while (!this.destroyed && batch > 0) {
              const { path: path4, depth, files = [] } = this.parent || {};
              if (files.length > 0) {
                const slice = files.splice(0, batch).map((dirent) => this._formatEntry(dirent, path4));
                for (const entry of await Promise.all(slice)) {
                  if (this.destroyed)
                    return;
                  const entryType = await this._getEntryType(entry);
                  if (entryType === "directory" && this._directoryFilter(entry)) {
                    if (depth <= this._maxDepth) {
                      this.parents.push(this._exploreDir(entry.fullPath, depth + 1));
                    }
                    if (this._wantsDir) {
                      this.push(entry);
                      batch--;
                    }
                  } else if ((entryType === "file" || this._includeAsFile(entry)) && this._fileFilter(entry)) {
                    if (this._wantsFile) {
                      this.push(entry);
                      batch--;
                    }
                  }
                }
              } else {
                const parent = this.parents.pop();
                if (!parent) {
                  this.push(null);
                  break;
                }
                this.parent = await parent;
                if (this.destroyed)
                  return;
              }
            }
          } catch (error2) {
            this.destroy(error2);
          } finally {
            this.reading = false;
          }
        }
        async _exploreDir(path4, depth) {
          let files;
          try {
            files = await readdir2(path4, this._rdOptions);
          } catch (error2) {
            this._onError(error2);
          }
          return { files, depth, path: path4 };
        }
        async _formatEntry(dirent, path4) {
          let entry;
          try {
            const basename3 = this._isDirent ? dirent.name : dirent;
            const fullPath = sysPath.resolve(sysPath.join(path4, basename3));
            entry = { path: sysPath.relative(this._root, fullPath), fullPath, basename: basename3 };
            entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);
          } catch (err) {
            this._onError(err);
          }
          return entry;
        }
        _onError(err) {
          if (isNormalFlowError(err) && !this.destroyed) {
            this.emit("warn", err);
          } else {
            this.destroy(err);
          }
        }
        async _getEntryType(entry) {
          const stats = entry && entry[this._statsProp];
          if (!stats) {
            return;
          }
          if (stats.isFile()) {
            return "file";
          }
          if (stats.isDirectory()) {
            return "directory";
          }
          if (stats && stats.isSymbolicLink()) {
            const full = entry.fullPath;
            try {
              const entryRealPath = await realpath2(full);
              const entryRealPathStats = await lstat2(entryRealPath);
              if (entryRealPathStats.isFile()) {
                return "file";
              }
              if (entryRealPathStats.isDirectory()) {
                const len = entryRealPath.length;
                if (full.startsWith(entryRealPath) && full.substr(len, 1) === sysPath.sep) {
                  const recursiveError = new Error(
                    `Circular symlink detected: "${full}" points to "${entryRealPath}"`
                  );
                  recursiveError.code = RECURSIVE_ERROR_CODE;
                  return this._onError(recursiveError);
                }
                return "directory";
              }
            } catch (error2) {
              this._onError(error2);
            }
          }
        }
        _includeAsFile(entry) {
          const stats = entry && entry[this._statsProp];
          return stats && this._wantsEverything && !stats.isDirectory();
        }
      };
      var readdirp = (root, options = {}) => {
        let type3 = options.entryType || options.type;
        if (type3 === "both")
          type3 = FILE_DIR_TYPE;
        if (type3)
          options.type = type3;
        if (!root) {
          throw new Error("readdirp: root argument is required. Usage: readdirp(root, options)");
        } else if (typeof root !== "string") {
          throw new TypeError("readdirp: root argument must be a string. Usage: readdirp(root, options)");
        } else if (type3 && !ALL_TYPES.includes(type3)) {
          throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(", ")}`);
        }
        options.root = root;
        return new ReaddirpStream(options);
      };
      var readdirpPromise = (root, options = {}) => {
        return new Promise((resolve4, reject) => {
          const files = [];
          readdirp(root, options).on("data", (entry) => files.push(entry)).on("end", () => resolve4(files)).on("error", (error2) => reject(error2));
        });
      };
      readdirp.promise = readdirpPromise;
      readdirp.ReaddirpStream = ReaddirpStream;
      readdirp.default = readdirp;
      module2.exports = readdirp;
    }
  });

  // ../../node_modules/.pnpm/normalize-path@3.0.0/node_modules/normalize-path/index.js
  var require_normalize_path = __commonJS({
    "../../node_modules/.pnpm/normalize-path@3.0.0/node_modules/normalize-path/index.js"(exports, module2) {
      module2.exports = function(path4, stripTrailing) {
        if (typeof path4 !== "string") {
          throw new TypeError("expected path to be a string");
        }
        if (path4 === "\\" || path4 === "/")
          return "/";
        var len = path4.length;
        if (len <= 1)
          return path4;
        var prefix = "";
        if (len > 4 && path4[3] === "\\") {
          var ch = path4[2];
          if ((ch === "?" || ch === ".") && path4.slice(0, 2) === "\\\\") {
            path4 = path4.slice(2);
            prefix = "//";
          }
        }
        var segs = path4.split(/[/\\]+/);
        if (stripTrailing !== false && segs[segs.length - 1] === "") {
          segs.pop();
        }
        return prefix + segs.join("/");
      };
    }
  });

  // ../../node_modules/.pnpm/anymatch@3.1.3/node_modules/anymatch/index.js
  var require_anymatch = __commonJS({
    "../../node_modules/.pnpm/anymatch@3.1.3/node_modules/anymatch/index.js"(exports, module2) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var picomatch = require_picomatch2();
      var normalizePath = require_normalize_path();
      var BANG = "!";
      var DEFAULT_OPTIONS = { returnIndex: false };
      var arrify = (item) => Array.isArray(item) ? item : [item];
      var createPattern = (matcher, options) => {
        if (typeof matcher === "function") {
          return matcher;
        }
        if (typeof matcher === "string") {
          const glob2 = picomatch(matcher, options);
          return (string2) => matcher === string2 || glob2(string2);
        }
        if (matcher instanceof RegExp) {
          return (string2) => matcher.test(string2);
        }
        return (string2) => false;
      };
      var matchPatterns = (patterns, negPatterns, args, returnIndex) => {
        const isList = Array.isArray(args);
        const _path = isList ? args[0] : args;
        if (!isList && typeof _path !== "string") {
          throw new TypeError("anymatch: second argument must be a string: got " + Object.prototype.toString.call(_path));
        }
        const path4 = normalizePath(_path, false);
        for (let index = 0; index < negPatterns.length; index++) {
          const nglob = negPatterns[index];
          if (nglob(path4)) {
            return returnIndex ? -1 : false;
          }
        }
        const applied = isList && [path4].concat(args.slice(1));
        for (let index = 0; index < patterns.length; index++) {
          const pattern = patterns[index];
          if (isList ? pattern(...applied) : pattern(path4)) {
            return returnIndex ? index : true;
          }
        }
        return returnIndex ? -1 : false;
      };
      var anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {
        if (matchers == null) {
          throw new TypeError("anymatch: specify first argument");
        }
        const opts = typeof options === "boolean" ? { returnIndex: options } : options;
        const returnIndex = opts.returnIndex || false;
        const mtchers = arrify(matchers);
        const negatedGlobs = mtchers.filter((item) => typeof item === "string" && item.charAt(0) === BANG).map((item) => item.slice(1)).map((item) => picomatch(item, opts));
        const patterns = mtchers.filter((item) => typeof item !== "string" || typeof item === "string" && item.charAt(0) !== BANG).map((matcher) => createPattern(matcher, opts));
        if (testString == null) {
          return (testString2, ri = false) => {
            const returnIndex2 = typeof ri === "boolean" ? ri : false;
            return matchPatterns(patterns, negatedGlobs, testString2, returnIndex2);
          };
        }
        return matchPatterns(patterns, negatedGlobs, testString, returnIndex);
      };
      anymatch.default = anymatch;
      module2.exports = anymatch;
    }
  });

  // ../../node_modules/.pnpm/is-extglob@2.1.1/node_modules/is-extglob/index.js
  var require_is_extglob = __commonJS({
    "../../node_modules/.pnpm/is-extglob@2.1.1/node_modules/is-extglob/index.js"(exports, module2) {
      module2.exports = function isExtglob(str) {
        if (typeof str !== "string" || str === "") {
          return false;
        }
        var match3;
        while (match3 = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
          if (match3[2])
            return true;
          str = str.slice(match3.index + match3[0].length);
        }
        return false;
      };
    }
  });

  // ../../node_modules/.pnpm/is-glob@4.0.3/node_modules/is-glob/index.js
  var require_is_glob = __commonJS({
    "../../node_modules/.pnpm/is-glob@4.0.3/node_modules/is-glob/index.js"(exports, module2) {
      var isExtglob = require_is_extglob();
      var chars = { "{": "}", "(": ")", "[": "]" };
      var strictCheck = function(str) {
        if (str[0] === "!") {
          return true;
        }
        var index = 0;
        var pipeIndex = -2;
        var closeSquareIndex = -2;
        var closeCurlyIndex = -2;
        var closeParenIndex = -2;
        var backSlashIndex = -2;
        while (index < str.length) {
          if (str[index] === "*") {
            return true;
          }
          if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
            return true;
          }
          if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
            if (closeSquareIndex < index) {
              closeSquareIndex = str.indexOf("]", index);
            }
            if (closeSquareIndex > index) {
              if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
                return true;
              }
              backSlashIndex = str.indexOf("\\", index);
              if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
                return true;
              }
            }
          }
          if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
            closeCurlyIndex = str.indexOf("}", index);
            if (closeCurlyIndex > index) {
              backSlashIndex = str.indexOf("\\", index);
              if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
                return true;
              }
            }
          }
          if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
            closeParenIndex = str.indexOf(")", index);
            if (closeParenIndex > index) {
              backSlashIndex = str.indexOf("\\", index);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
          if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
            if (pipeIndex < index) {
              pipeIndex = str.indexOf("|", index);
            }
            if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
              closeParenIndex = str.indexOf(")", pipeIndex);
              if (closeParenIndex > pipeIndex) {
                backSlashIndex = str.indexOf("\\", pipeIndex);
                if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                  return true;
                }
              }
            }
          }
          if (str[index] === "\\") {
            var open = str[index + 1];
            index += 2;
            var close = chars[open];
            if (close) {
              var n = str.indexOf(close, index);
              if (n !== -1) {
                index = n + 1;
              }
            }
            if (str[index] === "!") {
              return true;
            }
          } else {
            index++;
          }
        }
        return false;
      };
      var relaxedCheck = function(str) {
        if (str[0] === "!") {
          return true;
        }
        var index = 0;
        while (index < str.length) {
          if (/[*?{}()[\]]/.test(str[index])) {
            return true;
          }
          if (str[index] === "\\") {
            var open = str[index + 1];
            index += 2;
            var close = chars[open];
            if (close) {
              var n = str.indexOf(close, index);
              if (n !== -1) {
                index = n + 1;
              }
            }
            if (str[index] === "!") {
              return true;
            }
          } else {
            index++;
          }
        }
        return false;
      };
      module2.exports = function isGlob(str, options) {
        if (typeof str !== "string" || str === "") {
          return false;
        }
        if (isExtglob(str)) {
          return true;
        }
        var check = strictCheck;
        if (options && options.strict === false) {
          check = relaxedCheck;
        }
        return check(str);
      };
    }
  });

  // ../../node_modules/.pnpm/glob-parent@5.1.2/node_modules/glob-parent/index.js
  var require_glob_parent = __commonJS({
    "../../node_modules/.pnpm/glob-parent@5.1.2/node_modules/glob-parent/index.js"(exports, module2) {
      "use strict";
      var isGlob = require_is_glob();
      var pathPosixDirname = __require2("path").posix.dirname;
      var isWin32 = __require2("os").platform() === "win32";
      var slash = "/";
      var backslash = /\\/g;
      var enclosure = /[\{\[].*[\}\]]$/;
      var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
      var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
      module2.exports = function globParent(str, opts) {
        var options = Object.assign({ flipBackslashes: true }, opts);
        if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
          str = str.replace(backslash, slash);
        }
        if (enclosure.test(str)) {
          str += slash;
        }
        str += "a";
        do {
          str = pathPosixDirname(str);
        } while (isGlob(str) || globby.test(str));
        return str.replace(escaped, "$1");
      };
    }
  });

  // ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/utils.js
  var require_utils8 = __commonJS({
    "../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/utils.js"(exports) {
      "use strict";
      exports.isInteger = (num) => {
        if (typeof num === "number") {
          return Number.isInteger(num);
        }
        if (typeof num === "string" && num.trim() !== "") {
          return Number.isInteger(Number(num));
        }
        return false;
      };
      exports.find = (node, type3) => node.nodes.find((node2) => node2.type === type3);
      exports.exceedsLimit = (min, max2, step = 1, limit) => {
        if (limit === false)
          return false;
        if (!exports.isInteger(min) || !exports.isInteger(max2))
          return false;
        return (Number(max2) - Number(min)) / Number(step) >= limit;
      };
      exports.escapeNode = (block, n = 0, type3) => {
        let node = block.nodes[n];
        if (!node)
          return;
        if (type3 && node.type === type3 || node.type === "open" || node.type === "close") {
          if (node.escaped !== true) {
            node.value = "\\" + node.value;
            node.escaped = true;
          }
        }
      };
      exports.encloseBrace = (node) => {
        if (node.type !== "brace")
          return false;
        if (node.commas >> 0 + node.ranges >> 0 === 0) {
          node.invalid = true;
          return true;
        }
        return false;
      };
      exports.isInvalidBrace = (block) => {
        if (block.type !== "brace")
          return false;
        if (block.invalid === true || block.dollar)
          return true;
        if (block.commas >> 0 + block.ranges >> 0 === 0) {
          block.invalid = true;
          return true;
        }
        if (block.open !== true || block.close !== true) {
          block.invalid = true;
          return true;
        }
        return false;
      };
      exports.isOpenOrClose = (node) => {
        if (node.type === "open" || node.type === "close") {
          return true;
        }
        return node.open === true || node.close === true;
      };
      exports.reduce = (nodes) => nodes.reduce((acc, node) => {
        if (node.type === "text")
          acc.push(node.value);
        if (node.type === "range")
          node.type = "text";
        return acc;
      }, []);
      exports.flatten = (...args) => {
        const result = [];
        const flat = (arr) => {
          for (let i = 0; i < arr.length; i++) {
            let ele = arr[i];
            Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
          }
          return result;
        };
        flat(args);
        return result;
      };
    }
  });

  // ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/stringify.js
  var require_stringify = __commonJS({
    "../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/stringify.js"(exports, module2) {
      "use strict";
      var utils = require_utils8();
      module2.exports = (ast, options = {}) => {
        let stringify2 = (node, parent = {}) => {
          let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
          let invalidNode = node.invalid === true && options.escapeInvalid === true;
          let output3 = "";
          if (node.value) {
            if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
              return "\\" + node.value;
            }
            return node.value;
          }
          if (node.value) {
            return node.value;
          }
          if (node.nodes) {
            for (let child of node.nodes) {
              output3 += stringify2(child);
            }
          }
          return output3;
        };
        return stringify2(ast);
      };
    }
  });

  // ../../node_modules/.pnpm/is-number@7.0.0/node_modules/is-number/index.js
  var require_is_number = __commonJS({
    "../../node_modules/.pnpm/is-number@7.0.0/node_modules/is-number/index.js"(exports, module2) {
      "use strict";
      module2.exports = function(num) {
        if (typeof num === "number") {
          return num - num === 0;
        }
        if (typeof num === "string" && num.trim() !== "") {
          return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
        }
        return false;
      };
    }
  });

  // ../../node_modules/.pnpm/to-regex-range@5.0.1/node_modules/to-regex-range/index.js
  var require_to_regex_range = __commonJS({
    "../../node_modules/.pnpm/to-regex-range@5.0.1/node_modules/to-regex-range/index.js"(exports, module2) {
      "use strict";
      var isNumber = require_is_number();
      var toRegexRange = (min, max2, options) => {
        if (isNumber(min) === false) {
          throw new TypeError("toRegexRange: expected the first argument to be a number");
        }
        if (max2 === void 0 || min === max2) {
          return String(min);
        }
        if (isNumber(max2) === false) {
          throw new TypeError("toRegexRange: expected the second argument to be a number.");
        }
        let opts = { relaxZeros: true, ...options };
        if (typeof opts.strictZeros === "boolean") {
          opts.relaxZeros = opts.strictZeros === false;
        }
        let relax = String(opts.relaxZeros);
        let shorthand = String(opts.shorthand);
        let capture = String(opts.capture);
        let wrap = String(opts.wrap);
        let cacheKey = min + ":" + max2 + "=" + relax + shorthand + capture + wrap;
        if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
          return toRegexRange.cache[cacheKey].result;
        }
        let a = Math.min(min, max2);
        let b = Math.max(min, max2);
        if (Math.abs(a - b) === 1) {
          let result = min + "|" + max2;
          if (opts.capture) {
            return `(${result})`;
          }
          if (opts.wrap === false) {
            return result;
          }
          return `(?:${result})`;
        }
        let isPadded = hasPadding(min) || hasPadding(max2);
        let state = { min, max: max2, a, b };
        let positives = [];
        let negatives = [];
        if (isPadded) {
          state.isPadded = isPadded;
          state.maxLen = String(state.max).length;
        }
        if (a < 0) {
          let newMin = b < 0 ? Math.abs(b) : 1;
          negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
          a = state.a = 0;
        }
        if (b >= 0) {
          positives = splitToPatterns(a, b, state, opts);
        }
        state.negatives = negatives;
        state.positives = positives;
        state.result = collatePatterns(negatives, positives, opts);
        if (opts.capture === true) {
          state.result = `(${state.result})`;
        } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
          state.result = `(?:${state.result})`;
        }
        toRegexRange.cache[cacheKey] = state;
        return state.result;
      };
      function collatePatterns(neg, pos, options) {
        let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
        let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
        let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
        let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
        return subpatterns.join("|");
      }
      function splitToRanges(min, max2) {
        let nines = 1;
        let zeros = 1;
        let stop = countNines(min, nines);
        let stops = /* @__PURE__ */ new Set([max2]);
        while (min <= stop && stop <= max2) {
          stops.add(stop);
          nines += 1;
          stop = countNines(min, nines);
        }
        stop = countZeros(max2 + 1, zeros) - 1;
        while (min < stop && stop <= max2) {
          stops.add(stop);
          zeros += 1;
          stop = countZeros(max2 + 1, zeros) - 1;
        }
        stops = [...stops];
        stops.sort(compare);
        return stops;
      }
      function rangeToPattern(start, stop, options) {
        if (start === stop) {
          return { pattern: start, count: [], digits: 0 };
        }
        let zipped = zip(start, stop);
        let digits = zipped.length;
        let pattern = "";
        let count = 0;
        for (let i = 0; i < digits; i++) {
          let [startDigit, stopDigit] = zipped[i];
          if (startDigit === stopDigit) {
            pattern += startDigit;
          } else if (startDigit !== "0" || stopDigit !== "9") {
            pattern += toCharacterClass(startDigit, stopDigit, options);
          } else {
            count++;
          }
        }
        if (count) {
          pattern += options.shorthand === true ? "\\d" : "[0-9]";
        }
        return { pattern, count: [count], digits };
      }
      function splitToPatterns(min, max2, tok, options) {
        let ranges = splitToRanges(min, max2);
        let tokens = [];
        let start = min;
        let prev;
        for (let i = 0; i < ranges.length; i++) {
          let max3 = ranges[i];
          let obj = rangeToPattern(String(start), String(max3), options);
          let zeros = "";
          if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
            if (prev.count.length > 1) {
              prev.count.pop();
            }
            prev.count.push(obj.count[0]);
            prev.string = prev.pattern + toQuantifier(prev.count);
            start = max3 + 1;
            continue;
          }
          if (tok.isPadded) {
            zeros = padZeros(max3, tok, options);
          }
          obj.string = zeros + obj.pattern + toQuantifier(obj.count);
          tokens.push(obj);
          start = max3 + 1;
          prev = obj;
        }
        return tokens;
      }
      function filterPatterns(arr, comparison, prefix, intersection, options) {
        let result = [];
        for (let ele of arr) {
          let { string: string2 } = ele;
          if (!intersection && !contains3(comparison, "string", string2)) {
            result.push(prefix + string2);
          }
          if (intersection && contains3(comparison, "string", string2)) {
            result.push(prefix + string2);
          }
        }
        return result;
      }
      function zip(a, b) {
        let arr = [];
        for (let i = 0; i < a.length; i++)
          arr.push([a[i], b[i]]);
        return arr;
      }
      function compare(a, b) {
        return a > b ? 1 : b > a ? -1 : 0;
      }
      function contains3(arr, key, val) {
        return arr.some((ele) => ele[key] === val);
      }
      function countNines(min, len) {
        return Number(String(min).slice(0, -len) + "9".repeat(len));
      }
      function countZeros(integer, zeros) {
        return integer - integer % Math.pow(10, zeros);
      }
      function toQuantifier(digits) {
        let [start = 0, stop = ""] = digits;
        if (stop || start > 1) {
          return `{${start + (stop ? "," + stop : "")}}`;
        }
        return "";
      }
      function toCharacterClass(a, b, options) {
        return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
      }
      function hasPadding(str) {
        return /^-?(0+)\d/.test(str);
      }
      function padZeros(value, tok, options) {
        if (!tok.isPadded) {
          return value;
        }
        let diff = Math.abs(tok.maxLen - String(value).length);
        let relax = options.relaxZeros !== false;
        switch (diff) {
          case 0:
            return "";
          case 1:
            return relax ? "0?" : "0";
          case 2:
            return relax ? "0{0,2}" : "00";
          default: {
            return relax ? `0{0,${diff}}` : `0{${diff}}`;
          }
        }
      }
      toRegexRange.cache = {};
      toRegexRange.clearCache = () => toRegexRange.cache = {};
      module2.exports = toRegexRange;
    }
  });

  // ../../node_modules/.pnpm/fill-range@7.0.1/node_modules/fill-range/index.js
  var require_fill_range = __commonJS({
    "../../node_modules/.pnpm/fill-range@7.0.1/node_modules/fill-range/index.js"(exports, module2) {
      "use strict";
      var util = __require2("util");
      var toRegexRange = require_to_regex_range();
      var isObject2 = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
      var transform = (toNumber3) => {
        return (value) => toNumber3 === true ? Number(value) : String(value);
      };
      var isValidValue = (value) => {
        return typeof value === "number" || typeof value === "string" && value !== "";
      };
      var isNumber = (num) => Number.isInteger(+num);
      var zeros = (input) => {
        let value = `${input}`;
        let index = -1;
        if (value[0] === "-")
          value = value.slice(1);
        if (value === "0")
          return false;
        while (value[++index] === "0")
          ;
        return index > 0;
      };
      var stringify2 = (start, end, options) => {
        if (typeof start === "string" || typeof end === "string") {
          return true;
        }
        return options.stringify === true;
      };
      var pad3 = (input, maxLength, toNumber3) => {
        if (maxLength > 0) {
          let dash = input[0] === "-" ? "-" : "";
          if (dash)
            input = input.slice(1);
          input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
        }
        if (toNumber3 === false) {
          return String(input);
        }
        return input;
      };
      var toMaxLen = (input, maxLength) => {
        let negative = input[0] === "-" ? "-" : "";
        if (negative) {
          input = input.slice(1);
          maxLength--;
        }
        while (input.length < maxLength)
          input = "0" + input;
        return negative ? "-" + input : input;
      };
      var toSequence = (parts, options) => {
        parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
        parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
        let prefix = options.capture ? "" : "?:";
        let positives = "";
        let negatives = "";
        let result;
        if (parts.positives.length) {
          positives = parts.positives.join("|");
        }
        if (parts.negatives.length) {
          negatives = `-(${prefix}${parts.negatives.join("|")})`;
        }
        if (positives && negatives) {
          result = `${positives}|${negatives}`;
        } else {
          result = positives || negatives;
        }
        if (options.wrap) {
          return `(${prefix}${result})`;
        }
        return result;
      };
      var toRange = (a, b, isNumbers, options) => {
        if (isNumbers) {
          return toRegexRange(a, b, { wrap: false, ...options });
        }
        let start = String.fromCharCode(a);
        if (a === b)
          return start;
        let stop = String.fromCharCode(b);
        return `[${start}-${stop}]`;
      };
      var toRegex = (start, end, options) => {
        if (Array.isArray(start)) {
          let wrap = options.wrap === true;
          let prefix = options.capture ? "" : "?:";
          return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
        }
        return toRegexRange(start, end, options);
      };
      var rangeError = (...args) => {
        return new RangeError("Invalid range arguments: " + util.inspect(...args));
      };
      var invalidRange = (start, end, options) => {
        if (options.strictRanges === true)
          throw rangeError([start, end]);
        return [];
      };
      var invalidStep = (step, options) => {
        if (options.strictRanges === true) {
          throw new TypeError(`Expected step "${step}" to be a number`);
        }
        return [];
      };
      var fillNumbers = (start, end, step = 1, options = {}) => {
        let a = Number(start);
        let b = Number(end);
        if (!Number.isInteger(a) || !Number.isInteger(b)) {
          if (options.strictRanges === true)
            throw rangeError([start, end]);
          return [];
        }
        if (a === 0)
          a = 0;
        if (b === 0)
          b = 0;
        let descending = a > b;
        let startString = String(start);
        let endString = String(end);
        let stepString = String(step);
        step = Math.max(Math.abs(step), 1);
        let padded = zeros(startString) || zeros(endString) || zeros(stepString);
        let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
        let toNumber3 = padded === false && stringify2(start, end, options) === false;
        let format = options.transform || transform(toNumber3);
        if (options.toRegex && step === 1) {
          return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
        }
        let parts = { negatives: [], positives: [] };
        let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
        let range = [];
        let index = 0;
        while (descending ? a >= b : a <= b) {
          if (options.toRegex === true && step > 1) {
            push(a);
          } else {
            range.push(pad3(format(a, index), maxLen, toNumber3));
          }
          a = descending ? a - step : a + step;
          index++;
        }
        if (options.toRegex === true) {
          return step > 1 ? toSequence(parts, options) : toRegex(range, null, { wrap: false, ...options });
        }
        return range;
      };
      var fillLetters = (start, end, step = 1, options = {}) => {
        if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
          return invalidRange(start, end, options);
        }
        let format = options.transform || ((val) => String.fromCharCode(val));
        let a = `${start}`.charCodeAt(0);
        let b = `${end}`.charCodeAt(0);
        let descending = a > b;
        let min = Math.min(a, b);
        let max2 = Math.max(a, b);
        if (options.toRegex && step === 1) {
          return toRange(min, max2, false, options);
        }
        let range = [];
        let index = 0;
        while (descending ? a >= b : a <= b) {
          range.push(format(a, index));
          a = descending ? a - step : a + step;
          index++;
        }
        if (options.toRegex === true) {
          return toRegex(range, null, { wrap: false, options });
        }
        return range;
      };
      var fill = (start, end, step, options = {}) => {
        if (end == null && isValidValue(start)) {
          return [start];
        }
        if (!isValidValue(start) || !isValidValue(end)) {
          return invalidRange(start, end, options);
        }
        if (typeof step === "function") {
          return fill(start, end, 1, { transform: step });
        }
        if (isObject2(step)) {
          return fill(start, end, 0, step);
        }
        let opts = { ...options };
        if (opts.capture === true)
          opts.wrap = true;
        step = step || opts.step || 1;
        if (!isNumber(step)) {
          if (step != null && !isObject2(step))
            return invalidStep(step, opts);
          return fill(start, end, 1, step);
        }
        if (isNumber(start) && isNumber(end)) {
          return fillNumbers(start, end, step, opts);
        }
        return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
      };
      module2.exports = fill;
    }
  });

  // ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/compile.js
  var require_compile = __commonJS({
    "../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/compile.js"(exports, module2) {
      "use strict";
      var fill = require_fill_range();
      var utils = require_utils8();
      var compile6 = (ast, options = {}) => {
        let walk = (node, parent = {}) => {
          let invalidBlock = utils.isInvalidBrace(parent);
          let invalidNode = node.invalid === true && options.escapeInvalid === true;
          let invalid = invalidBlock === true || invalidNode === true;
          let prefix = options.escapeInvalid === true ? "\\" : "";
          let output3 = "";
          if (node.isOpen === true) {
            return prefix + node.value;
          }
          if (node.isClose === true) {
            return prefix + node.value;
          }
          if (node.type === "open") {
            return invalid ? prefix + node.value : "(";
          }
          if (node.type === "close") {
            return invalid ? prefix + node.value : ")";
          }
          if (node.type === "comma") {
            return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
          }
          if (node.value) {
            return node.value;
          }
          if (node.nodes && node.ranges > 0) {
            let args = utils.reduce(node.nodes);
            let range = fill(...args, { ...options, wrap: false, toRegex: true });
            if (range.length !== 0) {
              return args.length > 1 && range.length > 1 ? `(${range})` : range;
            }
          }
          if (node.nodes) {
            for (let child of node.nodes) {
              output3 += walk(child, node);
            }
          }
          return output3;
        };
        return walk(ast);
      };
      module2.exports = compile6;
    }
  });

  // ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/expand.js
  var require_expand = __commonJS({
    "../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/expand.js"(exports, module2) {
      "use strict";
      var fill = require_fill_range();
      var stringify2 = require_stringify();
      var utils = require_utils8();
      var append = (queue = "", stash = "", enclose = false) => {
        let result = [];
        queue = [].concat(queue);
        stash = [].concat(stash);
        if (!stash.length)
          return queue;
        if (!queue.length) {
          return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
        }
        for (let item of queue) {
          if (Array.isArray(item)) {
            for (let value of item) {
              result.push(append(value, stash, enclose));
            }
          } else {
            for (let ele of stash) {
              if (enclose === true && typeof ele === "string")
                ele = `{${ele}}`;
              result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
            }
          }
        }
        return utils.flatten(result);
      };
      var expand2 = (ast, options = {}) => {
        let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
        let walk = (node, parent = {}) => {
          node.queue = [];
          let p = parent;
          let q = parent.queue;
          while (p.type !== "brace" && p.type !== "root" && p.parent) {
            p = p.parent;
            q = p.queue;
          }
          if (node.invalid || node.dollar) {
            q.push(append(q.pop(), stringify2(node, options)));
            return;
          }
          if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
            q.push(append(q.pop(), ["{}"]));
            return;
          }
          if (node.nodes && node.ranges > 0) {
            let args = utils.reduce(node.nodes);
            if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
              throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
            }
            let range = fill(...args, options);
            if (range.length === 0) {
              range = stringify2(node, options);
            }
            q.push(append(q.pop(), range));
            node.nodes = [];
            return;
          }
          let enclose = utils.encloseBrace(node);
          let queue = node.queue;
          let block = node;
          while (block.type !== "brace" && block.type !== "root" && block.parent) {
            block = block.parent;
            queue = block.queue;
          }
          for (let i = 0; i < node.nodes.length; i++) {
            let child = node.nodes[i];
            if (child.type === "comma" && node.type === "brace") {
              if (i === 1)
                queue.push("");
              queue.push("");
              continue;
            }
            if (child.type === "close") {
              q.push(append(q.pop(), queue, enclose));
              continue;
            }
            if (child.value && child.type !== "open") {
              queue.push(append(queue.pop(), child.value));
              continue;
            }
            if (child.nodes) {
              walk(child, node);
            }
          }
          return queue;
        };
        return utils.flatten(walk(ast));
      };
      module2.exports = expand2;
    }
  });

  // ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/constants.js
  var require_constants4 = __commonJS({
    "../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/constants.js"(exports, module2) {
      "use strict";
      module2.exports = {
        MAX_LENGTH: 1024 * 64,
        // Digits
        CHAR_0: "0",
        /* 0 */
        CHAR_9: "9",
        /* 9 */
        // Alphabet chars.
        CHAR_UPPERCASE_A: "A",
        /* A */
        CHAR_LOWERCASE_A: "a",
        /* a */
        CHAR_UPPERCASE_Z: "Z",
        /* Z */
        CHAR_LOWERCASE_Z: "z",
        /* z */
        CHAR_LEFT_PARENTHESES: "(",
        /* ( */
        CHAR_RIGHT_PARENTHESES: ")",
        /* ) */
        CHAR_ASTERISK: "*",
        /* * */
        // Non-alphabetic chars.
        CHAR_AMPERSAND: "&",
        /* & */
        CHAR_AT: "@",
        /* @ */
        CHAR_BACKSLASH: "\\",
        /* \ */
        CHAR_BACKTICK: "`",
        /* ` */
        CHAR_CARRIAGE_RETURN: "\r",
        /* \r */
        CHAR_CIRCUMFLEX_ACCENT: "^",
        /* ^ */
        CHAR_COLON: ":",
        /* : */
        CHAR_COMMA: ",",
        /* , */
        CHAR_DOLLAR: "$",
        /* . */
        CHAR_DOT: ".",
        /* . */
        CHAR_DOUBLE_QUOTE: '"',
        /* " */
        CHAR_EQUAL: "=",
        /* = */
        CHAR_EXCLAMATION_MARK: "!",
        /* ! */
        CHAR_FORM_FEED: "\f",
        /* \f */
        CHAR_FORWARD_SLASH: "/",
        /* / */
        CHAR_HASH: "#",
        /* # */
        CHAR_HYPHEN_MINUS: "-",
        /* - */
        CHAR_LEFT_ANGLE_BRACKET: "<",
        /* < */
        CHAR_LEFT_CURLY_BRACE: "{",
        /* { */
        CHAR_LEFT_SQUARE_BRACKET: "[",
        /* [ */
        CHAR_LINE_FEED: "\n",
        /* \n */
        CHAR_NO_BREAK_SPACE: "\xA0",
        /* \u00A0 */
        CHAR_PERCENT: "%",
        /* % */
        CHAR_PLUS: "+",
        /* + */
        CHAR_QUESTION_MARK: "?",
        /* ? */
        CHAR_RIGHT_ANGLE_BRACKET: ">",
        /* > */
        CHAR_RIGHT_CURLY_BRACE: "}",
        /* } */
        CHAR_RIGHT_SQUARE_BRACKET: "]",
        /* ] */
        CHAR_SEMICOLON: ";",
        /* ; */
        CHAR_SINGLE_QUOTE: "'",
        /* ' */
        CHAR_SPACE: " ",
        /*   */
        CHAR_TAB: "	",
        /* \t */
        CHAR_UNDERSCORE: "_",
        /* _ */
        CHAR_VERTICAL_LINE: "|",
        /* | */
        CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
        /* \uFEFF */
      };
    }
  });

  // ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/parse.js
  var require_parse4 = __commonJS({
    "../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/lib/parse.js"(exports, module2) {
      "use strict";
      var stringify2 = require_stringify();
      var {
        MAX_LENGTH,
        CHAR_BACKSLASH,
        /* \ */
        CHAR_BACKTICK,
        /* ` */
        CHAR_COMMA,
        /* , */
        CHAR_DOT,
        /* . */
        CHAR_LEFT_PARENTHESES,
        /* ( */
        CHAR_RIGHT_PARENTHESES,
        /* ) */
        CHAR_LEFT_CURLY_BRACE,
        /* { */
        CHAR_RIGHT_CURLY_BRACE,
        /* } */
        CHAR_LEFT_SQUARE_BRACKET,
        /* [ */
        CHAR_RIGHT_SQUARE_BRACKET,
        /* ] */
        CHAR_DOUBLE_QUOTE,
        /* " */
        CHAR_SINGLE_QUOTE,
        /* ' */
        CHAR_NO_BREAK_SPACE,
        CHAR_ZERO_WIDTH_NOBREAK_SPACE
      } = require_constants4();
      var parse3 = (input, options = {}) => {
        if (typeof input !== "string") {
          throw new TypeError("Expected a string");
        }
        let opts = options || {};
        let max2 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
        if (input.length > max2) {
          throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max2})`);
        }
        let ast = { type: "root", input, nodes: [] };
        let stack = [ast];
        let block = ast;
        let prev = ast;
        let brackets = 0;
        let length = input.length;
        let index = 0;
        let depth = 0;
        let value;
        let memo = {};
        const advance = () => input[index++];
        const push = (node) => {
          if (node.type === "text" && prev.type === "dot") {
            prev.type = "text";
          }
          if (prev && prev.type === "text" && node.type === "text") {
            prev.value += node.value;
            return;
          }
          block.nodes.push(node);
          node.parent = block;
          node.prev = prev;
          prev = node;
          return node;
        };
        push({ type: "bos" });
        while (index < length) {
          block = stack[stack.length - 1];
          value = advance();
          if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
            continue;
          }
          if (value === CHAR_BACKSLASH) {
            push({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
            continue;
          }
          if (value === CHAR_RIGHT_SQUARE_BRACKET) {
            push({ type: "text", value: "\\" + value });
            continue;
          }
          if (value === CHAR_LEFT_SQUARE_BRACKET) {
            brackets++;
            let closed = true;
            let next;
            while (index < length && (next = advance())) {
              value += next;
              if (next === CHAR_LEFT_SQUARE_BRACKET) {
                brackets++;
                continue;
              }
              if (next === CHAR_BACKSLASH) {
                value += advance();
                continue;
              }
              if (next === CHAR_RIGHT_SQUARE_BRACKET) {
                brackets--;
                if (brackets === 0) {
                  break;
                }
              }
            }
            push({ type: "text", value });
            continue;
          }
          if (value === CHAR_LEFT_PARENTHESES) {
            block = push({ type: "paren", nodes: [] });
            stack.push(block);
            push({ type: "text", value });
            continue;
          }
          if (value === CHAR_RIGHT_PARENTHESES) {
            if (block.type !== "paren") {
              push({ type: "text", value });
              continue;
            }
            block = stack.pop();
            push({ type: "text", value });
            block = stack[stack.length - 1];
            continue;
          }
          if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
            let open = value;
            let next;
            if (options.keepQuotes !== true) {
              value = "";
            }
            while (index < length && (next = advance())) {
              if (next === CHAR_BACKSLASH) {
                value += next + advance();
                continue;
              }
              if (next === open) {
                if (options.keepQuotes === true)
                  value += next;
                break;
              }
              value += next;
            }
            push({ type: "text", value });
            continue;
          }
          if (value === CHAR_LEFT_CURLY_BRACE) {
            depth++;
            let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
            let brace = {
              type: "brace",
              open: true,
              close: false,
              dollar,
              depth,
              commas: 0,
              ranges: 0,
              nodes: []
            };
            block = push(brace);
            stack.push(block);
            push({ type: "open", value });
            continue;
          }
          if (value === CHAR_RIGHT_CURLY_BRACE) {
            if (block.type !== "brace") {
              push({ type: "text", value });
              continue;
            }
            let type3 = "close";
            block = stack.pop();
            block.close = true;
            push({ type: type3, value });
            depth--;
            block = stack[stack.length - 1];
            continue;
          }
          if (value === CHAR_COMMA && depth > 0) {
            if (block.ranges > 0) {
              block.ranges = 0;
              let open = block.nodes.shift();
              block.nodes = [open, { type: "text", value: stringify2(block) }];
            }
            push({ type: "comma", value });
            block.commas++;
            continue;
          }
          if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
            let siblings = block.nodes;
            if (depth === 0 || siblings.length === 0) {
              push({ type: "text", value });
              continue;
            }
            if (prev.type === "dot") {
              block.range = [];
              prev.value += value;
              prev.type = "range";
              if (block.nodes.length !== 3 && block.nodes.length !== 5) {
                block.invalid = true;
                block.ranges = 0;
                prev.type = "text";
                continue;
              }
              block.ranges++;
              block.args = [];
              continue;
            }
            if (prev.type === "range") {
              siblings.pop();
              let before = siblings[siblings.length - 1];
              before.value += prev.value + value;
              prev = before;
              block.ranges--;
              continue;
            }
            push({ type: "dot", value });
            continue;
          }
          push({ type: "text", value });
        }
        do {
          block = stack.pop();
          if (block.type !== "root") {
            block.nodes.forEach((node) => {
              if (!node.nodes) {
                if (node.type === "open")
                  node.isOpen = true;
                if (node.type === "close")
                  node.isClose = true;
                if (!node.nodes)
                  node.type = "text";
                node.invalid = true;
              }
            });
            let parent = stack[stack.length - 1];
            let index2 = parent.nodes.indexOf(block);
            parent.nodes.splice(index2, 1, ...block.nodes);
          }
        } while (stack.length > 0);
        push({ type: "eos" });
        return ast;
      };
      module2.exports = parse3;
    }
  });

  // ../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/index.js
  var require_braces = __commonJS({
    "../../node_modules/.pnpm/braces@3.0.2/node_modules/braces/index.js"(exports, module2) {
      "use strict";
      var stringify2 = require_stringify();
      var compile6 = require_compile();
      var expand2 = require_expand();
      var parse3 = require_parse4();
      var braces = (input, options = {}) => {
        let output3 = [];
        if (Array.isArray(input)) {
          for (let pattern of input) {
            let result = braces.create(pattern, options);
            if (Array.isArray(result)) {
              output3.push(...result);
            } else {
              output3.push(result);
            }
          }
        } else {
          output3 = [].concat(braces.create(input, options));
        }
        if (options && options.expand === true && options.nodupes === true) {
          output3 = [...new Set(output3)];
        }
        return output3;
      };
      braces.parse = (input, options = {}) => parse3(input, options);
      braces.stringify = (input, options = {}) => {
        if (typeof input === "string") {
          return stringify2(braces.parse(input, options), options);
        }
        return stringify2(input, options);
      };
      braces.compile = (input, options = {}) => {
        if (typeof input === "string") {
          input = braces.parse(input, options);
        }
        return compile6(input, options);
      };
      braces.expand = (input, options = {}) => {
        if (typeof input === "string") {
          input = braces.parse(input, options);
        }
        let result = expand2(input, options);
        if (options.noempty === true) {
          result = result.filter(Boolean);
        }
        if (options.nodupes === true) {
          result = [...new Set(result)];
        }
        return result;
      };
      braces.create = (input, options = {}) => {
        if (input === "" || input.length < 3) {
          return [input];
        }
        return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
      };
      module2.exports = braces;
    }
  });

  // ../../node_modules/.pnpm/binary-extensions@2.2.0/node_modules/binary-extensions/binary-extensions.json
  var require_binary_extensions = __commonJS({
    "../../node_modules/.pnpm/binary-extensions@2.2.0/node_modules/binary-extensions/binary-extensions.json"(exports, module2) {
      module2.exports = [
        "3dm",
        "3ds",
        "3g2",
        "3gp",
        "7z",
        "a",
        "aac",
        "adp",
        "ai",
        "aif",
        "aiff",
        "alz",
        "ape",
        "apk",
        "appimage",
        "ar",
        "arj",
        "asf",
        "au",
        "avi",
        "bak",
        "baml",
        "bh",
        "bin",
        "bk",
        "bmp",
        "btif",
        "bz2",
        "bzip2",
        "cab",
        "caf",
        "cgm",
        "class",
        "cmx",
        "cpio",
        "cr2",
        "cur",
        "dat",
        "dcm",
        "deb",
        "dex",
        "djvu",
        "dll",
        "dmg",
        "dng",
        "doc",
        "docm",
        "docx",
        "dot",
        "dotm",
        "dra",
        "DS_Store",
        "dsk",
        "dts",
        "dtshd",
        "dvb",
        "dwg",
        "dxf",
        "ecelp4800",
        "ecelp7470",
        "ecelp9600",
        "egg",
        "eol",
        "eot",
        "epub",
        "exe",
        "f4v",
        "fbs",
        "fh",
        "fla",
        "flac",
        "flatpak",
        "fli",
        "flv",
        "fpx",
        "fst",
        "fvt",
        "g3",
        "gh",
        "gif",
        "graffle",
        "gz",
        "gzip",
        "h261",
        "h263",
        "h264",
        "icns",
        "ico",
        "ief",
        "img",
        "ipa",
        "iso",
        "jar",
        "jpeg",
        "jpg",
        "jpgv",
        "jpm",
        "jxr",
        "key",
        "ktx",
        "lha",
        "lib",
        "lvp",
        "lz",
        "lzh",
        "lzma",
        "lzo",
        "m3u",
        "m4a",
        "m4v",
        "mar",
        "mdi",
        "mht",
        "mid",
        "midi",
        "mj2",
        "mka",
        "mkv",
        "mmr",
        "mng",
        "mobi",
        "mov",
        "movie",
        "mp3",
        "mp4",
        "mp4a",
        "mpeg",
        "mpg",
        "mpga",
        "mxu",
        "nef",
        "npx",
        "numbers",
        "nupkg",
        "o",
        "odp",
        "ods",
        "odt",
        "oga",
        "ogg",
        "ogv",
        "otf",
        "ott",
        "pages",
        "pbm",
        "pcx",
        "pdb",
        "pdf",
        "pea",
        "pgm",
        "pic",
        "png",
        "pnm",
        "pot",
        "potm",
        "potx",
        "ppa",
        "ppam",
        "ppm",
        "pps",
        "ppsm",
        "ppsx",
        "ppt",
        "pptm",
        "pptx",
        "psd",
        "pya",
        "pyc",
        "pyo",
        "pyv",
        "qt",
        "rar",
        "ras",
        "raw",
        "resources",
        "rgb",
        "rip",
        "rlc",
        "rmf",
        "rmvb",
        "rpm",
        "rtf",
        "rz",
        "s3m",
        "s7z",
        "scpt",
        "sgi",
        "shar",
        "snap",
        "sil",
        "sketch",
        "slk",
        "smv",
        "snk",
        "so",
        "stl",
        "suo",
        "sub",
        "swf",
        "tar",
        "tbz",
        "tbz2",
        "tga",
        "tgz",
        "thmx",
        "tif",
        "tiff",
        "tlz",
        "ttc",
        "ttf",
        "txz",
        "udf",
        "uvh",
        "uvi",
        "uvm",
        "uvp",
        "uvs",
        "uvu",
        "viv",
        "vob",
        "war",
        "wav",
        "wax",
        "wbmp",
        "wdp",
        "weba",
        "webm",
        "webp",
        "whl",
        "wim",
        "wm",
        "wma",
        "wmv",
        "wmx",
        "woff",
        "woff2",
        "wrm",
        "wvx",
        "xbm",
        "xif",
        "xla",
        "xlam",
        "xls",
        "xlsb",
        "xlsm",
        "xlsx",
        "xlt",
        "xltm",
        "xltx",
        "xm",
        "xmind",
        "xpi",
        "xpm",
        "xwd",
        "xz",
        "z",
        "zip",
        "zipx"
      ];
    }
  });

  // ../../node_modules/.pnpm/binary-extensions@2.2.0/node_modules/binary-extensions/index.js
  var require_binary_extensions2 = __commonJS({
    "../../node_modules/.pnpm/binary-extensions@2.2.0/node_modules/binary-extensions/index.js"(exports, module2) {
      module2.exports = require_binary_extensions();
    }
  });

  // ../../node_modules/.pnpm/is-binary-path@2.1.0/node_modules/is-binary-path/index.js
  var require_is_binary_path = __commonJS({
    "../../node_modules/.pnpm/is-binary-path@2.1.0/node_modules/is-binary-path/index.js"(exports, module2) {
      "use strict";
      var path4 = __require2("path");
      var binaryExtensions = require_binary_extensions2();
      var extensions = new Set(binaryExtensions);
      module2.exports = (filePath) => extensions.has(path4.extname(filePath).slice(1).toLowerCase());
    }
  });

  // ../../node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/lib/constants.js
  var require_constants5 = __commonJS({
    "../../node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/lib/constants.js"(exports) {
      "use strict";
      var { sep: sep2 } = __require2("path");
      var { platform } = process;
      var os = __require2("os");
      exports.EV_ALL = "all";
      exports.EV_READY = "ready";
      exports.EV_ADD = "add";
      exports.EV_CHANGE = "change";
      exports.EV_ADD_DIR = "addDir";
      exports.EV_UNLINK = "unlink";
      exports.EV_UNLINK_DIR = "unlinkDir";
      exports.EV_RAW = "raw";
      exports.EV_ERROR = "error";
      exports.STR_DATA = "data";
      exports.STR_END = "end";
      exports.STR_CLOSE = "close";
      exports.FSEVENT_CREATED = "created";
      exports.FSEVENT_MODIFIED = "modified";
      exports.FSEVENT_DELETED = "deleted";
      exports.FSEVENT_MOVED = "moved";
      exports.FSEVENT_CLONED = "cloned";
      exports.FSEVENT_UNKNOWN = "unknown";
      exports.FSEVENT_TYPE_FILE = "file";
      exports.FSEVENT_TYPE_DIRECTORY = "directory";
      exports.FSEVENT_TYPE_SYMLINK = "symlink";
      exports.KEY_LISTENERS = "listeners";
      exports.KEY_ERR = "errHandlers";
      exports.KEY_RAW = "rawEmitters";
      exports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];
      exports.DOT_SLASH = `.${sep2}`;
      exports.BACK_SLASH_RE = /\\/g;
      exports.DOUBLE_SLASH_RE = /\/\//;
      exports.SLASH_OR_BACK_SLASH_RE = /[/\\]/;
      exports.DOT_RE = /\..*\.(sw[px])$|~$|\.subl.*\.tmp/;
      exports.REPLACER_RE = /^\.[/\\]/;
      exports.SLASH = "/";
      exports.SLASH_SLASH = "//";
      exports.BRACE_START = "{";
      exports.BANG = "!";
      exports.ONE_DOT = ".";
      exports.TWO_DOTS = "..";
      exports.STAR = "*";
      exports.GLOBSTAR = "**";
      exports.ROOT_GLOBSTAR = "/**/*";
      exports.SLASH_GLOBSTAR = "/**";
      exports.DIR_SUFFIX = "Dir";
      exports.ANYMATCH_OPTS = { dot: true };
      exports.STRING_TYPE = "string";
      exports.FUNCTION_TYPE = "function";
      exports.EMPTY_STR = "";
      exports.EMPTY_FN = () => {
      };
      exports.IDENTITY_FN = (val) => val;
      exports.isWindows = platform === "win32";
      exports.isMacos = platform === "darwin";
      exports.isLinux = platform === "linux";
      exports.isIBMi = os.type() === "OS400";
    }
  });

  // ../../node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/lib/nodefs-handler.js
  var require_nodefs_handler = __commonJS({
    "../../node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/lib/nodefs-handler.js"(exports, module2) {
      "use strict";
      var fs4 = __require2("fs");
      var sysPath = __require2("path");
      var { promisify } = __require2("util");
      var isBinaryPath = require_is_binary_path();
      var {
        isWindows,
        isLinux,
        EMPTY_FN,
        EMPTY_STR,
        KEY_LISTENERS,
        KEY_ERR,
        KEY_RAW,
        HANDLER_KEYS,
        EV_CHANGE,
        EV_ADD,
        EV_ADD_DIR,
        EV_ERROR,
        STR_DATA,
        STR_END,
        BRACE_START,
        STAR
      } = require_constants5();
      var THROTTLE_MODE_WATCH = "watch";
      var open = promisify(fs4.open);
      var stat = promisify(fs4.stat);
      var lstat2 = promisify(fs4.lstat);
      var close = promisify(fs4.close);
      var fsrealpath = promisify(fs4.realpath);
      var statMethods = { lstat: lstat2, stat };
      var foreach = (val, fn) => {
        if (val instanceof Set) {
          val.forEach(fn);
        } else {
          fn(val);
        }
      };
      var addAndConvert = (main, prop, item) => {
        let container = main[prop];
        if (!(container instanceof Set)) {
          main[prop] = container = /* @__PURE__ */ new Set([container]);
        }
        container.add(item);
      };
      var clearItem = (cont) => (key) => {
        const set2 = cont[key];
        if (set2 instanceof Set) {
          set2.clear();
        } else {
          delete cont[key];
        }
      };
      var delFromSet = (main, prop, item) => {
        const container = main[prop];
        if (container instanceof Set) {
          container.delete(item);
        } else if (container === item) {
          delete main[prop];
        }
      };
      var isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;
      var FsWatchInstances = /* @__PURE__ */ new Map();
      function createFsWatchInstance(path4, options, listener, errHandler, emitRaw) {
        const handleEvent = (rawEvent, evPath) => {
          listener(path4);
          emitRaw(rawEvent, evPath, { watchedPath: path4 });
          if (evPath && path4 !== evPath) {
            fsWatchBroadcast(
              sysPath.resolve(path4, evPath),
              KEY_LISTENERS,
              sysPath.join(path4, evPath)
            );
          }
        };
        try {
          return fs4.watch(path4, options, handleEvent);
        } catch (error2) {
          errHandler(error2);
        }
      }
      var fsWatchBroadcast = (fullPath, type3, val1, val2, val3) => {
        const cont = FsWatchInstances.get(fullPath);
        if (!cont)
          return;
        foreach(cont[type3], (listener) => {
          listener(val1, val2, val3);
        });
      };
      var setFsWatchListener = (path4, fullPath, options, handlers) => {
        const { listener, errHandler, rawEmitter } = handlers;
        let cont = FsWatchInstances.get(fullPath);
        let watcher;
        if (!options.persistent) {
          watcher = createFsWatchInstance(
            path4,
            options,
            listener,
            errHandler,
            rawEmitter
          );
          return watcher.close.bind(watcher);
        }
        if (cont) {
          addAndConvert(cont, KEY_LISTENERS, listener);
          addAndConvert(cont, KEY_ERR, errHandler);
          addAndConvert(cont, KEY_RAW, rawEmitter);
        } else {
          watcher = createFsWatchInstance(
            path4,
            options,
            fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),
            errHandler,
            // no need to use broadcast here
            fsWatchBroadcast.bind(null, fullPath, KEY_RAW)
          );
          if (!watcher)
            return;
          watcher.on(EV_ERROR, async (error2) => {
            const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
            cont.watcherUnusable = true;
            if (isWindows && error2.code === "EPERM") {
              try {
                const fd = await open(path4, "r");
                await close(fd);
                broadcastErr(error2);
              } catch (err) {
              }
            } else {
              broadcastErr(error2);
            }
          });
          cont = {
            listeners: listener,
            errHandlers: errHandler,
            rawEmitters: rawEmitter,
            watcher
          };
          FsWatchInstances.set(fullPath, cont);
        }
        return () => {
          delFromSet(cont, KEY_LISTENERS, listener);
          delFromSet(cont, KEY_ERR, errHandler);
          delFromSet(cont, KEY_RAW, rawEmitter);
          if (isEmptySet(cont.listeners)) {
            cont.watcher.close();
            FsWatchInstances.delete(fullPath);
            HANDLER_KEYS.forEach(clearItem(cont));
            cont.watcher = void 0;
            Object.freeze(cont);
          }
        };
      };
      var FsWatchFileInstances = /* @__PURE__ */ new Map();
      var setFsWatchFileListener = (path4, fullPath, options, handlers) => {
        const { listener, rawEmitter } = handlers;
        let cont = FsWatchFileInstances.get(fullPath);
        let listeners = /* @__PURE__ */ new Set();
        let rawEmitters = /* @__PURE__ */ new Set();
        const copts = cont && cont.options;
        if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {
          listeners = cont.listeners;
          rawEmitters = cont.rawEmitters;
          fs4.unwatchFile(fullPath);
          cont = void 0;
        }
        if (cont) {
          addAndConvert(cont, KEY_LISTENERS, listener);
          addAndConvert(cont, KEY_RAW, rawEmitter);
        } else {
          cont = {
            listeners: listener,
            rawEmitters: rawEmitter,
            options,
            watcher: fs4.watchFile(fullPath, options, (curr, prev) => {
              foreach(cont.rawEmitters, (rawEmitter2) => {
                rawEmitter2(EV_CHANGE, fullPath, { curr, prev });
              });
              const currmtime = curr.mtimeMs;
              if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
                foreach(cont.listeners, (listener2) => listener2(path4, curr));
              }
            })
          };
          FsWatchFileInstances.set(fullPath, cont);
        }
        return () => {
          delFromSet(cont, KEY_LISTENERS, listener);
          delFromSet(cont, KEY_RAW, rawEmitter);
          if (isEmptySet(cont.listeners)) {
            FsWatchFileInstances.delete(fullPath);
            fs4.unwatchFile(fullPath);
            cont.options = cont.watcher = void 0;
            Object.freeze(cont);
          }
        };
      };
      var NodeFsHandler = class {
        /**
         * @param {import("../index").FSWatcher} fsW
         */
        constructor(fsW) {
          this.fsw = fsW;
          this._boundHandleError = (error2) => fsW._handleError(error2);
        }
        /**
         * Watch file for changes with fs_watchFile or fs_watch.
         * @param {String} path to file or dir
         * @param {Function} listener on fs change
         * @returns {Function} closer for the watcher instance
         */
        _watchWithNodeFs(path4, listener) {
          const opts = this.fsw.options;
          const directory = sysPath.dirname(path4);
          const basename3 = sysPath.basename(path4);
          const parent = this.fsw._getWatchedDir(directory);
          parent.add(basename3);
          const absolutePath = sysPath.resolve(path4);
          const options = { persistent: opts.persistent };
          if (!listener)
            listener = EMPTY_FN;
          let closer;
          if (opts.usePolling) {
            options.interval = opts.enableBinaryInterval && isBinaryPath(basename3) ? opts.binaryInterval : opts.interval;
            closer = setFsWatchFileListener(path4, absolutePath, options, {
              listener,
              rawEmitter: this.fsw._emitRaw
            });
          } else {
            closer = setFsWatchListener(path4, absolutePath, options, {
              listener,
              errHandler: this._boundHandleError,
              rawEmitter: this.fsw._emitRaw
            });
          }
          return closer;
        }
        /**
         * Watch a file and emit add event if warranted.
         * @param {Path} file Path
         * @param {fs.Stats} stats result of fs_stat
         * @param {Boolean} initialAdd was the file added at watch instantiation?
         * @returns {Function} closer for the watcher instance
         */
        _handleFile(file, stats, initialAdd) {
          if (this.fsw.closed) {
            return;
          }
          const dirname2 = sysPath.dirname(file);
          const basename3 = sysPath.basename(file);
          const parent = this.fsw._getWatchedDir(dirname2);
          let prevStats = stats;
          if (parent.has(basename3))
            return;
          const listener = async (path4, newStats) => {
            if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5))
              return;
            if (!newStats || newStats.mtimeMs === 0) {
              try {
                const newStats2 = await stat(file);
                if (this.fsw.closed)
                  return;
                const at = newStats2.atimeMs;
                const mt = newStats2.mtimeMs;
                if (!at || at <= mt || mt !== prevStats.mtimeMs) {
                  this.fsw._emit(EV_CHANGE, file, newStats2);
                }
                if (isLinux && prevStats.ino !== newStats2.ino) {
                  this.fsw._closeFile(path4);
                  prevStats = newStats2;
                  this.fsw._addPathCloser(path4, this._watchWithNodeFs(file, listener));
                } else {
                  prevStats = newStats2;
                }
              } catch (error2) {
                this.fsw._remove(dirname2, basename3);
              }
            } else if (parent.has(basename3)) {
              const at = newStats.atimeMs;
              const mt = newStats.mtimeMs;
              if (!at || at <= mt || mt !== prevStats.mtimeMs) {
                this.fsw._emit(EV_CHANGE, file, newStats);
              }
              prevStats = newStats;
            }
          };
          const closer = this._watchWithNodeFs(file, listener);
          if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
            if (!this.fsw._throttle(EV_ADD, file, 0))
              return;
            this.fsw._emit(EV_ADD, file, stats);
          }
          return closer;
        }
        /**
         * Handle symlinks encountered while reading a dir.
         * @param {Object} entry returned by readdirp
         * @param {String} directory path of dir being read
         * @param {String} path of this item
         * @param {String} item basename of this item
         * @returns {Promise<Boolean>} true if no more processing is needed for this entry.
         */
        async _handleSymlink(entry, directory, path4, item) {
          if (this.fsw.closed) {
            return;
          }
          const full = entry.fullPath;
          const dir = this.fsw._getWatchedDir(directory);
          if (!this.fsw.options.followSymlinks) {
            this.fsw._incrReadyCount();
            let linkPath;
            try {
              linkPath = await fsrealpath(path4);
            } catch (e) {
              this.fsw._emitReady();
              return true;
            }
            if (this.fsw.closed)
              return;
            if (dir.has(item)) {
              if (this.fsw._symlinkPaths.get(full) !== linkPath) {
                this.fsw._symlinkPaths.set(full, linkPath);
                this.fsw._emit(EV_CHANGE, path4, entry.stats);
              }
            } else {
              dir.add(item);
              this.fsw._symlinkPaths.set(full, linkPath);
              this.fsw._emit(EV_ADD, path4, entry.stats);
            }
            this.fsw._emitReady();
            return true;
          }
          if (this.fsw._symlinkPaths.has(full)) {
            return true;
          }
          this.fsw._symlinkPaths.set(full, true);
        }
        _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
          directory = sysPath.join(directory, EMPTY_STR);
          if (!wh.hasGlob) {
            throttler = this.fsw._throttle("readdir", directory, 1e3);
            if (!throttler)
              return;
          }
          const previous = this.fsw._getWatchedDir(wh.path);
          const current = /* @__PURE__ */ new Set();
          let stream2 = this.fsw._readdirp(directory, {
            fileFilter: (entry) => wh.filterPath(entry),
            directoryFilter: (entry) => wh.filterDir(entry),
            depth: 0
          }).on(STR_DATA, async (entry) => {
            if (this.fsw.closed) {
              stream2 = void 0;
              return;
            }
            const item = entry.path;
            let path4 = sysPath.join(directory, item);
            current.add(item);
            if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path4, item)) {
              return;
            }
            if (this.fsw.closed) {
              stream2 = void 0;
              return;
            }
            if (item === target || !target && !previous.has(item)) {
              this.fsw._incrReadyCount();
              path4 = sysPath.join(dir, sysPath.relative(dir, path4));
              this._addToNodeFs(path4, initialAdd, wh, depth + 1);
            }
          }).on(EV_ERROR, this._boundHandleError);
          return new Promise(
            (resolve4) => stream2.once(STR_END, () => {
              if (this.fsw.closed) {
                stream2 = void 0;
                return;
              }
              const wasThrottled = throttler ? throttler.clear() : false;
              resolve4();
              previous.getChildren().filter((item) => {
                return item !== directory && !current.has(item) && // in case of intersecting globs;
                // a path may have been filtered out of this readdir, but
                // shouldn't be removed because it matches a different glob
                (!wh.hasGlob || wh.filterPath({
                  fullPath: sysPath.resolve(directory, item)
                }));
              }).forEach((item) => {
                this.fsw._remove(directory, item);
              });
              stream2 = void 0;
              if (wasThrottled)
                this._handleRead(directory, false, wh, target, dir, depth, throttler);
            })
          );
        }
        /**
         * Read directory to add / remove files from `@watched` list and re-read it on change.
         * @param {String} dir fs path
         * @param {fs.Stats} stats
         * @param {Boolean} initialAdd
         * @param {Number} depth relative to user-supplied path
         * @param {String} target child path targeted for watch
         * @param {Object} wh Common watch helpers for this path
         * @param {String} realpath
         * @returns {Promise<Function>} closer for the watcher instance.
         */
        async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath2) {
          const parentDir = this.fsw._getWatchedDir(sysPath.dirname(dir));
          const tracked = parentDir.has(sysPath.basename(dir));
          if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {
            if (!wh.hasGlob || wh.globFilter(dir))
              this.fsw._emit(EV_ADD_DIR, dir, stats);
          }
          parentDir.add(sysPath.basename(dir));
          this.fsw._getWatchedDir(dir);
          let throttler;
          let closer;
          const oDepth = this.fsw.options.depth;
          if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath2)) {
            if (!target) {
              await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);
              if (this.fsw.closed)
                return;
            }
            closer = this._watchWithNodeFs(dir, (dirPath, stats2) => {
              if (stats2 && stats2.mtimeMs === 0)
                return;
              this._handleRead(dirPath, false, wh, target, dir, depth, throttler);
            });
          }
          return closer;
        }
        /**
         * Handle added file, directory, or glob pattern.
         * Delegates call to _handleFile / _handleDir after checks.
         * @param {String} path to file or ir
         * @param {Boolean} initialAdd was the file added at watch instantiation?
         * @param {Object} priorWh depth relative to user-supplied path
         * @param {Number} depth Child path actually targeted for watch
         * @param {String=} target Child path actually targeted for watch
         * @returns {Promise}
         */
        async _addToNodeFs(path4, initialAdd, priorWh, depth, target) {
          const ready = this.fsw._emitReady;
          if (this.fsw._isIgnored(path4) || this.fsw.closed) {
            ready();
            return false;
          }
          const wh = this.fsw._getWatchHelpers(path4, depth);
          if (!wh.hasGlob && priorWh) {
            wh.hasGlob = priorWh.hasGlob;
            wh.globFilter = priorWh.globFilter;
            wh.filterPath = (entry) => priorWh.filterPath(entry);
            wh.filterDir = (entry) => priorWh.filterDir(entry);
          }
          try {
            const stats = await statMethods[wh.statMethod](wh.watchPath);
            if (this.fsw.closed)
              return;
            if (this.fsw._isIgnored(wh.watchPath, stats)) {
              ready();
              return false;
            }
            const follow = this.fsw.options.followSymlinks && !path4.includes(STAR) && !path4.includes(BRACE_START);
            let closer;
            if (stats.isDirectory()) {
              const absPath = sysPath.resolve(path4);
              const targetPath = follow ? await fsrealpath(path4) : path4;
              if (this.fsw.closed)
                return;
              closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);
              if (this.fsw.closed)
                return;
              if (absPath !== targetPath && targetPath !== void 0) {
                this.fsw._symlinkPaths.set(absPath, targetPath);
              }
            } else if (stats.isSymbolicLink()) {
              const targetPath = follow ? await fsrealpath(path4) : path4;
              if (this.fsw.closed)
                return;
              const parent = sysPath.dirname(wh.watchPath);
              this.fsw._getWatchedDir(parent).add(wh.watchPath);
              this.fsw._emit(EV_ADD, wh.watchPath, stats);
              closer = await this._handleDir(parent, stats, initialAdd, depth, path4, wh, targetPath);
              if (this.fsw.closed)
                return;
              if (targetPath !== void 0) {
                this.fsw._symlinkPaths.set(sysPath.resolve(path4), targetPath);
              }
            } else {
              closer = this._handleFile(wh.watchPath, stats, initialAdd);
            }
            ready();
            this.fsw._addPathCloser(path4, closer);
            return false;
          } catch (error2) {
            if (this.fsw._handleError(error2)) {
              ready();
              return path4;
            }
          }
        }
      };
      module2.exports = NodeFsHandler;
    }
  });

  // ../../node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/lib/fsevents-handler.js
  var require_fsevents_handler = __commonJS({
    "../../node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/lib/fsevents-handler.js"(exports, module2) {
      "use strict";
      var fs4 = __require2("fs");
      var sysPath = __require2("path");
      var { promisify } = __require2("util");
      var fsevents;
      try {
        fsevents = __require2("fsevents");
      } catch (error2) {
        if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR)
          console.error(error2);
      }
      if (fsevents) {
        const mtch = process.version.match(/v(\d+)\.(\d+)/);
        if (mtch && mtch[1] && mtch[2]) {
          const maj = Number.parseInt(mtch[1], 10);
          const min = Number.parseInt(mtch[2], 10);
          if (maj === 8 && min < 16) {
            fsevents = void 0;
          }
        }
      }
      var {
        EV_ADD,
        EV_CHANGE,
        EV_ADD_DIR,
        EV_UNLINK,
        EV_ERROR,
        STR_DATA,
        STR_END,
        FSEVENT_CREATED,
        FSEVENT_MODIFIED,
        FSEVENT_DELETED,
        FSEVENT_MOVED,
        // FSEVENT_CLONED,
        FSEVENT_UNKNOWN,
        FSEVENT_TYPE_FILE,
        FSEVENT_TYPE_DIRECTORY,
        FSEVENT_TYPE_SYMLINK,
        ROOT_GLOBSTAR,
        DIR_SUFFIX,
        DOT_SLASH,
        FUNCTION_TYPE,
        EMPTY_FN,
        IDENTITY_FN
      } = require_constants5();
      var Depth = (value) => isNaN(value) ? {} : { depth: value };
      var stat = promisify(fs4.stat);
      var lstat2 = promisify(fs4.lstat);
      var realpath2 = promisify(fs4.realpath);
      var statMethods = { stat, lstat: lstat2 };
      var FSEventsWatchers = /* @__PURE__ */ new Map();
      var consolidateThreshhold = 10;
      var wrongEventFlags = /* @__PURE__ */ new Set([
        69888,
        70400,
        71424,
        72704,
        73472,
        131328,
        131840,
        262912
      ]);
      var createFSEventsInstance = (path4, callback) => {
        const stop = fsevents.watch(path4, callback);
        return { stop };
      };
      function setFSEventsListener(path4, realPath, listener, rawEmitter) {
        let watchPath = sysPath.extname(realPath) ? sysPath.dirname(realPath) : realPath;
        const parentPath = sysPath.dirname(watchPath);
        let cont = FSEventsWatchers.get(watchPath);
        if (couldConsolidate(parentPath)) {
          watchPath = parentPath;
        }
        const resolvedPath = sysPath.resolve(path4);
        const hasSymlink = resolvedPath !== realPath;
        const filteredListener = (fullPath, flags, info) => {
          if (hasSymlink)
            fullPath = fullPath.replace(realPath, resolvedPath);
          if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath.sep))
            listener(fullPath, flags, info);
        };
        let watchedParent = false;
        for (const watchedPath of FSEventsWatchers.keys()) {
          if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {
            watchPath = watchedPath;
            cont = FSEventsWatchers.get(watchPath);
            watchedParent = true;
            break;
          }
        }
        if (cont || watchedParent) {
          cont.listeners.add(filteredListener);
        } else {
          cont = {
            listeners: /* @__PURE__ */ new Set([filteredListener]),
            rawEmitter,
            watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {
              if (!cont.listeners.size)
                return;
              const info = fsevents.getInfo(fullPath, flags);
              cont.listeners.forEach((list) => {
                list(fullPath, flags, info);
              });
              cont.rawEmitter(info.event, fullPath, info);
            })
          };
          FSEventsWatchers.set(watchPath, cont);
        }
        return () => {
          const lst = cont.listeners;
          lst.delete(filteredListener);
          if (!lst.size) {
            FSEventsWatchers.delete(watchPath);
            if (cont.watcher)
              return cont.watcher.stop().then(() => {
                cont.rawEmitter = cont.watcher = void 0;
                Object.freeze(cont);
              });
          }
        };
      }
      var couldConsolidate = (path4) => {
        let count = 0;
        for (const watchPath of FSEventsWatchers.keys()) {
          if (watchPath.indexOf(path4) === 0) {
            count++;
            if (count >= consolidateThreshhold) {
              return true;
            }
          }
        }
        return false;
      };
      var canUse = () => fsevents && FSEventsWatchers.size < 128;
      var calcDepth = (path4, root) => {
        let i = 0;
        while (!path4.indexOf(root) && (path4 = sysPath.dirname(path4)) !== root)
          i++;
        return i;
      };
      var sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();
      var FsEventsHandler = class {
        /**
         * @param {import('../index').FSWatcher} fsw
         */
        constructor(fsw) {
          this.fsw = fsw;
        }
        checkIgnored(path4, stats) {
          const ipaths = this.fsw._ignoredPaths;
          if (this.fsw._isIgnored(path4, stats)) {
            ipaths.add(path4);
            if (stats && stats.isDirectory()) {
              ipaths.add(path4 + ROOT_GLOBSTAR);
            }
            return true;
          }
          ipaths.delete(path4);
          ipaths.delete(path4 + ROOT_GLOBSTAR);
        }
        addOrChange(path4, fullPath, realPath, parent, watchedDir, item, info, opts) {
          const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;
          this.handleEvent(event, path4, fullPath, realPath, parent, watchedDir, item, info, opts);
        }
        async checkExists(path4, fullPath, realPath, parent, watchedDir, item, info, opts) {
          try {
            const stats = await stat(path4);
            if (this.fsw.closed)
              return;
            if (sameTypes(info, stats)) {
              this.addOrChange(path4, fullPath, realPath, parent, watchedDir, item, info, opts);
            } else {
              this.handleEvent(EV_UNLINK, path4, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          } catch (error2) {
            if (error2.code === "EACCES") {
              this.addOrChange(path4, fullPath, realPath, parent, watchedDir, item, info, opts);
            } else {
              this.handleEvent(EV_UNLINK, path4, fullPath, realPath, parent, watchedDir, item, info, opts);
            }
          }
        }
        handleEvent(event, path4, fullPath, realPath, parent, watchedDir, item, info, opts) {
          if (this.fsw.closed || this.checkIgnored(path4))
            return;
          if (event === EV_UNLINK) {
            const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY;
            if (isDirectory || watchedDir.has(item)) {
              this.fsw._remove(parent, item, isDirectory);
            }
          } else {
            if (event === EV_ADD) {
              if (info.type === FSEVENT_TYPE_DIRECTORY)
                this.fsw._getWatchedDir(path4);
              if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {
                const curDepth = opts.depth === void 0 ? void 0 : calcDepth(fullPath, realPath) + 1;
                return this._addToFsEvents(path4, false, true, curDepth);
              }
              this.fsw._getWatchedDir(parent).add(item);
            }
            const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;
            this.fsw._emit(eventName, path4);
            if (eventName === EV_ADD_DIR)
              this._addToFsEvents(path4, false, true);
          }
        }
        /**
         * Handle symlinks encountered during directory scan
         * @param {String} watchPath  - file/dir path to be watched with fsevents
         * @param {String} realPath   - real path (in case of symlinks)
         * @param {Function} transform  - path transformer
         * @param {Function} globFilter - path filter in case a glob pattern was provided
         * @returns {Function} closer for the watcher instance
        */
        _watchWithFsEvents(watchPath, realPath, transform, globFilter) {
          if (this.fsw.closed || this.fsw._isIgnored(watchPath))
            return;
          const opts = this.fsw.options;
          const watchCallback = async (fullPath, flags, info) => {
            if (this.fsw.closed)
              return;
            if (opts.depth !== void 0 && calcDepth(fullPath, realPath) > opts.depth)
              return;
            const path4 = transform(sysPath.join(
              watchPath,
              sysPath.relative(watchPath, fullPath)
            ));
            if (globFilter && !globFilter(path4))
              return;
            const parent = sysPath.dirname(path4);
            const item = sysPath.basename(path4);
            const watchedDir = this.fsw._getWatchedDir(
              info.type === FSEVENT_TYPE_DIRECTORY ? path4 : parent
            );
            if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {
              if (typeof opts.ignored === FUNCTION_TYPE) {
                let stats;
                try {
                  stats = await stat(path4);
                } catch (error2) {
                }
                if (this.fsw.closed)
                  return;
                if (this.checkIgnored(path4, stats))
                  return;
                if (sameTypes(info, stats)) {
                  this.addOrChange(path4, fullPath, realPath, parent, watchedDir, item, info, opts);
                } else {
                  this.handleEvent(EV_UNLINK, path4, fullPath, realPath, parent, watchedDir, item, info, opts);
                }
              } else {
                this.checkExists(path4, fullPath, realPath, parent, watchedDir, item, info, opts);
              }
            } else {
              switch (info.event) {
                case FSEVENT_CREATED:
                case FSEVENT_MODIFIED:
                  return this.addOrChange(path4, fullPath, realPath, parent, watchedDir, item, info, opts);
                case FSEVENT_DELETED:
                case FSEVENT_MOVED:
                  return this.checkExists(path4, fullPath, realPath, parent, watchedDir, item, info, opts);
              }
            }
          };
          const closer = setFSEventsListener(
            watchPath,
            realPath,
            watchCallback,
            this.fsw._emitRaw
          );
          this.fsw._emitReady();
          return closer;
        }
        /**
         * Handle symlinks encountered during directory scan
         * @param {String} linkPath path to symlink
         * @param {String} fullPath absolute path to the symlink
         * @param {Function} transform pre-existing path transformer
         * @param {Number} curDepth level of subdirectories traversed to where symlink is
         * @returns {Promise<void>}
         */
        async _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {
          if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath))
            return;
          this.fsw._symlinkPaths.set(fullPath, true);
          this.fsw._incrReadyCount();
          try {
            const linkTarget = await realpath2(linkPath);
            if (this.fsw.closed)
              return;
            if (this.fsw._isIgnored(linkTarget)) {
              return this.fsw._emitReady();
            }
            this.fsw._incrReadyCount();
            this._addToFsEvents(linkTarget || linkPath, (path4) => {
              let aliasedPath = linkPath;
              if (linkTarget && linkTarget !== DOT_SLASH) {
                aliasedPath = path4.replace(linkTarget, linkPath);
              } else if (path4 !== DOT_SLASH) {
                aliasedPath = sysPath.join(linkPath, path4);
              }
              return transform(aliasedPath);
            }, false, curDepth);
          } catch (error2) {
            if (this.fsw._handleError(error2)) {
              return this.fsw._emitReady();
            }
          }
        }
        /**
         *
         * @param {Path} newPath
         * @param {fs.Stats} stats
         */
        emitAdd(newPath, stats, processPath, opts, forceAdd) {
          const pp = processPath(newPath);
          const isDir = stats.isDirectory();
          const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));
          const base = sysPath.basename(pp);
          if (isDir)
            this.fsw._getWatchedDir(pp);
          if (dirObj.has(base))
            return;
          dirObj.add(base);
          if (!opts.ignoreInitial || forceAdd === true) {
            this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);
          }
        }
        initWatch(realPath, path4, wh, processPath) {
          if (this.fsw.closed)
            return;
          const closer = this._watchWithFsEvents(
            wh.watchPath,
            sysPath.resolve(realPath || wh.watchPath),
            processPath,
            wh.globFilter
          );
          this.fsw._addPathCloser(path4, closer);
        }
        /**
         * Handle added path with fsevents
         * @param {String} path file/dir path or glob pattern
         * @param {Function|Boolean=} transform converts working path to what the user expects
         * @param {Boolean=} forceAdd ensure add is emitted
         * @param {Number=} priorDepth Level of subdirectories already traversed.
         * @returns {Promise<void>}
         */
        async _addToFsEvents(path4, transform, forceAdd, priorDepth) {
          if (this.fsw.closed) {
            return;
          }
          const opts = this.fsw.options;
          const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;
          const wh = this.fsw._getWatchHelpers(path4);
          try {
            const stats = await statMethods[wh.statMethod](wh.watchPath);
            if (this.fsw.closed)
              return;
            if (this.fsw._isIgnored(wh.watchPath, stats)) {
              throw null;
            }
            if (stats.isDirectory()) {
              if (!wh.globFilter)
                this.emitAdd(processPath(path4), stats, processPath, opts, forceAdd);
              if (priorDepth && priorDepth > opts.depth)
                return;
              this.fsw._readdirp(wh.watchPath, {
                fileFilter: (entry) => wh.filterPath(entry),
                directoryFilter: (entry) => wh.filterDir(entry),
                ...Depth(opts.depth - (priorDepth || 0))
              }).on(STR_DATA, (entry) => {
                if (this.fsw.closed) {
                  return;
                }
                if (entry.stats.isDirectory() && !wh.filterPath(entry))
                  return;
                const joinedPath = sysPath.join(wh.watchPath, entry.path);
                const { fullPath } = entry;
                if (wh.followSymlinks && entry.stats.isSymbolicLink()) {
                  const curDepth = opts.depth === void 0 ? void 0 : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;
                  this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);
                } else {
                  this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);
                }
              }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {
                this.fsw._emitReady();
              });
            } else {
              this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);
              this.fsw._emitReady();
            }
          } catch (error2) {
            if (!error2 || this.fsw._handleError(error2)) {
              this.fsw._emitReady();
              this.fsw._emitReady();
            }
          }
          if (opts.persistent && forceAdd !== true) {
            if (typeof transform === FUNCTION_TYPE) {
              this.initWatch(void 0, path4, wh, processPath);
            } else {
              let realPath;
              try {
                realPath = await realpath2(wh.watchPath);
              } catch (e) {
              }
              this.initWatch(realPath, path4, wh, processPath);
            }
          }
        }
      };
      module2.exports = FsEventsHandler;
      module2.exports.canUse = canUse;
    }
  });

  // ../../node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/index.js
  var require_chokidar = __commonJS({
    "../../node_modules/.pnpm/chokidar@3.5.3/node_modules/chokidar/index.js"(exports) {
      "use strict";
      var { EventEmitter } = __require2("events");
      var fs4 = __require2("fs");
      var sysPath = __require2("path");
      var { promisify } = __require2("util");
      var readdirp = require_readdirp();
      var anymatch = require_anymatch().default;
      var globParent = require_glob_parent();
      var isGlob = require_is_glob();
      var braces = require_braces();
      var normalizePath = require_normalize_path();
      var NodeFsHandler = require_nodefs_handler();
      var FsEventsHandler = require_fsevents_handler();
      var {
        EV_ALL,
        EV_READY,
        EV_ADD,
        EV_CHANGE,
        EV_UNLINK,
        EV_ADD_DIR,
        EV_UNLINK_DIR,
        EV_RAW,
        EV_ERROR,
        STR_CLOSE,
        STR_END,
        BACK_SLASH_RE,
        DOUBLE_SLASH_RE,
        SLASH_OR_BACK_SLASH_RE,
        DOT_RE,
        REPLACER_RE,
        SLASH,
        SLASH_SLASH,
        BRACE_START,
        BANG,
        ONE_DOT,
        TWO_DOTS,
        GLOBSTAR: GLOBSTAR2,
        SLASH_GLOBSTAR,
        ANYMATCH_OPTS,
        STRING_TYPE,
        FUNCTION_TYPE,
        EMPTY_STR,
        EMPTY_FN,
        isWindows,
        isMacos,
        isIBMi
      } = require_constants5();
      var stat = promisify(fs4.stat);
      var readdir2 = promisify(fs4.readdir);
      var arrify = (value = []) => Array.isArray(value) ? value : [value];
      var flatten = (list, result = []) => {
        list.forEach((item) => {
          if (Array.isArray(item)) {
            flatten(item, result);
          } else {
            result.push(item);
          }
        });
        return result;
      };
      var unifyPaths = (paths_) => {
        const paths = flatten(arrify(paths_));
        if (!paths.every((p) => typeof p === STRING_TYPE)) {
          throw new TypeError(`Non-string provided as watch path: ${paths}`);
        }
        return paths.map(normalizePathToUnix);
      };
      var toUnix = (string2) => {
        let str = string2.replace(BACK_SLASH_RE, SLASH);
        let prepend = false;
        if (str.startsWith(SLASH_SLASH)) {
          prepend = true;
        }
        while (str.match(DOUBLE_SLASH_RE)) {
          str = str.replace(DOUBLE_SLASH_RE, SLASH);
        }
        if (prepend) {
          str = SLASH + str;
        }
        return str;
      };
      var normalizePathToUnix = (path4) => toUnix(sysPath.normalize(toUnix(path4)));
      var normalizeIgnored = (cwd = EMPTY_STR) => (path4) => {
        if (typeof path4 !== STRING_TYPE)
          return path4;
        return normalizePathToUnix(sysPath.isAbsolute(path4) ? path4 : sysPath.join(cwd, path4));
      };
      var getAbsolutePath = (path4, cwd) => {
        if (sysPath.isAbsolute(path4)) {
          return path4;
        }
        if (path4.startsWith(BANG)) {
          return BANG + sysPath.join(cwd, path4.slice(1));
        }
        return sysPath.join(cwd, path4);
      };
      var undef = (opts, key) => opts[key] === void 0;
      var DirEntry = class {
        /**
         * @param {Path} dir
         * @param {Function} removeWatcher
         */
        constructor(dir, removeWatcher) {
          this.path = dir;
          this._removeWatcher = removeWatcher;
          this.items = /* @__PURE__ */ new Set();
        }
        add(item) {
          const { items } = this;
          if (!items)
            return;
          if (item !== ONE_DOT && item !== TWO_DOTS)
            items.add(item);
        }
        async remove(item) {
          const { items } = this;
          if (!items)
            return;
          items.delete(item);
          if (items.size > 0)
            return;
          const dir = this.path;
          try {
            await readdir2(dir);
          } catch (err) {
            if (this._removeWatcher) {
              this._removeWatcher(sysPath.dirname(dir), sysPath.basename(dir));
            }
          }
        }
        has(item) {
          const { items } = this;
          if (!items)
            return;
          return items.has(item);
        }
        /**
         * @returns {Array<String>}
         */
        getChildren() {
          const { items } = this;
          if (!items)
            return;
          return [...items.values()];
        }
        dispose() {
          this.items.clear();
          delete this.path;
          delete this._removeWatcher;
          delete this.items;
          Object.freeze(this);
        }
      };
      var STAT_METHOD_F = "stat";
      var STAT_METHOD_L = "lstat";
      var WatchHelper = class {
        constructor(path4, watchPath, follow, fsw) {
          this.fsw = fsw;
          this.path = path4 = path4.replace(REPLACER_RE, EMPTY_STR);
          this.watchPath = watchPath;
          this.fullWatchPath = sysPath.resolve(watchPath);
          this.hasGlob = watchPath !== path4;
          if (path4 === EMPTY_STR)
            this.hasGlob = false;
          this.globSymlink = this.hasGlob && follow ? void 0 : false;
          this.globFilter = this.hasGlob ? anymatch(path4, void 0, ANYMATCH_OPTS) : false;
          this.dirParts = this.getDirParts(path4);
          this.dirParts.forEach((parts) => {
            if (parts.length > 1)
              parts.pop();
          });
          this.followSymlinks = follow;
          this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;
        }
        checkGlobSymlink(entry) {
          if (this.globSymlink === void 0) {
            this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : { realPath: entry.fullParentDir, linkPath: this.fullWatchPath };
          }
          if (this.globSymlink) {
            return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);
          }
          return entry.fullPath;
        }
        entryPath(entry) {
          return sysPath.join(
            this.watchPath,
            sysPath.relative(this.watchPath, this.checkGlobSymlink(entry))
          );
        }
        filterPath(entry) {
          const { stats } = entry;
          if (stats && stats.isSymbolicLink())
            return this.filterDir(entry);
          const resolvedPath = this.entryPath(entry);
          const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE ? this.globFilter(resolvedPath) : true;
          return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);
        }
        getDirParts(path4) {
          if (!this.hasGlob)
            return [];
          const parts = [];
          const expandedPath = path4.includes(BRACE_START) ? braces.expand(path4) : [path4];
          expandedPath.forEach((path5) => {
            parts.push(sysPath.relative(this.watchPath, path5).split(SLASH_OR_BACK_SLASH_RE));
          });
          return parts;
        }
        filterDir(entry) {
          if (this.hasGlob) {
            const entryParts = this.getDirParts(this.checkGlobSymlink(entry));
            let globstar = false;
            this.unmatchedGlob = !this.dirParts.some((parts) => {
              return parts.every((part, i) => {
                if (part === GLOBSTAR2)
                  globstar = true;
                return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);
              });
            });
          }
          return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);
        }
      };
      var FSWatcher = class extends EventEmitter {
        // Not indenting methods for history sake; for now.
        constructor(_opts) {
          super();
          const opts = {};
          if (_opts)
            Object.assign(opts, _opts);
          this._watched = /* @__PURE__ */ new Map();
          this._closers = /* @__PURE__ */ new Map();
          this._ignoredPaths = /* @__PURE__ */ new Set();
          this._throttled = /* @__PURE__ */ new Map();
          this._symlinkPaths = /* @__PURE__ */ new Map();
          this._streams = /* @__PURE__ */ new Set();
          this.closed = false;
          if (undef(opts, "persistent"))
            opts.persistent = true;
          if (undef(opts, "ignoreInitial"))
            opts.ignoreInitial = false;
          if (undef(opts, "ignorePermissionErrors"))
            opts.ignorePermissionErrors = false;
          if (undef(opts, "interval"))
            opts.interval = 100;
          if (undef(opts, "binaryInterval"))
            opts.binaryInterval = 300;
          if (undef(opts, "disableGlobbing"))
            opts.disableGlobbing = false;
          opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;
          if (undef(opts, "useFsEvents"))
            opts.useFsEvents = !opts.usePolling;
          const canUseFsEvents = FsEventsHandler.canUse();
          if (!canUseFsEvents)
            opts.useFsEvents = false;
          if (undef(opts, "usePolling") && !opts.useFsEvents) {
            opts.usePolling = isMacos;
          }
          if (isIBMi) {
            opts.usePolling = true;
          }
          const envPoll = process.env.CHOKIDAR_USEPOLLING;
          if (envPoll !== void 0) {
            const envLower = envPoll.toLowerCase();
            if (envLower === "false" || envLower === "0") {
              opts.usePolling = false;
            } else if (envLower === "true" || envLower === "1") {
              opts.usePolling = true;
            } else {
              opts.usePolling = !!envLower;
            }
          }
          const envInterval = process.env.CHOKIDAR_INTERVAL;
          if (envInterval) {
            opts.interval = Number.parseInt(envInterval, 10);
          }
          if (undef(opts, "atomic"))
            opts.atomic = !opts.usePolling && !opts.useFsEvents;
          if (opts.atomic)
            this._pendingUnlinks = /* @__PURE__ */ new Map();
          if (undef(opts, "followSymlinks"))
            opts.followSymlinks = true;
          if (undef(opts, "awaitWriteFinish"))
            opts.awaitWriteFinish = false;
          if (opts.awaitWriteFinish === true)
            opts.awaitWriteFinish = {};
          const awf = opts.awaitWriteFinish;
          if (awf) {
            if (!awf.stabilityThreshold)
              awf.stabilityThreshold = 2e3;
            if (!awf.pollInterval)
              awf.pollInterval = 100;
            this._pendingWrites = /* @__PURE__ */ new Map();
          }
          if (opts.ignored)
            opts.ignored = arrify(opts.ignored);
          let readyCalls = 0;
          this._emitReady = () => {
            readyCalls++;
            if (readyCalls >= this._readyCount) {
              this._emitReady = EMPTY_FN;
              this._readyEmitted = true;
              process.nextTick(() => this.emit(EV_READY));
            }
          };
          this._emitRaw = (...args) => this.emit(EV_RAW, ...args);
          this._readyEmitted = false;
          this.options = opts;
          if (opts.useFsEvents) {
            this._fsEventsHandler = new FsEventsHandler(this);
          } else {
            this._nodeFsHandler = new NodeFsHandler(this);
          }
          Object.freeze(opts);
        }
        // Public methods
        /**
         * Adds paths to be watched on an existing FSWatcher instance
         * @param {Path|Array<Path>} paths_
         * @param {String=} _origAdd private; for handling non-existent paths to be watched
         * @param {Boolean=} _internal private; indicates a non-user add
         * @returns {FSWatcher} for chaining
         */
        add(paths_, _origAdd, _internal) {
          const { cwd, disableGlobbing } = this.options;
          this.closed = false;
          let paths = unifyPaths(paths_);
          if (cwd) {
            paths = paths.map((path4) => {
              const absPath = getAbsolutePath(path4, cwd);
              if (disableGlobbing || !isGlob(path4)) {
                return absPath;
              }
              return normalizePath(absPath);
            });
          }
          paths = paths.filter((path4) => {
            if (path4.startsWith(BANG)) {
              this._ignoredPaths.add(path4.slice(1));
              return false;
            }
            this._ignoredPaths.delete(path4);
            this._ignoredPaths.delete(path4 + SLASH_GLOBSTAR);
            this._userIgnored = void 0;
            return true;
          });
          if (this.options.useFsEvents && this._fsEventsHandler) {
            if (!this._readyCount)
              this._readyCount = paths.length;
            if (this.options.persistent)
              this._readyCount *= 2;
            paths.forEach((path4) => this._fsEventsHandler._addToFsEvents(path4));
          } else {
            if (!this._readyCount)
              this._readyCount = 0;
            this._readyCount += paths.length;
            Promise.all(
              paths.map(async (path4) => {
                const res = await this._nodeFsHandler._addToNodeFs(path4, !_internal, 0, 0, _origAdd);
                if (res)
                  this._emitReady();
                return res;
              })
            ).then((results) => {
              if (this.closed)
                return;
              results.filter((item) => item).forEach((item) => {
                this.add(sysPath.dirname(item), sysPath.basename(_origAdd || item));
              });
            });
          }
          return this;
        }
        /**
         * Close watchers or start ignoring events from specified paths.
         * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs
         * @returns {FSWatcher} for chaining
        */
        unwatch(paths_) {
          if (this.closed)
            return this;
          const paths = unifyPaths(paths_);
          const { cwd } = this.options;
          paths.forEach((path4) => {
            if (!sysPath.isAbsolute(path4) && !this._closers.has(path4)) {
              if (cwd)
                path4 = sysPath.join(cwd, path4);
              path4 = sysPath.resolve(path4);
            }
            this._closePath(path4);
            this._ignoredPaths.add(path4);
            if (this._watched.has(path4)) {
              this._ignoredPaths.add(path4 + SLASH_GLOBSTAR);
            }
            this._userIgnored = void 0;
          });
          return this;
        }
        /**
         * Close watchers and remove all listeners from watched paths.
         * @returns {Promise<void>}.
        */
        close() {
          if (this.closed)
            return this._closePromise;
          this.closed = true;
          this.removeAllListeners();
          const closers = [];
          this._closers.forEach((closerList) => closerList.forEach((closer) => {
            const promise = closer();
            if (promise instanceof Promise)
              closers.push(promise);
          }));
          this._streams.forEach((stream2) => stream2.destroy());
          this._userIgnored = void 0;
          this._readyCount = 0;
          this._readyEmitted = false;
          this._watched.forEach((dirent) => dirent.dispose());
          ["closers", "watched", "streams", "symlinkPaths", "throttled"].forEach((key) => {
            this[`_${key}`].clear();
          });
          this._closePromise = closers.length ? Promise.all(closers).then(() => void 0) : Promise.resolve();
          return this._closePromise;
        }
        /**
         * Expose list of watched paths
         * @returns {Object} for chaining
        */
        getWatched() {
          const watchList = {};
          this._watched.forEach((entry, dir) => {
            const key = this.options.cwd ? sysPath.relative(this.options.cwd, dir) : dir;
            watchList[key || ONE_DOT] = entry.getChildren().sort();
          });
          return watchList;
        }
        emitWithAll(event, args) {
          this.emit(...args);
          if (event !== EV_ERROR)
            this.emit(EV_ALL, ...args);
        }
        // Common helpers
        // --------------
        /**
         * Normalize and emit events.
         * Calling _emit DOES NOT MEAN emit() would be called!
         * @param {EventName} event Type of event
         * @param {Path} path File or directory path
         * @param {*=} val1 arguments to be passed with event
         * @param {*=} val2
         * @param {*=} val3
         * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag
         */
        async _emit(event, path4, val1, val2, val3) {
          if (this.closed)
            return;
          const opts = this.options;
          if (isWindows)
            path4 = sysPath.normalize(path4);
          if (opts.cwd)
            path4 = sysPath.relative(opts.cwd, path4);
          const args = [event, path4];
          if (val3 !== void 0)
            args.push(val1, val2, val3);
          else if (val2 !== void 0)
            args.push(val1, val2);
          else if (val1 !== void 0)
            args.push(val1);
          const awf = opts.awaitWriteFinish;
          let pw;
          if (awf && (pw = this._pendingWrites.get(path4))) {
            pw.lastChange = /* @__PURE__ */ new Date();
            return this;
          }
          if (opts.atomic) {
            if (event === EV_UNLINK) {
              this._pendingUnlinks.set(path4, args);
              setTimeout(() => {
                this._pendingUnlinks.forEach((entry, path5) => {
                  this.emit(...entry);
                  this.emit(EV_ALL, ...entry);
                  this._pendingUnlinks.delete(path5);
                });
              }, typeof opts.atomic === "number" ? opts.atomic : 100);
              return this;
            }
            if (event === EV_ADD && this._pendingUnlinks.has(path4)) {
              event = args[0] = EV_CHANGE;
              this._pendingUnlinks.delete(path4);
            }
          }
          if (awf && (event === EV_ADD || event === EV_CHANGE) && this._readyEmitted) {
            const awfEmit = (err, stats) => {
              if (err) {
                event = args[0] = EV_ERROR;
                args[1] = err;
                this.emitWithAll(event, args);
              } else if (stats) {
                if (args.length > 2) {
                  args[2] = stats;
                } else {
                  args.push(stats);
                }
                this.emitWithAll(event, args);
              }
            };
            this._awaitWriteFinish(path4, awf.stabilityThreshold, event, awfEmit);
            return this;
          }
          if (event === EV_CHANGE) {
            const isThrottled = !this._throttle(EV_CHANGE, path4, 50);
            if (isThrottled)
              return this;
          }
          if (opts.alwaysStat && val1 === void 0 && (event === EV_ADD || event === EV_ADD_DIR || event === EV_CHANGE)) {
            const fullPath = opts.cwd ? sysPath.join(opts.cwd, path4) : path4;
            let stats;
            try {
              stats = await stat(fullPath);
            } catch (err) {
            }
            if (!stats || this.closed)
              return;
            args.push(stats);
          }
          this.emitWithAll(event, args);
          return this;
        }
        /**
         * Common handler for errors
         * @param {Error} error
         * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag
         */
        _handleError(error2) {
          const code = error2 && error2.code;
          if (error2 && code !== "ENOENT" && code !== "ENOTDIR" && (!this.options.ignorePermissionErrors || code !== "EPERM" && code !== "EACCES")) {
            this.emit(EV_ERROR, error2);
          }
          return error2 || this.closed;
        }
        /**
         * Helper utility for throttling
         * @param {ThrottleType} actionType type being throttled
         * @param {Path} path being acted upon
         * @param {Number} timeout duration of time to suppress duplicate actions
         * @returns {Object|false} tracking object or false if action should be suppressed
         */
        _throttle(actionType, path4, timeout) {
          if (!this._throttled.has(actionType)) {
            this._throttled.set(actionType, /* @__PURE__ */ new Map());
          }
          const action = this._throttled.get(actionType);
          const actionPath = action.get(path4);
          if (actionPath) {
            actionPath.count++;
            return false;
          }
          let timeoutObject;
          const clear = () => {
            const item = action.get(path4);
            const count = item ? item.count : 0;
            action.delete(path4);
            clearTimeout(timeoutObject);
            if (item)
              clearTimeout(item.timeoutObject);
            return count;
          };
          timeoutObject = setTimeout(clear, timeout);
          const thr = { timeoutObject, clear, count: 0 };
          action.set(path4, thr);
          return thr;
        }
        _incrReadyCount() {
          return this._readyCount++;
        }
        /**
         * Awaits write operation to finish.
         * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.
         * @param {Path} path being acted upon
         * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished
         * @param {EventName} event
         * @param {Function} awfEmit Callback to be called when ready for event to be emitted.
         */
        _awaitWriteFinish(path4, threshold, event, awfEmit) {
          let timeoutHandler;
          let fullPath = path4;
          if (this.options.cwd && !sysPath.isAbsolute(path4)) {
            fullPath = sysPath.join(this.options.cwd, path4);
          }
          const now = /* @__PURE__ */ new Date();
          const awaitWriteFinish = (prevStat) => {
            fs4.stat(fullPath, (err, curStat) => {
              if (err || !this._pendingWrites.has(path4)) {
                if (err && err.code !== "ENOENT")
                  awfEmit(err);
                return;
              }
              const now2 = Number(/* @__PURE__ */ new Date());
              if (prevStat && curStat.size !== prevStat.size) {
                this._pendingWrites.get(path4).lastChange = now2;
              }
              const pw = this._pendingWrites.get(path4);
              const df = now2 - pw.lastChange;
              if (df >= threshold) {
                this._pendingWrites.delete(path4);
                awfEmit(void 0, curStat);
              } else {
                timeoutHandler = setTimeout(
                  awaitWriteFinish,
                  this.options.awaitWriteFinish.pollInterval,
                  curStat
                );
              }
            });
          };
          if (!this._pendingWrites.has(path4)) {
            this._pendingWrites.set(path4, {
              lastChange: now,
              cancelWait: () => {
                this._pendingWrites.delete(path4);
                clearTimeout(timeoutHandler);
                return event;
              }
            });
            timeoutHandler = setTimeout(
              awaitWriteFinish,
              this.options.awaitWriteFinish.pollInterval
            );
          }
        }
        _getGlobIgnored() {
          return [...this._ignoredPaths.values()];
        }
        /**
         * Determines whether user has asked to ignore this path.
         * @param {Path} path filepath or dir
         * @param {fs.Stats=} stats result of fs.stat
         * @returns {Boolean}
         */
        _isIgnored(path4, stats) {
          if (this.options.atomic && DOT_RE.test(path4))
            return true;
          if (!this._userIgnored) {
            const { cwd } = this.options;
            const ign = this.options.ignored;
            const ignored = ign && ign.map(normalizeIgnored(cwd));
            const paths = arrify(ignored).filter((path5) => typeof path5 === STRING_TYPE && !isGlob(path5)).map((path5) => path5 + SLASH_GLOBSTAR);
            const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);
            this._userIgnored = anymatch(list, void 0, ANYMATCH_OPTS);
          }
          return this._userIgnored([path4, stats]);
        }
        _isntIgnored(path4, stat2) {
          return !this._isIgnored(path4, stat2);
        }
        /**
         * Provides a set of common helpers and properties relating to symlink and glob handling.
         * @param {Path} path file, directory, or glob pattern being watched
         * @param {Number=} depth at any depth > 0, this isn't a glob
         * @returns {WatchHelper} object containing helpers for this path
         */
        _getWatchHelpers(path4, depth) {
          const watchPath = depth || this.options.disableGlobbing || !isGlob(path4) ? path4 : globParent(path4);
          const follow = this.options.followSymlinks;
          return new WatchHelper(path4, watchPath, follow, this);
        }
        // Directory helpers
        // -----------------
        /**
         * Provides directory tracking objects
         * @param {String} directory path of the directory
         * @returns {DirEntry} the directory's tracking object
         */
        _getWatchedDir(directory) {
          if (!this._boundRemove)
            this._boundRemove = this._remove.bind(this);
          const dir = sysPath.resolve(directory);
          if (!this._watched.has(dir))
            this._watched.set(dir, new DirEntry(dir, this._boundRemove));
          return this._watched.get(dir);
        }
        // File helpers
        // ------------
        /**
         * Check for read permissions.
         * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405
         * @param {fs.Stats} stats - object, result of fs_stat
         * @returns {Boolean} indicates whether the file can be read
        */
        _hasReadPermissions(stats) {
          if (this.options.ignorePermissionErrors)
            return true;
          const md = stats && Number.parseInt(stats.mode, 10);
          const st = md & 511;
          const it = Number.parseInt(st.toString(8)[0], 10);
          return Boolean(4 & it);
        }
        /**
         * Handles emitting unlink events for
         * files and directories, and via recursion, for
         * files and directories within directories that are unlinked
         * @param {String} directory within which the following item is located
         * @param {String} item      base path of item/directory
         * @returns {void}
        */
        _remove(directory, item, isDirectory) {
          const path4 = sysPath.join(directory, item);
          const fullPath = sysPath.resolve(path4);
          isDirectory = isDirectory != null ? isDirectory : this._watched.has(path4) || this._watched.has(fullPath);
          if (!this._throttle("remove", path4, 100))
            return;
          if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {
            this.add(directory, item, true);
          }
          const wp = this._getWatchedDir(path4);
          const nestedDirectoryChildren = wp.getChildren();
          nestedDirectoryChildren.forEach((nested) => this._remove(path4, nested));
          const parent = this._getWatchedDir(directory);
          const wasTracked = parent.has(item);
          parent.remove(item);
          if (this._symlinkPaths.has(fullPath)) {
            this._symlinkPaths.delete(fullPath);
          }
          let relPath = path4;
          if (this.options.cwd)
            relPath = sysPath.relative(this.options.cwd, path4);
          if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {
            const event = this._pendingWrites.get(relPath).cancelWait();
            if (event === EV_ADD)
              return;
          }
          this._watched.delete(path4);
          this._watched.delete(fullPath);
          const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK;
          if (wasTracked && !this._isIgnored(path4))
            this._emit(eventName, path4);
          if (!this.options.useFsEvents) {
            this._closePath(path4);
          }
        }
        /**
         * Closes all watchers for a path
         * @param {Path} path
         */
        _closePath(path4) {
          this._closeFile(path4);
          const dir = sysPath.dirname(path4);
          this._getWatchedDir(dir).remove(sysPath.basename(path4));
        }
        /**
         * Closes only file-specific watchers
         * @param {Path} path
         */
        _closeFile(path4) {
          const closers = this._closers.get(path4);
          if (!closers)
            return;
          closers.forEach((closer) => closer());
          this._closers.delete(path4);
        }
        /**
         *
         * @param {Path} path
         * @param {Function} closer
         */
        _addPathCloser(path4, closer) {
          if (!closer)
            return;
          let list = this._closers.get(path4);
          if (!list) {
            list = [];
            this._closers.set(path4, list);
          }
          list.push(closer);
        }
        _readdirp(root, opts) {
          if (this.closed)
            return;
          const options = { type: EV_ALL, alwaysStat: true, lstat: true, ...opts };
          let stream2 = readdirp(root, options);
          this._streams.add(stream2);
          stream2.once(STR_CLOSE, () => {
            stream2 = void 0;
          });
          stream2.once(STR_END, () => {
            if (stream2) {
              this._streams.delete(stream2);
              stream2 = void 0;
            }
          });
          return stream2;
        }
      };
      exports.FSWatcher = FSWatcher;
      var watch2 = (paths, options) => {
        const watcher = new FSWatcher(options);
        watcher.add(paths);
        return watcher;
      };
      exports.watch = watch2;
    }
  });

  // ../../node_modules/.pnpm/esbuild@0.19.3/node_modules/esbuild/lib/main.js
  var require_main = __commonJS({
    "../../node_modules/.pnpm/esbuild@0.19.3/node_modules/esbuild/lib/main.js"(exports, module2) {
      "use strict";
      var __defProp11 = Object.defineProperty;
      var __getOwnPropDesc3 = Object.getOwnPropertyDescriptor;
      var __getOwnPropNames3 = Object.getOwnPropertyNames;
      var __hasOwnProp3 = Object.prototype.hasOwnProperty;
      var __export3 = (target, all) => {
        for (var name in all)
          __defProp11(target, name, { get: all[name], enumerable: true });
      };
      var __copyProps3 = (to, from, except, desc) => {
        if (from && typeof from === "object" || typeof from === "function") {
          for (let key of __getOwnPropNames3(from))
            if (!__hasOwnProp3.call(to, key) && key !== except)
              __defProp11(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc3(from, key)) || desc.enumerable });
        }
        return to;
      };
      var __toCommonJS2 = (mod) => __copyProps3(__defProp11({}, "__esModule", { value: true }), mod);
      var node_exports = {};
      __export3(node_exports, {
        analyzeMetafile: () => analyzeMetafile,
        analyzeMetafileSync: () => analyzeMetafileSync,
        build: () => build3,
        buildSync: () => buildSync,
        context: () => context2,
        default: () => node_default3,
        formatMessages: () => formatMessages,
        formatMessagesSync: () => formatMessagesSync,
        initialize: () => initialize,
        transform: () => transform,
        transformSync: () => transformSync,
        version: () => version2
      });
      module2.exports = __toCommonJS2(node_exports);
      function encodePacket(packet) {
        let visit2 = (value) => {
          if (value === null) {
            bb.write8(0);
          } else if (typeof value === "boolean") {
            bb.write8(1);
            bb.write8(+value);
          } else if (typeof value === "number") {
            bb.write8(2);
            bb.write32(value | 0);
          } else if (typeof value === "string") {
            bb.write8(3);
            bb.write(encodeUTF8(value));
          } else if (value instanceof Uint8Array) {
            bb.write8(4);
            bb.write(value);
          } else if (value instanceof Array) {
            bb.write8(5);
            bb.write32(value.length);
            for (let item of value) {
              visit2(item);
            }
          } else {
            let keys4 = Object.keys(value);
            bb.write8(6);
            bb.write32(keys4.length);
            for (let key of keys4) {
              bb.write(encodeUTF8(key));
              visit2(value[key]);
            }
          }
        };
        let bb = new ByteBuffer();
        bb.write32(0);
        bb.write32(packet.id << 1 | +!packet.isRequest);
        visit2(packet.value);
        writeUInt32LE(bb.buf, bb.len - 4, 0);
        return bb.buf.subarray(0, bb.len);
      }
      function decodePacket(bytes3) {
        let visit2 = () => {
          switch (bb.read8()) {
            case 0:
              return null;
            case 1:
              return !!bb.read8();
            case 2:
              return bb.read32();
            case 3:
              return decodeUTF8(bb.read());
            case 4:
              return bb.read();
            case 5: {
              let count = bb.read32();
              let value2 = [];
              for (let i = 0; i < count; i++) {
                value2.push(visit2());
              }
              return value2;
            }
            case 6: {
              let count = bb.read32();
              let value2 = {};
              for (let i = 0; i < count; i++) {
                value2[decodeUTF8(bb.read())] = visit2();
              }
              return value2;
            }
            default:
              throw new Error("Invalid packet");
          }
        };
        let bb = new ByteBuffer(bytes3);
        let id = bb.read32();
        let isRequest2 = (id & 1) === 0;
        id >>>= 1;
        let value = visit2();
        if (bb.ptr !== bytes3.length) {
          throw new Error("Invalid packet");
        }
        return { id, isRequest: isRequest2, value };
      }
      var ByteBuffer = class {
        constructor(buf = new Uint8Array(1024)) {
          this.buf = buf;
          this.len = 0;
          this.ptr = 0;
        }
        _write(delta) {
          if (this.len + delta > this.buf.length) {
            let clone5 = new Uint8Array((this.len + delta) * 2);
            clone5.set(this.buf);
            this.buf = clone5;
          }
          this.len += delta;
          return this.len - delta;
        }
        write8(value) {
          let offset = this._write(1);
          this.buf[offset] = value;
        }
        write32(value) {
          let offset = this._write(4);
          writeUInt32LE(this.buf, value, offset);
        }
        write(bytes3) {
          let offset = this._write(4 + bytes3.length);
          writeUInt32LE(this.buf, bytes3.length, offset);
          this.buf.set(bytes3, offset + 4);
        }
        _read(delta) {
          if (this.ptr + delta > this.buf.length) {
            throw new Error("Invalid packet");
          }
          this.ptr += delta;
          return this.ptr - delta;
        }
        read8() {
          return this.buf[this._read(1)];
        }
        read32() {
          return readUInt32LE(this.buf, this._read(4));
        }
        read() {
          let length = this.read32();
          let bytes3 = new Uint8Array(length);
          let ptr = this._read(bytes3.length);
          bytes3.set(this.buf.subarray(ptr, ptr + length));
          return bytes3;
        }
      };
      var encodeUTF8;
      var decodeUTF8;
      var encodeInvariant;
      if (typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined") {
        let encoder = new TextEncoder();
        let decoder = new TextDecoder();
        encodeUTF8 = (text) => encoder.encode(text);
        decodeUTF8 = (bytes3) => decoder.decode(bytes3);
        encodeInvariant = 'new TextEncoder().encode("")';
      } else if (typeof Buffer !== "undefined") {
        encodeUTF8 = (text) => Buffer.from(text);
        decodeUTF8 = (bytes3) => {
          let { buffer, byteOffset, byteLength } = bytes3;
          return Buffer.from(buffer, byteOffset, byteLength).toString();
        };
        encodeInvariant = 'Buffer.from("")';
      } else {
        throw new Error("No UTF-8 codec found");
      }
      if (!(encodeUTF8("") instanceof Uint8Array))
        throw new Error(`Invariant violation: "${encodeInvariant} instanceof Uint8Array" is incorrectly false

This indicates that your JavaScript environment is broken. You cannot use
esbuild in this environment because esbuild relies on this invariant. This
is not a problem with esbuild. You need to fix your environment instead.
`);
      function readUInt32LE(buffer, offset) {
        return buffer[offset++] | buffer[offset++] << 8 | buffer[offset++] << 16 | buffer[offset++] << 24;
      }
      function writeUInt32LE(buffer, value, offset) {
        buffer[offset++] = value;
        buffer[offset++] = value >> 8;
        buffer[offset++] = value >> 16;
        buffer[offset++] = value >> 24;
      }
      var quote = JSON.stringify;
      var buildLogLevelDefault = "warning";
      var transformLogLevelDefault = "silent";
      function validateTarget(target) {
        validateStringValue(target, "target");
        if (target.indexOf(",") >= 0)
          throw new Error(`Invalid target: ${target}`);
        return target;
      }
      var canBeAnything = () => null;
      var mustBeBoolean = (value) => typeof value === "boolean" ? null : "a boolean";
      var mustBeString = (value) => typeof value === "string" ? null : "a string";
      var mustBeRegExp = (value) => value instanceof RegExp ? null : "a RegExp object";
      var mustBeInteger = (value) => typeof value === "number" && value === (value | 0) ? null : "an integer";
      var mustBeFunction = (value) => typeof value === "function" ? null : "a function";
      var mustBeArray = (value) => Array.isArray(value) ? null : "an array";
      var mustBeObject = (value) => typeof value === "object" && value !== null && !Array.isArray(value) ? null : "an object";
      var mustBeEntryPoints = (value) => typeof value === "object" && value !== null ? null : "an array or an object";
      var mustBeWebAssemblyModule = (value) => value instanceof WebAssembly.Module ? null : "a WebAssembly.Module";
      var mustBeObjectOrNull = (value) => typeof value === "object" && !Array.isArray(value) ? null : "an object or null";
      var mustBeStringOrBoolean = (value) => typeof value === "string" || typeof value === "boolean" ? null : "a string or a boolean";
      var mustBeStringOrObject = (value) => typeof value === "string" || typeof value === "object" && value !== null && !Array.isArray(value) ? null : "a string or an object";
      var mustBeStringOrArray = (value) => typeof value === "string" || Array.isArray(value) ? null : "a string or an array";
      var mustBeStringOrUint8Array = (value) => typeof value === "string" || value instanceof Uint8Array ? null : "a string or a Uint8Array";
      var mustBeStringOrURL = (value) => typeof value === "string" || value instanceof URL ? null : "a string or a URL";
      function getFlag(object2, keys4, key, mustBeFn) {
        let value = object2[key];
        keys4[key + ""] = true;
        if (value === void 0)
          return void 0;
        let mustBe = mustBeFn(value);
        if (mustBe !== null)
          throw new Error(`${quote(key)} must be ${mustBe}`);
        return value;
      }
      function checkForInvalidFlags(object2, keys4, where) {
        for (let key in object2) {
          if (!(key in keys4)) {
            throw new Error(`Invalid option ${where}: ${quote(key)}`);
          }
        }
      }
      function validateInitializeOptions(options) {
        let keys4 = /* @__PURE__ */ Object.create(null);
        let wasmURL = getFlag(options, keys4, "wasmURL", mustBeStringOrURL);
        let wasmModule = getFlag(options, keys4, "wasmModule", mustBeWebAssemblyModule);
        let worker = getFlag(options, keys4, "worker", mustBeBoolean);
        checkForInvalidFlags(options, keys4, "in initialize() call");
        return {
          wasmURL,
          wasmModule,
          worker
        };
      }
      function validateMangleCache(mangleCache) {
        let validated;
        if (mangleCache !== void 0) {
          validated = /* @__PURE__ */ Object.create(null);
          for (let key in mangleCache) {
            let value = mangleCache[key];
            if (typeof value === "string" || value === false) {
              validated[key] = value;
            } else {
              throw new Error(`Expected ${quote(key)} in mangle cache to map to either a string or false`);
            }
          }
        }
        return validated;
      }
      function pushLogFlags(flags, options, keys4, isTTY2, logLevelDefault) {
        let color = getFlag(options, keys4, "color", mustBeBoolean);
        let logLevel = getFlag(options, keys4, "logLevel", mustBeString);
        let logLimit = getFlag(options, keys4, "logLimit", mustBeInteger);
        if (color !== void 0)
          flags.push(`--color=${color}`);
        else if (isTTY2)
          flags.push(`--color=true`);
        flags.push(`--log-level=${logLevel || logLevelDefault}`);
        flags.push(`--log-limit=${logLimit || 0}`);
      }
      function validateStringValue(value, what, key) {
        if (typeof value !== "string") {
          throw new Error(`Expected value for ${what}${key !== void 0 ? " " + quote(key) : ""} to be a string, got ${typeof value} instead`);
        }
        return value;
      }
      function pushCommonFlags(flags, options, keys4) {
        let legalComments = getFlag(options, keys4, "legalComments", mustBeString);
        let sourceRoot = getFlag(options, keys4, "sourceRoot", mustBeString);
        let sourcesContent = getFlag(options, keys4, "sourcesContent", mustBeBoolean);
        let target = getFlag(options, keys4, "target", mustBeStringOrArray);
        let format = getFlag(options, keys4, "format", mustBeString);
        let globalName = getFlag(options, keys4, "globalName", mustBeString);
        let mangleProps = getFlag(options, keys4, "mangleProps", mustBeRegExp);
        let reserveProps = getFlag(options, keys4, "reserveProps", mustBeRegExp);
        let mangleQuoted = getFlag(options, keys4, "mangleQuoted", mustBeBoolean);
        let minify = getFlag(options, keys4, "minify", mustBeBoolean);
        let minifySyntax = getFlag(options, keys4, "minifySyntax", mustBeBoolean);
        let minifyWhitespace = getFlag(options, keys4, "minifyWhitespace", mustBeBoolean);
        let minifyIdentifiers = getFlag(options, keys4, "minifyIdentifiers", mustBeBoolean);
        let lineLimit = getFlag(options, keys4, "lineLimit", mustBeInteger);
        let drop = getFlag(options, keys4, "drop", mustBeArray);
        let dropLabels = getFlag(options, keys4, "dropLabels", mustBeArray);
        let charset = getFlag(options, keys4, "charset", mustBeString);
        let treeShaking = getFlag(options, keys4, "treeShaking", mustBeBoolean);
        let ignoreAnnotations = getFlag(options, keys4, "ignoreAnnotations", mustBeBoolean);
        let jsx = getFlag(options, keys4, "jsx", mustBeString);
        let jsxFactory = getFlag(options, keys4, "jsxFactory", mustBeString);
        let jsxFragment = getFlag(options, keys4, "jsxFragment", mustBeString);
        let jsxImportSource = getFlag(options, keys4, "jsxImportSource", mustBeString);
        let jsxDev = getFlag(options, keys4, "jsxDev", mustBeBoolean);
        let jsxSideEffects = getFlag(options, keys4, "jsxSideEffects", mustBeBoolean);
        let define2 = getFlag(options, keys4, "define", mustBeObject);
        let logOverride = getFlag(options, keys4, "logOverride", mustBeObject);
        let supported = getFlag(options, keys4, "supported", mustBeObject);
        let pure = getFlag(options, keys4, "pure", mustBeArray);
        let keepNames = getFlag(options, keys4, "keepNames", mustBeBoolean);
        let platform = getFlag(options, keys4, "platform", mustBeString);
        let tsconfigRaw = getFlag(options, keys4, "tsconfigRaw", mustBeStringOrObject);
        if (legalComments)
          flags.push(`--legal-comments=${legalComments}`);
        if (sourceRoot !== void 0)
          flags.push(`--source-root=${sourceRoot}`);
        if (sourcesContent !== void 0)
          flags.push(`--sources-content=${sourcesContent}`);
        if (target) {
          if (Array.isArray(target))
            flags.push(`--target=${Array.from(target).map(validateTarget).join(",")}`);
          else
            flags.push(`--target=${validateTarget(target)}`);
        }
        if (format)
          flags.push(`--format=${format}`);
        if (globalName)
          flags.push(`--global-name=${globalName}`);
        if (platform)
          flags.push(`--platform=${platform}`);
        if (tsconfigRaw)
          flags.push(`--tsconfig-raw=${typeof tsconfigRaw === "string" ? tsconfigRaw : JSON.stringify(tsconfigRaw)}`);
        if (minify)
          flags.push("--minify");
        if (minifySyntax)
          flags.push("--minify-syntax");
        if (minifyWhitespace)
          flags.push("--minify-whitespace");
        if (minifyIdentifiers)
          flags.push("--minify-identifiers");
        if (lineLimit)
          flags.push(`--line-limit=${lineLimit}`);
        if (charset)
          flags.push(`--charset=${charset}`);
        if (treeShaking !== void 0)
          flags.push(`--tree-shaking=${treeShaking}`);
        if (ignoreAnnotations)
          flags.push(`--ignore-annotations`);
        if (drop)
          for (let what of drop)
            flags.push(`--drop:${validateStringValue(what, "drop")}`);
        if (dropLabels)
          flags.push(`--drop-labels=${Array.from(dropLabels).map((what) => validateStringValue(what, "dropLabels")).join(",")}`);
        if (mangleProps)
          flags.push(`--mangle-props=${mangleProps.source}`);
        if (reserveProps)
          flags.push(`--reserve-props=${reserveProps.source}`);
        if (mangleQuoted !== void 0)
          flags.push(`--mangle-quoted=${mangleQuoted}`);
        if (jsx)
          flags.push(`--jsx=${jsx}`);
        if (jsxFactory)
          flags.push(`--jsx-factory=${jsxFactory}`);
        if (jsxFragment)
          flags.push(`--jsx-fragment=${jsxFragment}`);
        if (jsxImportSource)
          flags.push(`--jsx-import-source=${jsxImportSource}`);
        if (jsxDev)
          flags.push(`--jsx-dev`);
        if (jsxSideEffects)
          flags.push(`--jsx-side-effects`);
        if (define2) {
          for (let key in define2) {
            if (key.indexOf("=") >= 0)
              throw new Error(`Invalid define: ${key}`);
            flags.push(`--define:${key}=${validateStringValue(define2[key], "define", key)}`);
          }
        }
        if (logOverride) {
          for (let key in logOverride) {
            if (key.indexOf("=") >= 0)
              throw new Error(`Invalid log override: ${key}`);
            flags.push(`--log-override:${key}=${validateStringValue(logOverride[key], "log override", key)}`);
          }
        }
        if (supported) {
          for (let key in supported) {
            if (key.indexOf("=") >= 0)
              throw new Error(`Invalid supported: ${key}`);
            const value = supported[key];
            if (typeof value !== "boolean")
              throw new Error(`Expected value for supported ${quote(key)} to be a boolean, got ${typeof value} instead`);
            flags.push(`--supported:${key}=${value}`);
          }
        }
        if (pure)
          for (let fn of pure)
            flags.push(`--pure:${validateStringValue(fn, "pure")}`);
        if (keepNames)
          flags.push(`--keep-names`);
      }
      function flagsForBuildOptions(callName, options, isTTY2, logLevelDefault, writeDefault) {
        var _a2;
        let flags = [];
        let entries = [];
        let keys4 = /* @__PURE__ */ Object.create(null);
        let stdinContents = null;
        let stdinResolveDir = null;
        pushLogFlags(flags, options, keys4, isTTY2, logLevelDefault);
        pushCommonFlags(flags, options, keys4);
        let sourcemap = getFlag(options, keys4, "sourcemap", mustBeStringOrBoolean);
        let bundle = getFlag(options, keys4, "bundle", mustBeBoolean);
        let splitting = getFlag(options, keys4, "splitting", mustBeBoolean);
        let preserveSymlinks = getFlag(options, keys4, "preserveSymlinks", mustBeBoolean);
        let metafile = getFlag(options, keys4, "metafile", mustBeBoolean);
        let outfile = getFlag(options, keys4, "outfile", mustBeString);
        let outdir = getFlag(options, keys4, "outdir", mustBeString);
        let outbase = getFlag(options, keys4, "outbase", mustBeString);
        let tsconfig = getFlag(options, keys4, "tsconfig", mustBeString);
        let resolveExtensions = getFlag(options, keys4, "resolveExtensions", mustBeArray);
        let nodePathsInput = getFlag(options, keys4, "nodePaths", mustBeArray);
        let mainFields = getFlag(options, keys4, "mainFields", mustBeArray);
        let conditions = getFlag(options, keys4, "conditions", mustBeArray);
        let external = getFlag(options, keys4, "external", mustBeArray);
        let packages = getFlag(options, keys4, "packages", mustBeString);
        let alias = getFlag(options, keys4, "alias", mustBeObject);
        let loader = getFlag(options, keys4, "loader", mustBeObject);
        let outExtension = getFlag(options, keys4, "outExtension", mustBeObject);
        let publicPath = getFlag(options, keys4, "publicPath", mustBeString);
        let entryNames = getFlag(options, keys4, "entryNames", mustBeString);
        let chunkNames = getFlag(options, keys4, "chunkNames", mustBeString);
        let assetNames = getFlag(options, keys4, "assetNames", mustBeString);
        let inject = getFlag(options, keys4, "inject", mustBeArray);
        let banner = getFlag(options, keys4, "banner", mustBeObject);
        let footer = getFlag(options, keys4, "footer", mustBeObject);
        let entryPoints = getFlag(options, keys4, "entryPoints", mustBeEntryPoints);
        let absWorkingDir = getFlag(options, keys4, "absWorkingDir", mustBeString);
        let stdin = getFlag(options, keys4, "stdin", mustBeObject);
        let write = (_a2 = getFlag(options, keys4, "write", mustBeBoolean)) != null ? _a2 : writeDefault;
        let allowOverwrite = getFlag(options, keys4, "allowOverwrite", mustBeBoolean);
        let mangleCache = getFlag(options, keys4, "mangleCache", mustBeObject);
        keys4.plugins = true;
        checkForInvalidFlags(options, keys4, `in ${callName}() call`);
        if (sourcemap)
          flags.push(`--sourcemap${sourcemap === true ? "" : `=${sourcemap}`}`);
        if (bundle)
          flags.push("--bundle");
        if (allowOverwrite)
          flags.push("--allow-overwrite");
        if (splitting)
          flags.push("--splitting");
        if (preserveSymlinks)
          flags.push("--preserve-symlinks");
        if (metafile)
          flags.push(`--metafile`);
        if (outfile)
          flags.push(`--outfile=${outfile}`);
        if (outdir)
          flags.push(`--outdir=${outdir}`);
        if (outbase)
          flags.push(`--outbase=${outbase}`);
        if (tsconfig)
          flags.push(`--tsconfig=${tsconfig}`);
        if (packages)
          flags.push(`--packages=${packages}`);
        if (resolveExtensions) {
          let values = [];
          for (let value of resolveExtensions) {
            validateStringValue(value, "resolve extension");
            if (value.indexOf(",") >= 0)
              throw new Error(`Invalid resolve extension: ${value}`);
            values.push(value);
          }
          flags.push(`--resolve-extensions=${values.join(",")}`);
        }
        if (publicPath)
          flags.push(`--public-path=${publicPath}`);
        if (entryNames)
          flags.push(`--entry-names=${entryNames}`);
        if (chunkNames)
          flags.push(`--chunk-names=${chunkNames}`);
        if (assetNames)
          flags.push(`--asset-names=${assetNames}`);
        if (mainFields) {
          let values = [];
          for (let value of mainFields) {
            validateStringValue(value, "main field");
            if (value.indexOf(",") >= 0)
              throw new Error(`Invalid main field: ${value}`);
            values.push(value);
          }
          flags.push(`--main-fields=${values.join(",")}`);
        }
        if (conditions) {
          let values = [];
          for (let value of conditions) {
            validateStringValue(value, "condition");
            if (value.indexOf(",") >= 0)
              throw new Error(`Invalid condition: ${value}`);
            values.push(value);
          }
          flags.push(`--conditions=${values.join(",")}`);
        }
        if (external)
          for (let name of external)
            flags.push(`--external:${validateStringValue(name, "external")}`);
        if (alias) {
          for (let old in alias) {
            if (old.indexOf("=") >= 0)
              throw new Error(`Invalid package name in alias: ${old}`);
            flags.push(`--alias:${old}=${validateStringValue(alias[old], "alias", old)}`);
          }
        }
        if (banner) {
          for (let type3 in banner) {
            if (type3.indexOf("=") >= 0)
              throw new Error(`Invalid banner file type: ${type3}`);
            flags.push(`--banner:${type3}=${validateStringValue(banner[type3], "banner", type3)}`);
          }
        }
        if (footer) {
          for (let type3 in footer) {
            if (type3.indexOf("=") >= 0)
              throw new Error(`Invalid footer file type: ${type3}`);
            flags.push(`--footer:${type3}=${validateStringValue(footer[type3], "footer", type3)}`);
          }
        }
        if (inject)
          for (let path32 of inject)
            flags.push(`--inject:${validateStringValue(path32, "inject")}`);
        if (loader) {
          for (let ext2 in loader) {
            if (ext2.indexOf("=") >= 0)
              throw new Error(`Invalid loader extension: ${ext2}`);
            flags.push(`--loader:${ext2}=${validateStringValue(loader[ext2], "loader", ext2)}`);
          }
        }
        if (outExtension) {
          for (let ext2 in outExtension) {
            if (ext2.indexOf("=") >= 0)
              throw new Error(`Invalid out extension: ${ext2}`);
            flags.push(`--out-extension:${ext2}=${validateStringValue(outExtension[ext2], "out extension", ext2)}`);
          }
        }
        if (entryPoints) {
          if (Array.isArray(entryPoints)) {
            for (let i = 0, n = entryPoints.length; i < n; i++) {
              let entryPoint = entryPoints[i];
              if (typeof entryPoint === "object" && entryPoint !== null) {
                let entryPointKeys = /* @__PURE__ */ Object.create(null);
                let input = getFlag(entryPoint, entryPointKeys, "in", mustBeString);
                let output3 = getFlag(entryPoint, entryPointKeys, "out", mustBeString);
                checkForInvalidFlags(entryPoint, entryPointKeys, "in entry point at index " + i);
                if (input === void 0)
                  throw new Error('Missing property "in" for entry point at index ' + i);
                if (output3 === void 0)
                  throw new Error('Missing property "out" for entry point at index ' + i);
                entries.push([output3, input]);
              } else {
                entries.push(["", validateStringValue(entryPoint, "entry point at index " + i)]);
              }
            }
          } else {
            for (let key in entryPoints) {
              entries.push([key, validateStringValue(entryPoints[key], "entry point", key)]);
            }
          }
        }
        if (stdin) {
          let stdinKeys = /* @__PURE__ */ Object.create(null);
          let contents = getFlag(stdin, stdinKeys, "contents", mustBeStringOrUint8Array);
          let resolveDir = getFlag(stdin, stdinKeys, "resolveDir", mustBeString);
          let sourcefile = getFlag(stdin, stdinKeys, "sourcefile", mustBeString);
          let loader2 = getFlag(stdin, stdinKeys, "loader", mustBeString);
          checkForInvalidFlags(stdin, stdinKeys, 'in "stdin" object');
          if (sourcefile)
            flags.push(`--sourcefile=${sourcefile}`);
          if (loader2)
            flags.push(`--loader=${loader2}`);
          if (resolveDir)
            stdinResolveDir = resolveDir;
          if (typeof contents === "string")
            stdinContents = encodeUTF8(contents);
          else if (contents instanceof Uint8Array)
            stdinContents = contents;
        }
        let nodePaths = [];
        if (nodePathsInput) {
          for (let value of nodePathsInput) {
            value += "";
            nodePaths.push(value);
          }
        }
        return {
          entries,
          flags,
          write,
          stdinContents,
          stdinResolveDir,
          absWorkingDir,
          nodePaths,
          mangleCache: validateMangleCache(mangleCache)
        };
      }
      function flagsForTransformOptions(callName, options, isTTY2, logLevelDefault) {
        let flags = [];
        let keys4 = /* @__PURE__ */ Object.create(null);
        pushLogFlags(flags, options, keys4, isTTY2, logLevelDefault);
        pushCommonFlags(flags, options, keys4);
        let sourcemap = getFlag(options, keys4, "sourcemap", mustBeStringOrBoolean);
        let sourcefile = getFlag(options, keys4, "sourcefile", mustBeString);
        let loader = getFlag(options, keys4, "loader", mustBeString);
        let banner = getFlag(options, keys4, "banner", mustBeString);
        let footer = getFlag(options, keys4, "footer", mustBeString);
        let mangleCache = getFlag(options, keys4, "mangleCache", mustBeObject);
        checkForInvalidFlags(options, keys4, `in ${callName}() call`);
        if (sourcemap)
          flags.push(`--sourcemap=${sourcemap === true ? "external" : sourcemap}`);
        if (sourcefile)
          flags.push(`--sourcefile=${sourcefile}`);
        if (loader)
          flags.push(`--loader=${loader}`);
        if (banner)
          flags.push(`--banner=${banner}`);
        if (footer)
          flags.push(`--footer=${footer}`);
        return {
          flags,
          mangleCache: validateMangleCache(mangleCache)
        };
      }
      function createChannel(streamIn) {
        const requestCallbacksByKey = {};
        const closeData = { didClose: false, reason: "" };
        let responseCallbacks = {};
        let nextRequestID = 0;
        let nextBuildKey = 0;
        let stdout = new Uint8Array(16 * 1024);
        let stdoutUsed = 0;
        let readFromStdout = (chunk) => {
          let limit = stdoutUsed + chunk.length;
          if (limit > stdout.length) {
            let swap = new Uint8Array(limit * 2);
            swap.set(stdout);
            stdout = swap;
          }
          stdout.set(chunk, stdoutUsed);
          stdoutUsed += chunk.length;
          let offset = 0;
          while (offset + 4 <= stdoutUsed) {
            let length = readUInt32LE(stdout, offset);
            if (offset + 4 + length > stdoutUsed) {
              break;
            }
            offset += 4;
            handleIncomingPacket(stdout.subarray(offset, offset + length));
            offset += length;
          }
          if (offset > 0) {
            stdout.copyWithin(0, offset, stdoutUsed);
            stdoutUsed -= offset;
          }
        };
        let afterClose = (error2) => {
          closeData.didClose = true;
          if (error2)
            closeData.reason = ": " + (error2.message || error2);
          const text = "The service was stopped" + closeData.reason;
          for (let id in responseCallbacks) {
            responseCallbacks[id](text, null);
          }
          responseCallbacks = {};
        };
        let sendRequest = (refs, value, callback) => {
          if (closeData.didClose)
            return callback("The service is no longer running" + closeData.reason, null);
          let id = nextRequestID++;
          responseCallbacks[id] = (error2, response) => {
            try {
              callback(error2, response);
            } finally {
              if (refs)
                refs.unref();
            }
          };
          if (refs)
            refs.ref();
          streamIn.writeToStdin(encodePacket({ id, isRequest: true, value }));
        };
        let sendResponse = (id, value) => {
          if (closeData.didClose)
            throw new Error("The service is no longer running" + closeData.reason);
          streamIn.writeToStdin(encodePacket({ id, isRequest: false, value }));
        };
        let handleRequest = async (id, request) => {
          try {
            if (request.command === "ping") {
              sendResponse(id, {});
              return;
            }
            if (typeof request.key === "number") {
              const requestCallbacks = requestCallbacksByKey[request.key];
              if (!requestCallbacks) {
                return;
              }
              const callback = requestCallbacks[request.command];
              if (callback) {
                await callback(id, request);
                return;
              }
            }
            throw new Error(`Invalid command: ` + request.command);
          } catch (e) {
            const errors = [extractErrorMessageV8(e, streamIn, null, void 0, "")];
            try {
              sendResponse(id, { errors });
            } catch {
            }
          }
        };
        let isFirstPacket = true;
        let handleIncomingPacket = (bytes3) => {
          if (isFirstPacket) {
            isFirstPacket = false;
            let binaryVersion = String.fromCharCode(...bytes3);
            if (binaryVersion !== "0.19.3") {
              throw new Error(`Cannot start service: Host version "${"0.19.3"}" does not match binary version ${quote(binaryVersion)}`);
            }
            return;
          }
          let packet = decodePacket(bytes3);
          if (packet.isRequest) {
            handleRequest(packet.id, packet.value);
          } else {
            let callback = responseCallbacks[packet.id];
            delete responseCallbacks[packet.id];
            if (packet.value.error)
              callback(packet.value.error, {});
            else
              callback(null, packet.value);
          }
        };
        let buildOrContext = ({ callName, refs, options, isTTY: isTTY2, defaultWD: defaultWD2, callback }) => {
          let refCount = 0;
          const buildKey = nextBuildKey++;
          const requestCallbacks = {};
          const buildRefs = {
            ref() {
              if (++refCount === 1) {
                if (refs)
                  refs.ref();
              }
            },
            unref() {
              if (--refCount === 0) {
                delete requestCallbacksByKey[buildKey];
                if (refs)
                  refs.unref();
              }
            }
          };
          requestCallbacksByKey[buildKey] = requestCallbacks;
          buildRefs.ref();
          buildOrContextImpl(
            callName,
            buildKey,
            sendRequest,
            sendResponse,
            buildRefs,
            streamIn,
            requestCallbacks,
            options,
            isTTY2,
            defaultWD2,
            (err, res) => {
              try {
                callback(err, res);
              } finally {
                buildRefs.unref();
              }
            }
          );
        };
        let transform2 = ({ callName, refs, input, options, isTTY: isTTY2, fs: fs32, callback }) => {
          const details = createObjectStash();
          let start = (inputPath) => {
            try {
              if (typeof input !== "string" && !(input instanceof Uint8Array))
                throw new Error('The input to "transform" must be a string or a Uint8Array');
              let {
                flags,
                mangleCache
              } = flagsForTransformOptions(callName, options, isTTY2, transformLogLevelDefault);
              let request = {
                command: "transform",
                flags,
                inputFS: inputPath !== null,
                input: inputPath !== null ? encodeUTF8(inputPath) : typeof input === "string" ? encodeUTF8(input) : input
              };
              if (mangleCache)
                request.mangleCache = mangleCache;
              sendRequest(refs, request, (error2, response) => {
                if (error2)
                  return callback(new Error(error2), null);
                let errors = replaceDetailsInMessages(response.errors, details);
                let warnings = replaceDetailsInMessages(response.warnings, details);
                let outstanding = 1;
                let next = () => {
                  if (--outstanding === 0) {
                    let result = {
                      warnings,
                      code: response.code,
                      map: response.map,
                      mangleCache: void 0,
                      legalComments: void 0
                    };
                    if ("legalComments" in response)
                      result.legalComments = response == null ? void 0 : response.legalComments;
                    if (response.mangleCache)
                      result.mangleCache = response == null ? void 0 : response.mangleCache;
                    callback(null, result);
                  }
                };
                if (errors.length > 0)
                  return callback(failureErrorWithLog("Transform failed", errors, warnings), null);
                if (response.codeFS) {
                  outstanding++;
                  fs32.readFile(response.code, (err, contents) => {
                    if (err !== null) {
                      callback(err, null);
                    } else {
                      response.code = contents;
                      next();
                    }
                  });
                }
                if (response.mapFS) {
                  outstanding++;
                  fs32.readFile(response.map, (err, contents) => {
                    if (err !== null) {
                      callback(err, null);
                    } else {
                      response.map = contents;
                      next();
                    }
                  });
                }
                next();
              });
            } catch (e) {
              let flags = [];
              try {
                pushLogFlags(flags, options, {}, isTTY2, transformLogLevelDefault);
              } catch {
              }
              const error2 = extractErrorMessageV8(e, streamIn, details, void 0, "");
              sendRequest(refs, { command: "error", flags, error: error2 }, () => {
                error2.detail = details.load(error2.detail);
                callback(failureErrorWithLog("Transform failed", [error2], []), null);
              });
            }
          };
          if ((typeof input === "string" || input instanceof Uint8Array) && input.length > 1024 * 1024) {
            let next = start;
            start = () => fs32.writeFile(input, next);
          }
          start(null);
        };
        let formatMessages2 = ({ callName, refs, messages, options, callback }) => {
          let result = sanitizeMessages(messages, "messages", null, "");
          if (!options)
            throw new Error(`Missing second argument in ${callName}() call`);
          let keys4 = {};
          let kind = getFlag(options, keys4, "kind", mustBeString);
          let color = getFlag(options, keys4, "color", mustBeBoolean);
          let terminalWidth = getFlag(options, keys4, "terminalWidth", mustBeInteger);
          checkForInvalidFlags(options, keys4, `in ${callName}() call`);
          if (kind === void 0)
            throw new Error(`Missing "kind" in ${callName}() call`);
          if (kind !== "error" && kind !== "warning")
            throw new Error(`Expected "kind" to be "error" or "warning" in ${callName}() call`);
          let request = {
            command: "format-msgs",
            messages: result,
            isWarning: kind === "warning"
          };
          if (color !== void 0)
            request.color = color;
          if (terminalWidth !== void 0)
            request.terminalWidth = terminalWidth;
          sendRequest(refs, request, (error2, response) => {
            if (error2)
              return callback(new Error(error2), null);
            callback(null, response.messages);
          });
        };
        let analyzeMetafile2 = ({ callName, refs, metafile, options, callback }) => {
          if (options === void 0)
            options = {};
          let keys4 = {};
          let color = getFlag(options, keys4, "color", mustBeBoolean);
          let verbose = getFlag(options, keys4, "verbose", mustBeBoolean);
          checkForInvalidFlags(options, keys4, `in ${callName}() call`);
          let request = {
            command: "analyze-metafile",
            metafile
          };
          if (color !== void 0)
            request.color = color;
          if (verbose !== void 0)
            request.verbose = verbose;
          sendRequest(refs, request, (error2, response) => {
            if (error2)
              return callback(new Error(error2), null);
            callback(null, response.result);
          });
        };
        return {
          readFromStdout,
          afterClose,
          service: {
            buildOrContext,
            transform: transform2,
            formatMessages: formatMessages2,
            analyzeMetafile: analyzeMetafile2
          }
        };
      }
      function buildOrContextImpl(callName, buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, options, isTTY2, defaultWD2, callback) {
        const details = createObjectStash();
        const isContext = callName === "context";
        const handleError = (e, pluginName) => {
          const flags = [];
          try {
            pushLogFlags(flags, options, {}, isTTY2, buildLogLevelDefault);
          } catch {
          }
          const message = extractErrorMessageV8(e, streamIn, details, void 0, pluginName);
          sendRequest(refs, { command: "error", flags, error: message }, () => {
            message.detail = details.load(message.detail);
            callback(failureErrorWithLog(isContext ? "Context failed" : "Build failed", [message], []), null);
          });
        };
        let plugins;
        if (typeof options === "object") {
          const value = options.plugins;
          if (value !== void 0) {
            if (!Array.isArray(value))
              return handleError(new Error(`"plugins" must be an array`), "");
            plugins = value;
          }
        }
        if (plugins && plugins.length > 0) {
          if (streamIn.isSync)
            return handleError(new Error("Cannot use plugins in synchronous API calls"), "");
          handlePlugins(
            buildKey,
            sendRequest,
            sendResponse,
            refs,
            streamIn,
            requestCallbacks,
            options,
            plugins,
            details
          ).then(
            (result) => {
              if (!result.ok)
                return handleError(result.error, result.pluginName);
              try {
                buildOrContextContinue(result.requestPlugins, result.runOnEndCallbacks, result.scheduleOnDisposeCallbacks);
              } catch (e) {
                handleError(e, "");
              }
            },
            (e) => handleError(e, "")
          );
          return;
        }
        try {
          buildOrContextContinue(null, (result, done) => done([], []), () => {
          });
        } catch (e) {
          handleError(e, "");
        }
        function buildOrContextContinue(requestPlugins, runOnEndCallbacks, scheduleOnDisposeCallbacks) {
          const writeDefault = streamIn.hasFS;
          const {
            entries,
            flags,
            write,
            stdinContents,
            stdinResolveDir,
            absWorkingDir,
            nodePaths,
            mangleCache
          } = flagsForBuildOptions(callName, options, isTTY2, buildLogLevelDefault, writeDefault);
          if (write && !streamIn.hasFS)
            throw new Error(`The "write" option is unavailable in this environment`);
          const request = {
            command: "build",
            key: buildKey,
            entries,
            flags,
            write,
            stdinContents,
            stdinResolveDir,
            absWorkingDir: absWorkingDir || defaultWD2,
            nodePaths,
            context: isContext
          };
          if (requestPlugins)
            request.plugins = requestPlugins;
          if (mangleCache)
            request.mangleCache = mangleCache;
          const buildResponseToResult = (response, callback2) => {
            const result = {
              errors: replaceDetailsInMessages(response.errors, details),
              warnings: replaceDetailsInMessages(response.warnings, details),
              outputFiles: void 0,
              metafile: void 0,
              mangleCache: void 0
            };
            const originalErrors = result.errors.slice();
            const originalWarnings = result.warnings.slice();
            if (response.outputFiles)
              result.outputFiles = response.outputFiles.map(convertOutputFiles);
            if (response.metafile)
              result.metafile = JSON.parse(response.metafile);
            if (response.mangleCache)
              result.mangleCache = response.mangleCache;
            if (response.writeToStdout !== void 0)
              console.log(decodeUTF8(response.writeToStdout).replace(/\n$/, ""));
            runOnEndCallbacks(result, (onEndErrors, onEndWarnings) => {
              if (originalErrors.length > 0 || onEndErrors.length > 0) {
                const error2 = failureErrorWithLog("Build failed", originalErrors.concat(onEndErrors), originalWarnings.concat(onEndWarnings));
                return callback2(error2, null, onEndErrors, onEndWarnings);
              }
              callback2(null, result, onEndErrors, onEndWarnings);
            });
          };
          let latestResultPromise;
          let provideLatestResult;
          if (isContext)
            requestCallbacks["on-end"] = (id, request2) => new Promise((resolve4) => {
              buildResponseToResult(request2, (err, result, onEndErrors, onEndWarnings) => {
                const response = {
                  errors: onEndErrors,
                  warnings: onEndWarnings
                };
                if (provideLatestResult)
                  provideLatestResult(err, result);
                latestResultPromise = void 0;
                provideLatestResult = void 0;
                sendResponse(id, response);
                resolve4();
              });
            });
          sendRequest(refs, request, (error2, response) => {
            if (error2)
              return callback(new Error(error2), null);
            if (!isContext) {
              return buildResponseToResult(response, (err, res) => {
                scheduleOnDisposeCallbacks();
                return callback(err, res);
              });
            }
            if (response.errors.length > 0) {
              return callback(failureErrorWithLog("Context failed", response.errors, response.warnings), null);
            }
            let didDispose = false;
            const result = {
              rebuild: () => {
                if (!latestResultPromise)
                  latestResultPromise = new Promise((resolve4, reject) => {
                    let settlePromise;
                    provideLatestResult = (err, result2) => {
                      if (!settlePromise)
                        settlePromise = () => err ? reject(err) : resolve4(result2);
                    };
                    const triggerAnotherBuild = () => {
                      const request2 = {
                        command: "rebuild",
                        key: buildKey
                      };
                      sendRequest(refs, request2, (error22, response2) => {
                        if (error22) {
                          reject(new Error(error22));
                        } else if (settlePromise) {
                          settlePromise();
                        } else {
                          triggerAnotherBuild();
                        }
                      });
                    };
                    triggerAnotherBuild();
                  });
                return latestResultPromise;
              },
              watch: (options2 = {}) => new Promise((resolve4, reject) => {
                if (!streamIn.hasFS)
                  throw new Error(`Cannot use the "watch" API in this environment`);
                const keys4 = {};
                checkForInvalidFlags(options2, keys4, `in watch() call`);
                const request2 = {
                  command: "watch",
                  key: buildKey
                };
                sendRequest(refs, request2, (error22) => {
                  if (error22)
                    reject(new Error(error22));
                  else
                    resolve4(void 0);
                });
              }),
              serve: (options2 = {}) => new Promise((resolve4, reject) => {
                if (!streamIn.hasFS)
                  throw new Error(`Cannot use the "serve" API in this environment`);
                const keys4 = {};
                const port = getFlag(options2, keys4, "port", mustBeInteger);
                const host = getFlag(options2, keys4, "host", mustBeString);
                const servedir = getFlag(options2, keys4, "servedir", mustBeString);
                const keyfile = getFlag(options2, keys4, "keyfile", mustBeString);
                const certfile = getFlag(options2, keys4, "certfile", mustBeString);
                const fallback = getFlag(options2, keys4, "fallback", mustBeString);
                const onRequest = getFlag(options2, keys4, "onRequest", mustBeFunction);
                checkForInvalidFlags(options2, keys4, `in serve() call`);
                const request2 = {
                  command: "serve",
                  key: buildKey,
                  onRequest: !!onRequest
                };
                if (port !== void 0)
                  request2.port = port;
                if (host !== void 0)
                  request2.host = host;
                if (servedir !== void 0)
                  request2.servedir = servedir;
                if (keyfile !== void 0)
                  request2.keyfile = keyfile;
                if (certfile !== void 0)
                  request2.certfile = certfile;
                if (fallback !== void 0)
                  request2.fallback = fallback;
                sendRequest(refs, request2, (error22, response2) => {
                  if (error22)
                    return reject(new Error(error22));
                  if (onRequest) {
                    requestCallbacks["serve-request"] = (id, request3) => {
                      onRequest(request3.args);
                      sendResponse(id, {});
                    };
                  }
                  resolve4(response2);
                });
              }),
              cancel: () => new Promise((resolve4) => {
                if (didDispose)
                  return resolve4();
                const request2 = {
                  command: "cancel",
                  key: buildKey
                };
                sendRequest(refs, request2, () => {
                  resolve4();
                });
              }),
              dispose: () => new Promise((resolve4) => {
                if (didDispose)
                  return resolve4();
                didDispose = true;
                const request2 = {
                  command: "dispose",
                  key: buildKey
                };
                sendRequest(refs, request2, () => {
                  resolve4();
                  scheduleOnDisposeCallbacks();
                  refs.unref();
                });
              })
            };
            refs.ref();
            callback(null, result);
          });
        }
      }
      var handlePlugins = async (buildKey, sendRequest, sendResponse, refs, streamIn, requestCallbacks, initialOptions, plugins, details) => {
        let onStartCallbacks = [];
        let onEndCallbacks = [];
        let onResolveCallbacks = {};
        let onLoadCallbacks = {};
        let onDisposeCallbacks = [];
        let nextCallbackID = 0;
        let i = 0;
        let requestPlugins = [];
        let isSetupDone = false;
        plugins = [...plugins];
        for (let item of plugins) {
          let keys4 = {};
          if (typeof item !== "object")
            throw new Error(`Plugin at index ${i} must be an object`);
          const name = getFlag(item, keys4, "name", mustBeString);
          if (typeof name !== "string" || name === "")
            throw new Error(`Plugin at index ${i} is missing a name`);
          try {
            let setup = getFlag(item, keys4, "setup", mustBeFunction);
            if (typeof setup !== "function")
              throw new Error(`Plugin is missing a setup function`);
            checkForInvalidFlags(item, keys4, `on plugin ${quote(name)}`);
            let plugin = {
              name,
              onStart: false,
              onEnd: false,
              onResolve: [],
              onLoad: []
            };
            i++;
            let resolve4 = (path32, options = {}) => {
              if (!isSetupDone)
                throw new Error('Cannot call "resolve" before plugin setup has completed');
              if (typeof path32 !== "string")
                throw new Error(`The path to resolve must be a string`);
              let keys22 = /* @__PURE__ */ Object.create(null);
              let pluginName = getFlag(options, keys22, "pluginName", mustBeString);
              let importer = getFlag(options, keys22, "importer", mustBeString);
              let namespace = getFlag(options, keys22, "namespace", mustBeString);
              let resolveDir = getFlag(options, keys22, "resolveDir", mustBeString);
              let kind = getFlag(options, keys22, "kind", mustBeString);
              let pluginData = getFlag(options, keys22, "pluginData", canBeAnything);
              checkForInvalidFlags(options, keys22, "in resolve() call");
              return new Promise((resolve22, reject) => {
                const request = {
                  command: "resolve",
                  path: path32,
                  key: buildKey,
                  pluginName: name
                };
                if (pluginName != null)
                  request.pluginName = pluginName;
                if (importer != null)
                  request.importer = importer;
                if (namespace != null)
                  request.namespace = namespace;
                if (resolveDir != null)
                  request.resolveDir = resolveDir;
                if (kind != null)
                  request.kind = kind;
                else
                  throw new Error(`Must specify "kind" when calling "resolve"`);
                if (pluginData != null)
                  request.pluginData = details.store(pluginData);
                sendRequest(refs, request, (error2, response) => {
                  if (error2 !== null)
                    reject(new Error(error2));
                  else
                    resolve22({
                      errors: replaceDetailsInMessages(response.errors, details),
                      warnings: replaceDetailsInMessages(response.warnings, details),
                      path: response.path,
                      external: response.external,
                      sideEffects: response.sideEffects,
                      namespace: response.namespace,
                      suffix: response.suffix,
                      pluginData: details.load(response.pluginData)
                    });
                });
              });
            };
            let promise = setup({
              initialOptions,
              resolve: resolve4,
              onStart(callback) {
                let registeredText = `This error came from the "onStart" callback registered here:`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onStart");
                onStartCallbacks.push({ name, callback, note: registeredNote });
                plugin.onStart = true;
              },
              onEnd(callback) {
                let registeredText = `This error came from the "onEnd" callback registered here:`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onEnd");
                onEndCallbacks.push({ name, callback, note: registeredNote });
                plugin.onEnd = true;
              },
              onResolve(options, callback) {
                let registeredText = `This error came from the "onResolve" callback registered here:`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onResolve");
                let keys22 = {};
                let filter2 = getFlag(options, keys22, "filter", mustBeRegExp);
                let namespace = getFlag(options, keys22, "namespace", mustBeString);
                checkForInvalidFlags(options, keys22, `in onResolve() call for plugin ${quote(name)}`);
                if (filter2 == null)
                  throw new Error(`onResolve() call is missing a filter`);
                let id = nextCallbackID++;
                onResolveCallbacks[id] = { name, callback, note: registeredNote };
                plugin.onResolve.push({ id, filter: filter2.source, namespace: namespace || "" });
              },
              onLoad(options, callback) {
                let registeredText = `This error came from the "onLoad" callback registered here:`;
                let registeredNote = extractCallerV8(new Error(registeredText), streamIn, "onLoad");
                let keys22 = {};
                let filter2 = getFlag(options, keys22, "filter", mustBeRegExp);
                let namespace = getFlag(options, keys22, "namespace", mustBeString);
                checkForInvalidFlags(options, keys22, `in onLoad() call for plugin ${quote(name)}`);
                if (filter2 == null)
                  throw new Error(`onLoad() call is missing a filter`);
                let id = nextCallbackID++;
                onLoadCallbacks[id] = { name, callback, note: registeredNote };
                plugin.onLoad.push({ id, filter: filter2.source, namespace: namespace || "" });
              },
              onDispose(callback) {
                onDisposeCallbacks.push(callback);
              },
              esbuild: streamIn.esbuild
            });
            if (promise)
              await promise;
            requestPlugins.push(plugin);
          } catch (e) {
            return { ok: false, error: e, pluginName: name };
          }
        }
        requestCallbacks["on-start"] = async (id, request) => {
          let response = { errors: [], warnings: [] };
          await Promise.all(onStartCallbacks.map(async ({ name, callback, note }) => {
            try {
              let result = await callback();
              if (result != null) {
                if (typeof result !== "object")
                  throw new Error(`Expected onStart() callback in plugin ${quote(name)} to return an object`);
                let keys4 = {};
                let errors = getFlag(result, keys4, "errors", mustBeArray);
                let warnings = getFlag(result, keys4, "warnings", mustBeArray);
                checkForInvalidFlags(result, keys4, `from onStart() callback in plugin ${quote(name)}`);
                if (errors != null)
                  response.errors.push(...sanitizeMessages(errors, "errors", details, name));
                if (warnings != null)
                  response.warnings.push(...sanitizeMessages(warnings, "warnings", details, name));
              }
            } catch (e) {
              response.errors.push(extractErrorMessageV8(e, streamIn, details, note && note(), name));
            }
          }));
          sendResponse(id, response);
        };
        requestCallbacks["on-resolve"] = async (id, request) => {
          let response = {}, name = "", callback, note;
          for (let id2 of request.ids) {
            try {
              ({ name, callback, note } = onResolveCallbacks[id2]);
              let result = await callback({
                path: request.path,
                importer: request.importer,
                namespace: request.namespace,
                resolveDir: request.resolveDir,
                kind: request.kind,
                pluginData: details.load(request.pluginData)
              });
              if (result != null) {
                if (typeof result !== "object")
                  throw new Error(`Expected onResolve() callback in plugin ${quote(name)} to return an object`);
                let keys4 = {};
                let pluginName = getFlag(result, keys4, "pluginName", mustBeString);
                let path32 = getFlag(result, keys4, "path", mustBeString);
                let namespace = getFlag(result, keys4, "namespace", mustBeString);
                let suffix = getFlag(result, keys4, "suffix", mustBeString);
                let external = getFlag(result, keys4, "external", mustBeBoolean);
                let sideEffects = getFlag(result, keys4, "sideEffects", mustBeBoolean);
                let pluginData = getFlag(result, keys4, "pluginData", canBeAnything);
                let errors = getFlag(result, keys4, "errors", mustBeArray);
                let warnings = getFlag(result, keys4, "warnings", mustBeArray);
                let watchFiles = getFlag(result, keys4, "watchFiles", mustBeArray);
                let watchDirs = getFlag(result, keys4, "watchDirs", mustBeArray);
                checkForInvalidFlags(result, keys4, `from onResolve() callback in plugin ${quote(name)}`);
                response.id = id2;
                if (pluginName != null)
                  response.pluginName = pluginName;
                if (path32 != null)
                  response.path = path32;
                if (namespace != null)
                  response.namespace = namespace;
                if (suffix != null)
                  response.suffix = suffix;
                if (external != null)
                  response.external = external;
                if (sideEffects != null)
                  response.sideEffects = sideEffects;
                if (pluginData != null)
                  response.pluginData = details.store(pluginData);
                if (errors != null)
                  response.errors = sanitizeMessages(errors, "errors", details, name);
                if (warnings != null)
                  response.warnings = sanitizeMessages(warnings, "warnings", details, name);
                if (watchFiles != null)
                  response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
                if (watchDirs != null)
                  response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
                break;
              }
            } catch (e) {
              response = { id: id2, errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name)] };
              break;
            }
          }
          sendResponse(id, response);
        };
        requestCallbacks["on-load"] = async (id, request) => {
          let response = {}, name = "", callback, note;
          for (let id2 of request.ids) {
            try {
              ({ name, callback, note } = onLoadCallbacks[id2]);
              let result = await callback({
                path: request.path,
                namespace: request.namespace,
                suffix: request.suffix,
                pluginData: details.load(request.pluginData)
              });
              if (result != null) {
                if (typeof result !== "object")
                  throw new Error(`Expected onLoad() callback in plugin ${quote(name)} to return an object`);
                let keys4 = {};
                let pluginName = getFlag(result, keys4, "pluginName", mustBeString);
                let contents = getFlag(result, keys4, "contents", mustBeStringOrUint8Array);
                let resolveDir = getFlag(result, keys4, "resolveDir", mustBeString);
                let pluginData = getFlag(result, keys4, "pluginData", canBeAnything);
                let loader = getFlag(result, keys4, "loader", mustBeString);
                let errors = getFlag(result, keys4, "errors", mustBeArray);
                let warnings = getFlag(result, keys4, "warnings", mustBeArray);
                let watchFiles = getFlag(result, keys4, "watchFiles", mustBeArray);
                let watchDirs = getFlag(result, keys4, "watchDirs", mustBeArray);
                checkForInvalidFlags(result, keys4, `from onLoad() callback in plugin ${quote(name)}`);
                response.id = id2;
                if (pluginName != null)
                  response.pluginName = pluginName;
                if (contents instanceof Uint8Array)
                  response.contents = contents;
                else if (contents != null)
                  response.contents = encodeUTF8(contents);
                if (resolveDir != null)
                  response.resolveDir = resolveDir;
                if (pluginData != null)
                  response.pluginData = details.store(pluginData);
                if (loader != null)
                  response.loader = loader;
                if (errors != null)
                  response.errors = sanitizeMessages(errors, "errors", details, name);
                if (warnings != null)
                  response.warnings = sanitizeMessages(warnings, "warnings", details, name);
                if (watchFiles != null)
                  response.watchFiles = sanitizeStringArray(watchFiles, "watchFiles");
                if (watchDirs != null)
                  response.watchDirs = sanitizeStringArray(watchDirs, "watchDirs");
                break;
              }
            } catch (e) {
              response = { id: id2, errors: [extractErrorMessageV8(e, streamIn, details, note && note(), name)] };
              break;
            }
          }
          sendResponse(id, response);
        };
        let runOnEndCallbacks = (result, done) => done([], []);
        if (onEndCallbacks.length > 0) {
          runOnEndCallbacks = (result, done) => {
            (async () => {
              const onEndErrors = [];
              const onEndWarnings = [];
              for (const { name, callback, note } of onEndCallbacks) {
                let newErrors;
                let newWarnings;
                try {
                  const value = await callback(result);
                  if (value != null) {
                    if (typeof value !== "object")
                      throw new Error(`Expected onEnd() callback in plugin ${quote(name)} to return an object`);
                    let keys4 = {};
                    let errors = getFlag(value, keys4, "errors", mustBeArray);
                    let warnings = getFlag(value, keys4, "warnings", mustBeArray);
                    checkForInvalidFlags(value, keys4, `from onEnd() callback in plugin ${quote(name)}`);
                    if (errors != null)
                      newErrors = sanitizeMessages(errors, "errors", details, name);
                    if (warnings != null)
                      newWarnings = sanitizeMessages(warnings, "warnings", details, name);
                  }
                } catch (e) {
                  newErrors = [extractErrorMessageV8(e, streamIn, details, note && note(), name)];
                }
                if (newErrors) {
                  onEndErrors.push(...newErrors);
                  try {
                    result.errors.push(...newErrors);
                  } catch {
                  }
                }
                if (newWarnings) {
                  onEndWarnings.push(...newWarnings);
                  try {
                    result.warnings.push(...newWarnings);
                  } catch {
                  }
                }
              }
              done(onEndErrors, onEndWarnings);
            })();
          };
        }
        let scheduleOnDisposeCallbacks = () => {
          for (const cb of onDisposeCallbacks) {
            setTimeout(() => cb(), 0);
          }
        };
        isSetupDone = true;
        return {
          ok: true,
          requestPlugins,
          runOnEndCallbacks,
          scheduleOnDisposeCallbacks
        };
      };
      function createObjectStash() {
        const map2 = /* @__PURE__ */ new Map();
        let nextID = 0;
        return {
          load(id) {
            return map2.get(id);
          },
          store(value) {
            if (value === void 0)
              return -1;
            const id = nextID++;
            map2.set(id, value);
            return id;
          }
        };
      }
      function extractCallerV8(e, streamIn, ident) {
        let note;
        let tried = false;
        return () => {
          if (tried)
            return note;
          tried = true;
          try {
            let lines = (e.stack + "").split("\n");
            lines.splice(1, 1);
            let location = parseStackLinesV8(streamIn, lines, ident);
            if (location) {
              note = { text: e.message, location };
              return note;
            }
          } catch {
          }
        };
      }
      function extractErrorMessageV8(e, streamIn, stash, note, pluginName) {
        let text = "Internal error";
        let location = null;
        try {
          text = (e && e.message || e) + "";
        } catch {
        }
        try {
          location = parseStackLinesV8(streamIn, (e.stack + "").split("\n"), "");
        } catch {
        }
        return { id: "", pluginName, text, location, notes: note ? [note] : [], detail: stash ? stash.store(e) : -1 };
      }
      function parseStackLinesV8(streamIn, lines, ident) {
        let at = "    at ";
        if (streamIn.readFileSync && !lines[0].startsWith(at) && lines[1].startsWith(at)) {
          for (let i = 1; i < lines.length; i++) {
            let line = lines[i];
            if (!line.startsWith(at))
              continue;
            line = line.slice(at.length);
            while (true) {
              let match3 = /^(?:new |async )?\S+ \((.*)\)$/.exec(line);
              if (match3) {
                line = match3[1];
                continue;
              }
              match3 = /^eval at \S+ \((.*)\)(?:, \S+:\d+:\d+)?$/.exec(line);
              if (match3) {
                line = match3[1];
                continue;
              }
              match3 = /^(\S+):(\d+):(\d+)$/.exec(line);
              if (match3) {
                let contents;
                try {
                  contents = streamIn.readFileSync(match3[1], "utf8");
                } catch {
                  break;
                }
                let lineText = contents.split(/\r\n|\r|\n|\u2028|\u2029/)[+match3[2] - 1] || "";
                let column = +match3[3] - 1;
                let length = lineText.slice(column, column + ident.length) === ident ? ident.length : 0;
                return {
                  file: match3[1],
                  namespace: "file",
                  line: +match3[2],
                  column: encodeUTF8(lineText.slice(0, column)).length,
                  length: encodeUTF8(lineText.slice(column, column + length)).length,
                  lineText: lineText + "\n" + lines.slice(1).join("\n"),
                  suggestion: ""
                };
              }
              break;
            }
          }
        }
        return null;
      }
      function failureErrorWithLog(text, errors, warnings) {
        let limit = 5;
        text += errors.length < 1 ? "" : ` with ${errors.length} error${errors.length < 2 ? "" : "s"}:` + errors.slice(0, limit + 1).map((e, i) => {
          if (i === limit)
            return "\n...";
          if (!e.location)
            return `
error: ${e.text}`;
          let { file, line, column } = e.location;
          let pluginText = e.pluginName ? `[plugin: ${e.pluginName}] ` : "";
          return `
${file}:${line}:${column}: ERROR: ${pluginText}${e.text}`;
        }).join("");
        let error2 = new Error(text);
        for (const [key, value] of [["errors", errors], ["warnings", warnings]]) {
          Object.defineProperty(error2, key, {
            configurable: true,
            enumerable: true,
            get: () => value,
            set: (value2) => Object.defineProperty(error2, key, {
              configurable: true,
              enumerable: true,
              value: value2
            })
          });
        }
        return error2;
      }
      function replaceDetailsInMessages(messages, stash) {
        for (const message of messages) {
          message.detail = stash.load(message.detail);
        }
        return messages;
      }
      function sanitizeLocation(location, where) {
        if (location == null)
          return null;
        let keys4 = {};
        let file = getFlag(location, keys4, "file", mustBeString);
        let namespace = getFlag(location, keys4, "namespace", mustBeString);
        let line = getFlag(location, keys4, "line", mustBeInteger);
        let column = getFlag(location, keys4, "column", mustBeInteger);
        let length = getFlag(location, keys4, "length", mustBeInteger);
        let lineText = getFlag(location, keys4, "lineText", mustBeString);
        let suggestion = getFlag(location, keys4, "suggestion", mustBeString);
        checkForInvalidFlags(location, keys4, where);
        return {
          file: file || "",
          namespace: namespace || "",
          line: line || 0,
          column: column || 0,
          length: length || 0,
          lineText: lineText || "",
          suggestion: suggestion || ""
        };
      }
      function sanitizeMessages(messages, property, stash, fallbackPluginName) {
        let messagesClone = [];
        let index = 0;
        for (const message of messages) {
          let keys4 = {};
          let id = getFlag(message, keys4, "id", mustBeString);
          let pluginName = getFlag(message, keys4, "pluginName", mustBeString);
          let text = getFlag(message, keys4, "text", mustBeString);
          let location = getFlag(message, keys4, "location", mustBeObjectOrNull);
          let notes = getFlag(message, keys4, "notes", mustBeArray);
          let detail = getFlag(message, keys4, "detail", canBeAnything);
          let where = `in element ${index} of "${property}"`;
          checkForInvalidFlags(message, keys4, where);
          let notesClone = [];
          if (notes) {
            for (const note of notes) {
              let noteKeys = {};
              let noteText = getFlag(note, noteKeys, "text", mustBeString);
              let noteLocation = getFlag(note, noteKeys, "location", mustBeObjectOrNull);
              checkForInvalidFlags(note, noteKeys, where);
              notesClone.push({
                text: noteText || "",
                location: sanitizeLocation(noteLocation, where)
              });
            }
          }
          messagesClone.push({
            id: id || "",
            pluginName: pluginName || fallbackPluginName,
            text: text || "",
            location: sanitizeLocation(location, where),
            notes: notesClone,
            detail: stash ? stash.store(detail) : -1
          });
          index++;
        }
        return messagesClone;
      }
      function sanitizeStringArray(values, property) {
        const result = [];
        for (const value of values) {
          if (typeof value !== "string")
            throw new Error(`${quote(property)} must be an array of strings`);
          result.push(value);
        }
        return result;
      }
      function convertOutputFiles({ path: path32, contents, hash: hash5 }) {
        let text = null;
        return {
          path: path32,
          contents,
          hash: hash5,
          get text() {
            const binary = this.contents;
            if (text === null || binary !== contents) {
              contents = binary;
              text = decodeUTF8(binary);
            }
            return text;
          }
        };
      }
      var fs4 = __require2("fs");
      var os = __require2("os");
      var path4 = __require2("path");
      var ESBUILD_BINARY_PATH = process.env.ESBUILD_BINARY_PATH || ESBUILD_BINARY_PATH;
      var isValidBinaryPath = (x) => !!x && x !== "/usr/bin/esbuild";
      var packageDarwin_arm64 = "@esbuild/darwin-arm64";
      var packageDarwin_x64 = "@esbuild/darwin-x64";
      var knownWindowsPackages = {
        "win32 arm64 LE": "@esbuild/win32-arm64",
        "win32 ia32 LE": "@esbuild/win32-ia32",
        "win32 x64 LE": "@esbuild/win32-x64"
      };
      var knownUnixlikePackages = {
        "android arm64 LE": "@esbuild/android-arm64",
        "darwin arm64 LE": "@esbuild/darwin-arm64",
        "darwin x64 LE": "@esbuild/darwin-x64",
        "freebsd arm64 LE": "@esbuild/freebsd-arm64",
        "freebsd x64 LE": "@esbuild/freebsd-x64",
        "linux arm LE": "@esbuild/linux-arm",
        "linux arm64 LE": "@esbuild/linux-arm64",
        "linux ia32 LE": "@esbuild/linux-ia32",
        "linux mips64el LE": "@esbuild/linux-mips64el",
        "linux ppc64 LE": "@esbuild/linux-ppc64",
        "linux riscv64 LE": "@esbuild/linux-riscv64",
        "linux s390x BE": "@esbuild/linux-s390x",
        "linux x64 LE": "@esbuild/linux-x64",
        "linux loong64 LE": "@esbuild/linux-loong64",
        "netbsd x64 LE": "@esbuild/netbsd-x64",
        "openbsd x64 LE": "@esbuild/openbsd-x64",
        "sunos x64 LE": "@esbuild/sunos-x64"
      };
      var knownWebAssemblyFallbackPackages = {
        "android arm LE": "@esbuild/android-arm",
        "android x64 LE": "@esbuild/android-x64"
      };
      function pkgAndSubpathForCurrentPlatform() {
        let pkg;
        let subpath;
        let isWASM = false;
        let platformKey = `${process.platform} ${os.arch()} ${os.endianness()}`;
        if (platformKey in knownWindowsPackages) {
          pkg = knownWindowsPackages[platformKey];
          subpath = "esbuild.exe";
        } else if (platformKey in knownUnixlikePackages) {
          pkg = knownUnixlikePackages[platformKey];
          subpath = "bin/esbuild";
        } else if (platformKey in knownWebAssemblyFallbackPackages) {
          pkg = knownWebAssemblyFallbackPackages[platformKey];
          subpath = "bin/esbuild";
          isWASM = true;
        } else {
          throw new Error(`Unsupported platform: ${platformKey}`);
        }
        return { pkg, subpath, isWASM };
      }
      function pkgForSomeOtherPlatform() {
        const libMainJS = __require2.resolve("esbuild");
        const nodeModulesDirectory = path4.dirname(path4.dirname(path4.dirname(libMainJS)));
        if (path4.basename(nodeModulesDirectory) === "node_modules") {
          for (const unixKey in knownUnixlikePackages) {
            try {
              const pkg = knownUnixlikePackages[unixKey];
              if (fs4.existsSync(path4.join(nodeModulesDirectory, pkg)))
                return pkg;
            } catch {
            }
          }
          for (const windowsKey in knownWindowsPackages) {
            try {
              const pkg = knownWindowsPackages[windowsKey];
              if (fs4.existsSync(path4.join(nodeModulesDirectory, pkg)))
                return pkg;
            } catch {
            }
          }
        }
        return null;
      }
      function downloadedBinPath(pkg, subpath) {
        const esbuildLibDir = path4.dirname(__require2.resolve("esbuild"));
        return path4.join(esbuildLibDir, `downloaded-${pkg.replace("/", "-")}-${path4.basename(subpath)}`);
      }
      function generateBinPath() {
        if (isValidBinaryPath(ESBUILD_BINARY_PATH)) {
          if (!fs4.existsSync(ESBUILD_BINARY_PATH)) {
            console.warn(`[esbuild] Ignoring bad configuration: ESBUILD_BINARY_PATH=${ESBUILD_BINARY_PATH}`);
          } else {
            return { binPath: ESBUILD_BINARY_PATH, isWASM: false };
          }
        }
        const { pkg, subpath, isWASM } = pkgAndSubpathForCurrentPlatform();
        let binPath;
        try {
          binPath = __require2.resolve(`${pkg}/${subpath}`);
        } catch (e) {
          binPath = downloadedBinPath(pkg, subpath);
          if (!fs4.existsSync(binPath)) {
            try {
              __require2.resolve(pkg);
            } catch {
              const otherPkg = pkgForSomeOtherPlatform();
              if (otherPkg) {
                let suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild on Windows or macOS and copying "node_modules"
into a Docker image that runs Linux, or by copying "node_modules" between
Windows and WSL environments.

If you are installing with npm, you can try not copying the "node_modules"
directory when you copy the files over, and running "npm ci" or "npm install"
on the destination platform after the copy. Or you could consider using yarn
instead of npm which has built-in support for installing a package on multiple
platforms simultaneously.

If you are installing with yarn, you can try listing both this platform and the
other platform in your ".yarnrc.yml" file using the "supportedArchitectures"
feature: https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
                if (pkg === packageDarwin_x64 && otherPkg === packageDarwin_arm64 || pkg === packageDarwin_arm64 && otherPkg === packageDarwin_x64) {
                  suggestions = `
Specifically the "${otherPkg}" package is present but this platform
needs the "${pkg}" package instead. People often get into this
situation by installing esbuild with npm running inside of Rosetta 2 and then
trying to use it with node running outside of Rosetta 2, or vice versa (Rosetta
2 is Apple's on-the-fly x86_64-to-arm64 translation service).

If you are installing with npm, you can try ensuring that both npm and node are
not running under Rosetta 2 and then reinstalling esbuild. This likely involves
changing how you installed npm and/or node. For example, installing node with
the universal installer here should work: https://nodejs.org/en/download/. Or
you could consider using yarn instead of npm which has built-in support for
installing a package on multiple platforms simultaneously.

If you are installing with yarn, you can try listing both "arm64" and "x64"
in your ".yarnrc.yml" file using the "supportedArchitectures" feature:
https://yarnpkg.com/configuration/yarnrc/#supportedArchitectures
Keep in mind that this means multiple copies of esbuild will be present.
`;
                }
                throw new Error(`
You installed esbuild for another platform than the one you're currently using.
This won't work because esbuild is written with native code and needs to
install a platform-specific binary executable.
${suggestions}
Another alternative is to use the "esbuild-wasm" package instead, which works
the same way on all platforms. But it comes with a heavy performance cost and
can sometimes be 10x slower than the "esbuild" package, so you may also not
want to do that.
`);
              }
              throw new Error(`The package "${pkg}" could not be found, and is needed by esbuild.

If you are installing esbuild with npm, make sure that you don't specify the
"--no-optional" or "--omit=optional" flags. The "optionalDependencies" feature
of "package.json" is used by esbuild to install the correct binary executable
for your current platform.`);
            }
            throw e;
          }
        }
        if (/\.zip\//.test(binPath)) {
          let pnpapi;
          try {
            pnpapi = __require2("pnpapi");
          } catch (e) {
          }
          if (pnpapi) {
            const root = pnpapi.getPackageInformation(pnpapi.topLevel).packageLocation;
            const binTargetPath = path4.join(
              root,
              "node_modules",
              ".cache",
              "esbuild",
              `pnpapi-${pkg.replace("/", "-")}-${"0.19.3"}-${path4.basename(subpath)}`
            );
            if (!fs4.existsSync(binTargetPath)) {
              fs4.mkdirSync(path4.dirname(binTargetPath), { recursive: true });
              fs4.copyFileSync(binPath, binTargetPath);
              fs4.chmodSync(binTargetPath, 493);
            }
            return { binPath: binTargetPath, isWASM };
          }
        }
        return { binPath, isWASM };
      }
      var child_process = __require2("child_process");
      var crypto7 = __require2("crypto");
      var path23 = __require2("path");
      var fs22 = __require2("fs");
      var os2 = __require2("os");
      var tty = __require2("tty");
      var worker_threads;
      if (process.env.ESBUILD_WORKER_THREADS !== "0") {
        try {
          worker_threads = __require2("worker_threads");
        } catch {
        }
        let [major, minor] = process.versions.node.split(".");
        if (
          // <v12.17.0 does not work
          +major < 12 || +major === 12 && +minor < 17 || +major === 13 && +minor < 13
        ) {
          worker_threads = void 0;
        }
      }
      var _a;
      var isInternalWorkerThread = ((_a = worker_threads == null ? void 0 : worker_threads.workerData) == null ? void 0 : _a.esbuildVersion) === "0.19.3";
      var esbuildCommandAndArgs = () => {
        if ((!ESBUILD_BINARY_PATH || false) && (path23.basename(__filename) !== "main.js" || path23.basename(__dirname) !== "lib")) {
          throw new Error(
            `The esbuild JavaScript API cannot be bundled. Please mark the "esbuild" package as external so it's not included in the bundle.

More information: The file containing the code for esbuild's JavaScript API (${__filename}) does not appear to be inside the esbuild package on the file system, which usually means that the esbuild package was bundled into another file. This is problematic because the API needs to run a binary executable inside the esbuild package which is located using a relative path from the API code to the executable. If the esbuild package is bundled, the relative path will be incorrect and the executable won't be found.`
          );
        }
        if (false) {
          return ["node", [path23.join(__dirname, "..", "bin", "esbuild")]];
        } else {
          const { binPath, isWASM } = generateBinPath();
          if (isWASM) {
            return ["node", [binPath]];
          } else {
            return [binPath, []];
          }
        }
      };
      var isTTY = () => tty.isatty(2);
      var fsSync = {
        readFile(tempFile, callback) {
          try {
            let contents = fs22.readFileSync(tempFile, "utf8");
            try {
              fs22.unlinkSync(tempFile);
            } catch {
            }
            callback(null, contents);
          } catch (err) {
            callback(err, null);
          }
        },
        writeFile(contents, callback) {
          try {
            let tempFile = randomFileName();
            fs22.writeFileSync(tempFile, contents);
            callback(tempFile);
          } catch {
            callback(null);
          }
        }
      };
      var fsAsync = {
        readFile(tempFile, callback) {
          try {
            fs22.readFile(tempFile, "utf8", (err, contents) => {
              try {
                fs22.unlink(tempFile, () => callback(err, contents));
              } catch {
                callback(err, contents);
              }
            });
          } catch (err) {
            callback(err, null);
          }
        },
        writeFile(contents, callback) {
          try {
            let tempFile = randomFileName();
            fs22.writeFile(tempFile, contents, (err) => err !== null ? callback(null) : callback(tempFile));
          } catch {
            callback(null);
          }
        }
      };
      var version2 = "0.19.3";
      var build3 = (options) => ensureServiceIsRunning().build(options);
      var context2 = (buildOptions) => ensureServiceIsRunning().context(buildOptions);
      var transform = (input, options) => ensureServiceIsRunning().transform(input, options);
      var formatMessages = (messages, options) => ensureServiceIsRunning().formatMessages(messages, options);
      var analyzeMetafile = (messages, options) => ensureServiceIsRunning().analyzeMetafile(messages, options);
      var buildSync = (options) => {
        if (worker_threads && !isInternalWorkerThread) {
          if (!workerThreadService)
            workerThreadService = startWorkerThreadService(worker_threads);
          return workerThreadService.buildSync(options);
        }
        let result;
        runServiceSync((service) => service.buildOrContext({
          callName: "buildSync",
          refs: null,
          options,
          isTTY: isTTY(),
          defaultWD,
          callback: (err, res) => {
            if (err)
              throw err;
            result = res;
          }
        }));
        return result;
      };
      var transformSync = (input, options) => {
        if (worker_threads && !isInternalWorkerThread) {
          if (!workerThreadService)
            workerThreadService = startWorkerThreadService(worker_threads);
          return workerThreadService.transformSync(input, options);
        }
        let result;
        runServiceSync((service) => service.transform({
          callName: "transformSync",
          refs: null,
          input,
          options: options || {},
          isTTY: isTTY(),
          fs: fsSync,
          callback: (err, res) => {
            if (err)
              throw err;
            result = res;
          }
        }));
        return result;
      };
      var formatMessagesSync = (messages, options) => {
        if (worker_threads && !isInternalWorkerThread) {
          if (!workerThreadService)
            workerThreadService = startWorkerThreadService(worker_threads);
          return workerThreadService.formatMessagesSync(messages, options);
        }
        let result;
        runServiceSync((service) => service.formatMessages({
          callName: "formatMessagesSync",
          refs: null,
          messages,
          options,
          callback: (err, res) => {
            if (err)
              throw err;
            result = res;
          }
        }));
        return result;
      };
      var analyzeMetafileSync = (metafile, options) => {
        if (worker_threads && !isInternalWorkerThread) {
          if (!workerThreadService)
            workerThreadService = startWorkerThreadService(worker_threads);
          return workerThreadService.analyzeMetafileSync(metafile, options);
        }
        let result;
        runServiceSync((service) => service.analyzeMetafile({
          callName: "analyzeMetafileSync",
          refs: null,
          metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
          options,
          callback: (err, res) => {
            if (err)
              throw err;
            result = res;
          }
        }));
        return result;
      };
      var initializeWasCalled = false;
      var initialize = (options) => {
        options = validateInitializeOptions(options || {});
        if (options.wasmURL)
          throw new Error(`The "wasmURL" option only works in the browser`);
        if (options.wasmModule)
          throw new Error(`The "wasmModule" option only works in the browser`);
        if (options.worker)
          throw new Error(`The "worker" option only works in the browser`);
        if (initializeWasCalled)
          throw new Error('Cannot call "initialize" more than once');
        ensureServiceIsRunning();
        initializeWasCalled = true;
        return Promise.resolve();
      };
      var defaultWD = process.cwd();
      var longLivedService;
      var ensureServiceIsRunning = () => {
        if (longLivedService)
          return longLivedService;
        let [command, args] = esbuildCommandAndArgs();
        let child = child_process.spawn(command, args.concat(`--service=${"0.19.3"}`, "--ping"), {
          windowsHide: true,
          stdio: ["pipe", "pipe", "inherit"],
          cwd: defaultWD
        });
        let { readFromStdout, afterClose, service } = createChannel({
          writeToStdin(bytes3) {
            child.stdin.write(bytes3, (err) => {
              if (err)
                afterClose(err);
            });
          },
          readFileSync: fs22.readFileSync,
          isSync: false,
          hasFS: true,
          esbuild: node_exports
        });
        child.stdin.on("error", afterClose);
        child.on("error", afterClose);
        const stdin = child.stdin;
        const stdout = child.stdout;
        stdout.on("data", readFromStdout);
        stdout.on("end", afterClose);
        let refCount = 0;
        child.unref();
        if (stdin.unref) {
          stdin.unref();
        }
        if (stdout.unref) {
          stdout.unref();
        }
        const refs = {
          ref() {
            if (++refCount === 1)
              child.ref();
          },
          unref() {
            if (--refCount === 0)
              child.unref();
          }
        };
        longLivedService = {
          build: (options) => new Promise((resolve4, reject) => {
            service.buildOrContext({
              callName: "build",
              refs,
              options,
              isTTY: isTTY(),
              defaultWD,
              callback: (err, res) => err ? reject(err) : resolve4(res)
            });
          }),
          context: (options) => new Promise((resolve4, reject) => service.buildOrContext({
            callName: "context",
            refs,
            options,
            isTTY: isTTY(),
            defaultWD,
            callback: (err, res) => err ? reject(err) : resolve4(res)
          })),
          transform: (input, options) => new Promise((resolve4, reject) => service.transform({
            callName: "transform",
            refs,
            input,
            options: options || {},
            isTTY: isTTY(),
            fs: fsAsync,
            callback: (err, res) => err ? reject(err) : resolve4(res)
          })),
          formatMessages: (messages, options) => new Promise((resolve4, reject) => service.formatMessages({
            callName: "formatMessages",
            refs,
            messages,
            options,
            callback: (err, res) => err ? reject(err) : resolve4(res)
          })),
          analyzeMetafile: (metafile, options) => new Promise((resolve4, reject) => service.analyzeMetafile({
            callName: "analyzeMetafile",
            refs,
            metafile: typeof metafile === "string" ? metafile : JSON.stringify(metafile),
            options,
            callback: (err, res) => err ? reject(err) : resolve4(res)
          }))
        };
        return longLivedService;
      };
      var runServiceSync = (callback) => {
        let [command, args] = esbuildCommandAndArgs();
        let stdin = new Uint8Array();
        let { readFromStdout, afterClose, service } = createChannel({
          writeToStdin(bytes3) {
            if (stdin.length !== 0)
              throw new Error("Must run at most one command");
            stdin = bytes3;
          },
          isSync: true,
          hasFS: true,
          esbuild: node_exports
        });
        callback(service);
        let stdout = child_process.execFileSync(command, args.concat(`--service=${"0.19.3"}`), {
          cwd: defaultWD,
          windowsHide: true,
          input: stdin,
          // We don't know how large the output could be. If it's too large, the
          // command will fail with ENOBUFS. Reserve 16mb for now since that feels
          // like it should be enough. Also allow overriding this with an environment
          // variable.
          maxBuffer: +process.env.ESBUILD_MAX_BUFFER || 16 * 1024 * 1024
        });
        readFromStdout(stdout);
        afterClose(null);
      };
      var randomFileName = () => {
        return path23.join(os2.tmpdir(), `esbuild-${crypto7.randomBytes(32).toString("hex")}`);
      };
      var workerThreadService = null;
      var startWorkerThreadService = (worker_threads2) => {
        let { port1: mainPort, port2: workerPort } = new worker_threads2.MessageChannel();
        let worker = new worker_threads2.Worker(__filename, {
          workerData: { workerPort, defaultWD, esbuildVersion: "0.19.3" },
          transferList: [workerPort],
          // From node's documentation: https://nodejs.org/api/worker_threads.html
          //
          //   Take care when launching worker threads from preload scripts (scripts loaded
          //   and run using the `-r` command line flag). Unless the `execArgv` option is
          //   explicitly set, new Worker threads automatically inherit the command line flags
          //   from the running process and will preload the same preload scripts as the main
          //   thread. If the preload script unconditionally launches a worker thread, every
          //   thread spawned will spawn another until the application crashes.
          //
          execArgv: []
        });
        let nextID = 0;
        let fakeBuildError = (text) => {
          let error2 = new Error(`Build failed with 1 error:
error: ${text}`);
          let errors = [{ id: "", pluginName: "", text, location: null, notes: [], detail: void 0 }];
          error2.errors = errors;
          error2.warnings = [];
          return error2;
        };
        let validateBuildSyncOptions = (options) => {
          if (!options)
            return;
          let plugins = options.plugins;
          if (plugins && plugins.length > 0)
            throw fakeBuildError(`Cannot use plugins in synchronous API calls`);
        };
        let applyProperties = (object2, properties) => {
          for (let key in properties) {
            object2[key] = properties[key];
          }
        };
        let runCallSync = (command, args) => {
          let id = nextID++;
          let sharedBuffer = new SharedArrayBuffer(8);
          let sharedBufferView = new Int32Array(sharedBuffer);
          let msg = { sharedBuffer, id, command, args };
          worker.postMessage(msg);
          let status = Atomics.wait(sharedBufferView, 0, 0);
          if (status !== "ok" && status !== "not-equal")
            throw new Error("Internal error: Atomics.wait() failed: " + status);
          let { message: { id: id2, resolve: resolve4, reject, properties } } = worker_threads2.receiveMessageOnPort(mainPort);
          if (id !== id2)
            throw new Error(`Internal error: Expected id ${id} but got id ${id2}`);
          if (reject) {
            applyProperties(reject, properties);
            throw reject;
          }
          return resolve4;
        };
        worker.unref();
        return {
          buildSync(options) {
            validateBuildSyncOptions(options);
            return runCallSync("build", [options]);
          },
          transformSync(input, options) {
            return runCallSync("transform", [input, options]);
          },
          formatMessagesSync(messages, options) {
            return runCallSync("formatMessages", [messages, options]);
          },
          analyzeMetafileSync(metafile, options) {
            return runCallSync("analyzeMetafile", [metafile, options]);
          }
        };
      };
      var startSyncServiceWorker = () => {
        let workerPort = worker_threads.workerData.workerPort;
        let parentPort = worker_threads.parentPort;
        let extractProperties = (object2) => {
          let properties = {};
          if (object2 && typeof object2 === "object") {
            for (let key in object2) {
              properties[key] = object2[key];
            }
          }
          return properties;
        };
        try {
          let service = ensureServiceIsRunning();
          defaultWD = worker_threads.workerData.defaultWD;
          parentPort.on("message", (msg) => {
            (async () => {
              let { sharedBuffer, id, command, args } = msg;
              let sharedBufferView = new Int32Array(sharedBuffer);
              try {
                switch (command) {
                  case "build":
                    workerPort.postMessage({ id, resolve: await service.build(args[0]) });
                    break;
                  case "transform":
                    workerPort.postMessage({ id, resolve: await service.transform(args[0], args[1]) });
                    break;
                  case "formatMessages":
                    workerPort.postMessage({ id, resolve: await service.formatMessages(args[0], args[1]) });
                    break;
                  case "analyzeMetafile":
                    workerPort.postMessage({ id, resolve: await service.analyzeMetafile(args[0], args[1]) });
                    break;
                  default:
                    throw new Error(`Invalid command: ${command}`);
                }
              } catch (reject) {
                workerPort.postMessage({ id, reject, properties: extractProperties(reject) });
              }
              Atomics.add(sharedBufferView, 0, 1);
              Atomics.notify(sharedBufferView, 0, Infinity);
            })();
          });
        } catch (reject) {
          parentPort.on("message", (msg) => {
            let { sharedBuffer, id } = msg;
            let sharedBufferView = new Int32Array(sharedBuffer);
            workerPort.postMessage({ id, reject, properties: extractProperties(reject) });
            Atomics.add(sharedBufferView, 0, 1);
            Atomics.notify(sharedBufferView, 0, Infinity);
          });
        }
      };
      if (isInternalWorkerThread) {
        startSyncServiceWorker();
      }
      var node_default3 = node_exports;
    }
  });

  // ../../node_modules/.pnpm/joycon@3.1.1/node_modules/joycon/lib/index.js
  var require_lib5 = __commonJS({
    "../../node_modules/.pnpm/joycon@3.1.1/node_modules/joycon/lib/index.js"(exports, module2) {
      "use strict";
      Object.defineProperty(exports, "__esModule", {
        value: true
      });
      exports.default = void 0;
      var _fs = _interopRequireDefault(__require2("fs"));
      var _path = _interopRequireDefault(__require2("path"));
      function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : { default: obj };
      }
      var readFileSync7 = (fp) => {
        return _fs.default.readFileSync(fp, "utf8");
      };
      var pathExists = (fp) => new Promise((resolve4) => {
        _fs.default.access(fp, (err) => {
          resolve4(!err);
        });
      });
      var pathExistsSync = _fs.default.existsSync;
      var JoyCon2 = class {
        constructor({
          files,
          cwd = process.cwd(),
          stopDir,
          packageKey,
          parseJSON = JSON.parse
        } = {}) {
          this.options = {
            files,
            cwd,
            stopDir,
            packageKey,
            parseJSON
          };
          this.existsCache = /* @__PURE__ */ new Map();
          this.loaders = /* @__PURE__ */ new Set();
          this.packageJsonCache = /* @__PURE__ */ new Map();
          this.loadCache = /* @__PURE__ */ new Map();
        }
        addLoader(loader) {
          this.loaders.add(loader);
          return this;
        }
        removeLoader(name) {
          for (const loader of this.loaders) {
            if (name && loader.name === name) {
              this.loaders.delete(loader);
            }
          }
          return this;
        }
        async recusivelyResolve(options) {
          if (options.cwd === options.stopDir || _path.default.basename(options.cwd) === "node_modules") {
            return null;
          }
          for (const filename of options.files) {
            const file = _path.default.resolve(options.cwd, filename);
            const exists3 = process.env.NODE_ENV !== "test" && this.existsCache.has(file) ? this.existsCache.get(file) : await pathExists(file);
            this.existsCache.set(file, exists3);
            if (exists3) {
              if (!options.packageKey || _path.default.basename(file) !== "package.json") {
                return file;
              }
              const data = __require2(file);
              delete __require2.cache[file];
              const hasPackageKey = Object.prototype.hasOwnProperty.call(data, options.packageKey);
              if (hasPackageKey) {
                this.packageJsonCache.set(file, data);
                return file;
              }
            }
            continue;
          }
          return this.recusivelyResolve(Object.assign({}, options, {
            cwd: _path.default.dirname(options.cwd)
          }));
        }
        recusivelyResolveSync(options) {
          if (options.cwd === options.stopDir || _path.default.basename(options.cwd) === "node_modules") {
            return null;
          }
          for (const filename of options.files) {
            const file = _path.default.resolve(options.cwd, filename);
            const exists3 = process.env.NODE_ENV !== "test" && this.existsCache.has(file) ? this.existsCache.get(file) : pathExistsSync(file);
            this.existsCache.set(file, exists3);
            if (exists3) {
              if (!options.packageKey || _path.default.basename(file) !== "package.json") {
                return file;
              }
              const data = __require2(file);
              delete __require2.cache[file];
              const hasPackageKey = Object.prototype.hasOwnProperty.call(data, options.packageKey);
              if (hasPackageKey) {
                this.packageJsonCache.set(file, data);
                return file;
              }
            }
            continue;
          }
          return this.recusivelyResolveSync(Object.assign({}, options, {
            cwd: _path.default.dirname(options.cwd)
          }));
        }
        async resolve(...args) {
          const options = this.normalizeOptions(args);
          return this.recusivelyResolve(options);
        }
        resolveSync(...args) {
          const options = this.normalizeOptions(args);
          return this.recusivelyResolveSync(options);
        }
        runLoaderSync(loader, filepath) {
          return loader.loadSync(filepath);
        }
        runLoader(loader, filepath) {
          if (!loader.load)
            return loader.loadSync(filepath);
          return loader.load(filepath);
        }
        async load(...args) {
          const options = this.normalizeOptions(args);
          const filepath = await this.recusivelyResolve(options);
          if (filepath) {
            const defaultLoader = {
              test: /\.+/,
              loadSync: (filepath2) => {
                const extname = _path.default.extname(filepath2).slice(1);
                if (extname === "js" || extname === "cjs") {
                  delete __require2.cache[filepath2];
                  return __require2(filepath2);
                }
                if (this.packageJsonCache.has(filepath2)) {
                  return this.packageJsonCache.get(filepath2)[options.packageKey];
                }
                const data2 = this.options.parseJSON(readFileSync7(filepath2));
                return data2;
              }
            };
            const loader = this.findLoader(filepath) || defaultLoader;
            let data;
            if (this.loadCache.has(filepath)) {
              data = this.loadCache.get(filepath);
            } else {
              data = await this.runLoader(loader, filepath);
              this.loadCache.set(filepath, data);
            }
            return {
              path: filepath,
              data
            };
          }
          return {};
        }
        loadSync(...args) {
          const options = this.normalizeOptions(args);
          const filepath = this.recusivelyResolveSync(options);
          if (filepath) {
            const defaultLoader = {
              test: /\.+/,
              loadSync: (filepath2) => {
                const extname = _path.default.extname(filepath2).slice(1);
                if (extname === "js" || extname === "cjs") {
                  delete __require2.cache[filepath2];
                  return __require2(filepath2);
                }
                if (this.packageJsonCache.has(filepath2)) {
                  return this.packageJsonCache.get(filepath2)[options.packageKey];
                }
                const data2 = this.options.parseJSON(readFileSync7(filepath2));
                return data2;
              }
            };
            const loader = this.findLoader(filepath) || defaultLoader;
            let data;
            if (this.loadCache.has(filepath)) {
              data = this.loadCache.get(filepath);
            } else {
              data = this.runLoaderSync(loader, filepath);
              this.loadCache.set(filepath, data);
            }
            return {
              path: filepath,
              data
            };
          }
          return {};
        }
        findLoader(filepath) {
          for (const loader of this.loaders) {
            if (loader.test && loader.test.test(filepath)) {
              return loader;
            }
          }
          return null;
        }
        clearCache() {
          this.existsCache.clear();
          this.packageJsonCache.clear();
          this.loadCache.clear();
          return this;
        }
        normalizeOptions(args) {
          const options = Object.assign({}, this.options);
          if (Object.prototype.toString.call(args[0]) === "[object Object]") {
            Object.assign(options, args[0]);
          } else {
            if (args[0]) {
              options.files = args[0];
            }
            if (args[1]) {
              options.cwd = args[1];
            }
            if (args[2]) {
              options.stopDir = args[2];
            }
          }
          options.cwd = _path.default.resolve(options.cwd);
          options.stopDir = options.stopDir ? _path.default.resolve(options.stopDir) : _path.default.parse(options.cwd).root;
          if (!options.files || options.files.length === 0) {
            throw new Error("[joycon] files must be an non-empty array!");
          }
          options.__normalized__ = true;
          return options;
        }
      };
      exports.default = JoyCon2;
      module2.exports = JoyCon2;
      module2.exports.default = JoyCon2;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHas.js
  var require_baseHas = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHas.js"(exports, module2) {
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseHas(object2, key) {
        return object2 != null && hasOwnProperty.call(object2, key);
      }
      module2.exports = baseHas;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArray.js
  var require_isArray = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArray.js"(exports, module2) {
      var isArray = Array.isArray;
      module2.exports = isArray;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_freeGlobal.js
  var require_freeGlobal = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_freeGlobal.js"(exports, module2) {
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      module2.exports = freeGlobal;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js
  var require_root = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_root.js"(exports, module2) {
      var freeGlobal = require_freeGlobal();
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      module2.exports = root;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js
  var require_Symbol = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Symbol.js"(exports, module2) {
      var root = require_root();
      var Symbol2 = root.Symbol;
      module2.exports = Symbol2;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getRawTag.js
  var require_getRawTag = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getRawTag.js"(exports, module2) {
      var Symbol2 = require_Symbol();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var nativeObjectToString = objectProto.toString;
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result;
      }
      module2.exports = getRawTag;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_objectToString.js
  var require_objectToString = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_objectToString.js"(exports, module2) {
      var objectProto = Object.prototype;
      var nativeObjectToString = objectProto.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      module2.exports = objectToString;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetTag.js
  var require_baseGetTag = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetTag.js"(exports, module2) {
      var Symbol2 = require_Symbol();
      var getRawTag = require_getRawTag();
      var objectToString = require_objectToString();
      var nullTag = "[object Null]";
      var undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      module2.exports = baseGetTag;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObjectLike.js
  var require_isObjectLike2 = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObjectLike.js"(exports, module2) {
      function isObjectLike2(value) {
        return value != null && typeof value == "object";
      }
      module2.exports = isObjectLike2;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSymbol.js
  var require_isSymbol = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isSymbol.js"(exports, module2) {
      var baseGetTag = require_baseGetTag();
      var isObjectLike2 = require_isObjectLike2();
      var symbolTag = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike2(value) && baseGetTag(value) == symbolTag;
      }
      module2.exports = isSymbol;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKey.js
  var require_isKey = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKey.js"(exports, module2) {
      var isArray = require_isArray();
      var isSymbol = require_isSymbol();
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
      var reIsPlainProp = /^\w*$/;
      function isKey(value, object2) {
        if (isArray(value)) {
          return false;
        }
        var type3 = typeof value;
        if (type3 == "number" || type3 == "symbol" || type3 == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
      }
      module2.exports = isKey;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js
  var require_isObject = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isObject.js"(exports, module2) {
      function isObject2(value) {
        var type3 = typeof value;
        return value != null && (type3 == "object" || type3 == "function");
      }
      module2.exports = isObject2;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isFunction.js
  var require_isFunction = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isFunction.js"(exports, module2) {
      var baseGetTag = require_baseGetTag();
      var isObject2 = require_isObject();
      var asyncTag = "[object AsyncFunction]";
      var funcTag = "[object Function]";
      var genTag = "[object GeneratorFunction]";
      var proxyTag = "[object Proxy]";
      function isFunction(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      module2.exports = isFunction;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_coreJsData.js
  var require_coreJsData = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_coreJsData.js"(exports, module2) {
      var root = require_root();
      var coreJsData = root["__core-js_shared__"];
      module2.exports = coreJsData;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isMasked.js
  var require_isMasked = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isMasked.js"(exports, module2) {
      var coreJsData = require_coreJsData();
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      module2.exports = isMasked;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toSource.js
  var require_toSource = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toSource.js"(exports, module2) {
      var funcProto = Function.prototype;
      var funcToString = funcProto.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      module2.exports = toSource;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNative.js
  var require_baseIsNative = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsNative.js"(exports, module2) {
      var isFunction = require_isFunction();
      var isMasked = require_isMasked();
      var isObject2 = require_isObject();
      var toSource = require_toSource();
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto = Function.prototype;
      var objectProto = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var reIsNative = RegExp(
        "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      module2.exports = baseIsNative;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getValue.js
  var require_getValue = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getValue.js"(exports, module2) {
      function getValue(object2, key) {
        return object2 == null ? void 0 : object2[key];
      }
      module2.exports = getValue;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getNative.js
  var require_getNative = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getNative.js"(exports, module2) {
      var baseIsNative = require_baseIsNative();
      var getValue = require_getValue();
      function getNative(object2, key) {
        var value = getValue(object2, key);
        return baseIsNative(value) ? value : void 0;
      }
      module2.exports = getNative;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeCreate.js
  var require_nativeCreate = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeCreate.js"(exports, module2) {
      var getNative = require_getNative();
      var nativeCreate = getNative(Object, "create");
      module2.exports = nativeCreate;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashClear.js
  var require_hashClear = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashClear.js"(exports, module2) {
      var nativeCreate = require_nativeCreate();
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      module2.exports = hashClear;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashDelete.js
  var require_hashDelete = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashDelete.js"(exports, module2) {
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      module2.exports = hashDelete;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashGet.js
  var require_hashGet = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashGet.js"(exports, module2) {
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED ? void 0 : result;
        }
        return hasOwnProperty.call(data, key) ? data[key] : void 0;
      }
      module2.exports = hashGet;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashHas.js
  var require_hashHas = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashHas.js"(exports, module2) {
      var nativeCreate = require_nativeCreate();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
      }
      module2.exports = hashHas;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashSet.js
  var require_hashSet = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hashSet.js"(exports, module2) {
      var nativeCreate = require_nativeCreate();
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
        return this;
      }
      module2.exports = hashSet;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Hash.js
  var require_Hash = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Hash.js"(exports, module2) {
      var hashClear = require_hashClear();
      var hashDelete = require_hashDelete();
      var hashGet = require_hashGet();
      var hashHas = require_hashHas();
      var hashSet = require_hashSet();
      function Hash3(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      Hash3.prototype.clear = hashClear;
      Hash3.prototype["delete"] = hashDelete;
      Hash3.prototype.get = hashGet;
      Hash3.prototype.has = hashHas;
      Hash3.prototype.set = hashSet;
      module2.exports = Hash3;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheClear.js
  var require_listCacheClear = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheClear.js"(exports, module2) {
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      module2.exports = listCacheClear;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/eq.js
  var require_eq3 = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/eq.js"(exports, module2) {
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      module2.exports = eq;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assocIndexOf.js
  var require_assocIndexOf = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_assocIndexOf.js"(exports, module2) {
      var eq = require_eq3();
      function assocIndexOf(array2, key) {
        var length = array2.length;
        while (length--) {
          if (eq(array2[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      module2.exports = assocIndexOf;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheDelete.js
  var require_listCacheDelete = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheDelete.js"(exports, module2) {
      var assocIndexOf = require_assocIndexOf();
      var arrayProto = Array.prototype;
      var splice = arrayProto.splice;
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      module2.exports = listCacheDelete;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheGet.js
  var require_listCacheGet = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheGet.js"(exports, module2) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      module2.exports = listCacheGet;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheHas.js
  var require_listCacheHas = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheHas.js"(exports, module2) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      module2.exports = listCacheHas;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheSet.js
  var require_listCacheSet = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_listCacheSet.js"(exports, module2) {
      var assocIndexOf = require_assocIndexOf();
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      module2.exports = listCacheSet;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_ListCache.js
  var require_ListCache = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_ListCache.js"(exports, module2) {
      var listCacheClear = require_listCacheClear();
      var listCacheDelete = require_listCacheDelete();
      var listCacheGet = require_listCacheGet();
      var listCacheHas = require_listCacheHas();
      var listCacheSet = require_listCacheSet();
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      module2.exports = ListCache;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Map.js
  var require_Map = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Map.js"(exports, module2) {
      var getNative = require_getNative();
      var root = require_root();
      var Map2 = getNative(root, "Map");
      module2.exports = Map2;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheClear.js
  var require_mapCacheClear = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheClear.js"(exports, module2) {
      var Hash3 = require_Hash();
      var ListCache = require_ListCache();
      var Map2 = require_Map();
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash3(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash3()
        };
      }
      module2.exports = mapCacheClear;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKeyable.js
  var require_isKeyable = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isKeyable.js"(exports, module2) {
      function isKeyable(value) {
        var type3 = typeof value;
        return type3 == "string" || type3 == "number" || type3 == "symbol" || type3 == "boolean" ? value !== "__proto__" : value === null;
      }
      module2.exports = isKeyable;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMapData.js
  var require_getMapData = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMapData.js"(exports, module2) {
      var isKeyable = require_isKeyable();
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      module2.exports = getMapData;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheDelete.js
  var require_mapCacheDelete = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheDelete.js"(exports, module2) {
      var getMapData = require_getMapData();
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      module2.exports = mapCacheDelete;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheGet.js
  var require_mapCacheGet = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheGet.js"(exports, module2) {
      var getMapData = require_getMapData();
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      module2.exports = mapCacheGet;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheHas.js
  var require_mapCacheHas = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheHas.js"(exports, module2) {
      var getMapData = require_getMapData();
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      module2.exports = mapCacheHas;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheSet.js
  var require_mapCacheSet = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapCacheSet.js"(exports, module2) {
      var getMapData = require_getMapData();
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size = data.size;
        data.set(key, value);
        this.size += data.size == size ? 0 : 1;
        return this;
      }
      module2.exports = mapCacheSet;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_MapCache.js
  var require_MapCache = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_MapCache.js"(exports, module2) {
      var mapCacheClear = require_mapCacheClear();
      var mapCacheDelete = require_mapCacheDelete();
      var mapCacheGet = require_mapCacheGet();
      var mapCacheHas = require_mapCacheHas();
      var mapCacheSet = require_mapCacheSet();
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      module2.exports = MapCache;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/memoize.js
  var require_memoize = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/memoize.js"(exports, module2) {
      var MapCache = require_MapCache();
      var FUNC_ERROR_TEXT = "Expected a function";
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
          if (cache2.has(key)) {
            return cache2.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache2.set(key, result) || cache2;
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      module2.exports = memoize;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_memoizeCapped.js
  var require_memoizeCapped = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_memoizeCapped.js"(exports, module2) {
      var memoize = require_memoize();
      var MAX_MEMOIZE_SIZE = 500;
      function memoizeCapped(func) {
        var result = memoize(func, function(key) {
          if (cache2.size === MAX_MEMOIZE_SIZE) {
            cache2.clear();
          }
          return key;
        });
        var cache2 = result.cache;
        return result;
      }
      module2.exports = memoizeCapped;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToPath.js
  var require_stringToPath = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToPath.js"(exports, module2) {
      var memoizeCapped = require_memoizeCapped();
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = memoizeCapped(function(string2) {
        var result = [];
        if (string2.charCodeAt(0) === 46) {
          result.push("");
        }
        string2.replace(rePropName, function(match3, number4, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, "$1") : number4 || match3);
        });
        return result;
      });
      module2.exports = stringToPath;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayMap.js
  var require_arrayMap = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayMap.js"(exports, module2) {
      function arrayMap(array2, iteratee) {
        var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array2[index], index, array2);
        }
        return result;
      }
      module2.exports = arrayMap;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseToString.js
  var require_baseToString = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseToString.js"(exports, module2) {
      var Symbol2 = require_Symbol();
      var arrayMap = require_arrayMap();
      var isArray = require_isArray();
      var isSymbol = require_isSymbol();
      var INFINITY = 1 / 0;
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolToString2 = symbolProto ? symbolProto.toString : void 0;
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString2 ? symbolToString2.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      module2.exports = baseToString;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toString.js
  var require_toString = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/toString.js"(exports, module2) {
      var baseToString = require_baseToString();
      function toString3(value) {
        return value == null ? "" : baseToString(value);
      }
      module2.exports = toString3;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castPath.js
  var require_castPath = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castPath.js"(exports, module2) {
      var isArray = require_isArray();
      var isKey = require_isKey();
      var stringToPath = require_stringToPath();
      var toString3 = require_toString();
      function castPath(value, object2) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object2) ? [value] : stringToPath(toString3(value));
      }
      module2.exports = castPath;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsArguments.js
  var require_baseIsArguments = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsArguments.js"(exports, module2) {
      var baseGetTag = require_baseGetTag();
      var isObjectLike2 = require_isObjectLike2();
      var argsTag = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike2(value) && baseGetTag(value) == argsTag;
      }
      module2.exports = baseIsArguments;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArguments.js
  var require_isArguments = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArguments.js"(exports, module2) {
      var baseIsArguments = require_baseIsArguments();
      var isObjectLike2 = require_isObjectLike2();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike2(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      module2.exports = isArguments;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIndex.js
  var require_isIndex = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isIndex.js"(exports, module2) {
      var MAX_SAFE_INTEGER = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type3 = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type3 == "number" || type3 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      module2.exports = isIndex;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isLength.js
  var require_isLength = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isLength.js"(exports, module2) {
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      module2.exports = isLength;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toKey.js
  var require_toKey = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_toKey.js"(exports, module2) {
      var isSymbol = require_isSymbol();
      var INFINITY = 1 / 0;
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -INFINITY ? "-0" : result;
      }
      module2.exports = toKey;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasPath.js
  var require_hasPath = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasPath.js"(exports, module2) {
      var castPath = require_castPath();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var isIndex = require_isIndex();
      var isLength = require_isLength();
      var toKey = require_toKey();
      function hasPath(object2, path4, hasFunc) {
        path4 = castPath(path4, object2);
        var index = -1, length = path4.length, result = false;
        while (++index < length) {
          var key = toKey(path4[index]);
          if (!(result = object2 != null && hasFunc(object2, key))) {
            break;
          }
          object2 = object2[key];
        }
        if (result || ++index != length) {
          return result;
        }
        length = object2 == null ? 0 : object2.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object2) || isArguments(object2));
      }
      module2.exports = hasPath;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/has.js
  var require_has = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/has.js"(exports, module2) {
      var baseHas = require_baseHas();
      var hasPath = require_hasPath();
      function has4(object2, path4) {
        return object2 != null && hasPath(object2, path4, baseHas);
      }
      module2.exports = has4;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_defineProperty.js
  var require_defineProperty = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_defineProperty.js"(exports, module2) {
      var getNative = require_getNative();
      var defineProperty = function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      module2.exports = defineProperty;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignValue.js
  var require_baseAssignValue = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseAssignValue.js"(exports, module2) {
      var defineProperty = require_defineProperty();
      function baseAssignValue(object2, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object2, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object2[key] = value;
        }
      }
      module2.exports = baseAssignValue;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseFor.js
  var require_createBaseFor = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createBaseFor.js"(exports, module2) {
      function createBaseFor(fromRight) {
        return function(object2, iteratee, keysFunc) {
          var index = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object2;
        };
      }
      module2.exports = createBaseFor;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFor.js
  var require_baseFor = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseFor.js"(exports, module2) {
      var createBaseFor = require_createBaseFor();
      var baseFor = createBaseFor();
      module2.exports = baseFor;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTimes.js
  var require_baseTimes = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseTimes.js"(exports, module2) {
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      module2.exports = baseTimes;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubFalse.js
  var require_stubFalse = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubFalse.js"(exports, module2) {
      function stubFalse() {
        return false;
      }
      module2.exports = stubFalse;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isBuffer.js
  var require_isBuffer = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isBuffer.js"(exports, module2) {
      var root = require_root();
      var stubFalse = require_stubFalse();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root.Buffer : void 0;
      var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
      var isBuffer = nativeIsBuffer || stubFalse;
      module2.exports = isBuffer;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsTypedArray.js
  var require_baseIsTypedArray = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsTypedArray.js"(exports, module2) {
      var baseGetTag = require_baseGetTag();
      var isLength = require_isLength();
      var isObjectLike2 = require_isObjectLike2();
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var funcTag = "[object Function]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var objectTag = "[object Object]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var weakMapTag = "[object WeakMap]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var float32Tag = "[object Float32Array]";
      var float64Tag = "[object Float64Array]";
      var int8Tag = "[object Int8Array]";
      var int16Tag = "[object Int16Array]";
      var int32Tag = "[object Int32Array]";
      var uint8Tag = "[object Uint8Array]";
      var uint8ClampedTag = "[object Uint8ClampedArray]";
      var uint16Tag = "[object Uint16Array]";
      var uint32Tag = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      function baseIsTypedArray(value) {
        return isObjectLike2(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      module2.exports = baseIsTypedArray;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUnary.js
  var require_baseUnary = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseUnary.js"(exports, module2) {
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      module2.exports = baseUnary;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nodeUtil.js
  var require_nodeUtil = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nodeUtil.js"(exports, module2) {
      var freeGlobal = require_freeGlobal();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types2 = freeModule && freeModule.require && freeModule.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      module2.exports = nodeUtil;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isTypedArray.js
  var require_isTypedArray = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isTypedArray.js"(exports, module2) {
      var baseIsTypedArray = require_baseIsTypedArray();
      var baseUnary = require_baseUnary();
      var nodeUtil = require_nodeUtil();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      module2.exports = isTypedArray;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayLikeKeys.js
  var require_arrayLikeKeys = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayLikeKeys.js"(exports, module2) {
      var baseTimes = require_baseTimes();
      var isArguments = require_isArguments();
      var isArray = require_isArray();
      var isBuffer = require_isBuffer();
      var isIndex = require_isIndex();
      var isTypedArray = require_isTypedArray();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType2, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
          (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
          isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      module2.exports = arrayLikeKeys;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isPrototype.js
  var require_isPrototype = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isPrototype.js"(exports, module2) {
      var objectProto = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      module2.exports = isPrototype;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overArg.js
  var require_overArg = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_overArg.js"(exports, module2) {
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      module2.exports = overArg;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeys.js
  var require_nativeKeys = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_nativeKeys.js"(exports, module2) {
      var overArg = require_overArg();
      var nativeKeys = overArg(Object.keys, Object);
      module2.exports = nativeKeys;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeys.js
  var require_baseKeys = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseKeys.js"(exports, module2) {
      var isPrototype = require_isPrototype();
      var nativeKeys = require_nativeKeys();
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseKeys(object2) {
        if (!isPrototype(object2)) {
          return nativeKeys(object2);
        }
        var result = [];
        for (var key in Object(object2)) {
          if (hasOwnProperty.call(object2, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      module2.exports = baseKeys;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLike.js
  var require_isArrayLike = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/isArrayLike.js"(exports, module2) {
      var isFunction = require_isFunction();
      var isLength = require_isLength();
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      module2.exports = isArrayLike;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keys.js
  var require_keys = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/keys.js"(exports, module2) {
      var arrayLikeKeys = require_arrayLikeKeys();
      var baseKeys = require_baseKeys();
      var isArrayLike = require_isArrayLike();
      function keys4(object2) {
        return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
      }
      module2.exports = keys4;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseForOwn.js
  var require_baseForOwn = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseForOwn.js"(exports, module2) {
      var baseFor = require_baseFor();
      var keys4 = require_keys();
      function baseForOwn(object2, iteratee) {
        return object2 && baseFor(object2, iteratee, keys4);
      }
      module2.exports = baseForOwn;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackClear.js
  var require_stackClear = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackClear.js"(exports, module2) {
      var ListCache = require_ListCache();
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      module2.exports = stackClear;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackDelete.js
  var require_stackDelete = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackDelete.js"(exports, module2) {
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      module2.exports = stackDelete;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackGet.js
  var require_stackGet = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackGet.js"(exports, module2) {
      function stackGet(key) {
        return this.__data__.get(key);
      }
      module2.exports = stackGet;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackHas.js
  var require_stackHas = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackHas.js"(exports, module2) {
      function stackHas(key) {
        return this.__data__.has(key);
      }
      module2.exports = stackHas;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackSet.js
  var require_stackSet = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stackSet.js"(exports, module2) {
      var ListCache = require_ListCache();
      var Map2 = require_Map();
      var MapCache = require_MapCache();
      var LARGE_ARRAY_SIZE = 200;
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      module2.exports = stackSet;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Stack.js
  var require_Stack = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Stack.js"(exports, module2) {
      var ListCache = require_ListCache();
      var stackClear = require_stackClear();
      var stackDelete = require_stackDelete();
      var stackGet = require_stackGet();
      var stackHas = require_stackHas();
      var stackSet = require_stackSet();
      function Stack2(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      Stack2.prototype.clear = stackClear;
      Stack2.prototype["delete"] = stackDelete;
      Stack2.prototype.get = stackGet;
      Stack2.prototype.has = stackHas;
      Stack2.prototype.set = stackSet;
      module2.exports = Stack2;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheAdd.js
  var require_setCacheAdd = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheAdd.js"(exports, module2) {
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      module2.exports = setCacheAdd;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheHas.js
  var require_setCacheHas = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setCacheHas.js"(exports, module2) {
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      module2.exports = setCacheHas;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_SetCache.js
  var require_SetCache = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_SetCache.js"(exports, module2) {
      var MapCache = require_MapCache();
      var setCacheAdd = require_setCacheAdd();
      var setCacheHas = require_setCacheHas();
      function SetCache(values) {
        var index = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values[index]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      module2.exports = SetCache;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arraySome.js
  var require_arraySome = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arraySome.js"(exports, module2) {
      function arraySome(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        while (++index < length) {
          if (predicate(array2[index], index, array2)) {
            return true;
          }
        }
        return false;
      }
      module2.exports = arraySome;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cacheHas.js
  var require_cacheHas = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_cacheHas.js"(exports, module2) {
      function cacheHas(cache2, key) {
        return cache2.has(key);
      }
      module2.exports = cacheHas;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalArrays.js
  var require_equalArrays = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalArrays.js"(exports, module2) {
      var SetCache = require_SetCache();
      var arraySome = require_arraySome();
      var cacheHas = require_cacheHas();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array2);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array2;
        }
        var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
        stack.set(array2, other);
        stack.set(other, array2);
        while (++index < arrLength) {
          var arrValue = array2[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
          }
        }
        stack["delete"](array2);
        stack["delete"](other);
        return result;
      }
      module2.exports = equalArrays;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Uint8Array.js
  var require_Uint8Array = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Uint8Array.js"(exports, module2) {
      var root = require_root();
      var Uint8Array2 = root.Uint8Array;
      module2.exports = Uint8Array2;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapToArray.js
  var require_mapToArray = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_mapToArray.js"(exports, module2) {
      function mapToArray(map2) {
        var index = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      module2.exports = mapToArray;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToArray.js
  var require_setToArray = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_setToArray.js"(exports, module2) {
      function setToArray(set2) {
        var index = -1, result = Array(set2.size);
        set2.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      module2.exports = setToArray;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalByTag.js
  var require_equalByTag = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalByTag.js"(exports, module2) {
      var Symbol2 = require_Symbol();
      var Uint8Array2 = require_Uint8Array();
      var eq = require_eq3();
      var equalArrays = require_equalArrays();
      var mapToArray = require_mapToArray();
      var setToArray = require_setToArray();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      var boolTag = "[object Boolean]";
      var dateTag = "[object Date]";
      var errorTag = "[object Error]";
      var mapTag = "[object Map]";
      var numberTag = "[object Number]";
      var regexpTag = "[object RegExp]";
      var setTag = "[object Set]";
      var stringTag = "[object String]";
      var symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]";
      var dataViewTag = "[object DataView]";
      var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
      var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
              return false;
            }
            object2 = object2.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object2, +other);
          case errorTag:
            return object2.name == other.name && object2.message == other.message;
          case regexpTag:
          case stringTag:
            return object2 == other + "";
          case mapTag:
            var convert2 = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert2 || (convert2 = setToArray);
            if (object2.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object2);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object2, other);
            var result = equalArrays(convert2(object2), convert2(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object2);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object2) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      module2.exports = equalByTag;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayPush.js
  var require_arrayPush = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayPush.js"(exports, module2) {
      function arrayPush(array2, values) {
        var index = -1, length = values.length, offset = array2.length;
        while (++index < length) {
          array2[offset + index] = values[index];
        }
        return array2;
      }
      module2.exports = arrayPush;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetAllKeys.js
  var require_baseGetAllKeys = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGetAllKeys.js"(exports, module2) {
      var arrayPush = require_arrayPush();
      var isArray = require_isArray();
      function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
        var result = keysFunc(object2);
        return isArray(object2) ? result : arrayPush(result, symbolsFunc(object2));
      }
      module2.exports = baseGetAllKeys;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayFilter.js
  var require_arrayFilter = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayFilter.js"(exports, module2) {
      function arrayFilter(array2, predicate) {
        var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array2[index];
          if (predicate(value, index, array2)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      module2.exports = arrayFilter;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubArray.js
  var require_stubArray = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/stubArray.js"(exports, module2) {
      function stubArray() {
        return [];
      }
      module2.exports = stubArray;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbols.js
  var require_getSymbols = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getSymbols.js"(exports, module2) {
      var arrayFilter = require_arrayFilter();
      var stubArray = require_stubArray();
      var objectProto = Object.prototype;
      var propertyIsEnumerable = objectProto.propertyIsEnumerable;
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
        if (object2 == null) {
          return [];
        }
        object2 = Object(object2);
        return arrayFilter(nativeGetSymbols(object2), function(symbol) {
          return propertyIsEnumerable.call(object2, symbol);
        });
      };
      module2.exports = getSymbols;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeys.js
  var require_getAllKeys = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getAllKeys.js"(exports, module2) {
      var baseGetAllKeys = require_baseGetAllKeys();
      var getSymbols = require_getSymbols();
      var keys4 = require_keys();
      function getAllKeys(object2) {
        return baseGetAllKeys(object2, keys4, getSymbols);
      }
      module2.exports = getAllKeys;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalObjects.js
  var require_equalObjects = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_equalObjects.js"(exports, module2) {
      var getAllKeys = require_getAllKeys();
      var COMPARE_PARTIAL_FLAG = 1;
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object2);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object2;
        }
        var result = true;
        stack.set(object2, other);
        stack.set(other, object2);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object2[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object2.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack["delete"](object2);
        stack["delete"](other);
        return result;
      }
      module2.exports = equalObjects;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_DataView.js
  var require_DataView = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_DataView.js"(exports, module2) {
      var getNative = require_getNative();
      var root = require_root();
      var DataView2 = getNative(root, "DataView");
      module2.exports = DataView2;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Promise.js
  var require_Promise = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Promise.js"(exports, module2) {
      var getNative = require_getNative();
      var root = require_root();
      var Promise2 = getNative(root, "Promise");
      module2.exports = Promise2;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Set.js
  var require_Set = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_Set.js"(exports, module2) {
      var getNative = require_getNative();
      var root = require_root();
      var Set2 = getNative(root, "Set");
      module2.exports = Set2;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_WeakMap.js
  var require_WeakMap = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_WeakMap.js"(exports, module2) {
      var getNative = require_getNative();
      var root = require_root();
      var WeakMap2 = getNative(root, "WeakMap");
      module2.exports = WeakMap2;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getTag.js
  var require_getTag = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getTag.js"(exports, module2) {
      var DataView2 = require_DataView();
      var Map2 = require_Map();
      var Promise2 = require_Promise();
      var Set2 = require_Set();
      var WeakMap2 = require_WeakMap();
      var baseGetTag = require_baseGetTag();
      var toSource = require_toSource();
      var mapTag = "[object Map]";
      var objectTag = "[object Object]";
      var promiseTag = "[object Promise]";
      var setTag = "[object Set]";
      var weakMapTag = "[object WeakMap]";
      var dataViewTag = "[object DataView]";
      var dataViewCtorString = toSource(DataView2);
      var mapCtorString = toSource(Map2);
      var promiseCtorString = toSource(Promise2);
      var setCtorString = toSource(Set2);
      var weakMapCtorString = toSource(WeakMap2);
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result;
        };
      }
      module2.exports = getTag;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqualDeep.js
  var require_baseIsEqualDeep = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqualDeep.js"(exports, module2) {
      var Stack2 = require_Stack();
      var equalArrays = require_equalArrays();
      var equalByTag = require_equalByTag();
      var equalObjects = require_equalObjects();
      var getTag = require_getTag();
      var isArray = require_isArray();
      var isBuffer = require_isBuffer();
      var isTypedArray = require_isTypedArray();
      var COMPARE_PARTIAL_FLAG = 1;
      var argsTag = "[object Arguments]";
      var arrayTag = "[object Array]";
      var objectTag = "[object Object]";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object2), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object2)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack2());
          return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack2());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack2());
        return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
      }
      module2.exports = baseIsEqualDeep;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqual.js
  var require_baseIsEqual = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsEqual.js"(exports, module2) {
      var baseIsEqualDeep = require_baseIsEqualDeep();
      var isObjectLike2 = require_isObjectLike2();
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      module2.exports = baseIsEqual;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMatch.js
  var require_baseIsMatch = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIsMatch.js"(exports, module2) {
      var Stack2 = require_Stack();
      var baseIsEqual = require_baseIsEqual();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function baseIsMatch(object2, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object2 == null) {
          return !length;
        }
        object2 = Object(object2);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object2[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === void 0 && !(key in object2)) {
              return false;
            }
          } else {
            var stack = new Stack2();
            if (customizer) {
              var result = customizer(objValue, srcValue, key, object2, source, stack);
            }
            if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      module2.exports = baseIsMatch;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isStrictComparable.js
  var require_isStrictComparable = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_isStrictComparable.js"(exports, module2) {
      var isObject2 = require_isObject();
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      module2.exports = isStrictComparable;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMatchData.js
  var require_getMatchData = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_getMatchData.js"(exports, module2) {
      var isStrictComparable = require_isStrictComparable();
      var keys4 = require_keys();
      function getMatchData(object2) {
        var result = keys4(object2), length = result.length;
        while (length--) {
          var key = result[length], value = object2[key];
          result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
      }
      module2.exports = getMatchData;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_matchesStrictComparable.js
  var require_matchesStrictComparable = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_matchesStrictComparable.js"(exports, module2) {
      function matchesStrictComparable(key, srcValue) {
        return function(object2) {
          if (object2 == null) {
            return false;
          }
          return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
        };
      }
      module2.exports = matchesStrictComparable;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatches.js
  var require_baseMatches = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatches.js"(exports, module2) {
      var baseIsMatch = require_baseIsMatch();
      var getMatchData = require_getMatchData();
      var matchesStrictComparable = require_matchesStrictComparable();
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object2) {
          return object2 === source || baseIsMatch(object2, source, matchData);
        };
      }
      module2.exports = baseMatches;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGet.js
  var require_baseGet = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseGet.js"(exports, module2) {
      var castPath = require_castPath();
      var toKey = require_toKey();
      function baseGet(object2, path4) {
        path4 = castPath(path4, object2);
        var index = 0, length = path4.length;
        while (object2 != null && index < length) {
          object2 = object2[toKey(path4[index++])];
        }
        return index && index == length ? object2 : void 0;
      }
      module2.exports = baseGet;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/get.js
  var require_get = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/get.js"(exports, module2) {
      var baseGet = require_baseGet();
      function get(object2, path4, defaultValue) {
        var result = object2 == null ? void 0 : baseGet(object2, path4);
        return result === void 0 ? defaultValue : result;
      }
      module2.exports = get;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHasIn.js
  var require_baseHasIn = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseHasIn.js"(exports, module2) {
      function baseHasIn(object2, key) {
        return object2 != null && key in Object(object2);
      }
      module2.exports = baseHasIn;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/hasIn.js
  var require_hasIn = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/hasIn.js"(exports, module2) {
      var baseHasIn = require_baseHasIn();
      var hasPath = require_hasPath();
      function hasIn(object2, path4) {
        return object2 != null && hasPath(object2, path4, baseHasIn);
      }
      module2.exports = hasIn;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatchesProperty.js
  var require_baseMatchesProperty = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseMatchesProperty.js"(exports, module2) {
      var baseIsEqual = require_baseIsEqual();
      var get = require_get();
      var hasIn = require_hasIn();
      var isKey = require_isKey();
      var isStrictComparable = require_isStrictComparable();
      var matchesStrictComparable = require_matchesStrictComparable();
      var toKey = require_toKey();
      var COMPARE_PARTIAL_FLAG = 1;
      var COMPARE_UNORDERED_FLAG = 2;
      function baseMatchesProperty(path4, srcValue) {
        if (isKey(path4) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path4), srcValue);
        }
        return function(object2) {
          var objValue = get(object2, path4);
          return objValue === void 0 && objValue === srcValue ? hasIn(object2, path4) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      module2.exports = baseMatchesProperty;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/identity.js
  var require_identity = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/identity.js"(exports, module2) {
      function identity2(value) {
        return value;
      }
      module2.exports = identity2;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseProperty.js
  var require_baseProperty = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseProperty.js"(exports, module2) {
      function baseProperty(key) {
        return function(object2) {
          return object2 == null ? void 0 : object2[key];
        };
      }
      module2.exports = baseProperty;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePropertyDeep.js
  var require_basePropertyDeep = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePropertyDeep.js"(exports, module2) {
      var baseGet = require_baseGet();
      function basePropertyDeep(path4) {
        return function(object2) {
          return baseGet(object2, path4);
        };
      }
      module2.exports = basePropertyDeep;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/property.js
  var require_property = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/property.js"(exports, module2) {
      var baseProperty = require_baseProperty();
      var basePropertyDeep = require_basePropertyDeep();
      var isKey = require_isKey();
      var toKey = require_toKey();
      function property(path4) {
        return isKey(path4) ? baseProperty(toKey(path4)) : basePropertyDeep(path4);
      }
      module2.exports = property;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIteratee.js
  var require_baseIteratee = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseIteratee.js"(exports, module2) {
      var baseMatches = require_baseMatches();
      var baseMatchesProperty = require_baseMatchesProperty();
      var identity2 = require_identity();
      var isArray = require_isArray();
      var property = require_property();
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity2;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      module2.exports = baseIteratee;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/mapValues.js
  var require_mapValues = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/mapValues.js"(exports, module2) {
      var baseAssignValue = require_baseAssignValue();
      var baseForOwn = require_baseForOwn();
      var baseIteratee = require_baseIteratee();
      function mapValues3(object2, iteratee) {
        var result = {};
        iteratee = baseIteratee(iteratee, 3);
        baseForOwn(object2, function(value, key, object3) {
          baseAssignValue(result, key, iteratee(value, key, object3));
        });
        return result;
      }
      module2.exports = mapValues3;
    }
  });

  // ../../node_modules/.pnpm/property-expr@2.0.5/node_modules/property-expr/index.js
  var require_property_expr = __commonJS({
    "../../node_modules/.pnpm/property-expr@2.0.5/node_modules/property-expr/index.js"(exports, module2) {
      "use strict";
      function Cache(maxSize) {
        this._maxSize = maxSize;
        this.clear();
      }
      Cache.prototype.clear = function() {
        this._size = 0;
        this._values = /* @__PURE__ */ Object.create(null);
      };
      Cache.prototype.get = function(key) {
        return this._values[key];
      };
      Cache.prototype.set = function(key, value) {
        this._size >= this._maxSize && this.clear();
        if (!(key in this._values))
          this._size++;
        return this._values[key] = value;
      };
      var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g;
      var DIGIT_REGEX = /^\d+$/;
      var LEAD_DIGIT_REGEX = /^\d/;
      var SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g;
      var CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/;
      var MAX_CACHE_SIZE = 512;
      var pathCache = new Cache(MAX_CACHE_SIZE);
      var setCache = new Cache(MAX_CACHE_SIZE);
      var getCache = new Cache(MAX_CACHE_SIZE);
      module2.exports = {
        Cache,
        split: split4,
        normalizePath,
        setter: function(path4) {
          var parts = normalizePath(path4);
          return setCache.get(path4) || setCache.set(path4, function setter(obj, value) {
            var index = 0;
            var len = parts.length;
            var data = obj;
            while (index < len - 1) {
              var part = parts[index];
              if (part === "__proto__" || part === "constructor" || part === "prototype") {
                return obj;
              }
              data = data[parts[index++]];
            }
            data[parts[index]] = value;
          });
        },
        getter: function(path4, safe) {
          var parts = normalizePath(path4);
          return getCache.get(path4) || getCache.set(path4, function getter3(data) {
            var index = 0, len = parts.length;
            while (index < len) {
              if (data != null || !safe)
                data = data[parts[index++]];
              else
                return;
            }
            return data;
          });
        },
        join: function(segments) {
          return segments.reduce(function(path4, part) {
            return path4 + (isQuoted(part) || DIGIT_REGEX.test(part) ? "[" + part + "]" : (path4 ? "." : "") + part);
          }, "");
        },
        forEach: function(path4, cb, thisArg) {
          forEach2(Array.isArray(path4) ? path4 : split4(path4), cb, thisArg);
        }
      };
      function normalizePath(path4) {
        return pathCache.get(path4) || pathCache.set(
          path4,
          split4(path4).map(function(part) {
            return part.replace(CLEAN_QUOTES_REGEX, "$2");
          })
        );
      }
      function split4(path4) {
        return path4.match(SPLIT_REGEX) || [""];
      }
      function forEach2(parts, iter, thisArg) {
        var len = parts.length, part, idx, isArray, isBracket;
        for (idx = 0; idx < len; idx++) {
          part = parts[idx];
          if (part) {
            if (shouldBeQuoted(part)) {
              part = '"' + part + '"';
            }
            isBracket = isQuoted(part);
            isArray = !isBracket && /^\d+$/.test(part);
            iter.call(thisArg, part, isBracket, isArray, idx, parts);
          }
        }
      }
      function isQuoted(str) {
        return typeof str === "string" && str && ["'", '"'].indexOf(str.charAt(0)) !== -1;
      }
      function hasLeadingNumber(part) {
        return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX);
      }
      function hasSpecialChars(part) {
        return SPEC_CHAR_REGEX.test(part);
      }
      function shouldBeQuoted(part) {
        return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part));
      }
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayReduce.js
  var require_arrayReduce = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_arrayReduce.js"(exports, module2) {
      function arrayReduce(array2, iteratee, accumulator, initAccum) {
        var index = -1, length = array2 == null ? 0 : array2.length;
        if (initAccum && length) {
          accumulator = array2[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array2[index], index, array2);
        }
        return accumulator;
      }
      module2.exports = arrayReduce;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePropertyOf.js
  var require_basePropertyOf = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_basePropertyOf.js"(exports, module2) {
      function basePropertyOf(object2) {
        return function(key) {
          return object2 == null ? void 0 : object2[key];
        };
      }
      module2.exports = basePropertyOf;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_deburrLetter.js
  var require_deburrLetter = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_deburrLetter.js"(exports, module2) {
      var basePropertyOf = require_basePropertyOf();
      var deburredLetters = {
        // Latin-1 Supplement block.
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        // Latin Extended-A block.
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var deburrLetter = basePropertyOf(deburredLetters);
      module2.exports = deburrLetter;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/deburr.js
  var require_deburr = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/deburr.js"(exports, module2) {
      var deburrLetter = require_deburrLetter();
      var toString3 = require_toString();
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var rsComboMarksRange = "\\u0300-\\u036f";
      var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange = "\\u20d0-\\u20ff";
      var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
      var rsCombo = "[" + rsComboRange + "]";
      var reComboMark = RegExp(rsCombo, "g");
      function deburr(string2) {
        string2 = toString3(string2);
        return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      module2.exports = deburr;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_asciiWords.js
  var require_asciiWords = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_asciiWords.js"(exports, module2) {
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      function asciiWords(string2) {
        return string2.match(reAsciiWord) || [];
      }
      module2.exports = asciiWords;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasUnicodeWord.js
  var require_hasUnicodeWord = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasUnicodeWord.js"(exports, module2) {
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      function hasUnicodeWord(string2) {
        return reHasUnicodeWord.test(string2);
      }
      module2.exports = hasUnicodeWord;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_unicodeWords.js
  var require_unicodeWords = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_unicodeWords.js"(exports, module2) {
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f";
      var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange = "\\u20d0-\\u20ff";
      var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
      var rsDingbatRange = "\\u2700-\\u27bf";
      var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
      var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
      var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
      var rsPunctuationRange = "\\u2000-\\u206f";
      var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
      var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]";
      var rsBreak = "[" + rsBreakRange + "]";
      var rsCombo = "[" + rsComboRange + "]";
      var rsDigits = "\\d+";
      var rsDingbat = "[" + rsDingbatRange + "]";
      var rsLower = "[" + rsLowerRange + "]";
      var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
      var rsFitz = "\\ud83c[\\udffb-\\udfff]";
      var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
      var rsNonAstral = "[^" + rsAstralRange + "]";
      var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
      var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
      var rsUpper = "[" + rsUpperRange + "]";
      var rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
      var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
      var rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
      var rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
      var reOptMod = rsModifier + "?";
      var rsOptVar = "[" + rsVarRange + "]?";
      var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
      var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
      var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
      var rsSeq = rsOptVar + reOptMod + rsOptJoin;
      var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      function unicodeWords(string2) {
        return string2.match(reUnicodeWord) || [];
      }
      module2.exports = unicodeWords;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/words.js
  var require_words = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/words.js"(exports, module2) {
      var asciiWords = require_asciiWords();
      var hasUnicodeWord = require_hasUnicodeWord();
      var toString3 = require_toString();
      var unicodeWords = require_unicodeWords();
      function words(string2, pattern, guard) {
        string2 = toString3(string2);
        pattern = guard ? void 0 : pattern;
        if (pattern === void 0) {
          return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
        }
        return string2.match(pattern) || [];
      }
      module2.exports = words;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createCompounder.js
  var require_createCompounder = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createCompounder.js"(exports, module2) {
      var arrayReduce = require_arrayReduce();
      var deburr = require_deburr();
      var words = require_words();
      var rsApos = "['\u2019]";
      var reApos = RegExp(rsApos, "g");
      function createCompounder(callback) {
        return function(string2) {
          return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
        };
      }
      module2.exports = createCompounder;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/snakeCase.js
  var require_snakeCase = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/snakeCase.js"(exports, module2) {
      var createCompounder = require_createCompounder();
      var snakeCase2 = createCompounder(function(result, word, index) {
        return result + (index ? "_" : "") + word.toLowerCase();
      });
      module2.exports = snakeCase2;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSlice.js
  var require_baseSlice = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_baseSlice.js"(exports, module2) {
      function baseSlice(array2, start, end) {
        var index = -1, length = array2.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result = Array(length);
        while (++index < length) {
          result[index] = array2[index + start];
        }
        return result;
      }
      module2.exports = baseSlice;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castSlice.js
  var require_castSlice = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_castSlice.js"(exports, module2) {
      var baseSlice = require_baseSlice();
      function castSlice(array2, start, end) {
        var length = array2.length;
        end = end === void 0 ? length : end;
        return !start && end >= length ? array2 : baseSlice(array2, start, end);
      }
      module2.exports = castSlice;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasUnicode.js
  var require_hasUnicode = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_hasUnicode.js"(exports, module2) {
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f";
      var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange = "\\u20d0-\\u20ff";
      var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsZWJ = "\\u200d";
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      function hasUnicode(string2) {
        return reHasUnicode.test(string2);
      }
      module2.exports = hasUnicode;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_asciiToArray.js
  var require_asciiToArray = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_asciiToArray.js"(exports, module2) {
      function asciiToArray(string2) {
        return string2.split("");
      }
      module2.exports = asciiToArray;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_unicodeToArray.js
  var require_unicodeToArray = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_unicodeToArray.js"(exports, module2) {
      var rsAstralRange = "\\ud800-\\udfff";
      var rsComboMarksRange = "\\u0300-\\u036f";
      var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
      var rsComboSymbolsRange = "\\u20d0-\\u20ff";
      var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
      var rsVarRange = "\\ufe0e\\ufe0f";
      var rsAstral = "[" + rsAstralRange + "]";
      var rsCombo = "[" + rsComboRange + "]";
      var rsFitz = "\\ud83c[\\udffb-\\udfff]";
      var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
      var rsNonAstral = "[^" + rsAstralRange + "]";
      var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
      var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
      var rsZWJ = "\\u200d";
      var reOptMod = rsModifier + "?";
      var rsOptVar = "[" + rsVarRange + "]?";
      var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
      var rsSeq = rsOptVar + reOptMod + rsOptJoin;
      var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      function unicodeToArray(string2) {
        return string2.match(reUnicode) || [];
      }
      module2.exports = unicodeToArray;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToArray.js
  var require_stringToArray = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_stringToArray.js"(exports, module2) {
      var asciiToArray = require_asciiToArray();
      var hasUnicode = require_hasUnicode();
      var unicodeToArray = require_unicodeToArray();
      function stringToArray(string2) {
        return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
      }
      module2.exports = stringToArray;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createCaseFirst.js
  var require_createCaseFirst = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/_createCaseFirst.js"(exports, module2) {
      var castSlice = require_castSlice();
      var hasUnicode = require_hasUnicode();
      var stringToArray = require_stringToArray();
      var toString3 = require_toString();
      function createCaseFirst(methodName) {
        return function(string2) {
          string2 = toString3(string2);
          var strSymbols = hasUnicode(string2) ? stringToArray(string2) : void 0;
          var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      module2.exports = createCaseFirst;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/upperFirst.js
  var require_upperFirst = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/upperFirst.js"(exports, module2) {
      var createCaseFirst = require_createCaseFirst();
      var upperFirst3 = createCaseFirst("toUpperCase");
      module2.exports = upperFirst3;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/capitalize.js
  var require_capitalize = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/capitalize.js"(exports, module2) {
      var toString3 = require_toString();
      var upperFirst3 = require_upperFirst();
      function capitalize(string2) {
        return upperFirst3(toString3(string2).toLowerCase());
      }
      module2.exports = capitalize;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/camelCase.js
  var require_camelCase = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/camelCase.js"(exports, module2) {
      var capitalize = require_capitalize();
      var createCompounder = require_createCompounder();
      var camelCase3 = createCompounder(function(result, word, index) {
        word = word.toLowerCase();
        return result + (index ? capitalize(word) : word);
      });
      module2.exports = camelCase3;
    }
  });

  // ../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/mapKeys.js
  var require_mapKeys = __commonJS({
    "../../node_modules/.pnpm/lodash@4.17.21/node_modules/lodash/mapKeys.js"(exports, module2) {
      var baseAssignValue = require_baseAssignValue();
      var baseForOwn = require_baseForOwn();
      var baseIteratee = require_baseIteratee();
      function mapKeys2(object2, iteratee) {
        var result = {};
        iteratee = baseIteratee(iteratee, 3);
        baseForOwn(object2, function(value, key, object3) {
          baseAssignValue(result, iteratee(value, key, object3), value);
        });
        return result;
      }
      module2.exports = mapKeys2;
    }
  });

  // ../../node_modules/.pnpm/toposort@2.0.2/node_modules/toposort/index.js
  var require_toposort = __commonJS({
    "../../node_modules/.pnpm/toposort@2.0.2/node_modules/toposort/index.js"(exports, module2) {
      module2.exports = function(edges) {
        return toposort2(uniqueNodes(edges), edges);
      };
      module2.exports.array = toposort2;
      function toposort2(nodes, edges) {
        var cursor = nodes.length, sorted = new Array(cursor), visited = {}, i = cursor, outgoingEdges = makeOutgoingEdges(edges), nodesHash = makeNodesHash(nodes);
        edges.forEach(function(edge) {
          if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
            throw new Error("Unknown node. There is an unknown node in the supplied edges.");
          }
        });
        while (i--) {
          if (!visited[i])
            visit2(nodes[i], i, /* @__PURE__ */ new Set());
        }
        return sorted;
        function visit2(node, i2, predecessors) {
          if (predecessors.has(node)) {
            var nodeRep;
            try {
              nodeRep = ", node was:" + JSON.stringify(node);
            } catch (e) {
              nodeRep = "";
            }
            throw new Error("Cyclic dependency" + nodeRep);
          }
          if (!nodesHash.has(node)) {
            throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(node));
          }
          if (visited[i2])
            return;
          visited[i2] = true;
          var outgoing = outgoingEdges.get(node) || /* @__PURE__ */ new Set();
          outgoing = Array.from(outgoing);
          if (i2 = outgoing.length) {
            predecessors.add(node);
            do {
              var child = outgoing[--i2];
              visit2(child, nodesHash.get(child), predecessors);
            } while (i2);
            predecessors.delete(node);
          }
          sorted[--cursor] = node;
        }
      }
      function uniqueNodes(arr) {
        var res = /* @__PURE__ */ new Set();
        for (var i = 0, len = arr.length; i < len; i++) {
          var edge = arr[i];
          res.add(edge[0]);
          res.add(edge[1]);
        }
        return Array.from(res);
      }
      function makeOutgoingEdges(arr) {
        var edges = /* @__PURE__ */ new Map();
        for (var i = 0, len = arr.length; i < len; i++) {
          var edge = arr[i];
          if (!edges.has(edge[0]))
            edges.set(edge[0], /* @__PURE__ */ new Set());
          if (!edges.has(edge[1]))
            edges.set(edge[1], /* @__PURE__ */ new Set());
          edges.get(edge[0]).add(edge[1]);
        }
        return edges;
      }
      function makeNodesHash(arr) {
        var res = /* @__PURE__ */ new Map();
        for (var i = 0, len = arr.length; i < len; i++) {
          res.set(arr[i], i);
        }
        return res;
      }
    }
  });

  // ../versions/dist/index.mjs
  var import_semver = __toESM(require_semver2(), 1);
  function getBuiltinVersions() {
    return {
      FORC: "0.46.1",
      FUEL_CORE: "0.20.8",
      FUELS: "0.69.1"
    };
  }
  function checkFuelCoreVersionCompatibility(networkVersion) {
    const { FUEL_CORE: supportedVersion } = getBuiltinVersions();
    const networkMajor = import_semver.default.major(networkVersion);
    const networkMinor = import_semver.default.minor(networkVersion);
    const networkPatch = import_semver.default.patch(networkVersion);
    const supportedMajor = import_semver.default.major(supportedVersion);
    const supportedMinor = import_semver.default.minor(supportedVersion);
    const supportedPatch = import_semver.default.patch(supportedVersion);
    return {
      supportedVersion,
      isMajorSupported: networkMajor === supportedMajor,
      isMinorSupported: networkMinor === supportedMinor,
      isPatchSupported: networkPatch === supportedPatch
    };
  }
  var versions = getBuiltinVersions();

  // ../../node_modules/.pnpm/commander@9.4.1/node_modules/commander/esm.mjs
  var import_index = __toESM(require_commander(), 1);
  var {
    program,
    createCommand,
    createArgument,
    createOption,
    CommanderError,
    InvalidArgumentError,
    InvalidOptionArgumentError,
    // deprecated old name
    Command,
    Argument,
    Option,
    Help
  } = import_index.default;

  // ../errors/dist/index.mjs
  var __defProp2 = Object.defineProperty;
  var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField2 = (obj, key, value) => {
    __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var ErrorCode = /* @__PURE__ */ ((ErrorCode22) => {
    ErrorCode22["NO_ABIS_FOUND"] = "no-abis-found";
    ErrorCode22["ABI_TYPES_AND_VALUES_MISMATCH"] = "abi-types-and-values-mismatch";
    ErrorCode22["ABI_MAIN_METHOD_MISSING"] = "abi-main-method-missing";
    ErrorCode22["INVALID_COMPONENT"] = "invalid-component";
    ErrorCode22["FRAGMENT_NOT_FOUND"] = "fragment-not-found";
    ErrorCode22["CONFIGURABLE_NOT_FOUND"] = "configurable-not-found";
    ErrorCode22["TYPE_NOT_FOUND"] = "type-not-found";
    ErrorCode22["TYPE_NOT_SUPPORTED"] = "type-not-supported";
    ErrorCode22["INVALID_DECODE_VALUE"] = "invalid-decode-value";
    ErrorCode22["JSON_ABI_ERROR"] = "json-abi-error";
    ErrorCode22["TYPE_ID_NOT_FOUND"] = "type-id-not-found";
    ErrorCode22["BIN_FILE_NOT_FOUND"] = "bin-file-not-found";
    ErrorCode22["CODER_NOT_FOUND"] = "coder-not-found";
    ErrorCode22["INVALID_DATA"] = "invalid-data";
    ErrorCode22["FUNCTION_NOT_FOUND"] = "function-not-found";
    ErrorCode22["INVALID_BECH32_ADDRESS"] = "invalid-bech32-address";
    ErrorCode22["INVALID_EVM_ADDRESS"] = "invalid-evm-address";
    ErrorCode22["INVALID_B256_ADDRESS"] = "invalid-b256-address";
    ErrorCode22["INVALID_URL"] = "invalid-url";
    ErrorCode22["CHAIN_INFO_CACHE_EMPTY"] = "chain-info-cache-empty";
    ErrorCode22["NODE_INFO_CACHE_EMPTY"] = "node-info-cache-empty";
    ErrorCode22["MISSING_PROVIDER"] = "missing-provider";
    ErrorCode22["INVALID_PUBLIC_KEY"] = "invalid-public-key";
    ErrorCode22["INSUFFICIENT_BALANCE"] = "insufficient-balance";
    ErrorCode22["WALLET_MANAGER_ERROR"] = "wallet-manager-error";
    ErrorCode22["HD_WALLET_ERROR"] = "hd-wallet-error";
    ErrorCode22["PARSE_FAILED"] = "parse-failed";
    ErrorCode22["ENCODE_ERROR"] = "encode-error";
    ErrorCode22["DECODE_ERROR"] = "decode-error";
    ErrorCode22["INVALID_CREDENTIALS"] = "invalid-credentials";
    ErrorCode22["ENV_DEPENDENCY_MISSING"] = "env-dependency-missing";
    ErrorCode22["INVALID_TTL"] = "invalid-ttl";
    ErrorCode22["INVALID_INPUT_PARAMETERS"] = "invalid-input-parameters";
    ErrorCode22["NOT_IMPLEMENTED"] = "not-implemented";
    ErrorCode22["NOT_SUPPORTED"] = "not-supported";
    ErrorCode22["CONVERTING_FAILED"] = "converting-error";
    ErrorCode22["ELEMENT_NOT_FOUND"] = "element-not-found";
    ErrorCode22["MISSING_REQUIRED_PARAMETER"] = "missing-required-parameter";
    ErrorCode22["UNEXPECTED_HEX_VALUE"] = "unexpected-hex-value";
    ErrorCode22["GAS_PRICE_TOO_LOW"] = "gas-price-too-low";
    ErrorCode22["GAS_LIMIT_TOO_LOW"] = "gas-limit-too-low";
    ErrorCode22["TRANSACTION_NOT_FOUND"] = "transaction-not-found";
    ErrorCode22["TRANSACTION_FAILED"] = "transaction-failed";
    ErrorCode22["INVALID_CONFIGURABLE_CONSTANTS"] = "invalid-configurable-constants";
    ErrorCode22["INVALID_TRANSACTION_INPUT"] = "invalid-transaction-input";
    ErrorCode22["INVALID_TRANSACTION_OUTPUT"] = "invalid-transaction-output";
    ErrorCode22["INVALID_TRANSACTION_STATUS"] = "invalid-transaction-status";
    ErrorCode22["INVALID_TRANSACTION_TYPE"] = "invalid-transaction-type";
    ErrorCode22["TRANSACTION_ERROR"] = "transaction-error";
    ErrorCode22["INVALID_RECEIPT_TYPE"] = "invalid-receipt-type";
    ErrorCode22["INVALID_WORD_LIST"] = "invalid-word-list";
    ErrorCode22["INVALID_MNEMONIC"] = "invalid-mnemonic";
    ErrorCode22["INVALID_ENTROPY"] = "invalid-entropy";
    ErrorCode22["INVALID_SEED"] = "invalid-seed";
    ErrorCode22["INVALID_CHECKSUM"] = "invalid-checksum";
    ErrorCode22["INVALID_PASSWORD"] = "invalid-password";
    ErrorCode22["ACCOUNT_REQUIRED"] = "account-required";
    ErrorCode22["LATEST_BLOCK_UNAVAILABLE"] = "latest-block-unavailable";
    ErrorCode22["ERROR_BUILDING_BLOCK_EXPLORER_URL"] = "error-building-block-explorer-url";
    ErrorCode22["UNSUPPORTED_FUEL_CLIENT_VERSION"] = "unsupported-fuel-client-version";
    ErrorCode22["VITEPRESS_PLUGIN_ERROR"] = "vitepress-plugin-error";
    ErrorCode22["INVALID_MULTICALL"] = "invalid-multicall";
    ErrorCode22["SCRIPT_REVERTED"] = "script-reverted";
    ErrorCode22["SCRIPT_RETURN_INVALID_TYPE"] = "script-return-invalid-type";
    return ErrorCode22;
  })(ErrorCode || {});
  var _FuelError = class extends Error {
    VERSIONS = versions;
    static parse(e) {
      const error2 = e;
      if (error2.code === void 0) {
        throw new _FuelError(
          "parse-failed",
          "Failed to parse the error object. The required 'code' property is missing."
        );
      }
      const enumValues = Object.values(ErrorCode);
      const codeIsKnown = enumValues.includes(error2.code);
      if (!codeIsKnown) {
        throw new _FuelError(
          "parse-failed",
          `Unknown error code: ${error2.code}. Accepted codes: ${enumValues.join(", ")}.`
        );
      }
      return new _FuelError(error2.code, error2.message);
    }
    code;
    constructor(code, message) {
      super(message);
      this.code = code;
      this.name = "FuelError";
    }
    toObject() {
      const { code, name, message, VERSIONS } = this;
      return { code, name, message, VERSIONS };
    }
  };
  var FuelError = _FuelError;
  __publicField2(FuelError, "CODES", ErrorCode);

  // ../abi-typegen/dist/cli.mjs
  var import_fs2 = __require2("fs");

  // ../../node_modules/.pnpm/minimatch@9.0.2/node_modules/minimatch/dist/mjs/index.js
  var import_brace_expansion = __toESM(require_brace_expansion(), 1);

  // ../../node_modules/.pnpm/minimatch@9.0.2/node_modules/minimatch/dist/mjs/assert-valid-pattern.js
  var MAX_PATTERN_LENGTH = 1024 * 64;
  var assertValidPattern = (pattern) => {
    if (typeof pattern !== "string") {
      throw new TypeError("invalid pattern");
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
      throw new TypeError("pattern is too long");
    }
  };

  // ../../node_modules/.pnpm/minimatch@9.0.2/node_modules/minimatch/dist/mjs/brace-expressions.js
  var posixClasses = {
    "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
    "[:alpha:]": ["\\p{L}\\p{Nl}", true],
    "[:ascii:]": ["\\x00-\\x7f", false],
    "[:blank:]": ["\\p{Zs}\\t", true],
    "[:cntrl:]": ["\\p{Cc}", true],
    "[:digit:]": ["\\p{Nd}", true],
    "[:graph:]": ["\\p{Z}\\p{C}", true, true],
    "[:lower:]": ["\\p{Ll}", true],
    "[:print:]": ["\\p{C}", true],
    "[:punct:]": ["\\p{P}", true],
    "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
    "[:upper:]": ["\\p{Lu}", true],
    "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
    "[:xdigit:]": ["A-Fa-f0-9", false]
  };
  var braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
  var regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  var rangesToString = (ranges) => ranges.join("");
  var parseClass = (glob2, position) => {
    const pos = position;
    if (glob2.charAt(pos) !== "[") {
      throw new Error("not in a brace expression");
    }
    const ranges = [];
    const negs = [];
    let i = pos + 1;
    let sawStart = false;
    let uflag = false;
    let escaping = false;
    let negate = false;
    let endPos = pos;
    let rangeStart = "";
    WHILE:
      while (i < glob2.length) {
        const c = glob2.charAt(i);
        if ((c === "!" || c === "^") && i === pos + 1) {
          negate = true;
          i++;
          continue;
        }
        if (c === "]" && sawStart && !escaping) {
          endPos = i + 1;
          break;
        }
        sawStart = true;
        if (c === "\\") {
          if (!escaping) {
            escaping = true;
            i++;
            continue;
          }
        }
        if (c === "[" && !escaping) {
          for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
            if (glob2.startsWith(cls, i)) {
              if (rangeStart) {
                return ["$.", false, glob2.length - pos, true];
              }
              i += cls.length;
              if (neg)
                negs.push(unip);
              else
                ranges.push(unip);
              uflag = uflag || u;
              continue WHILE;
            }
          }
        }
        escaping = false;
        if (rangeStart) {
          if (c > rangeStart) {
            ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
          } else if (c === rangeStart) {
            ranges.push(braceEscape(c));
          }
          rangeStart = "";
          i++;
          continue;
        }
        if (glob2.startsWith("-]", i + 1)) {
          ranges.push(braceEscape(c + "-"));
          i += 2;
          continue;
        }
        if (glob2.startsWith("-", i + 1)) {
          rangeStart = c;
          i += 2;
          continue;
        }
        ranges.push(braceEscape(c));
        i++;
      }
    if (endPos < i) {
      return ["", false, 0, false];
    }
    if (!ranges.length && !negs.length) {
      return ["$.", false, glob2.length - pos, true];
    }
    if (negs.length === 0 && ranges.length === 1 && /^\\?.$/.test(ranges[0]) && !negate) {
      const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
      return [regexpEscape(r), false, endPos - pos, false];
    }
    const sranges = "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
    const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
    const comb = ranges.length && negs.length ? "(" + sranges + "|" + snegs + ")" : ranges.length ? sranges : snegs;
    return [comb, uflag, endPos - pos, true];
  };

  // ../../node_modules/.pnpm/minimatch@9.0.2/node_modules/minimatch/dist/mjs/unescape.js
  var unescape = (s, { windowsPathsNoEscape = false } = {}) => {
    return windowsPathsNoEscape ? s.replace(/\[([^\/\\])\]/g, "$1") : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2").replace(/\\([^\/])/g, "$1");
  };

  // ../../node_modules/.pnpm/minimatch@9.0.2/node_modules/minimatch/dist/mjs/ast.js
  var types = /* @__PURE__ */ new Set(["!", "?", "+", "*", "@"]);
  var isExtglobType = (c) => types.has(c);
  var startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
  var startNoDot = "(?!\\.)";
  var addPatternStart = /* @__PURE__ */ new Set(["[", "."]);
  var justDots = /* @__PURE__ */ new Set(["..", "."]);
  var reSpecials = new Set("().*{}+?[]^$\\!");
  var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  var qmark = "[^/]";
  var star = qmark + "*?";
  var starNoEmpty = qmark + "+?";
  var _root, _hasMagic, _uflag, _parts, _parent, _parentIndex, _negs, _filledNegs, _options, _toString, _emptyExt, _fillNegs, fillNegs_fn, _parseAST, parseAST_fn, _partsToRegExp, partsToRegExp_fn, _parseGlob, parseGlob_fn;
  var _AST = class {
    constructor(type3, parent, options = {}) {
      __privateAdd(this, _fillNegs);
      __privateAdd(this, _partsToRegExp);
      __publicField(this, "type");
      __privateAdd(this, _root, void 0);
      __privateAdd(this, _hasMagic, void 0);
      __privateAdd(this, _uflag, false);
      __privateAdd(this, _parts, []);
      __privateAdd(this, _parent, void 0);
      __privateAdd(this, _parentIndex, void 0);
      __privateAdd(this, _negs, void 0);
      __privateAdd(this, _filledNegs, false);
      __privateAdd(this, _options, void 0);
      __privateAdd(this, _toString, void 0);
      // set to true if it's an extglob with no children
      // (which really means one child of '')
      __privateAdd(this, _emptyExt, false);
      this.type = type3;
      if (type3)
        __privateSet(this, _hasMagic, true);
      __privateSet(this, _parent, parent);
      __privateSet(this, _root, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _root) : this);
      __privateSet(this, _options, __privateGet(this, _root) === this ? options : __privateGet(__privateGet(this, _root), _options));
      __privateSet(this, _negs, __privateGet(this, _root) === this ? [] : __privateGet(__privateGet(this, _root), _negs));
      if (type3 === "!" && !__privateGet(__privateGet(this, _root), _filledNegs))
        __privateGet(this, _negs).push(this);
      __privateSet(this, _parentIndex, __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0);
    }
    get hasMagic() {
      if (__privateGet(this, _hasMagic) !== void 0)
        return __privateGet(this, _hasMagic);
      for (const p of __privateGet(this, _parts)) {
        if (typeof p === "string")
          continue;
        if (p.type || p.hasMagic)
          return __privateSet(this, _hasMagic, true);
      }
      return __privateGet(this, _hasMagic);
    }
    // reconstructs the pattern
    toString() {
      if (__privateGet(this, _toString) !== void 0)
        return __privateGet(this, _toString);
      if (!this.type) {
        return __privateSet(this, _toString, __privateGet(this, _parts).map((p) => String(p)).join(""));
      } else {
        return __privateSet(this, _toString, this.type + "(" + __privateGet(this, _parts).map((p) => String(p)).join("|") + ")");
      }
    }
    push(...parts) {
      for (const p of parts) {
        if (p === "")
          continue;
        if (typeof p !== "string" && !(p instanceof _AST && __privateGet(p, _parent) === this)) {
          throw new Error("invalid part: " + p);
        }
        __privateGet(this, _parts).push(p);
      }
    }
    toJSON() {
      const ret3 = this.type === null ? __privateGet(this, _parts).slice().map((p) => typeof p === "string" ? p : p.toJSON()) : [this.type, ...__privateGet(this, _parts).map((p) => p.toJSON())];
      if (this.isStart() && !this.type)
        ret3.unshift([]);
      if (this.isEnd() && (this === __privateGet(this, _root) || __privateGet(__privateGet(this, _root), _filledNegs) && __privateGet(this, _parent)?.type === "!")) {
        ret3.push({});
      }
      return ret3;
    }
    isStart() {
      if (__privateGet(this, _root) === this)
        return true;
      if (!__privateGet(this, _parent)?.isStart())
        return false;
      if (__privateGet(this, _parentIndex) === 0)
        return true;
      const p = __privateGet(this, _parent);
      for (let i = 0; i < __privateGet(this, _parentIndex); i++) {
        const pp = __privateGet(p, _parts)[i];
        if (!(pp instanceof _AST && pp.type === "!")) {
          return false;
        }
      }
      return true;
    }
    isEnd() {
      if (__privateGet(this, _root) === this)
        return true;
      if (__privateGet(this, _parent)?.type === "!")
        return true;
      if (!__privateGet(this, _parent)?.isEnd())
        return false;
      if (!this.type)
        return __privateGet(this, _parent)?.isEnd();
      const pl = __privateGet(this, _parent) ? __privateGet(__privateGet(this, _parent), _parts).length : 0;
      return __privateGet(this, _parentIndex) === pl - 1;
    }
    copyIn(part) {
      if (typeof part === "string")
        this.push(part);
      else
        this.push(part.clone(this));
    }
    clone(parent) {
      const c = new _AST(this.type, parent);
      for (const p of __privateGet(this, _parts)) {
        c.copyIn(p);
      }
      return c;
    }
    static fromGlob(pattern, options = {}) {
      var _a;
      const ast = new _AST(null, void 0, options);
      __privateMethod(_a = _AST, _parseAST, parseAST_fn).call(_a, pattern, ast, 0, options);
      return ast;
    }
    // returns the regular expression if there's magic, or the unescaped
    // string if not.
    toMMPattern() {
      if (this !== __privateGet(this, _root))
        return __privateGet(this, _root).toMMPattern();
      const glob2 = this.toString();
      const [re, body, hasMagic2, uflag] = this.toRegExpSource();
      const anyMagic = hasMagic2 || __privateGet(this, _hasMagic) || __privateGet(this, _options).nocase && !__privateGet(this, _options).nocaseMagicOnly && glob2.toUpperCase() !== glob2.toLowerCase();
      if (!anyMagic) {
        return body;
      }
      const flags = (__privateGet(this, _options).nocase ? "i" : "") + (uflag ? "u" : "");
      return Object.assign(new RegExp(`^${re}$`, flags), {
        _src: re,
        _glob: glob2
      });
    }
    // returns the string match, the regexp source, whether there's magic
    // in the regexp (so a regular expression is required) and whether or
    // not the uflag is needed for the regular expression (for posix classes)
    // TODO: instead of injecting the start/end at this point, just return
    // the BODY of the regexp, along with the start/end portions suitable
    // for binding the start/end in either a joined full-path makeRe context
    // (where we bind to (^|/), or a standalone matchPart context (where
    // we bind to ^, and not /).  Otherwise slashes get duped!
    //
    // In part-matching mode, the start is:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: ^(?!\.\.?$)
    // - if dots allowed or not possible: ^
    // - if dots possible and not allowed: ^(?!\.)
    // end is:
    // - if not isEnd(): nothing
    // - else: $
    //
    // In full-path matching mode, we put the slash at the START of the
    // pattern, so start is:
    // - if first pattern: same as part-matching mode
    // - if not isStart(): nothing
    // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
    // - if dots allowed or not possible: /
    // - if dots possible and not allowed: /(?!\.)
    // end is:
    // - if last pattern, same as part-matching mode
    // - else nothing
    //
    // Always put the (?:$|/) on negated tails, though, because that has to be
    // there to bind the end of the negated pattern portion, and it's easier to
    // just stick it in now rather than try to inject it later in the middle of
    // the pattern.
    //
    // We can just always return the same end, and leave it up to the caller
    // to know whether it's going to be used joined or in parts.
    // And, if the start is adjusted slightly, can do the same there:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
    // - if dots allowed or not possible: (?:/|^)
    // - if dots possible and not allowed: (?:/|^)(?!\.)
    //
    // But it's better to have a simpler binding without a conditional, for
    // performance, so probably better to return both start options.
    //
    // Then the caller just ignores the end if it's not the first pattern,
    // and the start always gets applied.
    //
    // But that's always going to be $ if it's the ending pattern, or nothing,
    // so the caller can just attach $ at the end of the pattern when building.
    //
    // So the todo is:
    // - better detect what kind of start is needed
    // - return both flavors of starting pattern
    // - attach $ at the end of the pattern when creating the actual RegExp
    //
    // Ah, but wait, no, that all only applies to the root when the first pattern
    // is not an extglob. If the first pattern IS an extglob, then we need all
    // that dot prevention biz to live in the extglob portions, because eg
    // +(*|.x*) can match .xy but not .yx.
    //
    // So, return the two flavors if it's #root and the first child is not an
    // AST, otherwise leave it to the child AST to handle it, and there,
    // use the (?:^|/) style of start binding.
    //
    // Even simplified further:
    // - Since the start for a join is eg /(?!\.) and the start for a part
    // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
    // or start or whatever) and prepend ^ or / at the Regexp construction.
    toRegExpSource(allowDot) {
      const dot = allowDot ?? !!__privateGet(this, _options).dot;
      if (__privateGet(this, _root) === this)
        __privateMethod(this, _fillNegs, fillNegs_fn).call(this);
      if (!this.type) {
        const noEmpty = this.isStart() && this.isEnd();
        const src = __privateGet(this, _parts).map((p) => {
          var _a;
          const [re, _, hasMagic2, uflag] = typeof p === "string" ? __privateMethod(_a = _AST, _parseGlob, parseGlob_fn).call(_a, p, __privateGet(this, _hasMagic), noEmpty) : p.toRegExpSource(allowDot);
          __privateSet(this, _hasMagic, __privateGet(this, _hasMagic) || hasMagic2);
          __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
          return re;
        }).join("");
        let start2 = "";
        if (this.isStart()) {
          if (typeof __privateGet(this, _parts)[0] === "string") {
            const dotTravAllowed = __privateGet(this, _parts).length === 1 && justDots.has(__privateGet(this, _parts)[0]);
            if (!dotTravAllowed) {
              const aps = addPatternStart;
              const needNoTrav = (
                // dots are allowed, and the pattern starts with [ or .
                dot && aps.has(src.charAt(0)) || // the pattern starts with \., and then [ or .
                src.startsWith("\\.") && aps.has(src.charAt(2)) || // the pattern starts with \.\., and then [ or .
                src.startsWith("\\.\\.") && aps.has(src.charAt(4))
              );
              const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
              start2 = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : "";
            }
          }
        }
        let end = "";
        if (this.isEnd() && __privateGet(__privateGet(this, _root), _filledNegs) && __privateGet(this, _parent)?.type === "!") {
          end = "(?:$|\\/)";
        }
        const final2 = start2 + src + end;
        return [
          final2,
          unescape(src),
          __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
          __privateGet(this, _uflag)
        ];
      }
      const repeated = this.type === "*" || this.type === "+";
      const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
      let body = __privateMethod(this, _partsToRegExp, partsToRegExp_fn).call(this, dot);
      if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
        const s = this.toString();
        __privateSet(this, _parts, [s]);
        this.type = null;
        __privateSet(this, _hasMagic, void 0);
        return [s, unescape(this.toString()), false, false];
      }
      let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? "" : __privateMethod(this, _partsToRegExp, partsToRegExp_fn).call(this, true);
      if (bodyDotAllowed === body) {
        bodyDotAllowed = "";
      }
      if (bodyDotAllowed) {
        body = `(?:${body})(?:${bodyDotAllowed})*?`;
      }
      let final = "";
      if (this.type === "!" && __privateGet(this, _emptyExt)) {
        final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
      } else {
        const close = this.type === "!" ? (
          // !() must match something,but !(x) can match ''
          "))" + (this.isStart() && !dot && !allowDot ? startNoDot : "") + star + ")"
        ) : this.type === "@" ? ")" : this.type === "?" ? ")?" : this.type === "+" && bodyDotAllowed ? ")" : this.type === "*" && bodyDotAllowed ? `)?` : `)${this.type}`;
        final = start + body + close;
      }
      return [
        final,
        unescape(body),
        __privateSet(this, _hasMagic, !!__privateGet(this, _hasMagic)),
        __privateGet(this, _uflag)
      ];
    }
  };
  var AST = _AST;
  _root = new WeakMap();
  _hasMagic = new WeakMap();
  _uflag = new WeakMap();
  _parts = new WeakMap();
  _parent = new WeakMap();
  _parentIndex = new WeakMap();
  _negs = new WeakMap();
  _filledNegs = new WeakMap();
  _options = new WeakMap();
  _toString = new WeakMap();
  _emptyExt = new WeakMap();
  _fillNegs = new WeakSet();
  fillNegs_fn = function() {
    if (this !== __privateGet(this, _root))
      throw new Error("should only call on root");
    if (__privateGet(this, _filledNegs))
      return this;
    this.toString();
    __privateSet(this, _filledNegs, true);
    let n;
    while (n = __privateGet(this, _negs).pop()) {
      if (n.type !== "!")
        continue;
      let p = n;
      let pp = __privateGet(p, _parent);
      while (pp) {
        for (let i = __privateGet(p, _parentIndex) + 1; !pp.type && i < __privateGet(pp, _parts).length; i++) {
          for (const part of __privateGet(n, _parts)) {
            if (typeof part === "string") {
              throw new Error("string part in extglob AST??");
            }
            part.copyIn(__privateGet(pp, _parts)[i]);
          }
        }
        p = pp;
        pp = __privateGet(p, _parent);
      }
    }
    return this;
  };
  _parseAST = new WeakSet();
  parseAST_fn = function(str, ast, pos, opt) {
    var _a, _b;
    let escaping = false;
    let inBrace = false;
    let braceStart = -1;
    let braceNeg = false;
    if (ast.type === null) {
      let i2 = pos;
      let acc2 = "";
      while (i2 < str.length) {
        const c = str.charAt(i2++);
        if (escaping || c === "\\") {
          escaping = !escaping;
          acc2 += c;
          continue;
        }
        if (inBrace) {
          if (i2 === braceStart + 1) {
            if (c === "^" || c === "!") {
              braceNeg = true;
            }
          } else if (c === "]" && !(i2 === braceStart + 2 && braceNeg)) {
            inBrace = false;
          }
          acc2 += c;
          continue;
        } else if (c === "[") {
          inBrace = true;
          braceStart = i2;
          braceNeg = false;
          acc2 += c;
          continue;
        }
        if (!opt.noext && isExtglobType(c) && str.charAt(i2) === "(") {
          ast.push(acc2);
          acc2 = "";
          const ext2 = new _AST(c, ast);
          i2 = __privateMethod(_a = _AST, _parseAST, parseAST_fn).call(_a, str, ext2, i2, opt);
          ast.push(ext2);
          continue;
        }
        acc2 += c;
      }
      ast.push(acc2);
      return i2;
    }
    let i = pos + 1;
    let part = new _AST(null, ast);
    const parts = [];
    let acc = "";
    while (i < str.length) {
      const c = str.charAt(i++);
      if (escaping || c === "\\") {
        escaping = !escaping;
        acc += c;
        continue;
      }
      if (inBrace) {
        if (i === braceStart + 1) {
          if (c === "^" || c === "!") {
            braceNeg = true;
          }
        } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
          inBrace = false;
        }
        acc += c;
        continue;
      } else if (c === "[") {
        inBrace = true;
        braceStart = i;
        braceNeg = false;
        acc += c;
        continue;
      }
      if (isExtglobType(c) && str.charAt(i) === "(") {
        part.push(acc);
        acc = "";
        const ext2 = new _AST(c, part);
        part.push(ext2);
        i = __privateMethod(_b = _AST, _parseAST, parseAST_fn).call(_b, str, ext2, i, opt);
        continue;
      }
      if (c === "|") {
        part.push(acc);
        acc = "";
        parts.push(part);
        part = new _AST(null, ast);
        continue;
      }
      if (c === ")") {
        if (acc === "" && __privateGet(ast, _parts).length === 0) {
          __privateSet(ast, _emptyExt, true);
        }
        part.push(acc);
        acc = "";
        ast.push(...parts, part);
        return i;
      }
      acc += c;
    }
    ast.type = null;
    __privateSet(ast, _hasMagic, void 0);
    __privateSet(ast, _parts, [str.substring(pos - 1)]);
    return i;
  };
  _partsToRegExp = new WeakSet();
  partsToRegExp_fn = function(dot) {
    return __privateGet(this, _parts).map((p) => {
      if (typeof p === "string") {
        throw new Error("string type in extglob ast??");
      }
      const [re, _, _hasMagic2, uflag] = p.toRegExpSource(dot);
      __privateSet(this, _uflag, __privateGet(this, _uflag) || uflag);
      return re;
    }).filter((p) => !(this.isStart() && this.isEnd()) || !!p).join("|");
  };
  _parseGlob = new WeakSet();
  parseGlob_fn = function(glob2, hasMagic2, noEmpty = false) {
    let escaping = false;
    let re = "";
    let uflag = false;
    for (let i = 0; i < glob2.length; i++) {
      const c = glob2.charAt(i);
      if (escaping) {
        escaping = false;
        re += (reSpecials.has(c) ? "\\" : "") + c;
        continue;
      }
      if (c === "\\") {
        if (i === glob2.length - 1) {
          re += "\\\\";
        } else {
          escaping = true;
        }
        continue;
      }
      if (c === "[") {
        const [src, needUflag, consumed, magic] = parseClass(glob2, i);
        if (consumed) {
          re += src;
          uflag = uflag || needUflag;
          i += consumed - 1;
          hasMagic2 = hasMagic2 || magic;
          continue;
        }
      }
      if (c === "*") {
        if (noEmpty && glob2 === "*")
          re += starNoEmpty;
        else
          re += star;
        hasMagic2 = true;
        continue;
      }
      if (c === "?") {
        re += qmark;
        hasMagic2 = true;
        continue;
      }
      re += regExpEscape(c);
    }
    return [re, unescape(glob2), !!hasMagic2, uflag];
  };
  __privateAdd(AST, _parseAST);
  __privateAdd(AST, _parseGlob);

  // ../../node_modules/.pnpm/minimatch@9.0.2/node_modules/minimatch/dist/mjs/escape.js
  var escape = (s, { windowsPathsNoEscape = false } = {}) => {
    return windowsPathsNoEscape ? s.replace(/[?*()[\]]/g, "[$&]") : s.replace(/[?*()[\]\\]/g, "\\$&");
  };

  // ../../node_modules/.pnpm/minimatch@9.0.2/node_modules/minimatch/dist/mjs/index.js
  var minimatch = (p, pattern, options = {}) => {
    assertValidPattern(pattern);
    if (!options.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    return new Minimatch(pattern, options).match(p);
  };
  var starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
  var starDotExtTest = (ext2) => (f2) => !f2.startsWith(".") && f2.endsWith(ext2);
  var starDotExtTestDot = (ext2) => (f2) => f2.endsWith(ext2);
  var starDotExtTestNocase = (ext2) => {
    ext2 = ext2.toLowerCase();
    return (f2) => !f2.startsWith(".") && f2.toLowerCase().endsWith(ext2);
  };
  var starDotExtTestNocaseDot = (ext2) => {
    ext2 = ext2.toLowerCase();
    return (f2) => f2.toLowerCase().endsWith(ext2);
  };
  var starDotStarRE = /^\*+\.\*+$/;
  var starDotStarTest = (f2) => !f2.startsWith(".") && f2.includes(".");
  var starDotStarTestDot = (f2) => f2 !== "." && f2 !== ".." && f2.includes(".");
  var dotStarRE = /^\.\*+$/;
  var dotStarTest = (f2) => f2 !== "." && f2 !== ".." && f2.startsWith(".");
  var starRE = /^\*+$/;
  var starTest = (f2) => f2.length !== 0 && !f2.startsWith(".");
  var starTestDot = (f2) => f2.length !== 0 && f2 !== "." && f2 !== "..";
  var qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
  var qmarksTestNocase = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExt([$0]);
    if (!ext2)
      return noext;
    ext2 = ext2.toLowerCase();
    return (f2) => noext(f2) && f2.toLowerCase().endsWith(ext2);
  };
  var qmarksTestNocaseDot = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExtDot([$0]);
    if (!ext2)
      return noext;
    ext2 = ext2.toLowerCase();
    return (f2) => noext(f2) && f2.toLowerCase().endsWith(ext2);
  };
  var qmarksTestDot = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExtDot([$0]);
    return !ext2 ? noext : (f2) => noext(f2) && f2.endsWith(ext2);
  };
  var qmarksTest = ([$0, ext2 = ""]) => {
    const noext = qmarksTestNoExt([$0]);
    return !ext2 ? noext : (f2) => noext(f2) && f2.endsWith(ext2);
  };
  var qmarksTestNoExt = ([$0]) => {
    const len = $0.length;
    return (f2) => f2.length === len && !f2.startsWith(".");
  };
  var qmarksTestNoExtDot = ([$0]) => {
    const len = $0.length;
    return (f2) => f2.length === len && f2 !== "." && f2 !== "..";
  };
  var defaultPlatform = typeof process === "object" && process ? typeof process.env === "object" && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : "posix";
  var path = {
    win32: { sep: "\\" },
    posix: { sep: "/" }
  };
  var sep = defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
  minimatch.sep = sep;
  var GLOBSTAR = Symbol("globstar **");
  minimatch.GLOBSTAR = GLOBSTAR;
  var qmark2 = "[^/]";
  var star2 = qmark2 + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var filter = (pattern, options = {}) => (p) => minimatch(p, pattern, options);
  minimatch.filter = filter;
  var ext = (a, b = {}) => Object.assign({}, a, b);
  var defaults = (def) => {
    if (!def || typeof def !== "object" || !Object.keys(def).length) {
      return minimatch;
    }
    const orig = minimatch;
    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
    return Object.assign(m, {
      Minimatch: class Minimatch extends orig.Minimatch {
        constructor(pattern, options = {}) {
          super(pattern, ext(def, options));
        }
        static defaults(options) {
          return orig.defaults(ext(def, options)).Minimatch;
        }
      },
      AST: class AST extends orig.AST {
        /* c8 ignore start */
        constructor(type3, parent, options = {}) {
          super(type3, parent, ext(def, options));
        }
        /* c8 ignore stop */
        static fromGlob(pattern, options = {}) {
          return orig.AST.fromGlob(pattern, ext(def, options));
        }
      },
      unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
      escape: (s, options = {}) => orig.escape(s, ext(def, options)),
      filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
      defaults: (options) => orig.defaults(ext(def, options)),
      makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
      braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
      match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
      sep: orig.sep,
      GLOBSTAR
    });
  };
  minimatch.defaults = defaults;
  var braceExpand = (pattern, options = {}) => {
    assertValidPattern(pattern);
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
      return [pattern];
    }
    return (0, import_brace_expansion.default)(pattern);
  };
  minimatch.braceExpand = braceExpand;
  var makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
  minimatch.makeRe = makeRe;
  var match = (list, pattern, options = {}) => {
    const mm = new Minimatch(pattern, options);
    list = list.filter((f2) => mm.match(f2));
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  minimatch.match = match;
  var globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
  var regExpEscape2 = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  var Minimatch = class {
    options;
    set;
    pattern;
    windowsPathsNoEscape;
    nonegate;
    negate;
    comment;
    empty;
    preserveMultipleSlashes;
    partial;
    globSet;
    globParts;
    nocase;
    isWindows;
    platform;
    windowsNoMagicRoot;
    regexp;
    constructor(pattern, options = {}) {
      assertValidPattern(pattern);
      options = options || {};
      this.options = options;
      this.pattern = pattern;
      this.platform = options.platform || defaultPlatform;
      this.isWindows = this.platform === "win32";
      this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
      if (this.windowsPathsNoEscape) {
        this.pattern = this.pattern.replace(/\\/g, "/");
      }
      this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
      this.regexp = null;
      this.negate = false;
      this.nonegate = !!options.nonegate;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.nocase = !!this.options.nocase;
      this.windowsNoMagicRoot = options.windowsNoMagicRoot !== void 0 ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);
      this.globSet = [];
      this.globParts = [];
      this.set = [];
      this.make();
    }
    hasMagic() {
      if (this.options.magicalBraces && this.set.length > 1) {
        return true;
      }
      for (const pattern of this.set) {
        for (const part of pattern) {
          if (typeof part !== "string")
            return true;
        }
      }
      return false;
    }
    debug(..._) {
    }
    make() {
      const pattern = this.pattern;
      const options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      this.globSet = [...new Set(this.braceExpand())];
      if (options.debug) {
        this.debug = (...args) => console.error(...args);
      }
      this.debug(this.pattern, this.globSet);
      const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
      this.globParts = this.preprocess(rawGlobParts);
      this.debug(this.pattern, this.globParts);
      let set2 = this.globParts.map((s, _, __) => {
        if (this.isWindows && this.windowsNoMagicRoot) {
          const isUNC = s[0] === "" && s[1] === "" && (s[2] === "?" || !globMagic.test(s[2])) && !globMagic.test(s[3]);
          const isDrive = /^[a-z]:/i.test(s[0]);
          if (isUNC) {
            return [...s.slice(0, 4), ...s.slice(4).map((ss) => this.parse(ss))];
          } else if (isDrive) {
            return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
          }
        }
        return s.map((ss) => this.parse(ss));
      });
      this.debug(this.pattern, set2);
      this.set = set2.filter((s) => s.indexOf(false) === -1);
      if (this.isWindows) {
        for (let i = 0; i < this.set.length; i++) {
          const p = this.set[i];
          if (p[0] === "" && p[1] === "" && this.globParts[i][2] === "?" && typeof p[3] === "string" && /^[a-z]:$/i.test(p[3])) {
            p[2] = "?";
          }
        }
      }
      this.debug(this.pattern, this.set);
    }
    // various transforms to equivalent pattern sets that are
    // faster to process in a filesystem walk.  The goal is to
    // eliminate what we can, and push all ** patterns as far
    // to the right as possible, even if it increases the number
    // of patterns that we have to process.
    preprocess(globParts) {
      if (this.options.noglobstar) {
        for (let i = 0; i < globParts.length; i++) {
          for (let j = 0; j < globParts[i].length; j++) {
            if (globParts[i][j] === "**") {
              globParts[i][j] = "*";
            }
          }
        }
      }
      const { optimizationLevel = 1 } = this.options;
      if (optimizationLevel >= 2) {
        globParts = this.firstPhasePreProcess(globParts);
        globParts = this.secondPhasePreProcess(globParts);
      } else if (optimizationLevel >= 1) {
        globParts = this.levelOneOptimize(globParts);
      } else {
        globParts = this.adjascentGlobstarOptimize(globParts);
      }
      return globParts;
    }
    // just get rid of adjascent ** portions
    adjascentGlobstarOptimize(globParts) {
      return globParts.map((parts) => {
        let gs = -1;
        while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
          let i = gs;
          while (parts[i + 1] === "**") {
            i++;
          }
          if (i !== gs) {
            parts.splice(gs, i - gs);
          }
        }
        return parts;
      });
    }
    // get rid of adjascent ** and resolve .. portions
    levelOneOptimize(globParts) {
      return globParts.map((parts) => {
        parts = parts.reduce((set2, part) => {
          const prev = set2[set2.length - 1];
          if (part === "**" && prev === "**") {
            return set2;
          }
          if (part === "..") {
            if (prev && prev !== ".." && prev !== "." && prev !== "**") {
              set2.pop();
              return set2;
            }
          }
          set2.push(part);
          return set2;
        }, []);
        return parts.length === 0 ? [""] : parts;
      });
    }
    levelTwoFileOptimize(parts) {
      if (!Array.isArray(parts)) {
        parts = this.slashSplit(parts);
      }
      let didSomething = false;
      do {
        didSomething = false;
        if (!this.preserveMultipleSlashes) {
          for (let i = 1; i < parts.length - 1; i++) {
            const p = parts[i];
            if (i === 1 && p === "" && parts[0] === "")
              continue;
            if (p === "." || p === "") {
              didSomething = true;
              parts.splice(i, 1);
              i--;
            }
          }
          if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
            didSomething = true;
            parts.pop();
          }
        }
        let dd = 0;
        while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
          const p = parts[dd - 1];
          if (p && p !== "." && p !== ".." && p !== "**") {
            didSomething = true;
            parts.splice(dd - 1, 2);
            dd -= 2;
          }
        }
      } while (didSomething);
      return parts.length === 0 ? [""] : parts;
    }
    // First phase: single-pattern processing
    // <pre> is 1 or more portions
    // <rest> is 1 or more portions
    // <p> is any portion other than ., .., '', or **
    // <e> is . or ''
    //
    // **/.. is *brutal* for filesystem walking performance, because
    // it effectively resets the recursive walk each time it occurs,
    // and ** cannot be reduced out by a .. pattern part like a regexp
    // or most strings (other than .., ., and '') can be.
    //
    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
    // <pre>/<e>/<rest> -> <pre>/<rest>
    // <pre>/<p>/../<rest> -> <pre>/<rest>
    // **/**/<rest> -> **/<rest>
    //
    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
    // this WOULD be allowed if ** did follow symlinks, or * didn't
    firstPhasePreProcess(globParts) {
      let didSomething = false;
      do {
        didSomething = false;
        for (let parts of globParts) {
          let gs = -1;
          while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
            let gss = gs;
            while (parts[gss + 1] === "**") {
              gss++;
            }
            if (gss > gs) {
              parts.splice(gs + 1, gss - gs);
            }
            let next = parts[gs + 1];
            const p = parts[gs + 2];
            const p2 = parts[gs + 3];
            if (next !== "..")
              continue;
            if (!p || p === "." || p === ".." || !p2 || p2 === "." || p2 === "..") {
              continue;
            }
            didSomething = true;
            parts.splice(gs, 1);
            const other = parts.slice(0);
            other[gs] = "**";
            globParts.push(other);
            gs--;
          }
          if (!this.preserveMultipleSlashes) {
            for (let i = 1; i < parts.length - 1; i++) {
              const p = parts[i];
              if (i === 1 && p === "" && parts[0] === "")
                continue;
              if (p === "." || p === "") {
                didSomething = true;
                parts.splice(i, 1);
                i--;
              }
            }
            if (parts[0] === "." && parts.length === 2 && (parts[1] === "." || parts[1] === "")) {
              didSomething = true;
              parts.pop();
            }
          }
          let dd = 0;
          while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
            const p = parts[dd - 1];
            if (p && p !== "." && p !== ".." && p !== "**") {
              didSomething = true;
              const needDot = dd === 1 && parts[dd + 1] === "**";
              const splin = needDot ? ["."] : [];
              parts.splice(dd - 1, 2, ...splin);
              if (parts.length === 0)
                parts.push("");
              dd -= 2;
            }
          }
        }
      } while (didSomething);
      return globParts;
    }
    // second phase: multi-pattern dedupes
    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
    //
    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
    // ^-- not valid because ** doens't follow symlinks
    secondPhasePreProcess(globParts) {
      for (let i = 0; i < globParts.length - 1; i++) {
        for (let j = i + 1; j < globParts.length; j++) {
          const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
          if (!matched)
            continue;
          globParts[i] = matched;
          globParts[j] = [];
        }
      }
      return globParts.filter((gs) => gs.length);
    }
    partsMatch(a, b, emptyGSMatch = false) {
      let ai = 0;
      let bi = 0;
      let result = [];
      let which = "";
      while (ai < a.length && bi < b.length) {
        if (a[ai] === b[bi]) {
          result.push(which === "b" ? b[bi] : a[ai]);
          ai++;
          bi++;
        } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
          result.push(a[ai]);
          ai++;
        } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
          result.push(b[bi]);
          bi++;
        } else if (a[ai] === "*" && b[bi] && (this.options.dot || !b[bi].startsWith(".")) && b[bi] !== "**") {
          if (which === "b")
            return false;
          which = "a";
          result.push(a[ai]);
          ai++;
          bi++;
        } else if (b[bi] === "*" && a[ai] && (this.options.dot || !a[ai].startsWith(".")) && a[ai] !== "**") {
          if (which === "a")
            return false;
          which = "b";
          result.push(b[bi]);
          ai++;
          bi++;
        } else {
          return false;
        }
      }
      return a.length === b.length && result;
    }
    parseNegate() {
      if (this.nonegate)
        return;
      const pattern = this.pattern;
      let negate = false;
      let negateOffset = 0;
      for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.slice(negateOffset);
      this.negate = negate;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(file, pattern, partial = false) {
      const options = this.options;
      if (this.isWindows) {
        const fileDrive = typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
        const fileUNC = !fileDrive && file[0] === "" && file[1] === "" && file[2] === "?" && /^[a-z]:$/i.test(file[3]);
        const patternDrive = typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
        const patternUNC = !patternDrive && pattern[0] === "" && pattern[1] === "" && pattern[2] === "?" && typeof pattern[3] === "string" && /^[a-z]:$/i.test(pattern[3]);
        const fdi = fileUNC ? 3 : fileDrive ? 0 : void 0;
        const pdi = patternUNC ? 3 : patternDrive ? 0 : void 0;
        if (typeof fdi === "number" && typeof pdi === "number") {
          const [fd, pd] = [file[fdi], pattern[pdi]];
          if (fd.toLowerCase() === pd.toLowerCase()) {
            pattern[pdi] = fd;
            if (pdi > fdi) {
              pattern = pattern.slice(pdi);
            } else if (fdi > pdi) {
              file = file.slice(fdi);
            }
          }
        }
      }
      const { optimizationLevel = 1 } = this.options;
      if (optimizationLevel >= 2) {
        file = this.levelTwoFileOptimize(file);
      }
      this.debug("matchOne", this, { file, pattern });
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f2 = file[fi];
        this.debug(pattern, p, f2);
        if (p === false) {
          return false;
        }
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f2]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl) {
              return true;
            }
          }
          return false;
        }
        let hit;
        if (typeof p === "string") {
          hit = f2 === p;
          this.debug("string match", p, f2, hit);
        } else {
          hit = p.test(f2);
          this.debug("pattern match", p, f2, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      } else {
        throw new Error("wtf?");
      }
    }
    braceExpand() {
      return braceExpand(this.pattern, this.options);
    }
    parse(pattern) {
      assertValidPattern(pattern);
      const options = this.options;
      if (pattern === "**")
        return GLOBSTAR;
      if (pattern === "")
        return "";
      let m;
      let fastTest = null;
      if (m = pattern.match(starRE)) {
        fastTest = options.dot ? starTestDot : starTest;
      } else if (m = pattern.match(starDotExtRE)) {
        fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);
      } else if (m = pattern.match(qmarksRE)) {
        fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);
      } else if (m = pattern.match(starDotStarRE)) {
        fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
      } else if (m = pattern.match(dotStarRE)) {
        fastTest = dotStarTest;
      }
      const re = AST.fromGlob(pattern, this.options).toMMPattern();
      return fastTest ? Object.assign(re, { test: fastTest }) : re;
    }
    makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      const set2 = this.set;
      if (!set2.length) {
        this.regexp = false;
        return this.regexp;
      }
      const options = this.options;
      const twoStar = options.noglobstar ? star2 : options.dot ? twoStarDot : twoStarNoDot;
      const flags = new Set(options.nocase ? ["i"] : []);
      let re = set2.map((pattern) => {
        const pp = pattern.map((p) => {
          if (p instanceof RegExp) {
            for (const f2 of p.flags.split(""))
              flags.add(f2);
          }
          return typeof p === "string" ? regExpEscape2(p) : p === GLOBSTAR ? GLOBSTAR : p._src;
        });
        pp.forEach((p, i) => {
          const next = pp[i + 1];
          const prev = pp[i - 1];
          if (p !== GLOBSTAR || prev === GLOBSTAR) {
            return;
          }
          if (prev === void 0) {
            if (next !== void 0 && next !== GLOBSTAR) {
              pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
            } else {
              pp[i] = twoStar;
            }
          } else if (next === void 0) {
            pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?";
          } else if (next !== GLOBSTAR) {
            pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
            pp[i + 1] = GLOBSTAR;
          }
        });
        return pp.filter((p) => p !== GLOBSTAR).join("/");
      }).join("|");
      const [open, close] = set2.length > 1 ? ["(?:", ")"] : ["", ""];
      re = "^" + open + re + close + "$";
      if (this.negate)
        re = "^(?!" + re + ").+$";
      try {
        this.regexp = new RegExp(re, [...flags].join(""));
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    slashSplit(p) {
      if (this.preserveMultipleSlashes) {
        return p.split("/");
      } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
        return ["", ...p.split(/\/+/)];
      } else {
        return p.split(/\/+/);
      }
    }
    match(f2, partial = this.partial) {
      this.debug("match", f2, this.pattern);
      if (this.comment) {
        return false;
      }
      if (this.empty) {
        return f2 === "";
      }
      if (f2 === "/" && partial) {
        return true;
      }
      const options = this.options;
      if (this.isWindows) {
        f2 = f2.split("\\").join("/");
      }
      const ff = this.slashSplit(f2);
      this.debug(this.pattern, "split", ff);
      const set2 = this.set;
      this.debug(this.pattern, "set", set2);
      let filename = ff[ff.length - 1];
      if (!filename) {
        for (let i = ff.length - 2; !filename && i >= 0; i--) {
          filename = ff[i];
        }
      }
      for (let i = 0; i < set2.length; i++) {
        const pattern = set2[i];
        let file = ff;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        const hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate) {
            return true;
          }
          return !this.negate;
        }
      }
      if (options.flipNegate) {
        return false;
      }
      return this.negate;
    }
    static defaults(def) {
      return minimatch.defaults(def).Minimatch;
    }
  };
  minimatch.AST = AST;
  minimatch.Minimatch = Minimatch;
  minimatch.escape = escape;
  minimatch.unescape = unescape;

  // ../../node_modules/.pnpm/lru-cache@10.0.0/node_modules/lru-cache/dist/mjs/index.js
  var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
  var warned = /* @__PURE__ */ new Set();
  var PROCESS = typeof process === "object" && !!process ? process : {};
  var emitWarning = (msg, type3, code, fn) => {
    typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type3, code, fn) : console.error(`[${code}] ${type3}: ${msg}`);
  };
  var AC = globalThis.AbortController;
  var AS = globalThis.AbortSignal;
  if (typeof AC === "undefined") {
    AS = class AbortSignal {
      onabort;
      _onabort = [];
      reason;
      aborted = false;
      addEventListener(_, fn) {
        this._onabort.push(fn);
      }
    };
    AC = class AbortController {
      constructor() {
        warnACPolyfill();
      }
      signal = new AS();
      abort(reason) {
        if (this.signal.aborted)
          return;
        this.signal.reason = reason;
        this.signal.aborted = true;
        for (const fn of this.signal._onabort) {
          fn(reason);
        }
        this.signal.onabort?.(reason);
      }
    };
    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
    const warnACPolyfill = () => {
      if (!printACPolyfillWarning)
        return;
      printACPolyfillWarning = false;
      emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
    };
  }
  var shouldWarn = (code) => !warned.has(code);
  var TYPE = Symbol("type");
  var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
  var getUintArray = (max2) => !isPosInt(max2) ? null : max2 <= Math.pow(2, 8) ? Uint8Array : max2 <= Math.pow(2, 16) ? Uint16Array : max2 <= Math.pow(2, 32) ? Uint32Array : max2 <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
  var ZeroArray = class extends Array {
    constructor(size) {
      super(size);
      this.fill(0);
    }
  };
  var _constructing;
  var _Stack = class {
    heap;
    length;
    static create(max2) {
      const HeapCls = getUintArray(max2);
      if (!HeapCls)
        return [];
      __privateSet(_Stack, _constructing, true);
      const s = new _Stack(max2, HeapCls);
      __privateSet(_Stack, _constructing, false);
      return s;
    }
    constructor(max2, HeapCls) {
      if (!__privateGet(_Stack, _constructing)) {
        throw new TypeError("instantiate Stack using Stack.create(n)");
      }
      this.heap = new HeapCls(max2);
      this.length = 0;
    }
    push(n) {
      this.heap[this.length++] = n;
    }
    pop() {
      return this.heap[--this.length];
    }
  };
  var Stack = _Stack;
  _constructing = new WeakMap();
  // private constructor
  __privateAdd(Stack, _constructing, false);
  var LRUCache = class {
    // properties coming in from the options of these, only max and maxSize
    // really *need* to be protected. The rest can be modified, as they just
    // set defaults for various methods.
    #max;
    #maxSize;
    #dispose;
    #disposeAfter;
    #fetchMethod;
    /**
     * {@link LRUCache.OptionsBase.ttl}
     */
    ttl;
    /**
     * {@link LRUCache.OptionsBase.ttlResolution}
     */
    ttlResolution;
    /**
     * {@link LRUCache.OptionsBase.ttlAutopurge}
     */
    ttlAutopurge;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnGet}
     */
    updateAgeOnGet;
    /**
     * {@link LRUCache.OptionsBase.updateAgeOnHas}
     */
    updateAgeOnHas;
    /**
     * {@link LRUCache.OptionsBase.allowStale}
     */
    allowStale;
    /**
     * {@link LRUCache.OptionsBase.noDisposeOnSet}
     */
    noDisposeOnSet;
    /**
     * {@link LRUCache.OptionsBase.noUpdateTTL}
     */
    noUpdateTTL;
    /**
     * {@link LRUCache.OptionsBase.maxEntrySize}
     */
    maxEntrySize;
    /**
     * {@link LRUCache.OptionsBase.sizeCalculation}
     */
    sizeCalculation;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
     */
    noDeleteOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
     */
    noDeleteOnStaleGet;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
     */
    allowStaleOnFetchAbort;
    /**
     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
     */
    allowStaleOnFetchRejection;
    /**
     * {@link LRUCache.OptionsBase.ignoreFetchAbort}
     */
    ignoreFetchAbort;
    // computed properties
    #size;
    #calculatedSize;
    #keyMap;
    #keyList;
    #valList;
    #next;
    #prev;
    #head;
    #tail;
    #free;
    #disposed;
    #sizes;
    #starts;
    #ttls;
    #hasDispose;
    #hasFetchMethod;
    #hasDisposeAfter;
    /**
     * Do not call this method unless you need to inspect the
     * inner workings of the cache.  If anything returned by this
     * object is modified in any way, strange breakage may occur.
     *
     * These fields are private for a reason!
     *
     * @internal
     */
    static unsafeExposeInternals(c) {
      return {
        // properties
        starts: c.#starts,
        ttls: c.#ttls,
        sizes: c.#sizes,
        keyMap: c.#keyMap,
        keyList: c.#keyList,
        valList: c.#valList,
        next: c.#next,
        prev: c.#prev,
        get head() {
          return c.#head;
        },
        get tail() {
          return c.#tail;
        },
        free: c.#free,
        // methods
        isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
        backgroundFetch: (k, index, options, context2) => c.#backgroundFetch(k, index, options, context2),
        moveToTail: (index) => c.#moveToTail(index),
        indexes: (options) => c.#indexes(options),
        rindexes: (options) => c.#rindexes(options),
        isStale: (index) => c.#isStale(index)
      };
    }
    // Protected read-only members
    /**
     * {@link LRUCache.OptionsBase.max} (read-only)
     */
    get max() {
      return this.#max;
    }
    /**
     * {@link LRUCache.OptionsBase.maxSize} (read-only)
     */
    get maxSize() {
      return this.#maxSize;
    }
    /**
     * The total computed size of items in the cache (read-only)
     */
    get calculatedSize() {
      return this.#calculatedSize;
    }
    /**
     * The number of items stored in the cache (read-only)
     */
    get size() {
      return this.#size;
    }
    /**
     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
     */
    get fetchMethod() {
      return this.#fetchMethod;
    }
    /**
     * {@link LRUCache.OptionsBase.dispose} (read-only)
     */
    get dispose() {
      return this.#dispose;
    }
    /**
     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
     */
    get disposeAfter() {
      return this.#disposeAfter;
    }
    constructor(options) {
      const { max: max2 = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
      if (max2 !== 0 && !isPosInt(max2)) {
        throw new TypeError("max option must be a nonnegative integer");
      }
      const UintArray = max2 ? getUintArray(max2) : Array;
      if (!UintArray) {
        throw new Error("invalid max value: " + max2);
      }
      this.#max = max2;
      this.#maxSize = maxSize;
      this.maxEntrySize = maxEntrySize || this.#maxSize;
      this.sizeCalculation = sizeCalculation;
      if (this.sizeCalculation) {
        if (!this.#maxSize && !this.maxEntrySize) {
          throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
        }
        if (typeof this.sizeCalculation !== "function") {
          throw new TypeError("sizeCalculation set to non-function");
        }
      }
      if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
        throw new TypeError("fetchMethod must be a function if specified");
      }
      this.#fetchMethod = fetchMethod;
      this.#hasFetchMethod = !!fetchMethod;
      this.#keyMap = /* @__PURE__ */ new Map();
      this.#keyList = new Array(max2).fill(void 0);
      this.#valList = new Array(max2).fill(void 0);
      this.#next = new UintArray(max2);
      this.#prev = new UintArray(max2);
      this.#head = 0;
      this.#tail = 0;
      this.#free = Stack.create(max2);
      this.#size = 0;
      this.#calculatedSize = 0;
      if (typeof dispose === "function") {
        this.#dispose = dispose;
      }
      if (typeof disposeAfter === "function") {
        this.#disposeAfter = disposeAfter;
        this.#disposed = [];
      } else {
        this.#disposeAfter = void 0;
        this.#disposed = void 0;
      }
      this.#hasDispose = !!this.#dispose;
      this.#hasDisposeAfter = !!this.#disposeAfter;
      this.noDisposeOnSet = !!noDisposeOnSet;
      this.noUpdateTTL = !!noUpdateTTL;
      this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
      this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
      this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
      this.ignoreFetchAbort = !!ignoreFetchAbort;
      if (this.maxEntrySize !== 0) {
        if (this.#maxSize !== 0) {
          if (!isPosInt(this.#maxSize)) {
            throw new TypeError("maxSize must be a positive integer if specified");
          }
        }
        if (!isPosInt(this.maxEntrySize)) {
          throw new TypeError("maxEntrySize must be a positive integer if specified");
        }
        this.#initializeSizeTracking();
      }
      this.allowStale = !!allowStale;
      this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
      this.updateAgeOnGet = !!updateAgeOnGet;
      this.updateAgeOnHas = !!updateAgeOnHas;
      this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
      this.ttlAutopurge = !!ttlAutopurge;
      this.ttl = ttl || 0;
      if (this.ttl) {
        if (!isPosInt(this.ttl)) {
          throw new TypeError("ttl must be a positive integer if specified");
        }
        this.#initializeTTLTracking();
      }
      if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
        throw new TypeError("At least one of max, maxSize, or ttl is required");
      }
      if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
        const code = "LRU_CACHE_UNBOUNDED";
        if (shouldWarn(code)) {
          warned.add(code);
          const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
          emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
        }
      }
    }
    /**
     * Return the remaining TTL time for a given entry key
     */
    getRemainingTTL(key) {
      return this.#keyMap.has(key) ? Infinity : 0;
    }
    #initializeTTLTracking() {
      const ttls = new ZeroArray(this.#max);
      const starts = new ZeroArray(this.#max);
      this.#ttls = ttls;
      this.#starts = starts;
      this.#setItemTTL = (index, ttl, start = perf.now()) => {
        starts[index] = ttl !== 0 ? start : 0;
        ttls[index] = ttl;
        if (ttl !== 0 && this.ttlAutopurge) {
          const t = setTimeout(() => {
            if (this.#isStale(index)) {
              this.delete(this.#keyList[index]);
            }
          }, ttl + 1);
          if (t.unref) {
            t.unref();
          }
        }
      };
      this.#updateItemAge = (index) => {
        starts[index] = ttls[index] !== 0 ? perf.now() : 0;
      };
      this.#statusTTL = (status, index) => {
        if (ttls[index]) {
          const ttl = ttls[index];
          const start = starts[index];
          status.ttl = ttl;
          status.start = start;
          status.now = cachedNow || getNow();
          const age = status.now - start;
          status.remainingTTL = ttl - age;
        }
      };
      let cachedNow = 0;
      const getNow = () => {
        const n = perf.now();
        if (this.ttlResolution > 0) {
          cachedNow = n;
          const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
          if (t.unref) {
            t.unref();
          }
        }
        return n;
      };
      this.getRemainingTTL = (key) => {
        const index = this.#keyMap.get(key);
        if (index === void 0) {
          return 0;
        }
        const ttl = ttls[index];
        const start = starts[index];
        if (ttl === 0 || start === 0) {
          return Infinity;
        }
        const age = (cachedNow || getNow()) - start;
        return ttl - age;
      };
      this.#isStale = (index) => {
        return ttls[index] !== 0 && starts[index] !== 0 && (cachedNow || getNow()) - starts[index] > ttls[index];
      };
    }
    // conditionally set private methods related to TTL
    #updateItemAge = () => {
    };
    #statusTTL = () => {
    };
    #setItemTTL = () => {
    };
    /* c8 ignore stop */
    #isStale = () => false;
    #initializeSizeTracking() {
      const sizes = new ZeroArray(this.#max);
      this.#calculatedSize = 0;
      this.#sizes = sizes;
      this.#removeItemSize = (index) => {
        this.#calculatedSize -= sizes[index];
        sizes[index] = 0;
      };
      this.#requireSize = (k, v, size, sizeCalculation) => {
        if (this.#isBackgroundFetch(v)) {
          return 0;
        }
        if (!isPosInt(size)) {
          if (sizeCalculation) {
            if (typeof sizeCalculation !== "function") {
              throw new TypeError("sizeCalculation must be a function");
            }
            size = sizeCalculation(v, k);
            if (!isPosInt(size)) {
              throw new TypeError("sizeCalculation return invalid (expect positive integer)");
            }
          } else {
            throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
          }
        }
        return size;
      };
      this.#addItemSize = (index, size, status) => {
        sizes[index] = size;
        if (this.#maxSize) {
          const maxSize = this.#maxSize - sizes[index];
          while (this.#calculatedSize > maxSize) {
            this.#evict(true);
          }
        }
        this.#calculatedSize += sizes[index];
        if (status) {
          status.entrySize = size;
          status.totalCalculatedSize = this.#calculatedSize;
        }
      };
    }
    #removeItemSize = (_i) => {
    };
    #addItemSize = (_i, _s, _st) => {
    };
    #requireSize = (_k, _v, size, sizeCalculation) => {
      if (size || sizeCalculation) {
        throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
      }
      return 0;
    };
    *#indexes({ allowStale = this.allowStale } = {}) {
      if (this.#size) {
        for (let i = this.#tail; true; ) {
          if (!this.#isValidIndex(i)) {
            break;
          }
          if (allowStale || !this.#isStale(i)) {
            yield i;
          }
          if (i === this.#head) {
            break;
          } else {
            i = this.#prev[i];
          }
        }
      }
    }
    *#rindexes({ allowStale = this.allowStale } = {}) {
      if (this.#size) {
        for (let i = this.#head; true; ) {
          if (!this.#isValidIndex(i)) {
            break;
          }
          if (allowStale || !this.#isStale(i)) {
            yield i;
          }
          if (i === this.#tail) {
            break;
          } else {
            i = this.#next[i];
          }
        }
      }
    }
    #isValidIndex(index) {
      return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
    }
    /**
     * Return a generator yielding `[key, value]` pairs,
     * in order from most recently used to least recently used.
     */
    *entries() {
      for (const i of this.#indexes()) {
        if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
          yield [this.#keyList[i], this.#valList[i]];
        }
      }
    }
    /**
     * Inverse order version of {@link LRUCache.entries}
     *
     * Return a generator yielding `[key, value]` pairs,
     * in order from least recently used to most recently used.
     */
    *rentries() {
      for (const i of this.#rindexes()) {
        if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
          yield [this.#keyList[i], this.#valList[i]];
        }
      }
    }
    /**
     * Return a generator yielding the keys in the cache,
     * in order from most recently used to least recently used.
     */
    *keys() {
      for (const i of this.#indexes()) {
        const k = this.#keyList[i];
        if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
          yield k;
        }
      }
    }
    /**
     * Inverse order version of {@link LRUCache.keys}
     *
     * Return a generator yielding the keys in the cache,
     * in order from least recently used to most recently used.
     */
    *rkeys() {
      for (const i of this.#rindexes()) {
        const k = this.#keyList[i];
        if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
          yield k;
        }
      }
    }
    /**
     * Return a generator yielding the values in the cache,
     * in order from most recently used to least recently used.
     */
    *values() {
      for (const i of this.#indexes()) {
        const v = this.#valList[i];
        if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
          yield this.#valList[i];
        }
      }
    }
    /**
     * Inverse order version of {@link LRUCache.values}
     *
     * Return a generator yielding the values in the cache,
     * in order from least recently used to most recently used.
     */
    *rvalues() {
      for (const i of this.#rindexes()) {
        const v = this.#valList[i];
        if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
          yield this.#valList[i];
        }
      }
    }
    /**
     * Iterating over the cache itself yields the same results as
     * {@link LRUCache.entries}
     */
    [Symbol.iterator]() {
      return this.entries();
    }
    /**
     * Find a value for which the supplied fn method returns a truthy value,
     * similar to Array.find().  fn is called as fn(value, key, cache).
     */
    find(fn, getOptions = {}) {
      for (const i of this.#indexes()) {
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          continue;
        if (fn(value, this.#keyList[i], this)) {
          return this.get(this.#keyList[i], getOptions);
        }
      }
    }
    /**
     * Call the supplied function on each item in the cache, in order from
     * most recently used to least recently used.  fn is called as
     * fn(value, key, cache).  Does not update age or recenty of use.
     * Does not iterate over stale values.
     */
    forEach(fn, thisp = this) {
      for (const i of this.#indexes()) {
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          continue;
        fn.call(thisp, value, this.#keyList[i], this);
      }
    }
    /**
     * The same as {@link LRUCache.forEach} but items are iterated over in
     * reverse order.  (ie, less recently used items are iterated over first.)
     */
    rforEach(fn, thisp = this) {
      for (const i of this.#rindexes()) {
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          continue;
        fn.call(thisp, value, this.#keyList[i], this);
      }
    }
    /**
     * Delete any stale entries. Returns true if anything was removed,
     * false otherwise.
     */
    purgeStale() {
      let deleted = false;
      for (const i of this.#rindexes({ allowStale: true })) {
        if (this.#isStale(i)) {
          this.delete(this.#keyList[i]);
          deleted = true;
        }
      }
      return deleted;
    }
    /**
     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
     * passed to cache.load()
     */
    dump() {
      const arr = [];
      for (const i of this.#indexes({ allowStale: true })) {
        const key = this.#keyList[i];
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0 || key === void 0)
          continue;
        const entry = { value };
        if (this.#ttls && this.#starts) {
          entry.ttl = this.#ttls[i];
          const age = perf.now() - this.#starts[i];
          entry.start = Math.floor(Date.now() - age);
        }
        if (this.#sizes) {
          entry.size = this.#sizes[i];
        }
        arr.unshift([key, entry]);
      }
      return arr;
    }
    /**
     * Reset the cache and load in the items in entries in the order listed.
     * Note that the shape of the resulting cache may be different if the
     * same options are not used in both caches.
     */
    load(arr) {
      this.clear();
      for (const [key, entry] of arr) {
        if (entry.start) {
          const age = Date.now() - entry.start;
          entry.start = perf.now() - age;
        }
        this.set(key, entry.value, entry);
      }
    }
    /**
     * Add a value to the cache.
     *
     * Note: if `undefined` is specified as a value, this is an alias for
     * {@link LRUCache#delete}
     */
    set(k, v, setOptions = {}) {
      if (v === void 0) {
        this.delete(k);
        return this;
      }
      const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
      let { noUpdateTTL = this.noUpdateTTL } = setOptions;
      const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
      if (this.maxEntrySize && size > this.maxEntrySize) {
        if (status) {
          status.set = "miss";
          status.maxEntrySizeExceeded = true;
        }
        this.delete(k);
        return this;
      }
      let index = this.#size === 0 ? void 0 : this.#keyMap.get(k);
      if (index === void 0) {
        index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
        this.#keyList[index] = k;
        this.#valList[index] = v;
        this.#keyMap.set(k, index);
        this.#next[this.#tail] = index;
        this.#prev[index] = this.#tail;
        this.#tail = index;
        this.#size++;
        this.#addItemSize(index, size, status);
        if (status)
          status.set = "add";
        noUpdateTTL = false;
      } else {
        this.#moveToTail(index);
        const oldVal = this.#valList[index];
        if (v !== oldVal) {
          if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
            oldVal.__abortController.abort(new Error("replaced"));
          } else if (!noDisposeOnSet) {
            if (this.#hasDispose) {
              this.#dispose?.(oldVal, k, "set");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([oldVal, k, "set"]);
            }
          }
          this.#removeItemSize(index);
          this.#addItemSize(index, size, status);
          this.#valList[index] = v;
          if (status) {
            status.set = "replace";
            const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
            if (oldValue !== void 0)
              status.oldValue = oldValue;
          }
        } else if (status) {
          status.set = "update";
        }
      }
      if (ttl !== 0 && !this.#ttls) {
        this.#initializeTTLTracking();
      }
      if (this.#ttls) {
        if (!noUpdateTTL) {
          this.#setItemTTL(index, ttl, start);
        }
        if (status)
          this.#statusTTL(status, index);
      }
      if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
      return this;
    }
    /**
     * Evict the least recently used item, returning its value or
     * `undefined` if cache is empty.
     */
    pop() {
      try {
        while (this.#size) {
          const val = this.#valList[this.#head];
          this.#evict(true);
          if (this.#isBackgroundFetch(val)) {
            if (val.__staleWhileFetching) {
              return val.__staleWhileFetching;
            }
          } else if (val !== void 0) {
            return val;
          }
        }
      } finally {
        if (this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
      }
    }
    #evict(free) {
      const head = this.#head;
      const k = this.#keyList[head];
      const v = this.#valList[head];
      if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
        v.__abortController.abort(new Error("evicted"));
      } else if (this.#hasDispose || this.#hasDisposeAfter) {
        if (this.#hasDispose) {
          this.#dispose?.(v, k, "evict");
        }
        if (this.#hasDisposeAfter) {
          this.#disposed?.push([v, k, "evict"]);
        }
      }
      this.#removeItemSize(head);
      if (free) {
        this.#keyList[head] = void 0;
        this.#valList[head] = void 0;
        this.#free.push(head);
      }
      if (this.#size === 1) {
        this.#head = this.#tail = 0;
        this.#free.length = 0;
      } else {
        this.#head = this.#next[head];
      }
      this.#keyMap.delete(k);
      this.#size--;
      return head;
    }
    /**
     * Check if a key is in the cache, without updating the recency of use.
     * Will return false if the item is stale, even though it is technically
     * in the cache.
     *
     * Will not update item age unless
     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
     */
    has(k, hasOptions = {}) {
      const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
      const index = this.#keyMap.get(k);
      if (index !== void 0) {
        const v = this.#valList[index];
        if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0) {
          return false;
        }
        if (!this.#isStale(index)) {
          if (updateAgeOnHas) {
            this.#updateItemAge(index);
          }
          if (status) {
            status.has = "hit";
            this.#statusTTL(status, index);
          }
          return true;
        } else if (status) {
          status.has = "stale";
          this.#statusTTL(status, index);
        }
      } else if (status) {
        status.has = "miss";
      }
      return false;
    }
    /**
     * Like {@link LRUCache#get} but doesn't update recency or delete stale
     * items.
     *
     * Returns `undefined` if the item is stale, unless
     * {@link LRUCache.OptionsBase.allowStale} is set.
     */
    peek(k, peekOptions = {}) {
      const { allowStale = this.allowStale } = peekOptions;
      const index = this.#keyMap.get(k);
      if (index !== void 0 && (allowStale || !this.#isStale(index))) {
        const v = this.#valList[index];
        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      }
    }
    #backgroundFetch(k, index, options, context2) {
      const v = index === void 0 ? void 0 : this.#valList[index];
      if (this.#isBackgroundFetch(v)) {
        return v;
      }
      const ac = new AC();
      const { signal } = options;
      signal?.addEventListener("abort", () => ac.abort(signal.reason), {
        signal: ac.signal
      });
      const fetchOpts = {
        signal: ac.signal,
        options,
        context: context2
      };
      const cb = (v2, updateCache = false) => {
        const { aborted } = ac.signal;
        const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
        if (options.status) {
          if (aborted && !updateCache) {
            options.status.fetchAborted = true;
            options.status.fetchError = ac.signal.reason;
            if (ignoreAbort)
              options.status.fetchAbortIgnored = true;
          } else {
            options.status.fetchResolved = true;
          }
        }
        if (aborted && !ignoreAbort && !updateCache) {
          return fetchFail(ac.signal.reason);
        }
        const bf2 = p;
        if (this.#valList[index] === p) {
          if (v2 === void 0) {
            if (bf2.__staleWhileFetching) {
              this.#valList[index] = bf2.__staleWhileFetching;
            } else {
              this.delete(k);
            }
          } else {
            if (options.status)
              options.status.fetchUpdated = true;
            this.set(k, v2, fetchOpts.options);
          }
        }
        return v2;
      };
      const eb = (er) => {
        if (options.status) {
          options.status.fetchRejected = true;
          options.status.fetchError = er;
        }
        return fetchFail(er);
      };
      const fetchFail = (er) => {
        const { aborted } = ac.signal;
        const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
        const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
        const noDelete = allowStale || options.noDeleteOnFetchRejection;
        const bf2 = p;
        if (this.#valList[index] === p) {
          const del = !noDelete || bf2.__staleWhileFetching === void 0;
          if (del) {
            this.delete(k);
          } else if (!allowStaleAborted) {
            this.#valList[index] = bf2.__staleWhileFetching;
          }
        }
        if (allowStale) {
          if (options.status && bf2.__staleWhileFetching !== void 0) {
            options.status.returnedStale = true;
          }
          return bf2.__staleWhileFetching;
        } else if (bf2.__returned === bf2) {
          throw er;
        }
      };
      const pcall = (res, rej) => {
        const fmp = this.#fetchMethod?.(k, v, fetchOpts);
        if (fmp && fmp instanceof Promise) {
          fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
        }
        ac.signal.addEventListener("abort", () => {
          if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
            res(void 0);
            if (options.allowStaleOnFetchAbort) {
              res = (v2) => cb(v2, true);
            }
          }
        });
      };
      if (options.status)
        options.status.fetchDispatched = true;
      const p = new Promise(pcall).then(cb, eb);
      const bf = Object.assign(p, {
        __abortController: ac,
        __staleWhileFetching: v,
        __returned: void 0
      });
      if (index === void 0) {
        this.set(k, bf, { ...fetchOpts.options, status: void 0 });
        index = this.#keyMap.get(k);
      } else {
        this.#valList[index] = bf;
      }
      return bf;
    }
    #isBackgroundFetch(p) {
      if (!this.#hasFetchMethod)
        return false;
      const b = p;
      return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
    }
    async fetch(k, fetchOptions = {}) {
      const {
        // get options
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        // set options
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
        ignoreFetchAbort = this.ignoreFetchAbort,
        allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
        context: context2,
        forceRefresh = false,
        status,
        signal
      } = fetchOptions;
      if (!this.#hasFetchMethod) {
        if (status)
          status.fetch = "get";
        return this.get(k, {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          status
        });
      }
      const options = {
        allowStale,
        updateAgeOnGet,
        noDeleteOnStaleGet,
        ttl,
        noDisposeOnSet,
        size,
        sizeCalculation,
        noUpdateTTL,
        noDeleteOnFetchRejection,
        allowStaleOnFetchRejection,
        allowStaleOnFetchAbort,
        ignoreFetchAbort,
        status,
        signal
      };
      let index = this.#keyMap.get(k);
      if (index === void 0) {
        if (status)
          status.fetch = "miss";
        const p = this.#backgroundFetch(k, index, options, context2);
        return p.__returned = p;
      } else {
        const v = this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
          const stale = allowStale && v.__staleWhileFetching !== void 0;
          if (status) {
            status.fetch = "inflight";
            if (stale)
              status.returnedStale = true;
          }
          return stale ? v.__staleWhileFetching : v.__returned = v;
        }
        const isStale = this.#isStale(index);
        if (!forceRefresh && !isStale) {
          if (status)
            status.fetch = "hit";
          this.#moveToTail(index);
          if (updateAgeOnGet) {
            this.#updateItemAge(index);
          }
          if (status)
            this.#statusTTL(status, index);
          return v;
        }
        const p = this.#backgroundFetch(k, index, options, context2);
        const hasStale = p.__staleWhileFetching !== void 0;
        const staleVal = hasStale && allowStale;
        if (status) {
          status.fetch = isStale ? "stale" : "refresh";
          if (staleVal && isStale)
            status.returnedStale = true;
        }
        return staleVal ? p.__staleWhileFetching : p.__returned = p;
      }
    }
    /**
     * Return a value from the cache. Will update the recency of the cache
     * entry found.
     *
     * If the key is not found, get() will return `undefined`.
     */
    get(k, getOptions = {}) {
      const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
      const index = this.#keyMap.get(k);
      if (index !== void 0) {
        const value = this.#valList[index];
        const fetching = this.#isBackgroundFetch(value);
        if (status)
          this.#statusTTL(status, index);
        if (this.#isStale(index)) {
          if (status)
            status.get = "stale";
          if (!fetching) {
            if (!noDeleteOnStaleGet) {
              this.delete(k);
            }
            if (status && allowStale)
              status.returnedStale = true;
            return allowStale ? value : void 0;
          } else {
            if (status && allowStale && value.__staleWhileFetching !== void 0) {
              status.returnedStale = true;
            }
            return allowStale ? value.__staleWhileFetching : void 0;
          }
        } else {
          if (status)
            status.get = "hit";
          if (fetching) {
            return value.__staleWhileFetching;
          }
          this.#moveToTail(index);
          if (updateAgeOnGet) {
            this.#updateItemAge(index);
          }
          return value;
        }
      } else if (status) {
        status.get = "miss";
      }
    }
    #connect(p, n) {
      this.#prev[n] = p;
      this.#next[p] = n;
    }
    #moveToTail(index) {
      if (index !== this.#tail) {
        if (index === this.#head) {
          this.#head = this.#next[index];
        } else {
          this.#connect(this.#prev[index], this.#next[index]);
        }
        this.#connect(this.#tail, index);
        this.#tail = index;
      }
    }
    /**
     * Deletes a key out of the cache.
     * Returns true if the key was deleted, false otherwise.
     */
    delete(k) {
      let deleted = false;
      if (this.#size !== 0) {
        const index = this.#keyMap.get(k);
        if (index !== void 0) {
          deleted = true;
          if (this.#size === 1) {
            this.clear();
          } else {
            this.#removeItemSize(index);
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
              v.__abortController.abort(new Error("deleted"));
            } else if (this.#hasDispose || this.#hasDisposeAfter) {
              if (this.#hasDispose) {
                this.#dispose?.(v, k, "delete");
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([v, k, "delete"]);
              }
            }
            this.#keyMap.delete(k);
            this.#keyList[index] = void 0;
            this.#valList[index] = void 0;
            if (index === this.#tail) {
              this.#tail = this.#prev[index];
            } else if (index === this.#head) {
              this.#head = this.#next[index];
            } else {
              this.#next[this.#prev[index]] = this.#next[index];
              this.#prev[this.#next[index]] = this.#prev[index];
            }
            this.#size--;
            this.#free.push(index);
          }
        }
      }
      if (this.#hasDisposeAfter && this.#disposed?.length) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
      return deleted;
    }
    /**
     * Clear the cache entirely, throwing away all values.
     */
    clear() {
      for (const index of this.#rindexes({ allowStale: true })) {
        const v = this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
          v.__abortController.abort(new Error("deleted"));
        } else {
          const k = this.#keyList[index];
          if (this.#hasDispose) {
            this.#dispose?.(v, k, "delete");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([v, k, "delete"]);
          }
        }
      }
      this.#keyMap.clear();
      this.#valList.fill(void 0);
      this.#keyList.fill(void 0);
      if (this.#ttls && this.#starts) {
        this.#ttls.fill(0);
        this.#starts.fill(0);
      }
      if (this.#sizes) {
        this.#sizes.fill(0);
      }
      this.#head = 0;
      this.#tail = 0;
      this.#free.length = 0;
      this.#calculatedSize = 0;
      this.#size = 0;
      if (this.#hasDisposeAfter && this.#disposed) {
        const dt = this.#disposed;
        let task;
        while (task = dt?.shift()) {
          this.#disposeAfter?.(...task);
        }
      }
    }
  };

  // ../../node_modules/.pnpm/path-scurry@1.10.0/node_modules/path-scurry/dist/mjs/index.js
  var import_path = __require2("path");
  var import_url = __require2("url");
  var actualFS = __toESM(__require2("fs"), 1);
  var import_fs = __require2("fs");
  var import_promises = __require2("fs/promises");

  // ../../node_modules/.pnpm/minipass@6.0.2/node_modules/minipass/index.mjs
  var import_events = __toESM(__require2("events"), 1);
  var import_stream = __toESM(__require2("stream"), 1);
  var import_string_decoder = __toESM(__require2("string_decoder"), 1);
  var proc = typeof process === "object" && process ? process : {
    stdout: null,
    stderr: null
  };
  var SD = import_string_decoder.default.StringDecoder;
  var EOF = Symbol("EOF");
  var MAYBE_EMIT_END = Symbol("maybeEmitEnd");
  var EMITTED_END = Symbol("emittedEnd");
  var EMITTING_END = Symbol("emittingEnd");
  var EMITTED_ERROR = Symbol("emittedError");
  var CLOSED = Symbol("closed");
  var READ = Symbol("read");
  var FLUSH = Symbol("flush");
  var FLUSHCHUNK = Symbol("flushChunk");
  var ENCODING = Symbol("encoding");
  var DECODER = Symbol("decoder");
  var FLOWING = Symbol("flowing");
  var PAUSED = Symbol("paused");
  var RESUME = Symbol("resume");
  var BUFFER = Symbol("buffer");
  var PIPES = Symbol("pipes");
  var BUFFERLENGTH = Symbol("bufferLength");
  var BUFFERPUSH = Symbol("bufferPush");
  var BUFFERSHIFT = Symbol("bufferShift");
  var OBJECTMODE = Symbol("objectMode");
  var DESTROYED = Symbol("destroyed");
  var ERROR = Symbol("error");
  var EMITDATA = Symbol("emitData");
  var EMITEND = Symbol("emitEnd");
  var EMITEND2 = Symbol("emitEnd2");
  var ASYNC = Symbol("async");
  var ABORT = Symbol("abort");
  var ABORTED = Symbol("aborted");
  var SIGNAL = Symbol("signal");
  var defer = (fn) => Promise.resolve().then(fn);
  var doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
  var ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol("asyncIterator not implemented");
  var ITERATOR = doIter && Symbol.iterator || Symbol("iterator not implemented");
  var isEndish = (ev) => ev === "end" || ev === "finish" || ev === "prefinish";
  var isArrayBuffer = (b) => b instanceof ArrayBuffer || typeof b === "object" && b.constructor && b.constructor.name === "ArrayBuffer" && b.byteLength >= 0;
  var isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
  var Pipe = class {
    constructor(src, dest, opts) {
      this.src = src;
      this.dest = dest;
      this.opts = opts;
      this.ondrain = () => src[RESUME]();
      dest.on("drain", this.ondrain);
    }
    unpipe() {
      this.dest.removeListener("drain", this.ondrain);
    }
    // istanbul ignore next - only here for the prototype
    proxyErrors() {
    }
    end() {
      this.unpipe();
      if (this.opts.end)
        this.dest.end();
    }
  };
  var PipeProxyErrors = class extends Pipe {
    unpipe() {
      this.src.removeListener("error", this.proxyErrors);
      super.unpipe();
    }
    constructor(src, dest, opts) {
      super(src, dest, opts);
      this.proxyErrors = (er) => dest.emit("error", er);
      src.on("error", this.proxyErrors);
    }
  };
  var Minipass = class extends import_stream.default {
    constructor(options) {
      super();
      this[FLOWING] = false;
      this[PAUSED] = false;
      this[PIPES] = [];
      this[BUFFER] = [];
      this[OBJECTMODE] = options && options.objectMode || false;
      if (this[OBJECTMODE])
        this[ENCODING] = null;
      else
        this[ENCODING] = options && options.encoding || null;
      if (this[ENCODING] === "buffer")
        this[ENCODING] = null;
      this[ASYNC] = options && !!options.async || false;
      this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
      this[EOF] = false;
      this[EMITTED_END] = false;
      this[EMITTING_END] = false;
      this[CLOSED] = false;
      this[EMITTED_ERROR] = null;
      this.writable = true;
      this.readable = true;
      this[BUFFERLENGTH] = 0;
      this[DESTROYED] = false;
      if (options && options.debugExposeBuffer === true) {
        Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
      }
      if (options && options.debugExposePipes === true) {
        Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
      }
      this[SIGNAL] = options && options.signal;
      this[ABORTED] = false;
      if (this[SIGNAL]) {
        this[SIGNAL].addEventListener("abort", () => this[ABORT]());
        if (this[SIGNAL].aborted) {
          this[ABORT]();
        }
      }
    }
    get bufferLength() {
      return this[BUFFERLENGTH];
    }
    get encoding() {
      return this[ENCODING];
    }
    set encoding(enc) {
      if (this[OBJECTMODE])
        throw new Error("cannot set encoding in objectMode");
      if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))
        throw new Error("cannot change encoding");
      if (this[ENCODING] !== enc) {
        this[DECODER] = enc ? new SD(enc) : null;
        if (this[BUFFER].length)
          this[BUFFER] = this[BUFFER].map((chunk) => this[DECODER].write(chunk));
      }
      this[ENCODING] = enc;
    }
    setEncoding(enc) {
      this.encoding = enc;
    }
    get objectMode() {
      return this[OBJECTMODE];
    }
    set objectMode(om) {
      this[OBJECTMODE] = this[OBJECTMODE] || !!om;
    }
    get ["async"]() {
      return this[ASYNC];
    }
    set ["async"](a) {
      this[ASYNC] = this[ASYNC] || !!a;
    }
    // drop everything and get out of the flow completely
    [ABORT]() {
      this[ABORTED] = true;
      this.emit("abort", this[SIGNAL].reason);
      this.destroy(this[SIGNAL].reason);
    }
    get aborted() {
      return this[ABORTED];
    }
    set aborted(_) {
    }
    write(chunk, encoding, cb) {
      if (this[ABORTED])
        return false;
      if (this[EOF])
        throw new Error("write after end");
      if (this[DESTROYED]) {
        this.emit(
          "error",
          Object.assign(
            new Error("Cannot call write after a stream was destroyed"),
            { code: "ERR_STREAM_DESTROYED" }
          )
        );
        return true;
      }
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (!encoding)
        encoding = "utf8";
      const fn = this[ASYNC] ? defer : (f2) => f2();
      if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
        if (isArrayBufferView(chunk))
          chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);
        else if (isArrayBuffer(chunk))
          chunk = Buffer.from(chunk);
        else if (typeof chunk !== "string")
          this.objectMode = true;
      }
      if (this[OBJECTMODE]) {
        if (this.flowing && this[BUFFERLENGTH] !== 0)
          this[FLUSH](true);
        if (this.flowing)
          this.emit("data", chunk);
        else
          this[BUFFERPUSH](chunk);
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      if (!chunk.length) {
        if (this[BUFFERLENGTH] !== 0)
          this.emit("readable");
        if (cb)
          fn(cb);
        return this.flowing;
      }
      if (typeof chunk === "string" && // unless it is a string already ready for us to use
      !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {
        chunk = Buffer.from(chunk, encoding);
      }
      if (Buffer.isBuffer(chunk) && this[ENCODING])
        chunk = this[DECODER].write(chunk);
      if (this.flowing && this[BUFFERLENGTH] !== 0)
        this[FLUSH](true);
      if (this.flowing)
        this.emit("data", chunk);
      else
        this[BUFFERPUSH](chunk);
      if (this[BUFFERLENGTH] !== 0)
        this.emit("readable");
      if (cb)
        fn(cb);
      return this.flowing;
    }
    read(n) {
      if (this[DESTROYED])
        return null;
      if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
        this[MAYBE_EMIT_END]();
        return null;
      }
      if (this[OBJECTMODE])
        n = null;
      if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
        if (this.encoding)
          this[BUFFER] = [this[BUFFER].join("")];
        else
          this[BUFFER] = [Buffer.concat(this[BUFFER], this[BUFFERLENGTH])];
      }
      const ret3 = this[READ](n || null, this[BUFFER][0]);
      this[MAYBE_EMIT_END]();
      return ret3;
    }
    [READ](n, chunk) {
      if (n === chunk.length || n === null)
        this[BUFFERSHIFT]();
      else {
        this[BUFFER][0] = chunk.slice(n);
        chunk = chunk.slice(0, n);
        this[BUFFERLENGTH] -= n;
      }
      this.emit("data", chunk);
      if (!this[BUFFER].length && !this[EOF])
        this.emit("drain");
      return chunk;
    }
    end(chunk, encoding, cb) {
      if (typeof chunk === "function")
        cb = chunk, chunk = null;
      if (typeof encoding === "function")
        cb = encoding, encoding = "utf8";
      if (chunk)
        this.write(chunk, encoding);
      if (cb)
        this.once("end", cb);
      this[EOF] = true;
      this.writable = false;
      if (this.flowing || !this[PAUSED])
        this[MAYBE_EMIT_END]();
      return this;
    }
    // don't let the internal resume be overwritten
    [RESUME]() {
      if (this[DESTROYED])
        return;
      this[PAUSED] = false;
      this[FLOWING] = true;
      this.emit("resume");
      if (this[BUFFER].length)
        this[FLUSH]();
      else if (this[EOF])
        this[MAYBE_EMIT_END]();
      else
        this.emit("drain");
    }
    resume() {
      return this[RESUME]();
    }
    pause() {
      this[FLOWING] = false;
      this[PAUSED] = true;
    }
    get destroyed() {
      return this[DESTROYED];
    }
    get flowing() {
      return this[FLOWING];
    }
    get paused() {
      return this[PAUSED];
    }
    [BUFFERPUSH](chunk) {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] += 1;
      else
        this[BUFFERLENGTH] += chunk.length;
      this[BUFFER].push(chunk);
    }
    [BUFFERSHIFT]() {
      if (this[OBJECTMODE])
        this[BUFFERLENGTH] -= 1;
      else
        this[BUFFERLENGTH] -= this[BUFFER][0].length;
      return this[BUFFER].shift();
    }
    [FLUSH](noDrain) {
      do {
      } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);
      if (!noDrain && !this[BUFFER].length && !this[EOF])
        this.emit("drain");
    }
    [FLUSHCHUNK](chunk) {
      this.emit("data", chunk);
      return this.flowing;
    }
    pipe(dest, opts) {
      if (this[DESTROYED])
        return;
      const ended = this[EMITTED_END];
      opts = opts || {};
      if (dest === proc.stdout || dest === proc.stderr)
        opts.end = false;
      else
        opts.end = opts.end !== false;
      opts.proxyErrors = !!opts.proxyErrors;
      if (ended) {
        if (opts.end)
          dest.end();
      } else {
        this[PIPES].push(
          !opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts)
        );
        if (this[ASYNC])
          defer(() => this[RESUME]());
        else
          this[RESUME]();
      }
      return dest;
    }
    unpipe(dest) {
      const p = this[PIPES].find((p2) => p2.dest === dest);
      if (p) {
        this[PIPES].splice(this[PIPES].indexOf(p), 1);
        p.unpipe();
      }
    }
    addListener(ev, fn) {
      return this.on(ev, fn);
    }
    on(ev, fn) {
      const ret3 = super.on(ev, fn);
      if (ev === "data" && !this[PIPES].length && !this.flowing)
        this[RESUME]();
      else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
        super.emit("readable");
      else if (isEndish(ev) && this[EMITTED_END]) {
        super.emit(ev);
        this.removeAllListeners(ev);
      } else if (ev === "error" && this[EMITTED_ERROR]) {
        if (this[ASYNC])
          defer(() => fn.call(this, this[EMITTED_ERROR]));
        else
          fn.call(this, this[EMITTED_ERROR]);
      }
      return ret3;
    }
    get emittedEnd() {
      return this[EMITTED_END];
    }
    [MAYBE_EMIT_END]() {
      if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {
        this[EMITTING_END] = true;
        this.emit("end");
        this.emit("prefinish");
        this.emit("finish");
        if (this[CLOSED])
          this.emit("close");
        this[EMITTING_END] = false;
      }
    }
    emit(ev, data, ...extra) {
      if (ev !== "error" && ev !== "close" && ev !== DESTROYED && this[DESTROYED])
        return;
      else if (ev === "data") {
        return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);
      } else if (ev === "end") {
        return this[EMITEND]();
      } else if (ev === "close") {
        this[CLOSED] = true;
        if (!this[EMITTED_END] && !this[DESTROYED])
          return;
        const ret4 = super.emit("close");
        this.removeAllListeners("close");
        return ret4;
      } else if (ev === "error") {
        this[EMITTED_ERROR] = data;
        super.emit(ERROR, data);
        const ret4 = !this[SIGNAL] || this.listeners("error").length ? super.emit("error", data) : false;
        this[MAYBE_EMIT_END]();
        return ret4;
      } else if (ev === "resume") {
        const ret4 = super.emit("resume");
        this[MAYBE_EMIT_END]();
        return ret4;
      } else if (ev === "finish" || ev === "prefinish") {
        const ret4 = super.emit(ev);
        this.removeAllListeners(ev);
        return ret4;
      }
      const ret3 = super.emit(ev, data, ...extra);
      this[MAYBE_EMIT_END]();
      return ret3;
    }
    [EMITDATA](data) {
      for (const p of this[PIPES]) {
        if (p.dest.write(data) === false)
          this.pause();
      }
      const ret3 = super.emit("data", data);
      this[MAYBE_EMIT_END]();
      return ret3;
    }
    [EMITEND]() {
      if (this[EMITTED_END])
        return;
      this[EMITTED_END] = true;
      this.readable = false;
      if (this[ASYNC])
        defer(() => this[EMITEND2]());
      else
        this[EMITEND2]();
    }
    [EMITEND2]() {
      if (this[DECODER]) {
        const data = this[DECODER].end();
        if (data) {
          for (const p of this[PIPES]) {
            p.dest.write(data);
          }
          super.emit("data", data);
        }
      }
      for (const p of this[PIPES]) {
        p.end();
      }
      const ret3 = super.emit("end");
      this.removeAllListeners("end");
      return ret3;
    }
    // const all = await stream.collect()
    collect() {
      const buf = [];
      if (!this[OBJECTMODE])
        buf.dataLength = 0;
      const p = this.promise();
      this.on("data", (c) => {
        buf.push(c);
        if (!this[OBJECTMODE])
          buf.dataLength += c.length;
      });
      return p.then(() => buf);
    }
    // const data = await stream.concat()
    concat() {
      return this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this.collect().then(
        (buf) => this[OBJECTMODE] ? Promise.reject(new Error("cannot concat in objectMode")) : this[ENCODING] ? buf.join("") : Buffer.concat(buf, buf.dataLength)
      );
    }
    // stream.promise().then(() => done, er => emitted error)
    promise() {
      return new Promise((resolve4, reject) => {
        this.on(DESTROYED, () => reject(new Error("stream destroyed")));
        this.on("error", (er) => reject(er));
        this.on("end", () => resolve4());
      });
    }
    // for await (let chunk of stream)
    [ASYNCITERATOR]() {
      let stopped = false;
      const stop = () => {
        this.pause();
        stopped = true;
        return Promise.resolve({ done: true });
      };
      const next = () => {
        if (stopped)
          return stop();
        const res = this.read();
        if (res !== null)
          return Promise.resolve({ done: false, value: res });
        if (this[EOF])
          return stop();
        let resolve4 = null;
        let reject = null;
        const onerr = (er) => {
          this.removeListener("data", ondata);
          this.removeListener("end", onend);
          this.removeListener(DESTROYED, ondestroy);
          stop();
          reject(er);
        };
        const ondata = (value) => {
          this.removeListener("error", onerr);
          this.removeListener("end", onend);
          this.removeListener(DESTROYED, ondestroy);
          this.pause();
          resolve4({ value, done: !!this[EOF] });
        };
        const onend = () => {
          this.removeListener("error", onerr);
          this.removeListener("data", ondata);
          this.removeListener(DESTROYED, ondestroy);
          stop();
          resolve4({ done: true });
        };
        const ondestroy = () => onerr(new Error("stream destroyed"));
        return new Promise((res2, rej) => {
          reject = rej;
          resolve4 = res2;
          this.once(DESTROYED, ondestroy);
          this.once("error", onerr);
          this.once("end", onend);
          this.once("data", ondata);
        });
      };
      return {
        next,
        throw: stop,
        return: stop,
        [ASYNCITERATOR]() {
          return this;
        }
      };
    }
    // for (let chunk of stream)
    [ITERATOR]() {
      let stopped = false;
      const stop = () => {
        this.pause();
        this.removeListener(ERROR, stop);
        this.removeListener(DESTROYED, stop);
        this.removeListener("end", stop);
        stopped = true;
        return { done: true };
      };
      const next = () => {
        if (stopped)
          return stop();
        const value = this.read();
        return value === null ? stop() : { value };
      };
      this.once("end", stop);
      this.once(ERROR, stop);
      this.once(DESTROYED, stop);
      return {
        next,
        throw: stop,
        return: stop,
        [ITERATOR]() {
          return this;
        }
      };
    }
    destroy(er) {
      if (this[DESTROYED]) {
        if (er)
          this.emit("error", er);
        else
          this.emit(DESTROYED);
        return this;
      }
      this[DESTROYED] = true;
      this[BUFFER].length = 0;
      this[BUFFERLENGTH] = 0;
      if (typeof this.close === "function" && !this[CLOSED])
        this.close();
      if (er)
        this.emit("error", er);
      else
        this.emit(DESTROYED);
      return this;
    }
    static isStream(s) {
      return !!s && (s instanceof Minipass || s instanceof import_stream.default || s instanceof import_events.default && // readable
      (typeof s.pipe === "function" || // writable
      typeof s.write === "function" && typeof s.end === "function"));
    }
  };

  // ../../node_modules/.pnpm/path-scurry@1.10.0/node_modules/path-scurry/dist/mjs/index.js
  var realpathSync = import_fs.realpathSync.native;
  var defaultFS = {
    lstatSync: import_fs.lstatSync,
    readdir: import_fs.readdir,
    readdirSync: import_fs.readdirSync,
    readlinkSync: import_fs.readlinkSync,
    realpathSync,
    promises: {
      lstat: import_promises.lstat,
      readdir: import_promises.readdir,
      readlink: import_promises.readlink,
      realpath: import_promises.realpath
    }
  };
  var fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {
    ...defaultFS,
    ...fsOption,
    promises: {
      ...defaultFS.promises,
      ...fsOption.promises || {}
    }
  };
  var uncDriveRegexp = /^\\\\\?\\([a-z]:)\\?$/i;
  var uncToDrive = (rootPath) => rootPath.replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
  var eitherSep = /[\\\/]/;
  var UNKNOWN = 0;
  var IFIFO = 1;
  var IFCHR = 2;
  var IFDIR = 4;
  var IFBLK = 6;
  var IFREG = 8;
  var IFLNK = 10;
  var IFSOCK = 12;
  var IFMT = 15;
  var IFMT_UNKNOWN = ~IFMT;
  var READDIR_CALLED = 16;
  var LSTAT_CALLED = 32;
  var ENOTDIR = 64;
  var ENOENT = 128;
  var ENOREADLINK = 256;
  var ENOREALPATH = 512;
  var ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;
  var TYPEMASK = 1023;
  var entToType = (s) => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;
  var normalizeCache = /* @__PURE__ */ new Map();
  var normalize = (s) => {
    const c = normalizeCache.get(s);
    if (c)
      return c;
    const n = s.normalize("NFKD");
    normalizeCache.set(s, n);
    return n;
  };
  var normalizeNocaseCache = /* @__PURE__ */ new Map();
  var normalizeNocase = (s) => {
    const c = normalizeNocaseCache.get(s);
    if (c)
      return c;
    const n = normalize(s.toLowerCase());
    normalizeNocaseCache.set(s, n);
    return n;
  };
  var ResolveCache = class extends LRUCache {
    constructor() {
      super({ max: 256 });
    }
  };
  var ChildrenCache = class extends LRUCache {
    constructor(maxSize = 16 * 1024) {
      super({
        maxSize,
        // parent + children
        sizeCalculation: (a) => a.length + 1
      });
    }
  };
  var setAsCwd = Symbol("PathScurry setAsCwd");
  var PathBase = class {
    /**
     * the basename of this path
     *
     * **Important**: *always* test the path name against any test string
     * usingthe {@link isNamed} method, and not by directly comparing this
     * string. Otherwise, unicode path strings that the system sees as identical
     * will not be properly treated as the same path, leading to incorrect
     * behavior and possible security issues.
     */
    name;
    /**
     * the Path entry corresponding to the path root.
     *
     * @internal
     */
    root;
    /**
     * All roots found within the current PathScurry family
     *
     * @internal
     */
    roots;
    /**
     * a reference to the parent path, or undefined in the case of root entries
     *
     * @internal
     */
    parent;
    /**
     * boolean indicating whether paths are compared case-insensitively
     * @internal
     */
    nocase;
    // potential default fs override
    #fs;
    // Stats fields
    #dev;
    get dev() {
      return this.#dev;
    }
    #mode;
    get mode() {
      return this.#mode;
    }
    #nlink;
    get nlink() {
      return this.#nlink;
    }
    #uid;
    get uid() {
      return this.#uid;
    }
    #gid;
    get gid() {
      return this.#gid;
    }
    #rdev;
    get rdev() {
      return this.#rdev;
    }
    #blksize;
    get blksize() {
      return this.#blksize;
    }
    #ino;
    get ino() {
      return this.#ino;
    }
    #size;
    get size() {
      return this.#size;
    }
    #blocks;
    get blocks() {
      return this.#blocks;
    }
    #atimeMs;
    get atimeMs() {
      return this.#atimeMs;
    }
    #mtimeMs;
    get mtimeMs() {
      return this.#mtimeMs;
    }
    #ctimeMs;
    get ctimeMs() {
      return this.#ctimeMs;
    }
    #birthtimeMs;
    get birthtimeMs() {
      return this.#birthtimeMs;
    }
    #atime;
    get atime() {
      return this.#atime;
    }
    #mtime;
    get mtime() {
      return this.#mtime;
    }
    #ctime;
    get ctime() {
      return this.#ctime;
    }
    #birthtime;
    get birthtime() {
      return this.#birthtime;
    }
    #matchName;
    #depth;
    #fullpath;
    #fullpathPosix;
    #relative;
    #relativePosix;
    #type;
    #children;
    #linkTarget;
    #realpath;
    /**
     * This property is for compatibility with the Dirent class as of
     * Node v20, where Dirent['path'] refers to the path of the directory
     * that was passed to readdir.  So, somewhat counterintuitively, this
     * property refers to the *parent* path, not the path object itself.
     * For root entries, it's the path to the entry itself.
     */
    get path() {
      return (this.parent || this).fullpath();
    }
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type3 = UNKNOWN, root, roots, nocase, children, opts) {
      this.name = name;
      this.#matchName = nocase ? normalizeNocase(name) : normalize(name);
      this.#type = type3 & TYPEMASK;
      this.nocase = nocase;
      this.roots = roots;
      this.root = root || this;
      this.#children = children;
      this.#fullpath = opts.fullpath;
      this.#relative = opts.relative;
      this.#relativePosix = opts.relativePosix;
      this.parent = opts.parent;
      if (this.parent) {
        this.#fs = this.parent.#fs;
      } else {
        this.#fs = fsFromOption(opts.fs);
      }
    }
    /**
     * Returns the depth of the Path object from its root.
     *
     * For example, a path at `/foo/bar` would have a depth of 2.
     */
    depth() {
      if (this.#depth !== void 0)
        return this.#depth;
      if (!this.parent)
        return this.#depth = 0;
      return this.#depth = this.parent.depth() + 1;
    }
    /**
     * @internal
     */
    childrenCache() {
      return this.#children;
    }
    /**
     * Get the Path object referenced by the string path, resolved from this Path
     */
    resolve(path4) {
      if (!path4) {
        return this;
      }
      const rootPath = this.getRootString(path4);
      const dir = path4.substring(rootPath.length);
      const dirParts = dir.split(this.splitSep);
      const result = rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);
      return result;
    }
    #resolveParts(dirParts) {
      let p = this;
      for (const part of dirParts) {
        p = p.child(part);
      }
      return p;
    }
    /**
     * Returns the cached children Path objects, if still available.  If they
     * have fallen out of the cache, then returns an empty array, and resets the
     * READDIR_CALLED bit, so that future calls to readdir() will require an fs
     * lookup.
     *
     * @internal
     */
    children() {
      const cached = this.#children.get(this);
      if (cached) {
        return cached;
      }
      const children = Object.assign([], { provisional: 0 });
      this.#children.set(this, children);
      this.#type &= ~READDIR_CALLED;
      return children;
    }
    /**
     * Resolves a path portion and returns or creates the child Path.
     *
     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is
     * `'..'`.
     *
     * This should not be called directly.  If `pathPart` contains any path
     * separators, it will lead to unsafe undefined behavior.
     *
     * Use `Path.resolve()` instead.
     *
     * @internal
     */
    child(pathPart, opts) {
      if (pathPart === "" || pathPart === ".") {
        return this;
      }
      if (pathPart === "..") {
        return this.parent || this;
      }
      const children = this.children();
      const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);
      for (const p of children) {
        if (p.#matchName === name) {
          return p;
        }
      }
      const s = this.parent ? this.sep : "";
      const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : void 0;
      const pchild = this.newChild(pathPart, UNKNOWN, {
        ...opts,
        parent: this,
        fullpath
      });
      if (!this.canReaddir()) {
        pchild.#type |= ENOENT;
      }
      children.push(pchild);
      return pchild;
    }
    /**
     * The relative path from the cwd. If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpath()
     */
    relative() {
      if (this.#relative !== void 0) {
        return this.#relative;
      }
      const name = this.name;
      const p = this.parent;
      if (!p) {
        return this.#relative = this.name;
      }
      const pv = p.relative();
      return pv + (!pv || !p.parent ? "" : this.sep) + name;
    }
    /**
     * The relative path from the cwd, using / as the path separator.
     * If it does not share an ancestor with
     * the cwd, then this ends up being equivalent to the fullpathPosix()
     * On posix systems, this is identical to relative().
     */
    relativePosix() {
      if (this.sep === "/")
        return this.relative();
      if (this.#relativePosix !== void 0)
        return this.#relativePosix;
      const name = this.name;
      const p = this.parent;
      if (!p) {
        return this.#relativePosix = this.fullpathPosix();
      }
      const pv = p.relativePosix();
      return pv + (!pv || !p.parent ? "" : "/") + name;
    }
    /**
     * The fully resolved path string for this Path entry
     */
    fullpath() {
      if (this.#fullpath !== void 0) {
        return this.#fullpath;
      }
      const name = this.name;
      const p = this.parent;
      if (!p) {
        return this.#fullpath = this.name;
      }
      const pv = p.fullpath();
      const fp = pv + (!p.parent ? "" : this.sep) + name;
      return this.#fullpath = fp;
    }
    /**
     * On platforms other than windows, this is identical to fullpath.
     *
     * On windows, this is overridden to return the forward-slash form of the
     * full UNC path.
     */
    fullpathPosix() {
      if (this.#fullpathPosix !== void 0)
        return this.#fullpathPosix;
      if (this.sep === "/")
        return this.#fullpathPosix = this.fullpath();
      if (!this.parent) {
        const p2 = this.fullpath().replace(/\\/g, "/");
        if (/^[a-z]:\//i.test(p2)) {
          return this.#fullpathPosix = `//?/${p2}`;
        } else {
          return this.#fullpathPosix = p2;
        }
      }
      const p = this.parent;
      const pfpp = p.fullpathPosix();
      const fpp = pfpp + (!pfpp || !p.parent ? "" : "/") + this.name;
      return this.#fullpathPosix = fpp;
    }
    /**
     * Is the Path of an unknown type?
     *
     * Note that we might know *something* about it if there has been a previous
     * filesystem operation, for example that it does not exist, or is not a
     * link, or whether it has child entries.
     */
    isUnknown() {
      return (this.#type & IFMT) === UNKNOWN;
    }
    isType(type3) {
      return this[`is${type3}`]();
    }
    getType() {
      return this.isUnknown() ? "Unknown" : this.isDirectory() ? "Directory" : this.isFile() ? "File" : this.isSymbolicLink() ? "SymbolicLink" : this.isFIFO() ? "FIFO" : this.isCharacterDevice() ? "CharacterDevice" : this.isBlockDevice() ? "BlockDevice" : (
        /* c8 ignore start */
        this.isSocket() ? "Socket" : "Unknown"
      );
    }
    /**
     * Is the Path a regular file?
     */
    isFile() {
      return (this.#type & IFMT) === IFREG;
    }
    /**
     * Is the Path a directory?
     */
    isDirectory() {
      return (this.#type & IFMT) === IFDIR;
    }
    /**
     * Is the path a character device?
     */
    isCharacterDevice() {
      return (this.#type & IFMT) === IFCHR;
    }
    /**
     * Is the path a block device?
     */
    isBlockDevice() {
      return (this.#type & IFMT) === IFBLK;
    }
    /**
     * Is the path a FIFO pipe?
     */
    isFIFO() {
      return (this.#type & IFMT) === IFIFO;
    }
    /**
     * Is the path a socket?
     */
    isSocket() {
      return (this.#type & IFMT) === IFSOCK;
    }
    /**
     * Is the path a symbolic link?
     */
    isSymbolicLink() {
      return (this.#type & IFLNK) === IFLNK;
    }
    /**
     * Return the entry if it has been subject of a successful lstat, or
     * undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* simply
     * mean that we haven't called lstat on it.
     */
    lstatCached() {
      return this.#type & LSTAT_CALLED ? this : void 0;
    }
    /**
     * Return the cached link target if the entry has been the subject of a
     * successful readlink, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readlink() has been called at some point.
     */
    readlinkCached() {
      return this.#linkTarget;
    }
    /**
     * Returns the cached realpath target if the entry has been the subject
     * of a successful realpath, or undefined otherwise.
     *
     * Does not read the filesystem, so an undefined result *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * realpath() has been called at some point.
     */
    realpathCached() {
      return this.#realpath;
    }
    /**
     * Returns the cached child Path entries array if the entry has been the
     * subject of a successful readdir(), or [] otherwise.
     *
     * Does not read the filesystem, so an empty array *could* just mean we
     * don't have any cached data. Only use it if you are very sure that a
     * readdir() has been called recently enough to still be valid.
     */
    readdirCached() {
      const children = this.children();
      return children.slice(0, children.provisional);
    }
    /**
     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have
     * any indication that readlink will definitely fail.
     *
     * Returns false if the path is known to not be a symlink, if a previous
     * readlink failed, or if the entry does not exist.
     */
    canReadlink() {
      if (this.#linkTarget)
        return true;
      if (!this.parent)
        return false;
      const ifmt = this.#type & IFMT;
      return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);
    }
    /**
     * Return true if readdir has previously been successfully called on this
     * path, indicating that cachedReaddir() is likely valid.
     */
    calledReaddir() {
      return !!(this.#type & READDIR_CALLED);
    }
    /**
     * Returns true if the path is known to not exist. That is, a previous lstat
     * or readdir failed to verify its existence when that would have been
     * expected, or a parent entry was marked either enoent or enotdir.
     */
    isENOENT() {
      return !!(this.#type & ENOENT);
    }
    /**
     * Return true if the path is a match for the given path name.  This handles
     * case sensitivity and unicode normalization.
     *
     * Note: even on case-sensitive systems, it is **not** safe to test the
     * equality of the `.name` property to determine whether a given pathname
     * matches, due to unicode normalization mismatches.
     *
     * Always use this method instead of testing the `path.name` property
     * directly.
     */
    isNamed(n) {
      return !this.nocase ? this.#matchName === normalize(n) : this.#matchName === normalizeNocase(n);
    }
    /**
     * Return the Path object corresponding to the target of a symbolic link.
     *
     * If the Path is not a symbolic link, or if the readlink call fails for any
     * reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     */
    async readlink() {
      const target = this.#linkTarget;
      if (target) {
        return target;
      }
      if (!this.canReadlink()) {
        return void 0;
      }
      if (!this.parent) {
        return void 0;
      }
      try {
        const read = await this.#fs.promises.readlink(this.fullpath());
        const linkTarget = this.parent.resolve(read);
        if (linkTarget) {
          return this.#linkTarget = linkTarget;
        }
      } catch (er) {
        this.#readlinkFail(er.code);
        return void 0;
      }
    }
    /**
     * Synchronous {@link PathBase.readlink}
     */
    readlinkSync() {
      const target = this.#linkTarget;
      if (target) {
        return target;
      }
      if (!this.canReadlink()) {
        return void 0;
      }
      if (!this.parent) {
        return void 0;
      }
      try {
        const read = this.#fs.readlinkSync(this.fullpath());
        const linkTarget = this.parent.resolve(read);
        if (linkTarget) {
          return this.#linkTarget = linkTarget;
        }
      } catch (er) {
        this.#readlinkFail(er.code);
        return void 0;
      }
    }
    #readdirSuccess(children) {
      this.#type |= READDIR_CALLED;
      for (let p = children.provisional; p < children.length; p++) {
        children[p].#markENOENT();
      }
    }
    #markENOENT() {
      if (this.#type & ENOENT)
        return;
      this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;
      this.#markChildrenENOENT();
    }
    #markChildrenENOENT() {
      const children = this.children();
      children.provisional = 0;
      for (const p of children) {
        p.#markENOENT();
      }
    }
    #markENOREALPATH() {
      this.#type |= ENOREALPATH;
      this.#markENOTDIR();
    }
    // save the information when we know the entry is not a dir
    #markENOTDIR() {
      if (this.#type & ENOTDIR)
        return;
      let t = this.#type;
      if ((t & IFMT) === IFDIR)
        t &= IFMT_UNKNOWN;
      this.#type = t | ENOTDIR;
      this.#markChildrenENOENT();
    }
    #readdirFail(code = "") {
      if (code === "ENOTDIR" || code === "EPERM") {
        this.#markENOTDIR();
      } else if (code === "ENOENT") {
        this.#markENOENT();
      } else {
        this.children().provisional = 0;
      }
    }
    #lstatFail(code = "") {
      if (code === "ENOTDIR") {
        const p = this.parent;
        p.#markENOTDIR();
      } else if (code === "ENOENT") {
        this.#markENOENT();
      }
    }
    #readlinkFail(code = "") {
      let ter = this.#type;
      ter |= ENOREADLINK;
      if (code === "ENOENT")
        ter |= ENOENT;
      if (code === "EINVAL" || code === "UNKNOWN") {
        ter &= IFMT_UNKNOWN;
      }
      this.#type = ter;
      if (code === "ENOTDIR" && this.parent) {
        this.parent.#markENOTDIR();
      }
    }
    #readdirAddChild(e, c) {
      return this.#readdirMaybePromoteChild(e, c) || this.#readdirAddNewChild(e, c);
    }
    #readdirAddNewChild(e, c) {
      const type3 = entToType(e);
      const child = this.newChild(e.name, type3, { parent: this });
      const ifmt = child.#type & IFMT;
      if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {
        child.#type |= ENOTDIR;
      }
      c.unshift(child);
      c.provisional++;
      return child;
    }
    #readdirMaybePromoteChild(e, c) {
      for (let p = c.provisional; p < c.length; p++) {
        const pchild = c[p];
        const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);
        if (name !== pchild.#matchName) {
          continue;
        }
        return this.#readdirPromoteChild(e, pchild, p, c);
      }
    }
    #readdirPromoteChild(e, p, index, c) {
      const v = p.name;
      p.#type = p.#type & IFMT_UNKNOWN | entToType(e);
      if (v !== e.name)
        p.name = e.name;
      if (index !== c.provisional) {
        if (index === c.length - 1)
          c.pop();
        else
          c.splice(index, 1);
        c.unshift(p);
      }
      c.provisional++;
      return p;
    }
    /**
     * Call lstat() on this Path, and update all known information that can be
     * determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async lstat() {
      if ((this.#type & ENOENT) === 0) {
        try {
          this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));
          return this;
        } catch (er) {
          this.#lstatFail(er.code);
        }
      }
    }
    /**
     * synchronous {@link PathBase.lstat}
     */
    lstatSync() {
      if ((this.#type & ENOENT) === 0) {
        try {
          this.#applyStat(this.#fs.lstatSync(this.fullpath()));
          return this;
        } catch (er) {
          this.#lstatFail(er.code);
        }
      }
    }
    #applyStat(st) {
      const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev: dev2, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid } = st;
      this.#atime = atime;
      this.#atimeMs = atimeMs;
      this.#birthtime = birthtime;
      this.#birthtimeMs = birthtimeMs;
      this.#blksize = blksize;
      this.#blocks = blocks;
      this.#ctime = ctime;
      this.#ctimeMs = ctimeMs;
      this.#dev = dev2;
      this.#gid = gid;
      this.#ino = ino;
      this.#mode = mode;
      this.#mtime = mtime;
      this.#mtimeMs = mtimeMs;
      this.#nlink = nlink;
      this.#rdev = rdev;
      this.#size = size;
      this.#uid = uid;
      const ifmt = entToType(st);
      this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED;
      if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {
        this.#type |= ENOTDIR;
      }
    }
    #onReaddirCB = [];
    #readdirCBInFlight = false;
    #callOnReaddirCB(children) {
      this.#readdirCBInFlight = false;
      const cbs = this.#onReaddirCB.slice();
      this.#onReaddirCB.length = 0;
      cbs.forEach((cb) => cb(null, children));
    }
    /**
     * Standard node-style callback interface to get list of directory entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     *
     * @param cb The callback called with (er, entries).  Note that the `er`
     * param is somewhat extraneous, as all readdir() errors are handled and
     * simply result in an empty set of entries being returned.
     * @param allowZalgo Boolean indicating that immediately known results should
     * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release
     * zalgo at your peril, the dark pony lord is devious and unforgiving.
     */
    readdirCB(cb, allowZalgo = false) {
      if (!this.canReaddir()) {
        if (allowZalgo)
          cb(null, []);
        else
          queueMicrotask(() => cb(null, []));
        return;
      }
      const children = this.children();
      if (this.calledReaddir()) {
        const c = children.slice(0, children.provisional);
        if (allowZalgo)
          cb(null, c);
        else
          queueMicrotask(() => cb(null, c));
        return;
      }
      this.#onReaddirCB.push(cb);
      if (this.#readdirCBInFlight) {
        return;
      }
      this.#readdirCBInFlight = true;
      const fullpath = this.fullpath();
      this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {
        if (er) {
          this.#readdirFail(er.code);
          children.provisional = 0;
        } else {
          for (const e of entries) {
            this.#readdirAddChild(e, children);
          }
          this.#readdirSuccess(children);
        }
        this.#callOnReaddirCB(children.slice(0, children.provisional));
        return;
      });
    }
    #asyncReaddirInFlight;
    /**
     * Return an array of known child entries.
     *
     * If the Path cannot or does not contain any children, then an empty array
     * is returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async readdir() {
      if (!this.canReaddir()) {
        return [];
      }
      const children = this.children();
      if (this.calledReaddir()) {
        return children.slice(0, children.provisional);
      }
      const fullpath = this.fullpath();
      if (this.#asyncReaddirInFlight) {
        await this.#asyncReaddirInFlight;
      } else {
        let resolve4 = () => {
        };
        this.#asyncReaddirInFlight = new Promise((res) => resolve4 = res);
        try {
          for (const e of await this.#fs.promises.readdir(fullpath, {
            withFileTypes: true
          })) {
            this.#readdirAddChild(e, children);
          }
          this.#readdirSuccess(children);
        } catch (er) {
          this.#readdirFail(er.code);
          children.provisional = 0;
        }
        this.#asyncReaddirInFlight = void 0;
        resolve4();
      }
      return children.slice(0, children.provisional);
    }
    /**
     * synchronous {@link PathBase.readdir}
     */
    readdirSync() {
      if (!this.canReaddir()) {
        return [];
      }
      const children = this.children();
      if (this.calledReaddir()) {
        return children.slice(0, children.provisional);
      }
      const fullpath = this.fullpath();
      try {
        for (const e of this.#fs.readdirSync(fullpath, {
          withFileTypes: true
        })) {
          this.#readdirAddChild(e, children);
        }
        this.#readdirSuccess(children);
      } catch (er) {
        this.#readdirFail(er.code);
        children.provisional = 0;
      }
      return children.slice(0, children.provisional);
    }
    canReaddir() {
      if (this.#type & ENOCHILD)
        return false;
      const ifmt = IFMT & this.#type;
      if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {
        return false;
      }
      return true;
    }
    shouldWalk(dirs, walkFilter) {
      return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));
    }
    /**
     * Return the Path object corresponding to path as resolved
     * by realpath(3).
     *
     * If the realpath call fails for any reason, `undefined` is returned.
     *
     * Result is cached, and thus may be outdated if the filesystem is mutated.
     * On success, returns a Path object.
     */
    async realpath() {
      if (this.#realpath)
        return this.#realpath;
      if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
        return void 0;
      try {
        const rp = await this.#fs.promises.realpath(this.fullpath());
        return this.#realpath = this.resolve(rp);
      } catch (_) {
        this.#markENOREALPATH();
      }
    }
    /**
     * Synchronous {@link realpath}
     */
    realpathSync() {
      if (this.#realpath)
        return this.#realpath;
      if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)
        return void 0;
      try {
        const rp = this.#fs.realpathSync(this.fullpath());
        return this.#realpath = this.resolve(rp);
      } catch (_) {
        this.#markENOREALPATH();
      }
    }
    /**
     * Internal method to mark this Path object as the scurry cwd,
     * called by {@link PathScurry#chdir}
     *
     * @internal
     */
    [setAsCwd](oldCwd) {
      if (oldCwd === this)
        return;
      const changed = /* @__PURE__ */ new Set([]);
      let rp = [];
      let p = this;
      while (p && p.parent) {
        changed.add(p);
        p.#relative = rp.join(this.sep);
        p.#relativePosix = rp.join("/");
        p = p.parent;
        rp.push("..");
      }
      p = oldCwd;
      while (p && p.parent && !changed.has(p)) {
        p.#relative = void 0;
        p.#relativePosix = void 0;
        p = p.parent;
      }
    }
  };
  var PathWin32 = class extends PathBase {
    /**
     * Separator for generating path strings.
     */
    sep = "\\";
    /**
     * Separator for parsing path strings.
     */
    splitSep = eitherSep;
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type3 = UNKNOWN, root, roots, nocase, children, opts) {
      super(name, type3, root, roots, nocase, children, opts);
    }
    /**
     * @internal
     */
    newChild(name, type3 = UNKNOWN, opts = {}) {
      return new PathWin32(name, type3, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
    /**
     * @internal
     */
    getRootString(path4) {
      return import_path.win32.parse(path4).root;
    }
    /**
     * @internal
     */
    getRoot(rootPath) {
      rootPath = uncToDrive(rootPath.toUpperCase());
      if (rootPath === this.root.name) {
        return this.root;
      }
      for (const [compare, root] of Object.entries(this.roots)) {
        if (this.sameRoot(rootPath, compare)) {
          return this.roots[rootPath] = root;
        }
      }
      return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;
    }
    /**
     * @internal
     */
    sameRoot(rootPath, compare = this.root.name) {
      rootPath = rootPath.toUpperCase().replace(/\//g, "\\").replace(uncDriveRegexp, "$1\\");
      return rootPath === compare;
    }
  };
  var PathPosix = class extends PathBase {
    /**
     * separator for parsing path strings
     */
    splitSep = "/";
    /**
     * separator for generating path strings
     */
    sep = "/";
    /**
     * Do not create new Path objects directly.  They should always be accessed
     * via the PathScurry class or other methods on the Path class.
     *
     * @internal
     */
    constructor(name, type3 = UNKNOWN, root, roots, nocase, children, opts) {
      super(name, type3, root, roots, nocase, children, opts);
    }
    /**
     * @internal
     */
    getRootString(path4) {
      return path4.startsWith("/") ? "/" : "";
    }
    /**
     * @internal
     */
    getRoot(_rootPath) {
      return this.root;
    }
    /**
     * @internal
     */
    newChild(name, type3 = UNKNOWN, opts = {}) {
      return new PathPosix(name, type3, this.root, this.roots, this.nocase, this.childrenCache(), opts);
    }
  };
  var PathScurryBase = class {
    /**
     * The root Path entry for the current working directory of this Scurry
     */
    root;
    /**
     * The string path for the root of this Scurry's current working directory
     */
    rootPath;
    /**
     * A collection of all roots encountered, referenced by rootPath
     */
    roots;
    /**
     * The Path entry corresponding to this PathScurry's current working directory.
     */
    cwd;
    #resolveCache;
    #resolvePosixCache;
    #children;
    /**
     * Perform path comparisons case-insensitively.
     *
     * Defaults true on Darwin and Windows systems, false elsewhere.
     */
    nocase;
    #fs;
    /**
     * This class should not be instantiated directly.
     *
     * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry
     *
     * @internal
     */
    constructor(cwd = process.cwd(), pathImpl, sep2, { nocase, childrenCacheSize = 16 * 1024, fs: fs4 = defaultFS } = {}) {
      this.#fs = fsFromOption(fs4);
      if (cwd instanceof URL || cwd.startsWith("file://")) {
        cwd = (0, import_url.fileURLToPath)(cwd);
      }
      const cwdPath = pathImpl.resolve(cwd);
      this.roots = /* @__PURE__ */ Object.create(null);
      this.rootPath = this.parseRootPath(cwdPath);
      this.#resolveCache = new ResolveCache();
      this.#resolvePosixCache = new ResolveCache();
      this.#children = new ChildrenCache(childrenCacheSize);
      const split4 = cwdPath.substring(this.rootPath.length).split(sep2);
      if (split4.length === 1 && !split4[0]) {
        split4.pop();
      }
      if (nocase === void 0) {
        throw new TypeError("must provide nocase setting to PathScurryBase ctor");
      }
      this.nocase = nocase;
      this.root = this.newRoot(this.#fs);
      this.roots[this.rootPath] = this.root;
      let prev = this.root;
      let len = split4.length - 1;
      const joinSep = pathImpl.sep;
      let abs = this.rootPath;
      let sawFirst = false;
      for (const part of split4) {
        const l = len--;
        prev = prev.child(part, {
          relative: new Array(l).fill("..").join(joinSep),
          relativePosix: new Array(l).fill("..").join("/"),
          fullpath: abs += (sawFirst ? "" : joinSep) + part
        });
        sawFirst = true;
      }
      this.cwd = prev;
    }
    /**
     * Get the depth of a provided path, string, or the cwd
     */
    depth(path4 = this.cwd) {
      if (typeof path4 === "string") {
        path4 = this.cwd.resolve(path4);
      }
      return path4.depth();
    }
    /**
     * Return the cache of child entries.  Exposed so subclasses can create
     * child Path objects in a platform-specific way.
     *
     * @internal
     */
    childrenCache() {
      return this.#children;
    }
    /**
     * Resolve one or more path strings to a resolved string
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolve(...paths) {
      let r = "";
      for (let i = paths.length - 1; i >= 0; i--) {
        const p = paths[i];
        if (!p || p === ".")
          continue;
        r = r ? `${p}/${r}` : p;
        if (this.isAbsolute(p)) {
          break;
        }
      }
      const cached = this.#resolveCache.get(r);
      if (cached !== void 0) {
        return cached;
      }
      const result = this.cwd.resolve(r).fullpath();
      this.#resolveCache.set(r, result);
      return result;
    }
    /**
     * Resolve one or more path strings to a resolved string, returning
     * the posix path.  Identical to .resolve() on posix systems, but on
     * windows will return a forward-slash separated UNC path.
     *
     * Same interface as require('path').resolve.
     *
     * Much faster than path.resolve() when called multiple times for the same
     * path, because the resolved Path objects are cached.  Much slower
     * otherwise.
     */
    resolvePosix(...paths) {
      let r = "";
      for (let i = paths.length - 1; i >= 0; i--) {
        const p = paths[i];
        if (!p || p === ".")
          continue;
        r = r ? `${p}/${r}` : p;
        if (this.isAbsolute(p)) {
          break;
        }
      }
      const cached = this.#resolvePosixCache.get(r);
      if (cached !== void 0) {
        return cached;
      }
      const result = this.cwd.resolve(r).fullpathPosix();
      this.#resolvePosixCache.set(r, result);
      return result;
    }
    /**
     * find the relative path from the cwd to the supplied path string or entry
     */
    relative(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.relative();
    }
    /**
     * find the relative path from the cwd to the supplied path string or
     * entry, using / as the path delimiter, even on Windows.
     */
    relativePosix(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.relativePosix();
    }
    /**
     * Return the basename for the provided string or Path object
     */
    basename(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.name;
    }
    /**
     * Return the dirname for the provided string or Path object
     */
    dirname(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return (entry.parent || entry).fullpath();
    }
    async readdir(entry = this.cwd, opts = {
      withFileTypes: true
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes } = opts;
      if (!entry.canReaddir()) {
        return [];
      } else {
        const p = await entry.readdir();
        return withFileTypes ? p : p.map((e) => e.name);
      }
    }
    readdirSync(entry = this.cwd, opts = {
      withFileTypes: true
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true } = opts;
      if (!entry.canReaddir()) {
        return [];
      } else if (withFileTypes) {
        return entry.readdirSync();
      } else {
        return entry.readdirSync().map((e) => e.name);
      }
    }
    /**
     * Call lstat() on the string or Path object, and update all known
     * information that can be determined.
     *
     * Note that unlike `fs.lstat()`, the returned value does not contain some
     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that
     * information is required, you will need to call `fs.lstat` yourself.
     *
     * If the Path refers to a nonexistent file, or if the lstat call fails for
     * any reason, `undefined` is returned.  Otherwise the updated Path object is
     * returned.
     *
     * Results are cached, and thus may be out of date if the filesystem is
     * mutated.
     */
    async lstat(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.lstat();
    }
    /**
     * synchronous {@link PathScurryBase.lstat}
     */
    lstatSync(entry = this.cwd) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      }
      return entry.lstatSync();
    }
    async readlink(entry = this.cwd, { withFileTypes } = {
      withFileTypes: false
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        withFileTypes = entry.withFileTypes;
        entry = this.cwd;
      }
      const e = await entry.readlink();
      return withFileTypes ? e : e?.fullpath();
    }
    readlinkSync(entry = this.cwd, { withFileTypes } = {
      withFileTypes: false
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        withFileTypes = entry.withFileTypes;
        entry = this.cwd;
      }
      const e = entry.readlinkSync();
      return withFileTypes ? e : e?.fullpath();
    }
    async realpath(entry = this.cwd, { withFileTypes } = {
      withFileTypes: false
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        withFileTypes = entry.withFileTypes;
        entry = this.cwd;
      }
      const e = await entry.realpath();
      return withFileTypes ? e : e?.fullpath();
    }
    realpathSync(entry = this.cwd, { withFileTypes } = {
      withFileTypes: false
    }) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        withFileTypes = entry.withFileTypes;
        entry = this.cwd;
      }
      const e = entry.realpathSync();
      return withFileTypes ? e : e?.fullpath();
    }
    async walk(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
      const results = [];
      if (!filter2 || filter2(entry)) {
        results.push(withFileTypes ? entry : entry.fullpath());
      }
      const dirs = /* @__PURE__ */ new Set();
      const walk = (dir, cb) => {
        dirs.add(dir);
        dir.readdirCB((er, entries) => {
          if (er) {
            return cb(er);
          }
          let len = entries.length;
          if (!len)
            return cb();
          const next = () => {
            if (--len === 0) {
              cb();
            }
          };
          for (const e of entries) {
            if (!filter2 || filter2(e)) {
              results.push(withFileTypes ? e : e.fullpath());
            }
            if (follow && e.isSymbolicLink()) {
              e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r).then((r) => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());
            } else {
              if (e.shouldWalk(dirs, walkFilter)) {
                walk(e, next);
              } else {
                next();
              }
            }
          }
        }, true);
      };
      const start = entry;
      return new Promise((res, rej) => {
        walk(start, (er) => {
          if (er)
            return rej(er);
          res(results);
        });
      });
    }
    walkSync(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
      const results = [];
      if (!filter2 || filter2(entry)) {
        results.push(withFileTypes ? entry : entry.fullpath());
      }
      const dirs = /* @__PURE__ */ new Set([entry]);
      for (const dir of dirs) {
        const entries = dir.readdirSync();
        for (const e of entries) {
          if (!filter2 || filter2(e)) {
            results.push(withFileTypes ? e : e.fullpath());
          }
          let r = e;
          if (e.isSymbolicLink()) {
            if (!(follow && (r = e.realpathSync())))
              continue;
            if (r.isUnknown())
              r.lstatSync();
          }
          if (r.shouldWalk(dirs, walkFilter)) {
            dirs.add(r);
          }
        }
      }
      return results;
    }
    /**
     * Support for `for await`
     *
     * Alias for {@link PathScurryBase.iterate}
     *
     * Note: As of Node 19, this is very slow, compared to other methods of
     * walking.  Consider using {@link PathScurryBase.stream} if memory overhead
     * and backpressure are concerns, or {@link PathScurryBase.walk} if not.
     */
    [Symbol.asyncIterator]() {
      return this.iterate();
    }
    iterate(entry = this.cwd, options = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        options = entry;
        entry = this.cwd;
      }
      return this.stream(entry, options)[Symbol.asyncIterator]();
    }
    /**
     * Iterating over a PathScurry performs a synchronous walk.
     *
     * Alias for {@link PathScurryBase.iterateSync}
     */
    [Symbol.iterator]() {
      return this.iterateSync();
    }
    *iterateSync(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
      if (!filter2 || filter2(entry)) {
        yield withFileTypes ? entry : entry.fullpath();
      }
      const dirs = /* @__PURE__ */ new Set([entry]);
      for (const dir of dirs) {
        const entries = dir.readdirSync();
        for (const e of entries) {
          if (!filter2 || filter2(e)) {
            yield withFileTypes ? e : e.fullpath();
          }
          let r = e;
          if (e.isSymbolicLink()) {
            if (!(follow && (r = e.realpathSync())))
              continue;
            if (r.isUnknown())
              r.lstatSync();
          }
          if (r.shouldWalk(dirs, walkFilter)) {
            dirs.add(r);
          }
        }
      }
    }
    stream(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
      const results = new Minipass({ objectMode: true });
      if (!filter2 || filter2(entry)) {
        results.write(withFileTypes ? entry : entry.fullpath());
      }
      const dirs = /* @__PURE__ */ new Set();
      const queue = [entry];
      let processing = 0;
      const process2 = () => {
        let paused = false;
        while (!paused) {
          const dir = queue.shift();
          if (!dir) {
            if (processing === 0)
              results.end();
            return;
          }
          processing++;
          dirs.add(dir);
          const onReaddir = (er, entries, didRealpaths = false) => {
            if (er)
              return results.emit("error", er);
            if (follow && !didRealpaths) {
              const promises = [];
              for (const e of entries) {
                if (e.isSymbolicLink()) {
                  promises.push(e.realpath().then((r) => r?.isUnknown() ? r.lstat() : r));
                }
              }
              if (promises.length) {
                Promise.all(promises).then(() => onReaddir(null, entries, true));
                return;
              }
            }
            for (const e of entries) {
              if (e && (!filter2 || filter2(e))) {
                if (!results.write(withFileTypes ? e : e.fullpath())) {
                  paused = true;
                }
              }
            }
            processing--;
            for (const e of entries) {
              const r = e.realpathCached() || e;
              if (r.shouldWalk(dirs, walkFilter)) {
                queue.push(r);
              }
            }
            if (paused && !results.flowing) {
              results.once("drain", process2);
            } else if (!sync2) {
              process2();
            }
          };
          let sync2 = true;
          dir.readdirCB(onReaddir, true);
          sync2 = false;
        }
      };
      process2();
      return results;
    }
    streamSync(entry = this.cwd, opts = {}) {
      if (typeof entry === "string") {
        entry = this.cwd.resolve(entry);
      } else if (!(entry instanceof PathBase)) {
        opts = entry;
        entry = this.cwd;
      }
      const { withFileTypes = true, follow = false, filter: filter2, walkFilter } = opts;
      const results = new Minipass({ objectMode: true });
      const dirs = /* @__PURE__ */ new Set();
      if (!filter2 || filter2(entry)) {
        results.write(withFileTypes ? entry : entry.fullpath());
      }
      const queue = [entry];
      let processing = 0;
      const process2 = () => {
        let paused = false;
        while (!paused) {
          const dir = queue.shift();
          if (!dir) {
            if (processing === 0)
              results.end();
            return;
          }
          processing++;
          dirs.add(dir);
          const entries = dir.readdirSync();
          for (const e of entries) {
            if (!filter2 || filter2(e)) {
              if (!results.write(withFileTypes ? e : e.fullpath())) {
                paused = true;
              }
            }
          }
          processing--;
          for (const e of entries) {
            let r = e;
            if (e.isSymbolicLink()) {
              if (!(follow && (r = e.realpathSync())))
                continue;
              if (r.isUnknown())
                r.lstatSync();
            }
            if (r.shouldWalk(dirs, walkFilter)) {
              queue.push(r);
            }
          }
        }
        if (paused && !results.flowing)
          results.once("drain", process2);
      };
      process2();
      return results;
    }
    chdir(path4 = this.cwd) {
      const oldCwd = this.cwd;
      this.cwd = typeof path4 === "string" ? this.cwd.resolve(path4) : path4;
      this.cwd[setAsCwd](oldCwd);
    }
  };
  var PathScurryWin32 = class extends PathScurryBase {
    /**
     * separator for generating path strings
     */
    sep = "\\";
    constructor(cwd = process.cwd(), opts = {}) {
      const { nocase = true } = opts;
      super(cwd, import_path.win32, "\\", { ...opts, nocase });
      this.nocase = nocase;
      for (let p = this.cwd; p; p = p.parent) {
        p.nocase = this.nocase;
      }
    }
    /**
     * @internal
     */
    parseRootPath(dir) {
      return import_path.win32.parse(dir).root.toUpperCase();
    }
    /**
     * @internal
     */
    newRoot(fs4) {
      return new PathWin32(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs4 });
    }
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p) {
      return p.startsWith("/") || p.startsWith("\\") || /^[a-z]:(\/|\\)/i.test(p);
    }
  };
  var PathScurryPosix = class extends PathScurryBase {
    /**
     * separator for generating path strings
     */
    sep = "/";
    constructor(cwd = process.cwd(), opts = {}) {
      const { nocase = false } = opts;
      super(cwd, import_path.posix, "/", { ...opts, nocase });
      this.nocase = nocase;
    }
    /**
     * @internal
     */
    parseRootPath(_dir) {
      return "/";
    }
    /**
     * @internal
     */
    newRoot(fs4) {
      return new PathPosix(this.rootPath, IFDIR, void 0, this.roots, this.nocase, this.childrenCache(), { fs: fs4 });
    }
    /**
     * Return true if the provided path string is an absolute path
     */
    isAbsolute(p) {
      return p.startsWith("/");
    }
  };
  var PathScurryDarwin = class extends PathScurryPosix {
    constructor(cwd = process.cwd(), opts = {}) {
      const { nocase = true } = opts;
      super(cwd, { ...opts, nocase });
    }
  };
  var Path = process.platform === "win32" ? PathWin32 : PathPosix;
  var PathScurry = process.platform === "win32" ? PathScurryWin32 : process.platform === "darwin" ? PathScurryDarwin : PathScurryPosix;

  // ../../node_modules/.pnpm/glob@10.2.6/node_modules/glob/dist/mjs/glob.js
  var import_url2 = __require2("url");

  // ../../node_modules/.pnpm/glob@10.2.6/node_modules/glob/dist/mjs/pattern.js
  var isPatternList = (pl) => pl.length >= 1;
  var isGlobList = (gl) => gl.length >= 1;
  var Pattern = class {
    #patternList;
    #globList;
    #index;
    length;
    #platform;
    #rest;
    #globString;
    #isDrive;
    #isUNC;
    #isAbsolute;
    #followGlobstar = true;
    constructor(patternList, globList, index, platform) {
      if (!isPatternList(patternList)) {
        throw new TypeError("empty pattern list");
      }
      if (!isGlobList(globList)) {
        throw new TypeError("empty glob list");
      }
      if (globList.length !== patternList.length) {
        throw new TypeError("mismatched pattern list and glob list lengths");
      }
      this.length = patternList.length;
      if (index < 0 || index >= this.length) {
        throw new TypeError("index out of range");
      }
      this.#patternList = patternList;
      this.#globList = globList;
      this.#index = index;
      this.#platform = platform;
      if (this.#index === 0) {
        if (this.isUNC()) {
          const [p0, p1, p2, p3, ...prest] = this.#patternList;
          const [g0, g1, g2, g3, ...grest] = this.#globList;
          if (prest[0] === "") {
            prest.shift();
            grest.shift();
          }
          const p = [p0, p1, p2, p3, ""].join("/");
          const g = [g0, g1, g2, g3, ""].join("/");
          this.#patternList = [p, ...prest];
          this.#globList = [g, ...grest];
          this.length = this.#patternList.length;
        } else if (this.isDrive() || this.isAbsolute()) {
          const [p1, ...prest] = this.#patternList;
          const [g1, ...grest] = this.#globList;
          if (prest[0] === "") {
            prest.shift();
            grest.shift();
          }
          const p = p1 + "/";
          const g = g1 + "/";
          this.#patternList = [p, ...prest];
          this.#globList = [g, ...grest];
          this.length = this.#patternList.length;
        }
      }
    }
    /**
     * The first entry in the parsed list of patterns
     */
    pattern() {
      return this.#patternList[this.#index];
    }
    /**
     * true of if pattern() returns a string
     */
    isString() {
      return typeof this.#patternList[this.#index] === "string";
    }
    /**
     * true of if pattern() returns GLOBSTAR
     */
    isGlobstar() {
      return this.#patternList[this.#index] === GLOBSTAR;
    }
    /**
     * true if pattern() returns a regexp
     */
    isRegExp() {
      return this.#patternList[this.#index] instanceof RegExp;
    }
    /**
     * The /-joined set of glob parts that make up this pattern
     */
    globString() {
      return this.#globString = this.#globString || (this.#index === 0 ? this.isAbsolute() ? this.#globList[0] + this.#globList.slice(1).join("/") : this.#globList.join("/") : this.#globList.slice(this.#index).join("/"));
    }
    /**
     * true if there are more pattern parts after this one
     */
    hasMore() {
      return this.length > this.#index + 1;
    }
    /**
     * The rest of the pattern after this part, or null if this is the end
     */
    rest() {
      if (this.#rest !== void 0)
        return this.#rest;
      if (!this.hasMore())
        return this.#rest = null;
      this.#rest = new Pattern(this.#patternList, this.#globList, this.#index + 1, this.#platform);
      this.#rest.#isAbsolute = this.#isAbsolute;
      this.#rest.#isUNC = this.#isUNC;
      this.#rest.#isDrive = this.#isDrive;
      return this.#rest;
    }
    /**
     * true if the pattern represents a //unc/path/ on windows
     */
    isUNC() {
      const pl = this.#patternList;
      return this.#isUNC !== void 0 ? this.#isUNC : this.#isUNC = this.#platform === "win32" && this.#index === 0 && pl[0] === "" && pl[1] === "" && typeof pl[2] === "string" && !!pl[2] && typeof pl[3] === "string" && !!pl[3];
    }
    // pattern like C:/...
    // split = ['C:', ...]
    // XXX: would be nice to handle patterns like `c:*` to test the cwd
    // in c: for *, but I don't know of a way to even figure out what that
    // cwd is without actually chdir'ing into it?
    /**
     * True if the pattern starts with a drive letter on Windows
     */
    isDrive() {
      const pl = this.#patternList;
      return this.#isDrive !== void 0 ? this.#isDrive : this.#isDrive = this.#platform === "win32" && this.#index === 0 && this.length > 1 && typeof pl[0] === "string" && /^[a-z]:$/i.test(pl[0]);
    }
    // pattern = '/' or '/...' or '/x/...'
    // split = ['', ''] or ['', ...] or ['', 'x', ...]
    // Drive and UNC both considered absolute on windows
    /**
     * True if the pattern is rooted on an absolute path
     */
    isAbsolute() {
      const pl = this.#patternList;
      return this.#isAbsolute !== void 0 ? this.#isAbsolute : this.#isAbsolute = pl[0] === "" && pl.length > 1 || this.isDrive() || this.isUNC();
    }
    /**
     * consume the root of the pattern, and return it
     */
    root() {
      const p = this.#patternList[0];
      return typeof p === "string" && this.isAbsolute() && this.#index === 0 ? p : "";
    }
    /**
     * Check to see if the current globstar pattern is allowed to follow
     * a symbolic link.
     */
    checkFollowGlobstar() {
      return !(this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar);
    }
    /**
     * Mark that the current globstar pattern is following a symbolic link
     */
    markFollowGlobstar() {
      if (this.#index === 0 || !this.isGlobstar() || !this.#followGlobstar)
        return false;
      this.#followGlobstar = false;
      return true;
    }
  };

  // ../../node_modules/.pnpm/glob@10.2.6/node_modules/glob/dist/mjs/ignore.js
  var defaultPlatform2 = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
  var Ignore = class {
    relative;
    relativeChildren;
    absolute;
    absoluteChildren;
    constructor(ignored, { nobrace, nocase, noext, noglobstar, platform = defaultPlatform2 }) {
      this.relative = [];
      this.absolute = [];
      this.relativeChildren = [];
      this.absoluteChildren = [];
      const mmopts = {
        dot: true,
        nobrace,
        nocase,
        noext,
        noglobstar,
        optimizationLevel: 2,
        platform,
        nocomment: true,
        nonegate: true
      };
      for (const ign of ignored) {
        const mm = new Minimatch(ign, mmopts);
        for (let i = 0; i < mm.set.length; i++) {
          const parsed = mm.set[i];
          const globParts = mm.globParts[i];
          const p = new Pattern(parsed, globParts, 0, platform);
          const m = new Minimatch(p.globString(), mmopts);
          const children = globParts[globParts.length - 1] === "**";
          const absolute = p.isAbsolute();
          if (absolute)
            this.absolute.push(m);
          else
            this.relative.push(m);
          if (children) {
            if (absolute)
              this.absoluteChildren.push(m);
            else
              this.relativeChildren.push(m);
          }
        }
      }
    }
    ignored(p) {
      const fullpath = p.fullpath();
      const fullpaths = `${fullpath}/`;
      const relative2 = p.relative() || ".";
      const relatives = `${relative2}/`;
      for (const m of this.relative) {
        if (m.match(relative2) || m.match(relatives))
          return true;
      }
      for (const m of this.absolute) {
        if (m.match(fullpath) || m.match(fullpaths))
          return true;
      }
      return false;
    }
    childrenIgnored(p) {
      const fullpath = p.fullpath() + "/";
      const relative2 = (p.relative() || ".") + "/";
      for (const m of this.relativeChildren) {
        if (m.match(relative2))
          return true;
      }
      for (const m of this.absoluteChildren) {
        if (m.match(fullpath))
          true;
      }
      return false;
    }
  };

  // ../../node_modules/.pnpm/glob@10.2.6/node_modules/glob/dist/mjs/processor.js
  var HasWalkedCache = class {
    store;
    constructor(store = /* @__PURE__ */ new Map()) {
      this.store = store;
    }
    copy() {
      return new HasWalkedCache(new Map(this.store));
    }
    hasWalked(target, pattern) {
      return this.store.get(target.fullpath())?.has(pattern.globString());
    }
    storeWalked(target, pattern) {
      const fullpath = target.fullpath();
      const cached = this.store.get(fullpath);
      if (cached)
        cached.add(pattern.globString());
      else
        this.store.set(fullpath, /* @__PURE__ */ new Set([pattern.globString()]));
    }
  };
  var MatchRecord = class {
    store = /* @__PURE__ */ new Map();
    add(target, absolute, ifDir) {
      const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);
      const current = this.store.get(target);
      this.store.set(target, current === void 0 ? n : n & current);
    }
    // match, absolute, ifdir
    entries() {
      return [...this.store.entries()].map(([path4, n]) => [
        path4,
        !!(n & 2),
        !!(n & 1)
      ]);
    }
  };
  var SubWalks = class {
    store = /* @__PURE__ */ new Map();
    add(target, pattern) {
      if (!target.canReaddir()) {
        return;
      }
      const subs = this.store.get(target);
      if (subs) {
        if (!subs.find((p) => p.globString() === pattern.globString())) {
          subs.push(pattern);
        }
      } else
        this.store.set(target, [pattern]);
    }
    get(target) {
      const subs = this.store.get(target);
      if (!subs) {
        throw new Error("attempting to walk unknown path");
      }
      return subs;
    }
    entries() {
      return this.keys().map((k) => [k, this.store.get(k)]);
    }
    keys() {
      return [...this.store.keys()].filter((t) => t.canReaddir());
    }
  };
  var Processor = class {
    hasWalkedCache;
    matches = new MatchRecord();
    subwalks = new SubWalks();
    patterns;
    follow;
    dot;
    opts;
    constructor(opts, hasWalkedCache) {
      this.opts = opts;
      this.follow = !!opts.follow;
      this.dot = !!opts.dot;
      this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();
    }
    processPatterns(target, patterns) {
      this.patterns = patterns;
      const processingSet = patterns.map((p) => [target, p]);
      for (let [t, pattern] of processingSet) {
        this.hasWalkedCache.storeWalked(t, pattern);
        const root = pattern.root();
        const absolute = pattern.isAbsolute() && this.opts.absolute !== false;
        if (root) {
          t = t.resolve(root === "/" && this.opts.root !== void 0 ? this.opts.root : root);
          const rest2 = pattern.rest();
          if (!rest2) {
            this.matches.add(t, true, false);
            continue;
          } else {
            pattern = rest2;
          }
        }
        if (t.isENOENT())
          continue;
        let p;
        let rest;
        let changed = false;
        while (typeof (p = pattern.pattern()) === "string" && (rest = pattern.rest())) {
          const c = t.resolve(p);
          if (c.isUnknown() && p !== "..")
            break;
          t = c;
          pattern = rest;
          changed = true;
        }
        p = pattern.pattern();
        rest = pattern.rest();
        if (changed) {
          if (this.hasWalkedCache.hasWalked(t, pattern))
            continue;
          this.hasWalkedCache.storeWalked(t, pattern);
        }
        if (typeof p === "string") {
          if (!rest) {
            const ifDir = p === ".." || p === "" || p === ".";
            this.matches.add(t.resolve(p), absolute, ifDir);
          } else {
            this.subwalks.add(t, pattern);
          }
          continue;
        } else if (p === GLOBSTAR) {
          if (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) {
            this.subwalks.add(t, pattern);
          }
          const rp = rest?.pattern();
          const rrest = rest?.rest();
          if (!rest || (rp === "" || rp === ".") && !rrest) {
            this.matches.add(t, absolute, rp === "" || rp === ".");
          } else {
            if (rp === "..") {
              const tp = t.parent || t;
              if (!rrest)
                this.matches.add(tp, absolute, true);
              else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {
                this.subwalks.add(tp, rrest);
              }
            }
          }
        } else if (p instanceof RegExp) {
          this.subwalks.add(t, pattern);
        }
      }
      return this;
    }
    subwalkTargets() {
      return this.subwalks.keys();
    }
    child() {
      return new Processor(this.opts, this.hasWalkedCache);
    }
    // return a new Processor containing the subwalks for each
    // child entry, and a set of matches, and
    // a hasWalkedCache that's a copy of this one
    // then we're going to call
    filterEntries(parent, entries) {
      const patterns = this.subwalks.get(parent);
      const results = this.child();
      for (const e of entries) {
        for (const pattern of patterns) {
          const absolute = pattern.isAbsolute();
          const p = pattern.pattern();
          const rest = pattern.rest();
          if (p === GLOBSTAR) {
            results.testGlobstar(e, pattern, rest, absolute);
          } else if (p instanceof RegExp) {
            results.testRegExp(e, p, rest, absolute);
          } else {
            results.testString(e, p, rest, absolute);
          }
        }
      }
      return results;
    }
    testGlobstar(e, pattern, rest, absolute) {
      if (this.dot || !e.name.startsWith(".")) {
        if (!pattern.hasMore()) {
          this.matches.add(e, absolute, false);
        }
        if (e.canReaddir()) {
          if (this.follow || !e.isSymbolicLink()) {
            this.subwalks.add(e, pattern);
          } else if (e.isSymbolicLink()) {
            if (rest && pattern.checkFollowGlobstar()) {
              this.subwalks.add(e, rest);
            } else if (pattern.markFollowGlobstar()) {
              this.subwalks.add(e, pattern);
            }
          }
        }
      }
      if (rest) {
        const rp = rest.pattern();
        if (typeof rp === "string" && // dots and empty were handled already
        rp !== ".." && rp !== "" && rp !== ".") {
          this.testString(e, rp, rest.rest(), absolute);
        } else if (rp === "..") {
          const ep = e.parent || e;
          this.subwalks.add(ep, rest);
        } else if (rp instanceof RegExp) {
          this.testRegExp(e, rp, rest.rest(), absolute);
        }
      }
    }
    testRegExp(e, p, rest, absolute) {
      if (!p.test(e.name))
        return;
      if (!rest) {
        this.matches.add(e, absolute, false);
      } else {
        this.subwalks.add(e, rest);
      }
    }
    testString(e, p, rest, absolute) {
      if (!e.isNamed(p))
        return;
      if (!rest) {
        this.matches.add(e, absolute, false);
      } else {
        this.subwalks.add(e, rest);
      }
    }
  };

  // ../../node_modules/.pnpm/glob@10.2.6/node_modules/glob/dist/mjs/walker.js
  var makeIgnore = (ignore, opts) => typeof ignore === "string" ? new Ignore([ignore], opts) : Array.isArray(ignore) ? new Ignore(ignore, opts) : ignore;
  var GlobUtil = class {
    path;
    patterns;
    opts;
    seen = /* @__PURE__ */ new Set();
    paused = false;
    aborted = false;
    #onResume = [];
    #ignore;
    #sep;
    signal;
    maxDepth;
    constructor(patterns, path4, opts) {
      this.patterns = patterns;
      this.path = path4;
      this.opts = opts;
      this.#sep = !opts.posix && opts.platform === "win32" ? "\\" : "/";
      if (opts.ignore) {
        this.#ignore = makeIgnore(opts.ignore, opts);
      }
      this.maxDepth = opts.maxDepth || Infinity;
      if (opts.signal) {
        this.signal = opts.signal;
        this.signal.addEventListener("abort", () => {
          this.#onResume.length = 0;
        });
      }
    }
    #ignored(path4) {
      return this.seen.has(path4) || !!this.#ignore?.ignored?.(path4);
    }
    #childrenIgnored(path4) {
      return !!this.#ignore?.childrenIgnored?.(path4);
    }
    // backpressure mechanism
    pause() {
      this.paused = true;
    }
    resume() {
      if (this.signal?.aborted)
        return;
      this.paused = false;
      let fn = void 0;
      while (!this.paused && (fn = this.#onResume.shift())) {
        fn();
      }
    }
    onResume(fn) {
      if (this.signal?.aborted)
        return;
      if (!this.paused) {
        fn();
      } else {
        this.#onResume.push(fn);
      }
    }
    // do the requisite realpath/stat checking, and return the path
    // to add or undefined to filter it out.
    async matchCheck(e, ifDir) {
      if (ifDir && this.opts.nodir)
        return void 0;
      let rpc;
      if (this.opts.realpath) {
        rpc = e.realpathCached() || await e.realpath();
        if (!rpc)
          return void 0;
        e = rpc;
      }
      const needStat = e.isUnknown() || this.opts.stat;
      return this.matchCheckTest(needStat ? await e.lstat() : e, ifDir);
    }
    matchCheckTest(e, ifDir) {
      return e && (this.maxDepth === Infinity || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && !this.#ignored(e) ? e : void 0;
    }
    matchCheckSync(e, ifDir) {
      if (ifDir && this.opts.nodir)
        return void 0;
      let rpc;
      if (this.opts.realpath) {
        rpc = e.realpathCached() || e.realpathSync();
        if (!rpc)
          return void 0;
        e = rpc;
      }
      const needStat = e.isUnknown() || this.opts.stat;
      return this.matchCheckTest(needStat ? e.lstatSync() : e, ifDir);
    }
    matchFinish(e, absolute) {
      if (this.#ignored(e))
        return;
      const abs = this.opts.absolute === void 0 ? absolute : this.opts.absolute;
      this.seen.add(e);
      const mark = this.opts.mark && e.isDirectory() ? this.#sep : "";
      if (this.opts.withFileTypes) {
        this.matchEmit(e);
      } else if (abs) {
        const abs2 = this.opts.posix ? e.fullpathPosix() : e.fullpath();
        this.matchEmit(abs2 + mark);
      } else {
        const rel = this.opts.posix ? e.relativePosix() : e.relative();
        const pre = this.opts.dotRelative && !rel.startsWith(".." + this.#sep) ? "." + this.#sep : "";
        this.matchEmit(!rel ? "." + mark : pre + rel + mark);
      }
    }
    async match(e, absolute, ifDir) {
      const p = await this.matchCheck(e, ifDir);
      if (p)
        this.matchFinish(p, absolute);
    }
    matchSync(e, absolute, ifDir) {
      const p = this.matchCheckSync(e, ifDir);
      if (p)
        this.matchFinish(p, absolute);
    }
    walkCB(target, patterns, cb) {
      if (this.signal?.aborted)
        cb();
      this.walkCB2(target, patterns, new Processor(this.opts), cb);
    }
    walkCB2(target, patterns, processor, cb) {
      if (this.#childrenIgnored(target))
        return cb();
      if (this.signal?.aborted)
        cb();
      if (this.paused) {
        this.onResume(() => this.walkCB2(target, patterns, processor, cb));
        return;
      }
      processor.processPatterns(target, patterns);
      let tasks = 1;
      const next = () => {
        if (--tasks === 0)
          cb();
      };
      for (const [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        tasks++;
        this.match(m, absolute, ifDir).then(() => next());
      }
      for (const t of processor.subwalkTargets()) {
        if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
          continue;
        }
        tasks++;
        const childrenCached = t.readdirCached();
        if (t.calledReaddir())
          this.walkCB3(t, childrenCached, processor, next);
        else {
          t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
        }
      }
      next();
    }
    walkCB3(target, entries, processor, cb) {
      processor = processor.filterEntries(target, entries);
      let tasks = 1;
      const next = () => {
        if (--tasks === 0)
          cb();
      };
      for (const [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        tasks++;
        this.match(m, absolute, ifDir).then(() => next());
      }
      for (const [target2, patterns] of processor.subwalks.entries()) {
        tasks++;
        this.walkCB2(target2, patterns, processor.child(), next);
      }
      next();
    }
    walkCBSync(target, patterns, cb) {
      if (this.signal?.aborted)
        cb();
      this.walkCB2Sync(target, patterns, new Processor(this.opts), cb);
    }
    walkCB2Sync(target, patterns, processor, cb) {
      if (this.#childrenIgnored(target))
        return cb();
      if (this.signal?.aborted)
        cb();
      if (this.paused) {
        this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
        return;
      }
      processor.processPatterns(target, patterns);
      let tasks = 1;
      const next = () => {
        if (--tasks === 0)
          cb();
      };
      for (const [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        this.matchSync(m, absolute, ifDir);
      }
      for (const t of processor.subwalkTargets()) {
        if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
          continue;
        }
        tasks++;
        const children = t.readdirSync();
        this.walkCB3Sync(t, children, processor, next);
      }
      next();
    }
    walkCB3Sync(target, entries, processor, cb) {
      processor = processor.filterEntries(target, entries);
      let tasks = 1;
      const next = () => {
        if (--tasks === 0)
          cb();
      };
      for (const [m, absolute, ifDir] of processor.matches.entries()) {
        if (this.#ignored(m))
          continue;
        this.matchSync(m, absolute, ifDir);
      }
      for (const [target2, patterns] of processor.subwalks.entries()) {
        tasks++;
        this.walkCB2Sync(target2, patterns, processor.child(), next);
      }
      next();
    }
  };
  var GlobWalker = class extends GlobUtil {
    matches;
    constructor(patterns, path4, opts) {
      super(patterns, path4, opts);
      this.matches = /* @__PURE__ */ new Set();
    }
    matchEmit(e) {
      this.matches.add(e);
    }
    async walk() {
      if (this.signal?.aborted)
        throw this.signal.reason;
      if (this.path.isUnknown()) {
        await this.path.lstat();
      }
      await new Promise((res, rej) => {
        this.walkCB(this.path, this.patterns, () => {
          if (this.signal?.aborted) {
            rej(this.signal.reason);
          } else {
            res(this.matches);
          }
        });
      });
      return this.matches;
    }
    walkSync() {
      if (this.signal?.aborted)
        throw this.signal.reason;
      if (this.path.isUnknown()) {
        this.path.lstatSync();
      }
      this.walkCBSync(this.path, this.patterns, () => {
        if (this.signal?.aborted)
          throw this.signal.reason;
      });
      return this.matches;
    }
  };
  var GlobStream = class extends GlobUtil {
    results;
    constructor(patterns, path4, opts) {
      super(patterns, path4, opts);
      this.results = new Minipass({
        signal: this.signal,
        objectMode: true
      });
      this.results.on("drain", () => this.resume());
      this.results.on("resume", () => this.resume());
    }
    matchEmit(e) {
      this.results.write(e);
      if (!this.results.flowing)
        this.pause();
    }
    stream() {
      const target = this.path;
      if (target.isUnknown()) {
        target.lstat().then(() => {
          this.walkCB(target, this.patterns, () => this.results.end());
        });
      } else {
        this.walkCB(target, this.patterns, () => this.results.end());
      }
      return this.results;
    }
    streamSync() {
      if (this.path.isUnknown()) {
        this.path.lstatSync();
      }
      this.walkCBSync(this.path, this.patterns, () => this.results.end());
      return this.results;
    }
  };

  // ../../node_modules/.pnpm/glob@10.2.6/node_modules/glob/dist/mjs/glob.js
  var defaultPlatform3 = typeof process === "object" && process && typeof process.platform === "string" ? process.platform : "linux";
  var Glob = class {
    absolute;
    cwd;
    root;
    dot;
    dotRelative;
    follow;
    ignore;
    magicalBraces;
    mark;
    matchBase;
    maxDepth;
    nobrace;
    nocase;
    nodir;
    noext;
    noglobstar;
    pattern;
    platform;
    realpath;
    scurry;
    stat;
    signal;
    windowsPathsNoEscape;
    withFileTypes;
    /**
     * The options provided to the constructor.
     */
    opts;
    /**
     * An array of parsed immutable {@link Pattern} objects.
     */
    patterns;
    /**
     * All options are stored as properties on the `Glob` object.
     *
     * See {@link GlobOptions} for full options descriptions.
     *
     * Note that a previous `Glob` object can be passed as the
     * `GlobOptions` to another `Glob` instantiation to re-use settings
     * and caches with a new pattern.
     *
     * Traversal functions can be called multiple times to run the walk
     * again.
     */
    constructor(pattern, opts) {
      this.withFileTypes = !!opts.withFileTypes;
      this.signal = opts.signal;
      this.follow = !!opts.follow;
      this.dot = !!opts.dot;
      this.dotRelative = !!opts.dotRelative;
      this.nodir = !!opts.nodir;
      this.mark = !!opts.mark;
      if (!opts.cwd) {
        this.cwd = "";
      } else if (opts.cwd instanceof URL || opts.cwd.startsWith("file://")) {
        opts.cwd = (0, import_url2.fileURLToPath)(opts.cwd);
      }
      this.cwd = opts.cwd || "";
      this.root = opts.root;
      this.magicalBraces = !!opts.magicalBraces;
      this.nobrace = !!opts.nobrace;
      this.noext = !!opts.noext;
      this.realpath = !!opts.realpath;
      this.absolute = opts.absolute;
      this.noglobstar = !!opts.noglobstar;
      this.matchBase = !!opts.matchBase;
      this.maxDepth = typeof opts.maxDepth === "number" ? opts.maxDepth : Infinity;
      this.stat = !!opts.stat;
      this.ignore = opts.ignore;
      if (this.withFileTypes && this.absolute !== void 0) {
        throw new Error("cannot set absolute and withFileTypes:true");
      }
      if (typeof pattern === "string") {
        pattern = [pattern];
      }
      this.windowsPathsNoEscape = !!opts.windowsPathsNoEscape || opts.allowWindowsEscape === false;
      if (this.windowsPathsNoEscape) {
        pattern = pattern.map((p) => p.replace(/\\/g, "/"));
      }
      if (this.matchBase) {
        if (opts.noglobstar) {
          throw new TypeError("base matching requires globstar");
        }
        pattern = pattern.map((p) => p.includes("/") ? p : `./**/${p}`);
      }
      this.pattern = pattern;
      this.platform = opts.platform || defaultPlatform3;
      this.opts = { ...opts, platform: this.platform };
      if (opts.scurry) {
        this.scurry = opts.scurry;
        if (opts.nocase !== void 0 && opts.nocase !== opts.scurry.nocase) {
          throw new Error("nocase option contradicts provided scurry option");
        }
      } else {
        const Scurry = opts.platform === "win32" ? PathScurryWin32 : opts.platform === "darwin" ? PathScurryDarwin : opts.platform ? PathScurryPosix : PathScurry;
        this.scurry = new Scurry(this.cwd, {
          nocase: opts.nocase,
          fs: opts.fs
        });
      }
      this.nocase = this.scurry.nocase;
      const nocaseMagicOnly = this.platform === "darwin" || this.platform === "win32";
      const mmo = {
        // default nocase based on platform
        ...opts,
        dot: this.dot,
        matchBase: this.matchBase,
        nobrace: this.nobrace,
        nocase: this.nocase,
        nocaseMagicOnly,
        nocomment: true,
        noext: this.noext,
        nonegate: true,
        optimizationLevel: 2,
        platform: this.platform,
        windowsPathsNoEscape: this.windowsPathsNoEscape,
        debug: !!this.opts.debug
      };
      const mms = this.pattern.map((p) => new Minimatch(p, mmo));
      const [matchSet, globParts] = mms.reduce((set2, m) => {
        set2[0].push(...m.set);
        set2[1].push(...m.globParts);
        return set2;
      }, [[], []]);
      this.patterns = matchSet.map((set2, i) => {
        return new Pattern(set2, globParts[i], 0, this.platform);
      });
    }
    async walk() {
      return [
        ...await new GlobWalker(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase
        }).walk()
      ];
    }
    walkSync() {
      return [
        ...new GlobWalker(this.patterns, this.scurry.cwd, {
          ...this.opts,
          maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
          platform: this.platform,
          nocase: this.nocase
        }).walkSync()
      ];
    }
    stream() {
      return new GlobStream(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase
      }).stream();
    }
    streamSync() {
      return new GlobStream(this.patterns, this.scurry.cwd, {
        ...this.opts,
        maxDepth: this.maxDepth !== Infinity ? this.maxDepth + this.scurry.cwd.depth() : Infinity,
        platform: this.platform,
        nocase: this.nocase
      }).streamSync();
    }
    /**
     * Default sync iteration function. Returns a Generator that
     * iterates over the results.
     */
    iterateSync() {
      return this.streamSync()[Symbol.iterator]();
    }
    [Symbol.iterator]() {
      return this.iterateSync();
    }
    /**
     * Default async iteration function. Returns an AsyncGenerator that
     * iterates over the results.
     */
    iterate() {
      return this.stream()[Symbol.asyncIterator]();
    }
    [Symbol.asyncIterator]() {
      return this.iterate();
    }
  };

  // ../../node_modules/.pnpm/glob@10.2.6/node_modules/glob/dist/mjs/has-magic.js
  var hasMagic = (pattern, options = {}) => {
    if (!Array.isArray(pattern)) {
      pattern = [pattern];
    }
    for (const p of pattern) {
      if (new Minimatch(p, options).hasMagic())
        return true;
    }
    return false;
  };

  // ../../node_modules/.pnpm/glob@10.2.6/node_modules/glob/dist/mjs/index.js
  function globStreamSync(pattern, options = {}) {
    return new Glob(pattern, options).streamSync();
  }
  function globStream(pattern, options = {}) {
    return new Glob(pattern, options).stream();
  }
  function globSync(pattern, options = {}) {
    return new Glob(pattern, options).walkSync();
  }
  async function glob_(pattern, options = {}) {
    return new Glob(pattern, options).walk();
  }
  function globIterateSync(pattern, options = {}) {
    return new Glob(pattern, options).iterateSync();
  }
  function globIterate(pattern, options = {}) {
    return new Glob(pattern, options).iterate();
  }
  var streamSync = globStreamSync;
  var stream = Object.assign(globStream, { sync: globStreamSync });
  var iterateSync = globIterateSync;
  var iterate = Object.assign(globIterate, {
    sync: globIterateSync
  });
  var sync = Object.assign(globSync, {
    stream: globStreamSync,
    iterate: globIterateSync
  });
  var glob = Object.assign(glob_, {
    glob: glob_,
    globSync,
    sync,
    globStream,
    stream,
    globStreamSync,
    streamSync,
    globIterate,
    iterate,
    globIterateSync,
    iterateSync,
    Glob,
    hasMagic,
    escape,
    unescape
  });
  glob.glob = glob;

  // ../abi-typegen/dist/cli.mjs
  var import_mkdirp = __toESM(require_mkdirp(), 1);
  var import_path8 = __require2("path");
  var import_rimraf = __toESM(require_rimraf(), 1);

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/_version.js
  var version = "6.7.1";

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/utils/properties.js
  function checkType(value, type3, name) {
    const types2 = type3.split("|").map((t) => t.trim());
    for (let i = 0; i < types2.length; i++) {
      switch (type3) {
        case "any":
          return;
        case "bigint":
        case "boolean":
        case "number":
        case "string":
          if (typeof value === type3) {
            return;
          }
      }
    }
    const error2 = new Error(`invalid value for type ${type3}`);
    error2.code = "INVALID_ARGUMENT";
    error2.argument = `value.${name}`;
    error2.value = value;
    throw error2;
  }
  function defineProperties(target, values, types2) {
    for (let key in values) {
      let value = values[key];
      const type3 = types2 ? types2[key] : null;
      if (type3) {
        checkType(value, type3, key);
      }
      Object.defineProperty(target, key, { enumerable: true, value, writable: false });
    }
  }

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/utils/errors.js
  function stringify(value) {
    if (value == null) {
      return "null";
    }
    if (Array.isArray(value)) {
      return "[ " + value.map(stringify).join(", ") + " ]";
    }
    if (value instanceof Uint8Array) {
      const HEX = "0123456789abcdef";
      let result = "0x";
      for (let i = 0; i < value.length; i++) {
        result += HEX[value[i] >> 4];
        result += HEX[value[i] & 15];
      }
      return result;
    }
    if (typeof value === "object" && typeof value.toJSON === "function") {
      return stringify(value.toJSON());
    }
    switch (typeof value) {
      case "boolean":
      case "symbol":
        return value.toString();
      case "bigint":
        return BigInt(value).toString();
      case "number":
        return value.toString();
      case "string":
        return JSON.stringify(value);
      case "object": {
        const keys4 = Object.keys(value);
        keys4.sort();
        return "{ " + keys4.map((k) => `${stringify(k)}: ${stringify(value[k])}`).join(", ") + " }";
      }
    }
    return `[ COULD NOT SERIALIZE ]`;
  }
  function makeError(message, code, info) {
    {
      const details = [];
      if (info) {
        if ("message" in info || "code" in info || "name" in info) {
          throw new Error(`value will overwrite populated values: ${stringify(info)}`);
        }
        for (const key in info) {
          const value = info[key];
          details.push(key + "=" + stringify(value));
        }
      }
      details.push(`code=${code}`);
      details.push(`version=${version}`);
      if (details.length) {
        message += " (" + details.join(", ") + ")";
      }
    }
    let error2;
    switch (code) {
      case "INVALID_ARGUMENT":
        error2 = new TypeError(message);
        break;
      case "NUMERIC_FAULT":
      case "BUFFER_OVERRUN":
        error2 = new RangeError(message);
        break;
      default:
        error2 = new Error(message);
    }
    defineProperties(error2, { code });
    if (info) {
      Object.assign(error2, info);
    }
    return error2;
  }
  function assert(check, message, code, info) {
    if (!check) {
      throw makeError(message, code, info);
    }
  }
  function assertArgument(check, message, name, value) {
    assert(check, message, "INVALID_ARGUMENT", { argument: name, value });
  }
  var _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
    try {
      if ("test".normalize(form) !== "test") {
        throw new Error("bad");
      }
      ;
      if (form === "NFD") {
        const check = String.fromCharCode(233).normalize("NFD");
        const expected = String.fromCharCode(101, 769);
        if (check !== expected) {
          throw new Error("broken");
        }
      }
      accum.push(form);
    } catch (error2) {
    }
    return accum;
  }, []);
  function assertNormalize(form) {
    assert(_normalizeForms.indexOf(form) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
      operation: "String.prototype.normalize",
      info: { form }
    });
  }

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/utils/data.js
  function _getBytes(value, name, copy) {
    if (value instanceof Uint8Array) {
      if (copy) {
        return new Uint8Array(value);
      }
      return value;
    }
    if (typeof value === "string" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
      const result = new Uint8Array((value.length - 2) / 2);
      let offset = 2;
      for (let i = 0; i < result.length; i++) {
        result[i] = parseInt(value.substring(offset, offset + 2), 16);
        offset += 2;
      }
      return result;
    }
    assertArgument(false, "invalid BytesLike value", name || "value", value);
  }
  function getBytes(value, name) {
    return _getBytes(value, name, false);
  }
  function getBytesCopy(value, name) {
    return _getBytes(value, name, true);
  }
  function isHexString(value, length) {
    if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
      return false;
    }
    if (typeof length === "number" && value.length !== 2 + 2 * length) {
      return false;
    }
    if (length === true && value.length % 2 !== 0) {
      return false;
    }
    return true;
  }
  var HexCharacters = "0123456789abcdef";
  function hexlify(data) {
    const bytes3 = getBytes(data);
    let result = "0x";
    for (let i = 0; i < bytes3.length; i++) {
      const v = bytes3[i];
      result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
    }
    return result;
  }
  function concat(datas) {
    return "0x" + datas.map((d) => hexlify(d).substring(2)).join("");
  }
  function dataSlice(data, start, end) {
    const bytes3 = getBytes(data);
    if (end != null && end > bytes3.length) {
      assert(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
        buffer: bytes3,
        length: bytes3.length,
        offset: end
      });
    }
    return hexlify(bytes3.slice(start == null ? 0 : start, end == null ? bytes3.length : end));
  }

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/utils/maths.js
  var BN_0 = BigInt(0);
  var BN_1 = BigInt(1);
  var maxValue = 9007199254740991;
  function getBigInt(value, name) {
    switch (typeof value) {
      case "bigint":
        return value;
      case "number":
        assertArgument(Number.isInteger(value), "underflow", name || "value", value);
        assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
        return BigInt(value);
      case "string":
        try {
          if (value === "") {
            throw new Error("empty string");
          }
          if (value[0] === "-" && value[1] !== "-") {
            return -BigInt(value.substring(1));
          }
          return BigInt(value);
        } catch (e) {
          assertArgument(false, `invalid BigNumberish string: ${e.message}`, name || "value", value);
        }
    }
    assertArgument(false, "invalid BigNumberish value", name || "value", value);
  }
  function getUint(value, name) {
    const result = getBigInt(value, name);
    assert(result >= BN_0, "unsigned value cannot be negative", "NUMERIC_FAULT", {
      fault: "overflow",
      operation: "getUint",
      value
    });
    return result;
  }
  var Nibbles = "0123456789abcdef";
  function toBigInt(value) {
    if (value instanceof Uint8Array) {
      let result = "0x0";
      for (const v of value) {
        result += Nibbles[v >> 4];
        result += Nibbles[v & 15];
      }
      return BigInt(result);
    }
    return getBigInt(value);
  }
  function getNumber(value, name) {
    switch (typeof value) {
      case "bigint":
        assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
        return Number(value);
      case "number":
        assertArgument(Number.isInteger(value), "underflow", name || "value", value);
        assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
        return value;
      case "string":
        try {
          if (value === "") {
            throw new Error("empty string");
          }
          return getNumber(BigInt(value), name);
        } catch (e) {
          assertArgument(false, `invalid numeric string: ${e.message}`, name || "value", value);
        }
    }
    assertArgument(false, "invalid numeric value", name || "value", value);
  }
  function toBeHex(_value, _width) {
    const value = getUint(_value, "value");
    let result = value.toString(16);
    if (_width == null) {
      if (result.length % 2) {
        result = "0" + result;
      }
    } else {
      const width = getNumber(_width, "width");
      assert(width * 2 >= result.length, `value exceeds width (${width} bits)`, "NUMERIC_FAULT", {
        operation: "toBeHex",
        fault: "overflow",
        value: _value
      });
      while (result.length < width * 2) {
        result = "0" + result;
      }
    }
    return "0x" + result;
  }

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/utils/base58.js
  var Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  var Lookup = null;
  function getAlpha(letter) {
    if (Lookup == null) {
      Lookup = {};
      for (let i = 0; i < Alphabet.length; i++) {
        Lookup[Alphabet[i]] = BigInt(i);
      }
    }
    const result = Lookup[letter];
    assertArgument(result != null, `invalid base58 value`, "letter", letter);
    return result;
  }
  var BN_02 = BigInt(0);
  var BN_58 = BigInt(58);
  function encodeBase58(_value) {
    let value = toBigInt(getBytes(_value));
    let result = "";
    while (value) {
      result = Alphabet[Number(value % BN_58)] + result;
      value /= BN_58;
    }
    return result;
  }
  function decodeBase58(value) {
    let result = BN_02;
    for (let i = 0; i < value.length; i++) {
      result *= BN_58;
      result += getAlpha(value[i]);
    }
    return result;
  }

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/utils/utf8.js
  function errorFunc(reason, offset, bytes3, output3, badCodepoint) {
    assertArgument(false, `invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes3);
  }
  function ignoreFunc(reason, offset, bytes3, output3, badCodepoint) {
    if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
      let i = 0;
      for (let o = offset + 1; o < bytes3.length; o++) {
        if (bytes3[o] >> 6 !== 2) {
          break;
        }
        i++;
      }
      return i;
    }
    if (reason === "OVERRUN") {
      return bytes3.length - offset - 1;
    }
    return 0;
  }
  function replaceFunc(reason, offset, bytes3, output3, badCodepoint) {
    if (reason === "OVERLONG") {
      assertArgument(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
      output3.push(badCodepoint);
      return 0;
    }
    output3.push(65533);
    return ignoreFunc(reason, offset, bytes3, output3, badCodepoint);
  }
  var Utf8ErrorFuncs = Object.freeze({
    error: errorFunc,
    ignore: ignoreFunc,
    replace: replaceFunc
  });
  function getUtf8CodePoints(_bytes, onError) {
    if (onError == null) {
      onError = Utf8ErrorFuncs.error;
    }
    const bytes3 = getBytes(_bytes, "bytes");
    const result = [];
    let i = 0;
    while (i < bytes3.length) {
      const c = bytes3[i++];
      if (c >> 7 === 0) {
        result.push(c);
        continue;
      }
      let extraLength = null;
      let overlongMask = null;
      if ((c & 224) === 192) {
        extraLength = 1;
        overlongMask = 127;
      } else if ((c & 240) === 224) {
        extraLength = 2;
        overlongMask = 2047;
      } else if ((c & 248) === 240) {
        extraLength = 3;
        overlongMask = 65535;
      } else {
        if ((c & 192) === 128) {
          i += onError("UNEXPECTED_CONTINUE", i - 1, bytes3, result);
        } else {
          i += onError("BAD_PREFIX", i - 1, bytes3, result);
        }
        continue;
      }
      if (i - 1 + extraLength >= bytes3.length) {
        i += onError("OVERRUN", i - 1, bytes3, result);
        continue;
      }
      let res = c & (1 << 8 - extraLength - 1) - 1;
      for (let j = 0; j < extraLength; j++) {
        let nextChar = bytes3[i];
        if ((nextChar & 192) != 128) {
          i += onError("MISSING_CONTINUE", i, bytes3, result);
          res = null;
          break;
        }
        ;
        res = res << 6 | nextChar & 63;
        i++;
      }
      if (res === null) {
        continue;
      }
      if (res > 1114111) {
        i += onError("OUT_OF_RANGE", i - 1 - extraLength, bytes3, result, res);
        continue;
      }
      if (res >= 55296 && res <= 57343) {
        i += onError("UTF16_SURROGATE", i - 1 - extraLength, bytes3, result, res);
        continue;
      }
      if (res <= overlongMask) {
        i += onError("OVERLONG", i - 1 - extraLength, bytes3, result, res);
        continue;
      }
      result.push(res);
    }
    return result;
  }
  function toUtf8Bytes(str, form) {
    if (form != null) {
      assertNormalize(form);
      str = str.normalize(form);
    }
    let result = [];
    for (let i = 0; i < str.length; i++) {
      const c = str.charCodeAt(i);
      if (c < 128) {
        result.push(c);
      } else if (c < 2048) {
        result.push(c >> 6 | 192);
        result.push(c & 63 | 128);
      } else if ((c & 64512) == 55296) {
        i++;
        const c2 = str.charCodeAt(i);
        assertArgument(i < str.length && (c2 & 64512) === 56320, "invalid surrogate pair", "str", str);
        const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
        result.push(pair >> 18 | 240);
        result.push(pair >> 12 & 63 | 128);
        result.push(pair >> 6 & 63 | 128);
        result.push(pair & 63 | 128);
      } else {
        result.push(c >> 12 | 224);
        result.push(c >> 6 & 63 | 128);
        result.push(c & 63 | 128);
      }
    }
    return new Uint8Array(result);
  }
  function _toUtf8String(codePoints) {
    return codePoints.map((codePoint) => {
      if (codePoint <= 65535) {
        return String.fromCharCode(codePoint);
      }
      codePoint -= 65536;
      return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
    }).join("");
  }
  function toUtf8String(bytes3, onError) {
    return _toUtf8String(getUtf8CodePoints(bytes3, onError));
  }

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/crypto/crypto.js
  var import_crypto = __require2("crypto");

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/crypto/hmac.js
  var locked = false;
  var _computeHmac = function(algorithm, key, data) {
    return (0, import_crypto.createHmac)(algorithm, key).update(data).digest();
  };
  var __computeHmac = _computeHmac;
  function computeHmac(algorithm, _key, _data) {
    const key = getBytes(_key, "key");
    const data = getBytes(_data, "data");
    return hexlify(__computeHmac(algorithm, key, data));
  }
  computeHmac._ = _computeHmac;
  computeHmac.lock = function() {
    locked = true;
  };
  computeHmac.register = function(func) {
    if (locked) {
      throw new Error("computeHmac is locked");
    }
    __computeHmac = func;
  };
  Object.freeze(computeHmac);

  // ../../node_modules/.pnpm/@noble+hashes@1.1.2/node_modules/@noble/hashes/esm/_assert.js
  function number(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error(`Wrong positive integer: ${n}`);
  }
  function bool(b) {
    if (typeof b !== "boolean")
      throw new Error(`Expected boolean, not ${b}`);
  }
  function bytes(b, ...lengths) {
    if (!(b instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
  }
  function hash(hash5) {
    if (typeof hash5 !== "function" || typeof hash5.create !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number(hash5.outputLen);
    number(hash5.blockLen);
  }
  function exists(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function output(out, instance) {
    bytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  }
  var assert2 = {
    number,
    bool,
    bytes,
    hash,
    exists,
    output
  };
  var assert_default = assert2;

  // ../../node_modules/.pnpm/@noble+hashes@1.1.2/node_modules/@noble/hashes/esm/_u64.js
  var U32_MASK64 = BigInt(2 ** 32 - 1);
  var _32n = BigInt(32);
  function fromBig(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
    return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
  }
  function split(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
      const { h, l } = fromBig(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  }
  var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
  var shrSH = (h, l, s) => h >>> s;
  var shrSL = (h, l, s) => h << 32 - s | l >>> s;
  var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
  var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
  var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
  var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
  var rotr32H = (h, l) => l;
  var rotr32L = (h, l) => h;
  var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
  var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
  var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
  var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
  function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
  }
  var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
  var u64 = {
    fromBig,
    split,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
  };
  var u64_default = u64;

  // ../../node_modules/.pnpm/@noble+hashes@1.1.2/node_modules/@noble/hashes/esm/utils.js
  var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  if (!isLE)
    throw new Error("Non little-endian hardware is not supported");
  var hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
  function utf8ToBytes(str) {
    if (typeof str !== "string") {
      throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
    }
    return new TextEncoder().encode(str);
  }
  function toBytes(data) {
    if (typeof data === "string")
      data = utf8ToBytes(data);
    if (!(data instanceof Uint8Array))
      throw new TypeError(`Expected input type is Uint8Array (got ${typeof data})`);
    return data;
  }
  var Hash = class {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  };
  function wrapConstructor(hashConstructor) {
    const hashC = (message) => hashConstructor().update(toBytes(message)).digest();
    const tmp = hashConstructor();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashConstructor();
    return hashC;
  }
  function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }

  // ../../node_modules/.pnpm/@noble+hashes@1.1.2/node_modules/@noble/hashes/esm/sha3.js
  var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
  var _0n = BigInt(0);
  var _1n = BigInt(1);
  var _2n = BigInt(2);
  var _7n = BigInt(7);
  var _256n = BigInt(256);
  var _0x71n = BigInt(113);
  for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI.push(2 * (5 * y + x));
    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
    let t = _0n;
    for (let j = 0; j < 7; j++) {
      R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
      if (R & _2n)
        t ^= _1n << (_1n << BigInt(j)) - _1n;
    }
    _SHA3_IOTA.push(t);
  }
  var [SHA3_IOTA_H, SHA3_IOTA_L] = u64_default.split(_SHA3_IOTA, true);
  var rotlH = (h, l, s) => s > 32 ? u64_default.rotlBH(h, l, s) : u64_default.rotlSH(h, l, s);
  var rotlL = (h, l, s) => s > 32 ? u64_default.rotlBL(h, l, s) : u64_default.rotlSL(h, l, s);
  function keccakP(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    for (let round = 24 - rounds; round < 24; round++) {
      for (let x = 0; x < 10; x++)
        B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
      for (let x = 0; x < 10; x += 2) {
        const idx1 = (x + 8) % 10;
        const idx0 = (x + 2) % 10;
        const B0 = B[idx0];
        const B1 = B[idx0 + 1];
        const Th = rotlH(B0, B1, 1) ^ B[idx1];
        const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
        for (let y = 0; y < 50; y += 10) {
          s[x + y] ^= Th;
          s[x + y + 1] ^= Tl;
        }
      }
      let curH = s[2];
      let curL = s[3];
      for (let t = 0; t < 24; t++) {
        const shift = SHA3_ROTL[t];
        const Th = rotlH(curH, curL, shift);
        const Tl = rotlL(curH, curL, shift);
        const PI = SHA3_PI[t];
        curH = s[PI];
        curL = s[PI + 1];
        s[PI] = Th;
        s[PI + 1] = Tl;
      }
      for (let y = 0; y < 50; y += 10) {
        for (let x = 0; x < 10; x++)
          B[x] = s[y + x];
        for (let x = 0; x < 10; x++)
          s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
      }
      s[0] ^= SHA3_IOTA_H[round];
      s[1] ^= SHA3_IOTA_L[round];
    }
    B.fill(0);
  }
  var Keccak = class extends Hash {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
      super();
      this.blockLen = blockLen;
      this.suffix = suffix;
      this.outputLen = outputLen;
      this.enableXOF = enableXOF;
      this.rounds = rounds;
      this.pos = 0;
      this.posOut = 0;
      this.finished = false;
      this.destroyed = false;
      assert_default.number(outputLen);
      if (0 >= this.blockLen || this.blockLen >= 200)
        throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200);
      this.state32 = u32(this.state);
    }
    keccak() {
      keccakP(this.state32, this.rounds);
      this.posOut = 0;
      this.pos = 0;
    }
    update(data) {
      assert_default.exists(this);
      const { blockLen, state } = this;
      data = toBytes(data);
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        for (let i = 0; i < take; i++)
          state[this.pos++] ^= data[pos++];
        if (this.pos === blockLen)
          this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = true;
      const { state, suffix, pos, blockLen } = this;
      state[pos] ^= suffix;
      if ((suffix & 128) !== 0 && pos === blockLen - 1)
        this.keccak();
      state[blockLen - 1] ^= 128;
      this.keccak();
    }
    writeInto(out) {
      assert_default.exists(this, false);
      assert_default.bytes(out);
      this.finish();
      const bufferOut = this.state;
      const { blockLen } = this;
      for (let pos = 0, len = out.length; pos < len; ) {
        if (this.posOut >= blockLen)
          this.keccak();
        const take = Math.min(blockLen - this.posOut, len - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
    xofInto(out) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(out);
    }
    xof(bytes3) {
      assert_default.number(bytes3);
      return this.xofInto(new Uint8Array(bytes3));
    }
    digestInto(out) {
      assert_default.output(out, this);
      if (this.finished)
        throw new Error("digest() was already called");
      this.writeInto(out);
      this.destroy();
      return out;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true;
      this.state.fill(0);
    }
    _cloneInto(to) {
      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
      to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
      to.state32.set(this.state32);
      to.pos = this.pos;
      to.posOut = this.posOut;
      to.finished = this.finished;
      to.rounds = rounds;
      to.suffix = suffix;
      to.outputLen = outputLen;
      to.enableXOF = enableXOF;
      to.destroyed = this.destroyed;
      return to;
    }
  };
  var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
  var sha3_224 = gen(6, 144, 224 / 8);
  var sha3_256 = gen(6, 136, 256 / 8);
  var sha3_384 = gen(6, 104, 384 / 8);
  var sha3_512 = gen(6, 72, 512 / 8);
  var keccak_224 = gen(1, 144, 224 / 8);
  var keccak_256 = gen(1, 136, 256 / 8);
  var keccak_384 = gen(1, 104, 384 / 8);
  var keccak_512 = gen(1, 72, 512 / 8);
  var genShake = (suffix, blockLen, outputLen) => wrapConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
  var shake128 = genShake(31, 168, 128 / 8);
  var shake256 = genShake(31, 136, 256 / 8);

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/crypto/keccak.js
  var locked2 = false;
  var _keccak256 = function(data) {
    return keccak_256(data);
  };
  var __keccak256 = _keccak256;
  function keccak256(_data) {
    const data = getBytes(_data, "data");
    return hexlify(__keccak256(data));
  }
  keccak256._ = _keccak256;
  keccak256.lock = function() {
    locked2 = true;
  };
  keccak256.register = function(func) {
    if (locked2) {
      throw new TypeError("keccak256 is locked");
    }
    __keccak256 = func;
  };
  Object.freeze(keccak256);

  // ../../node_modules/.pnpm/@noble+hashes@1.1.2/node_modules/@noble/hashes/esm/_sha2.js
  function setBigUint64(view, byteOffset, value, isLE3) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE3);
    const _32n3 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n3 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE3 ? 4 : 0;
    const l = isLE3 ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE3);
    view.setUint32(byteOffset + l, wl, isLE3);
  }
  var SHA2 = class extends Hash {
    constructor(blockLen, outputLen, padOffset, isLE3) {
      super();
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE3;
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView(this.buffer);
    }
    update(data) {
      assert_default.exists(this);
      const { view, buffer, blockLen } = this;
      data = toBytes(data);
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      assert_default.exists(this);
      assert_default.output(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE3 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos; i < blockLen; i++)
        buffer[i] = 0;
      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE3);
      this.process(view, 0);
      const oview = createView(out);
      this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE3));
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor());
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.length = length;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
  };

  // ../../node_modules/.pnpm/@noble+hashes@1.1.2/node_modules/@noble/hashes/esm/ripemd160.js
  var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
  var Id = Uint8Array.from({ length: 16 }, (_, i) => i);
  var Pi = Id.map((i) => (9 * i + 5) % 16);
  var idxL = [Id];
  var idxR = [Pi];
  for (let i = 0; i < 4; i++)
    for (let j of [idxL, idxR])
      j.push(j[i].map((k) => Rho[k]));
  var shifts = [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
    [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
    [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
    [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
  ].map((i) => new Uint8Array(i));
  var shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
  var shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
  var Kl = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]);
  var Kr = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]);
  var rotl = (word, shift) => word << shift | word >>> 32 - shift;
  function f(group, x, y, z) {
    if (group === 0)
      return x ^ y ^ z;
    else if (group === 1)
      return x & y | ~x & z;
    else if (group === 2)
      return (x | ~y) ^ z;
    else if (group === 3)
      return x & z | y & ~z;
    else
      return x ^ (y | ~z);
  }
  var BUF = new Uint32Array(16);
  var RIPEMD160 = class extends SHA2 {
    constructor() {
      super(64, 20, 8, true);
      this.h0 = 1732584193 | 0;
      this.h1 = 4023233417 | 0;
      this.h2 = 2562383102 | 0;
      this.h3 = 271733878 | 0;
      this.h4 = 3285377520 | 0;
    }
    get() {
      const { h0, h1, h2, h3, h4 } = this;
      return [h0, h1, h2, h3, h4];
    }
    set(h0, h1, h2, h3, h4) {
      this.h0 = h0 | 0;
      this.h1 = h1 | 0;
      this.h2 = h2 | 0;
      this.h3 = h3 | 0;
      this.h4 = h4 | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4)
        BUF[i] = view.getUint32(offset, true);
      let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
      for (let group = 0; group < 5; group++) {
        const rGroup = 4 - group;
        const hbl = Kl[group], hbr = Kr[group];
        const rl = idxL[group], rr = idxR[group];
        const sl = shiftsL[group], sr = shiftsR[group];
        for (let i = 0; i < 16; i++) {
          const tl = rotl(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el | 0;
          al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
        }
        for (let i = 0; i < 16; i++) {
          const tr2 = rotl(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er | 0;
          ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr2;
        }
      }
      this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
    }
    roundClean() {
      BUF.fill(0);
    }
    destroy() {
      this.destroyed = true;
      this.buffer.fill(0);
      this.set(0, 0, 0, 0, 0);
    }
  };
  var ripemd160 = wrapConstructor(() => new RIPEMD160());

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/crypto/ripemd160.js
  var locked3 = false;
  var _ripemd160 = function(data) {
    return ripemd160(data);
  };
  var __ripemd160 = _ripemd160;
  function ripemd1602(_data) {
    const data = getBytes(_data, "data");
    return hexlify(__ripemd160(data));
  }
  ripemd1602._ = _ripemd160;
  ripemd1602.lock = function() {
    locked3 = true;
  };
  ripemd1602.register = function(func) {
    if (locked3) {
      throw new TypeError("ripemd160 is locked");
    }
    __ripemd160 = func;
  };
  Object.freeze(ripemd1602);

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/crypto/pbkdf2.js
  var locked4 = false;
  var _pbkdf2 = function(password, salt, iterations, keylen, algo) {
    return (0, import_crypto.pbkdf2Sync)(password, salt, iterations, keylen, algo);
  };
  var __pbkdf2 = _pbkdf2;
  function pbkdf2(_password, _salt, iterations, keylen, algo) {
    const password = getBytes(_password, "password");
    const salt = getBytes(_salt, "salt");
    return hexlify(__pbkdf2(password, salt, iterations, keylen, algo));
  }
  pbkdf2._ = _pbkdf2;
  pbkdf2.lock = function() {
    locked4 = true;
  };
  pbkdf2.register = function(func) {
    if (locked4) {
      throw new Error("pbkdf2 is locked");
    }
    __pbkdf2 = func;
  };
  Object.freeze(pbkdf2);

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/crypto/sha2.js
  var _sha256 = function(data) {
    return (0, import_crypto.createHash)("sha256").update(data).digest();
  };
  var _sha512 = function(data) {
    return (0, import_crypto.createHash)("sha512").update(data).digest();
  };
  var __sha256 = _sha256;
  var __sha512 = _sha512;
  var locked256 = false;
  var locked512 = false;
  function sha256(_data) {
    const data = getBytes(_data, "data");
    return hexlify(__sha256(data));
  }
  sha256._ = _sha256;
  sha256.lock = function() {
    locked256 = true;
  };
  sha256.register = function(func) {
    if (locked256) {
      throw new Error("sha256 is locked");
    }
    __sha256 = func;
  };
  Object.freeze(sha256);
  function sha512(_data) {
    const data = getBytes(_data, "data");
    return hexlify(__sha512(data));
  }
  sha512._ = _sha512;
  sha512.lock = function() {
    locked512 = true;
  };
  sha512.register = function(func) {
    if (locked512) {
      throw new Error("sha512 is locked");
    }
    __sha512 = func;
  };
  Object.freeze(sha256);

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/address/address.js
  var BN_03 = BigInt(0);
  var BN_36 = BigInt(36);
  function getChecksumAddress(address) {
    address = address.toLowerCase();
    const chars = address.substring(2).split("");
    const expanded = new Uint8Array(40);
    for (let i = 0; i < 40; i++) {
      expanded[i] = chars[i].charCodeAt(0);
    }
    const hashed = getBytes(keccak256(expanded));
    for (let i = 0; i < 40; i += 2) {
      if (hashed[i >> 1] >> 4 >= 8) {
        chars[i] = chars[i].toUpperCase();
      }
      if ((hashed[i >> 1] & 15) >= 8) {
        chars[i + 1] = chars[i + 1].toUpperCase();
      }
    }
    return "0x" + chars.join("");
  }
  var ibanLookup = {};
  for (let i = 0; i < 10; i++) {
    ibanLookup[String(i)] = String(i);
  }
  for (let i = 0; i < 26; i++) {
    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
  }
  var safeDigits = 15;
  function ibanChecksum(address) {
    address = address.toUpperCase();
    address = address.substring(4) + address.substring(0, 2) + "00";
    let expanded = address.split("").map((c) => {
      return ibanLookup[c];
    }).join("");
    while (expanded.length >= safeDigits) {
      let block = expanded.substring(0, safeDigits);
      expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
    }
    let checksum = String(98 - parseInt(expanded, 10) % 97);
    while (checksum.length < 2) {
      checksum = "0" + checksum;
    }
    return checksum;
  }
  var Base36 = function() {
    ;
    const result = {};
    for (let i = 0; i < 36; i++) {
      const key = "0123456789abcdefghijklmnopqrstuvwxyz"[i];
      result[key] = BigInt(i);
    }
    return result;
  }();
  function fromBase36(value) {
    value = value.toLowerCase();
    let result = BN_03;
    for (let i = 0; i < value.length; i++) {
      result = result * BN_36 + Base36[value[i]];
    }
    return result;
  }
  function getAddress(address) {
    assertArgument(typeof address === "string", "invalid address", "address", address);
    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
      if (!address.startsWith("0x")) {
        address = "0x" + address;
      }
      const result = getChecksumAddress(address);
      assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, "bad address checksum", "address", address);
      return result;
    }
    if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
      assertArgument(address.substring(2, 4) === ibanChecksum(address), "bad icap checksum", "address", address);
      let result = fromBase36(address.substring(4)).toString(16);
      while (result.length < 40) {
        result = "0" + result;
      }
      return getChecksumAddress("0x" + result);
    }
    assertArgument(false, "invalid address", "address", address);
  }

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/transaction/accesslist.js
  function accessSetify(addr, storageKeys) {
    return {
      address: getAddress(addr),
      storageKeys: storageKeys.map((storageKey, index) => {
        assertArgument(isHexString(storageKey, 32), "invalid slot", `storageKeys[${index}]`, storageKey);
        return storageKey.toLowerCase();
      })
    };
  }
  function accessListify(value) {
    if (Array.isArray(value)) {
      return value.map((set2, index) => {
        if (Array.isArray(set2)) {
          assertArgument(set2.length === 2, "invalid slot set", `value[${index}]`, set2);
          return accessSetify(set2[0], set2[1]);
        }
        assertArgument(set2 != null && typeof set2 === "object", "invalid address-slot set", "value", value);
        return accessSetify(set2.address, set2.storageKeys);
      });
    }
    assertArgument(value != null && typeof value === "object", "invalid access list", "value", value);
    const result = Object.keys(value).map((addr) => {
      const storageKeys = value[addr].reduce((accum, storageKey) => {
        accum[storageKey] = true;
        return accum;
      }, {});
      return accessSetify(addr, Object.keys(storageKeys).sort());
    });
    result.sort((a, b) => a.address.localeCompare(b.address));
    return result;
  }

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/providers/plugins-network.js
  var EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
  var NetworkPlugin = class {
    /**
     *  The name of the plugin.
     *
     *  It is recommended to use reverse-domain-notation, which permits
     *  unique names with a known authority as well as hierarchal entries.
     */
    name;
    /**
     *  Creates a new **NetworkPlugin**.
     */
    constructor(name) {
      defineProperties(this, { name });
    }
    /**
     *  Creates a copy of this plugin.
     */
    clone() {
      return new NetworkPlugin(this.name);
    }
  };
  var GasCostPlugin = class extends NetworkPlugin {
    /**
     *  The block number to treat these values as valid from.
     *
     *  This allows a hardfork to have updated values included as well as
     *  mulutiple hardforks to be supported.
     */
    effectiveBlock;
    /**
     *  The transactions base fee.
     */
    txBase;
    /**
     *  The fee for creating a new account.
     */
    txCreate;
    /**
     *  The fee per zero-byte in the data.
     */
    txDataZero;
    /**
     *  The fee per non-zero-byte in the data.
     */
    txDataNonzero;
    /**
     *  The fee per storage key in the [[link-eip-2930]] access list.
     */
    txAccessListStorageKey;
    /**
     *  The fee per address in the [[link-eip-2930]] access list.
     */
    txAccessListAddress;
    /**
     *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
     *  latest block or another GasCostPlugin supercedes that block number,
     *  with the associated %%costs%%.
     */
    constructor(effectiveBlock, costs) {
      if (effectiveBlock == null) {
        effectiveBlock = 0;
      }
      super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);
      const props = { effectiveBlock };
      function set2(name, nullish) {
        let value = (costs || {})[name];
        if (value == null) {
          value = nullish;
        }
        assertArgument(typeof value === "number", `invalud value for ${name}`, "costs", costs);
        props[name] = value;
      }
      set2("txBase", 21e3);
      set2("txCreate", 32e3);
      set2("txDataZero", 4);
      set2("txDataNonzero", 16);
      set2("txAccessListStorageKey", 1900);
      set2("txAccessListAddress", 2400);
      defineProperties(this, props);
    }
    clone() {
      return new GasCostPlugin(this.effectiveBlock, this);
    }
  };
  var EnsPlugin = class extends NetworkPlugin {
    /**
     *  The ENS Registrty Contract address.
     */
    address;
    /**
     *  The chain ID that the ENS contract lives on.
     */
    targetNetwork;
    /**
     *  Creates a new **EnsPlugin** connected to %%address%% on the
     *  %%targetNetwork%%. The default ENS address and mainnet is used
     *  if unspecified.
     */
    constructor(address, targetNetwork) {
      super("org.ethers.plugins.network.Ens");
      defineProperties(this, {
        address: address || EnsAddress,
        targetNetwork: targetNetwork == null ? 1 : targetNetwork
      });
    }
    clone() {
      return new EnsPlugin(this.address, this.targetNetwork);
    }
  };
  var FetchUrlFeeDataNetworkPlugin = class extends NetworkPlugin {
    #url;
    #processFunc;
    /**
     *  The URL to initialize the FetchRequest with in %%processFunc%%.
     */
    get url() {
      return this.#url;
    }
    /**
     *  The callback to use when computing the FeeData.
     */
    get processFunc() {
      return this.#processFunc;
    }
    /**
     *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
     *  be used when computing the fee data for the network.
     */
    constructor(url, processFunc) {
      super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
      this.#url = url;
      this.#processFunc = processFunc;
    }
    // We are immutable, so we can serve as our own clone
    clone() {
      return this;
    }
  };

  // ../../node_modules/.pnpm/ethers@6.7.1/node_modules/ethers/lib.esm/providers/network.js
  var Networks = /* @__PURE__ */ new Map();
  var Network = class {
    #name;
    #chainId;
    #plugins;
    /**
     *  Creates a new **Network** for %%name%% and %%chainId%%.
     */
    constructor(name, chainId) {
      this.#name = name;
      this.#chainId = getBigInt(chainId);
      this.#plugins = /* @__PURE__ */ new Map();
    }
    /**
     *  Returns a JSON-compatible representation of a Network.
     */
    toJSON() {
      return { name: this.name, chainId: String(this.chainId) };
    }
    /**
     *  The network common name.
     *
     *  This is the canonical name, as networks migh have multiple
     *  names.
     */
    get name() {
      return this.#name;
    }
    set name(value) {
      this.#name = value;
    }
    /**
     *  The network chain ID.
     */
    get chainId() {
      return this.#chainId;
    }
    set chainId(value) {
      this.#chainId = getBigInt(value, "chainId");
    }
    /**
     *  Returns true if %%other%% matches this network. Any chain ID
     *  must match, and if no chain ID is present, the name must match.
     *
     *  This method does not currently check for additional properties,
     *  such as ENS address or plug-in compatibility.
     */
    matches(other) {
      if (other == null) {
        return false;
      }
      if (typeof other === "string") {
        try {
          return this.chainId === getBigInt(other);
        } catch (error2) {
        }
        return this.name === other;
      }
      if (typeof other === "number" || typeof other === "bigint") {
        try {
          return this.chainId === getBigInt(other);
        } catch (error2) {
        }
        return false;
      }
      if (typeof other === "object") {
        if (other.chainId != null) {
          try {
            return this.chainId === getBigInt(other.chainId);
          } catch (error2) {
          }
          return false;
        }
        if (other.name != null) {
          return this.name === other.name;
        }
        return false;
      }
      return false;
    }
    /**
     *  Returns the list of plugins currently attached to this Network.
     */
    get plugins() {
      return Array.from(this.#plugins.values());
    }
    /**
     *  Attach a new %%plugin%% to this Network. The network name
     *  must be unique, excluding any fragment.
     */
    attachPlugin(plugin) {
      if (this.#plugins.get(plugin.name)) {
        throw new Error(`cannot replace existing plugin: ${plugin.name} `);
      }
      this.#plugins.set(plugin.name, plugin.clone());
      return this;
    }
    /**
     *  Return the plugin, if any, matching %%name%% exactly. Plugins
     *  with fragments will not be returned unless %%name%% includes
     *  a fragment.
     */
    getPlugin(name) {
      return this.#plugins.get(name) || null;
    }
    /**
     *  Gets a list of all plugins that match %%name%%, with otr without
     *  a fragment.
     */
    getPlugins(basename3) {
      return this.plugins.filter((p) => p.name.split("#")[0] === basename3);
    }
    /**
     *  Create a copy of this Network.
     */
    clone() {
      const clone5 = new Network(this.name, this.chainId);
      this.plugins.forEach((plugin) => {
        clone5.attachPlugin(plugin.clone());
      });
      return clone5;
    }
    /**
     *  Compute the intrinsic gas required for a transaction.
     *
     *  A GasCostPlugin can be attached to override the default
     *  values.
     */
    computeIntrinsicGas(tx) {
      const costs = this.getPlugin("org.ethers.plugins.network.GasCost") || new GasCostPlugin();
      let gas = costs.txBase;
      if (tx.to == null) {
        gas += costs.txCreate;
      }
      if (tx.data) {
        for (let i = 2; i < tx.data.length; i += 2) {
          if (tx.data.substring(i, i + 2) === "00") {
            gas += costs.txDataZero;
          } else {
            gas += costs.txDataNonzero;
          }
        }
      }
      if (tx.accessList) {
        const accessList = accessListify(tx.accessList);
        for (const addr in accessList) {
          gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
        }
      }
      return gas;
    }
    /**
     *  Returns a new Network for the %%network%% name or chainId.
     */
    static from(network) {
      injectCommonNetworks();
      if (network == null) {
        return Network.from("mainnet");
      }
      if (typeof network === "number") {
        network = BigInt(network);
      }
      if (typeof network === "string" || typeof network === "bigint") {
        const networkFunc = Networks.get(network);
        if (networkFunc) {
          return networkFunc();
        }
        if (typeof network === "bigint") {
          return new Network("unknown", network);
        }
        assertArgument(false, "unknown network", "network", network);
      }
      if (typeof network.clone === "function") {
        const clone5 = network.clone();
        return clone5;
      }
      if (typeof network === "object") {
        assertArgument(typeof network.name === "string" && typeof network.chainId === "number", "invalid network object name or chainId", "network", network);
        const custom = new Network(network.name, network.chainId);
        if (network.ensAddress || network.ensNetwork != null) {
          custom.attachPlugin(new EnsPlugin(network.ensAddress, network.ensNetwork));
        }
        return custom;
      }
      assertArgument(false, "invalid network", "network", network);
    }
    /**
     *  Register %%nameOrChainId%% with a function which returns
     *  an instance of a Network representing that chain.
     */
    static register(nameOrChainId, networkFunc) {
      if (typeof nameOrChainId === "number") {
        nameOrChainId = BigInt(nameOrChainId);
      }
      const existing = Networks.get(nameOrChainId);
      if (existing) {
        assertArgument(false, `conflicting network for ${JSON.stringify(existing.name)}`, "nameOrChainId", nameOrChainId);
      }
      Networks.set(nameOrChainId, networkFunc);
    }
  };
  function parseUnits(_value, decimals) {
    const value = String(_value);
    if (!value.match(/^[0-9.]+$/)) {
      throw new Error(`invalid gwei value: ${_value}`);
    }
    const comps = value.split(".");
    if (comps.length === 1) {
      comps.push("");
    }
    if (comps.length !== 2) {
      throw new Error(`invalid gwei value: ${_value}`);
    }
    while (comps[1].length < decimals) {
      comps[1] += "0";
    }
    if (comps[1].length > 9) {
      let frac = BigInt(comps[1].substring(0, 9));
      if (!comps[1].substring(9).match(/^0+$/)) {
        frac++;
      }
      comps[1] = frac.toString();
    }
    return BigInt(comps[0] + comps[1]);
  }
  function getGasStationPlugin(url) {
    return new FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request) => {
      request.setHeader("User-Agent", "ethers");
      let response;
      try {
        const [_response, _feeData] = await Promise.all([
          request.send(),
          fetchFeeData()
        ]);
        response = _response;
        const payload = response.bodyJson.standard;
        const feeData = {
          gasPrice: _feeData.gasPrice,
          maxFeePerGas: parseUnits(payload.maxFee, 9),
          maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9)
        };
        return feeData;
      } catch (error2) {
        assert(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, "SERVER_ERROR", { request, response, error: error2 });
      }
    });
  }
  function getPriorityFeePlugin(maxPriorityFeePerGas) {
    return new FetchUrlFeeDataNetworkPlugin("data:", async (fetchFeeData, provider, request) => {
      const feeData = await fetchFeeData();
      if (feeData.maxFeePerGas == null || feeData.maxPriorityFeePerGas == null) {
        return feeData;
      }
      const baseFee = feeData.maxFeePerGas - feeData.maxPriorityFeePerGas;
      return {
        gasPrice: feeData.gasPrice,
        maxFeePerGas: baseFee + maxPriorityFeePerGas,
        maxPriorityFeePerGas
      };
    });
  }
  var injected = false;
  function injectCommonNetworks() {
    if (injected) {
      return;
    }
    injected = true;
    function registerEth(name, chainId, options) {
      const func = function() {
        const network = new Network(name, chainId);
        if (options.ensNetwork != null) {
          network.attachPlugin(new EnsPlugin(null, options.ensNetwork));
        }
        network.attachPlugin(new GasCostPlugin());
        (options.plugins || []).forEach((plugin) => {
          network.attachPlugin(plugin);
        });
        return network;
      };
      Network.register(name, func);
      Network.register(chainId, func);
      if (options.altNames) {
        options.altNames.forEach((name2) => {
          Network.register(name2, func);
        });
      }
    }
    registerEth("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] });
    registerEth("ropsten", 3, { ensNetwork: 3 });
    registerEth("rinkeby", 4, { ensNetwork: 4 });
    registerEth("goerli", 5, { ensNetwork: 5 });
    registerEth("kovan", 42, { ensNetwork: 42 });
    registerEth("sepolia", 11155111, {});
    registerEth("classic", 61, {});
    registerEth("classicKotti", 6, {});
    registerEth("arbitrum", 42161, {
      ensNetwork: 1
    });
    registerEth("arbitrum-goerli", 421613, {});
    registerEth("bnb", 56, { ensNetwork: 1 });
    registerEth("bnbt", 97, {});
    registerEth("linea", 59144, { ensNetwork: 1 });
    registerEth("linea-goerli", 59140, {});
    registerEth("matic", 137, {
      ensNetwork: 1,
      plugins: [
        getGasStationPlugin("https://gasstation.polygon.technology/v2")
      ]
    });
    registerEth("matic-mumbai", 80001, {
      altNames: ["maticMumbai", "maticmum"],
      plugins: [
        getGasStationPlugin("https://gasstation-testnet.polygon.technology/v2")
      ]
    });
    registerEth("optimism", 10, {
      ensNetwork: 1,
      plugins: [
        getPriorityFeePlugin(BigInt("1000000"))
      ]
    });
    registerEth("optimism-goerli", 420, {});
    registerEth("xdai", 100, { ensNetwork: 1 });
  }

  // ../utils/dist/index.mjs
  var __create2 = Object.create;
  var __defProp3 = Object.defineProperty;
  var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames2 = Object.getOwnPropertyNames;
  var __getProtoOf2 = Object.getPrototypeOf;
  var __hasOwnProp2 = Object.prototype.hasOwnProperty;
  var __commonJS2 = (cb, mod) => function __require3() {
    return mod || (0, cb[__getOwnPropNames2(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps2 = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames2(from))
        if (!__hasOwnProp2.call(to, key) && key !== except)
          __defProp3(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM2 = (mod, isNodeMode, target) => (target = mod != null ? __create2(__getProtoOf2(mod)) : {}, __copyProps2(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp3(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var require_constants2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/internal/constants.js"(exports, module2) {
      var SEMVER_SPEC_VERSION = "2.0.0";
      var MAX_LENGTH = 256;
      var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
      9007199254740991;
      var MAX_SAFE_COMPONENT_LENGTH = 16;
      module2.exports = {
        SEMVER_SPEC_VERSION,
        MAX_LENGTH,
        MAX_SAFE_INTEGER,
        MAX_SAFE_COMPONENT_LENGTH
      };
    }
  });
  var require_debug2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/internal/debug.js"(exports, module2) {
      var debug2 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
      };
      module2.exports = debug2;
    }
  });
  var require_re2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/internal/re.js"(exports, module2) {
      var { MAX_SAFE_COMPONENT_LENGTH } = require_constants2();
      var debug2 = require_debug2();
      exports = module2.exports = {};
      var re = exports.re = [];
      var src = exports.src = [];
      var t = exports.t = {};
      var R = 0;
      var createToken2 = (name, value, isGlobal) => {
        const index = R++;
        debug2(name, index, value);
        t[name] = index;
        src[index] = value;
        re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      };
      createToken2("NUMERICIDENTIFIER", "0|[1-9]\\d*");
      createToken2("NUMERICIDENTIFIERLOOSE", "[0-9]+");
      createToken2("NONNUMERICIDENTIFIER", "\\d*[a-zA-Z-][a-zA-Z0-9-]*");
      createToken2("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
      createToken2("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
      createToken2("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
      createToken2("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
      createToken2("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
      createToken2("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
      createToken2("BUILDIDENTIFIER", "[0-9A-Za-z-]+");
      createToken2("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
      createToken2("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
      createToken2("FULL", `^${src[t.FULLPLAIN]}$`);
      createToken2("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
      createToken2("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
      createToken2("GTLT", "((?:<|>)?=?)");
      createToken2("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
      createToken2("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
      createToken2("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
      createToken2("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
      createToken2("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
      createToken2("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
      createToken2("COERCE", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:$|[^\\d])`);
      createToken2("COERCERTL", src[t.COERCE], true);
      createToken2("LONETILDE", "(?:~>?)");
      createToken2("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
      exports.tildeTrimReplace = "$1~";
      createToken2("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
      createToken2("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
      createToken2("LONECARET", "(?:\\^)");
      createToken2("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
      exports.caretTrimReplace = "$1^";
      createToken2("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
      createToken2("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
      createToken2("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
      createToken2("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
      createToken2("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
      exports.comparatorTrimReplace = "$1$2$3";
      createToken2("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
      createToken2("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
      createToken2("STAR", "(<|>)?=?\\s*\\*");
      createToken2("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
      createToken2("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
    }
  });
  var require_parse_options2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/internal/parse-options.js"(exports, module2) {
      var opts = ["includePrerelease", "loose", "rtl"];
      var parseOptions = (options) => !options ? {} : typeof options !== "object" ? { loose: true } : opts.filter((k) => options[k]).reduce((o, k) => {
        o[k] = true;
        return o;
      }, {});
      module2.exports = parseOptions;
    }
  });
  var require_identifiers2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/internal/identifiers.js"(exports, module2) {
      var numeric = /^[0-9]+$/;
      var compareIdentifiers = (a, b) => {
        const anum = numeric.test(a);
        const bnum = numeric.test(b);
        if (anum && bnum) {
          a = +a;
          b = +b;
        }
        return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
      };
      var rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
      module2.exports = {
        compareIdentifiers,
        rcompareIdentifiers
      };
    }
  });
  var require_semver3 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/classes/semver.js"(exports, module2) {
      var debug2 = require_debug2();
      var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants2();
      var { re, t } = require_re2();
      var parseOptions = require_parse_options2();
      var { compareIdentifiers } = require_identifiers2();
      var SemVer = class {
        constructor(version2, options) {
          options = parseOptions(options);
          if (version2 instanceof SemVer) {
            if (version2.loose === !!options.loose && version2.includePrerelease === !!options.includePrerelease) {
              return version2;
            } else {
              version2 = version2.version;
            }
          } else if (typeof version2 !== "string") {
            throw new TypeError(`Invalid Version: ${version2}`);
          }
          if (version2.length > MAX_LENGTH) {
            throw new TypeError(
              `version is longer than ${MAX_LENGTH} characters`
            );
          }
          debug2("SemVer", version2, options);
          this.options = options;
          this.loose = !!options.loose;
          this.includePrerelease = !!options.includePrerelease;
          const m = version2.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
          if (!m) {
            throw new TypeError(`Invalid Version: ${version2}`);
          }
          this.raw = version2;
          this.major = +m[1];
          this.minor = +m[2];
          this.patch = +m[3];
          if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
            throw new TypeError("Invalid major version");
          }
          if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
            throw new TypeError("Invalid minor version");
          }
          if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
            throw new TypeError("Invalid patch version");
          }
          if (!m[4]) {
            this.prerelease = [];
          } else {
            this.prerelease = m[4].split(".").map((id) => {
              if (/^[0-9]+$/.test(id)) {
                const num = +id;
                if (num >= 0 && num < MAX_SAFE_INTEGER) {
                  return num;
                }
              }
              return id;
            });
          }
          this.build = m[5] ? m[5].split(".") : [];
          this.format();
        }
        format() {
          this.version = `${this.major}.${this.minor}.${this.patch}`;
          if (this.prerelease.length) {
            this.version += `-${this.prerelease.join(".")}`;
          }
          return this.version;
        }
        toString() {
          return this.version;
        }
        compare(other) {
          debug2("SemVer.compare", this.version, this.options, other);
          if (!(other instanceof SemVer)) {
            if (typeof other === "string" && other === this.version) {
              return 0;
            }
            other = new SemVer(other, this.options);
          }
          if (other.version === this.version) {
            return 0;
          }
          return this.compareMain(other) || this.comparePre(other);
        }
        compareMain(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }
          return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
        }
        comparePre(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }
          if (this.prerelease.length && !other.prerelease.length) {
            return -1;
          } else if (!this.prerelease.length && other.prerelease.length) {
            return 1;
          } else if (!this.prerelease.length && !other.prerelease.length) {
            return 0;
          }
          let i = 0;
          do {
            const a = this.prerelease[i];
            const b = other.prerelease[i];
            debug2("prerelease compare", i, a, b);
            if (a === void 0 && b === void 0) {
              return 0;
            } else if (b === void 0) {
              return 1;
            } else if (a === void 0) {
              return -1;
            } else if (a === b) {
              continue;
            } else {
              return compareIdentifiers(a, b);
            }
          } while (++i);
        }
        compareBuild(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }
          let i = 0;
          do {
            const a = this.build[i];
            const b = other.build[i];
            debug2("prerelease compare", i, a, b);
            if (a === void 0 && b === void 0) {
              return 0;
            } else if (b === void 0) {
              return 1;
            } else if (a === void 0) {
              return -1;
            } else if (a === b) {
              continue;
            } else {
              return compareIdentifiers(a, b);
            }
          } while (++i);
        }
        // preminor will bump the version up to the next minor release, and immediately
        // down to pre-release. premajor and prepatch work the same way.
        inc(release, identifier) {
          switch (release) {
            case "premajor":
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor = 0;
              this.major++;
              this.inc("pre", identifier);
              break;
            case "preminor":
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor++;
              this.inc("pre", identifier);
              break;
            case "prepatch":
              this.prerelease.length = 0;
              this.inc("patch", identifier);
              this.inc("pre", identifier);
              break;
            case "prerelease":
              if (this.prerelease.length === 0) {
                this.inc("patch", identifier);
              }
              this.inc("pre", identifier);
              break;
            case "major":
              if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
                this.major++;
              }
              this.minor = 0;
              this.patch = 0;
              this.prerelease = [];
              break;
            case "minor":
              if (this.patch !== 0 || this.prerelease.length === 0) {
                this.minor++;
              }
              this.patch = 0;
              this.prerelease = [];
              break;
            case "patch":
              if (this.prerelease.length === 0) {
                this.patch++;
              }
              this.prerelease = [];
              break;
            case "pre":
              if (this.prerelease.length === 0) {
                this.prerelease = [0];
              } else {
                let i = this.prerelease.length;
                while (--i >= 0) {
                  if (typeof this.prerelease[i] === "number") {
                    this.prerelease[i]++;
                    i = -2;
                  }
                }
                if (i === -1) {
                  this.prerelease.push(0);
                }
              }
              if (identifier) {
                if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                  if (isNaN(this.prerelease[1])) {
                    this.prerelease = [identifier, 0];
                  }
                } else {
                  this.prerelease = [identifier, 0];
                }
              }
              break;
            default:
              throw new Error(`invalid increment argument: ${release}`);
          }
          this.format();
          this.raw = this.version;
          return this;
        }
      };
      module2.exports = SemVer;
    }
  });
  var require_parse2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/parse.js"(exports, module2) {
      var { MAX_LENGTH } = require_constants2();
      var { re, t } = require_re2();
      var SemVer = require_semver3();
      var parseOptions = require_parse_options2();
      var parse3 = (version2, options) => {
        options = parseOptions(options);
        if (version2 instanceof SemVer) {
          return version2;
        }
        if (typeof version2 !== "string") {
          return null;
        }
        if (version2.length > MAX_LENGTH) {
          return null;
        }
        const r = options.loose ? re[t.LOOSE] : re[t.FULL];
        if (!r.test(version2)) {
          return null;
        }
        try {
          return new SemVer(version2, options);
        } catch (er) {
          return null;
        }
      };
      module2.exports = parse3;
    }
  });
  var require_valid3 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/valid.js"(exports, module2) {
      var parse3 = require_parse2();
      var valid = (version2, options) => {
        const v = parse3(version2, options);
        return v ? v.version : null;
      };
      module2.exports = valid;
    }
  });
  var require_clean2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/clean.js"(exports, module2) {
      var parse3 = require_parse2();
      var clean = (version2, options) => {
        const s = parse3(version2.trim().replace(/^[=v]+/, ""), options);
        return s ? s.version : null;
      };
      module2.exports = clean;
    }
  });
  var require_inc2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/inc.js"(exports, module2) {
      var SemVer = require_semver3();
      var inc = (version2, release, options, identifier) => {
        if (typeof options === "string") {
          identifier = options;
          options = void 0;
        }
        try {
          return new SemVer(
            version2 instanceof SemVer ? version2.version : version2,
            options
          ).inc(release, identifier).version;
        } catch (er) {
          return null;
        }
      };
      module2.exports = inc;
    }
  });
  var require_compare2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/compare.js"(exports, module2) {
      var SemVer = require_semver3();
      var compare = (a, b, loose) => new SemVer(a, loose).compare(new SemVer(b, loose));
      module2.exports = compare;
    }
  });
  var require_eq2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/eq.js"(exports, module2) {
      var compare = require_compare2();
      var eq = (a, b, loose) => compare(a, b, loose) === 0;
      module2.exports = eq;
    }
  });
  var require_diff2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/diff.js"(exports, module2) {
      var parse3 = require_parse2();
      var eq = require_eq2();
      var diff = (version1, version2) => {
        if (eq(version1, version2)) {
          return null;
        } else {
          const v1 = parse3(version1);
          const v2 = parse3(version2);
          const hasPre = v1.prerelease.length || v2.prerelease.length;
          const prefix = hasPre ? "pre" : "";
          const defaultResult = hasPre ? "prerelease" : "";
          for (const key in v1) {
            if (key === "major" || key === "minor" || key === "patch") {
              if (v1[key] !== v2[key]) {
                return prefix + key;
              }
            }
          }
          return defaultResult;
        }
      };
      module2.exports = diff;
    }
  });
  var require_major2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/major.js"(exports, module2) {
      var SemVer = require_semver3();
      var major = (a, loose) => new SemVer(a, loose).major;
      module2.exports = major;
    }
  });
  var require_minor2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/minor.js"(exports, module2) {
      var SemVer = require_semver3();
      var minor = (a, loose) => new SemVer(a, loose).minor;
      module2.exports = minor;
    }
  });
  var require_patch2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/patch.js"(exports, module2) {
      var SemVer = require_semver3();
      var patch = (a, loose) => new SemVer(a, loose).patch;
      module2.exports = patch;
    }
  });
  var require_prerelease2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/prerelease.js"(exports, module2) {
      var parse3 = require_parse2();
      var prerelease = (version2, options) => {
        const parsed = parse3(version2, options);
        return parsed && parsed.prerelease.length ? parsed.prerelease : null;
      };
      module2.exports = prerelease;
    }
  });
  var require_rcompare2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/rcompare.js"(exports, module2) {
      var compare = require_compare2();
      var rcompare = (a, b, loose) => compare(b, a, loose);
      module2.exports = rcompare;
    }
  });
  var require_compare_loose2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/compare-loose.js"(exports, module2) {
      var compare = require_compare2();
      var compareLoose = (a, b) => compare(a, b, true);
      module2.exports = compareLoose;
    }
  });
  var require_compare_build2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/compare-build.js"(exports, module2) {
      var SemVer = require_semver3();
      var compareBuild = (a, b, loose) => {
        const versionA = new SemVer(a, loose);
        const versionB = new SemVer(b, loose);
        return versionA.compare(versionB) || versionA.compareBuild(versionB);
      };
      module2.exports = compareBuild;
    }
  });
  var require_sort2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/sort.js"(exports, module2) {
      var compareBuild = require_compare_build2();
      var sort = (list, loose) => list.sort((a, b) => compareBuild(a, b, loose));
      module2.exports = sort;
    }
  });
  var require_rsort2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/rsort.js"(exports, module2) {
      var compareBuild = require_compare_build2();
      var rsort = (list, loose) => list.sort((a, b) => compareBuild(b, a, loose));
      module2.exports = rsort;
    }
  });
  var require_gt2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/gt.js"(exports, module2) {
      var compare = require_compare2();
      var gt = (a, b, loose) => compare(a, b, loose) > 0;
      module2.exports = gt;
    }
  });
  var require_lt2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/lt.js"(exports, module2) {
      var compare = require_compare2();
      var lt = (a, b, loose) => compare(a, b, loose) < 0;
      module2.exports = lt;
    }
  });
  var require_neq2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/neq.js"(exports, module2) {
      var compare = require_compare2();
      var neq = (a, b, loose) => compare(a, b, loose) !== 0;
      module2.exports = neq;
    }
  });
  var require_gte2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/gte.js"(exports, module2) {
      var compare = require_compare2();
      var gte = (a, b, loose) => compare(a, b, loose) >= 0;
      module2.exports = gte;
    }
  });
  var require_lte2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/lte.js"(exports, module2) {
      var compare = require_compare2();
      var lte = (a, b, loose) => compare(a, b, loose) <= 0;
      module2.exports = lte;
    }
  });
  var require_cmp2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/cmp.js"(exports, module2) {
      var eq = require_eq2();
      var neq = require_neq2();
      var gt = require_gt2();
      var gte = require_gte2();
      var lt = require_lt2();
      var lte = require_lte2();
      var cmp = (a, op, b, loose) => {
        switch (op) {
          case "===":
            if (typeof a === "object") {
              a = a.version;
            }
            if (typeof b === "object") {
              b = b.version;
            }
            return a === b;
          case "!==":
            if (typeof a === "object") {
              a = a.version;
            }
            if (typeof b === "object") {
              b = b.version;
            }
            return a !== b;
          case "":
          case "=":
          case "==":
            return eq(a, b, loose);
          case "!=":
            return neq(a, b, loose);
          case ">":
            return gt(a, b, loose);
          case ">=":
            return gte(a, b, loose);
          case "<":
            return lt(a, b, loose);
          case "<=":
            return lte(a, b, loose);
          default:
            throw new TypeError(`Invalid operator: ${op}`);
        }
      };
      module2.exports = cmp;
    }
  });
  var require_coerce2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/coerce.js"(exports, module2) {
      var SemVer = require_semver3();
      var parse3 = require_parse2();
      var { re, t } = require_re2();
      var coerce = (version2, options) => {
        if (version2 instanceof SemVer) {
          return version2;
        }
        if (typeof version2 === "number") {
          version2 = String(version2);
        }
        if (typeof version2 !== "string") {
          return null;
        }
        options = options || {};
        let match3 = null;
        if (!options.rtl) {
          match3 = version2.match(re[t.COERCE]);
        } else {
          let next;
          while ((next = re[t.COERCERTL].exec(version2)) && (!match3 || match3.index + match3[0].length !== version2.length)) {
            if (!match3 || next.index + next[0].length !== match3.index + match3[0].length) {
              match3 = next;
            }
            re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
          }
          re[t.COERCERTL].lastIndex = -1;
        }
        if (match3 === null) {
          return null;
        }
        return parse3(`${match3[2]}.${match3[3] || "0"}.${match3[4] || "0"}`, options);
      };
      module2.exports = coerce;
    }
  });
  var require_iterator2 = __commonJS2({
    "../../node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/iterator.js"(exports, module2) {
      "use strict";
      module2.exports = function(Yallist) {
        Yallist.prototype[Symbol.iterator] = function* () {
          for (let walker = this.head; walker; walker = walker.next) {
            yield walker.value;
          }
        };
      };
    }
  });
  var require_yallist2 = __commonJS2({
    "../../node_modules/.pnpm/yallist@4.0.0/node_modules/yallist/yallist.js"(exports, module2) {
      "use strict";
      module2.exports = Yallist;
      Yallist.Node = Node2;
      Yallist.create = Yallist;
      function Yallist(list) {
        var self2 = this;
        if (!(self2 instanceof Yallist)) {
          self2 = new Yallist();
        }
        self2.tail = null;
        self2.head = null;
        self2.length = 0;
        if (list && typeof list.forEach === "function") {
          list.forEach(function(item) {
            self2.push(item);
          });
        } else if (arguments.length > 0) {
          for (var i = 0, l = arguments.length; i < l; i++) {
            self2.push(arguments[i]);
          }
        }
        return self2;
      }
      Yallist.prototype.removeNode = function(node) {
        if (node.list !== this) {
          throw new Error("removing node which does not belong to this list");
        }
        var next = node.next;
        var prev = node.prev;
        if (next) {
          next.prev = prev;
        }
        if (prev) {
          prev.next = next;
        }
        if (node === this.head) {
          this.head = next;
        }
        if (node === this.tail) {
          this.tail = prev;
        }
        node.list.length--;
        node.next = null;
        node.prev = null;
        node.list = null;
        return next;
      };
      Yallist.prototype.unshiftNode = function(node) {
        if (node === this.head) {
          return;
        }
        if (node.list) {
          node.list.removeNode(node);
        }
        var head = this.head;
        node.list = this;
        node.next = head;
        if (head) {
          head.prev = node;
        }
        this.head = node;
        if (!this.tail) {
          this.tail = node;
        }
        this.length++;
      };
      Yallist.prototype.pushNode = function(node) {
        if (node === this.tail) {
          return;
        }
        if (node.list) {
          node.list.removeNode(node);
        }
        var tail = this.tail;
        node.list = this;
        node.prev = tail;
        if (tail) {
          tail.next = node;
        }
        this.tail = node;
        if (!this.head) {
          this.head = node;
        }
        this.length++;
      };
      Yallist.prototype.push = function() {
        for (var i = 0, l = arguments.length; i < l; i++) {
          push(this, arguments[i]);
        }
        return this.length;
      };
      Yallist.prototype.unshift = function() {
        for (var i = 0, l = arguments.length; i < l; i++) {
          unshift(this, arguments[i]);
        }
        return this.length;
      };
      Yallist.prototype.pop = function() {
        if (!this.tail) {
          return void 0;
        }
        var res = this.tail.value;
        this.tail = this.tail.prev;
        if (this.tail) {
          this.tail.next = null;
        } else {
          this.head = null;
        }
        this.length--;
        return res;
      };
      Yallist.prototype.shift = function() {
        if (!this.head) {
          return void 0;
        }
        var res = this.head.value;
        this.head = this.head.next;
        if (this.head) {
          this.head.prev = null;
        } else {
          this.tail = null;
        }
        this.length--;
        return res;
      };
      Yallist.prototype.forEach = function(fn, thisp) {
        thisp = thisp || this;
        for (var walker = this.head, i = 0; walker !== null; i++) {
          fn.call(thisp, walker.value, i, this);
          walker = walker.next;
        }
      };
      Yallist.prototype.forEachReverse = function(fn, thisp) {
        thisp = thisp || this;
        for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
          fn.call(thisp, walker.value, i, this);
          walker = walker.prev;
        }
      };
      Yallist.prototype.get = function(n) {
        for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
          walker = walker.next;
        }
        if (i === n && walker !== null) {
          return walker.value;
        }
      };
      Yallist.prototype.getReverse = function(n) {
        for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
          walker = walker.prev;
        }
        if (i === n && walker !== null) {
          return walker.value;
        }
      };
      Yallist.prototype.map = function(fn, thisp) {
        thisp = thisp || this;
        var res = new Yallist();
        for (var walker = this.head; walker !== null; ) {
          res.push(fn.call(thisp, walker.value, this));
          walker = walker.next;
        }
        return res;
      };
      Yallist.prototype.mapReverse = function(fn, thisp) {
        thisp = thisp || this;
        var res = new Yallist();
        for (var walker = this.tail; walker !== null; ) {
          res.push(fn.call(thisp, walker.value, this));
          walker = walker.prev;
        }
        return res;
      };
      Yallist.prototype.reduce = function(fn, initial) {
        var acc;
        var walker = this.head;
        if (arguments.length > 1) {
          acc = initial;
        } else if (this.head) {
          walker = this.head.next;
          acc = this.head.value;
        } else {
          throw new TypeError("Reduce of empty list with no initial value");
        }
        for (var i = 0; walker !== null; i++) {
          acc = fn(acc, walker.value, i);
          walker = walker.next;
        }
        return acc;
      };
      Yallist.prototype.reduceReverse = function(fn, initial) {
        var acc;
        var walker = this.tail;
        if (arguments.length > 1) {
          acc = initial;
        } else if (this.tail) {
          walker = this.tail.prev;
          acc = this.tail.value;
        } else {
          throw new TypeError("Reduce of empty list with no initial value");
        }
        for (var i = this.length - 1; walker !== null; i--) {
          acc = fn(acc, walker.value, i);
          walker = walker.prev;
        }
        return acc;
      };
      Yallist.prototype.toArray = function() {
        var arr = new Array(this.length);
        for (var i = 0, walker = this.head; walker !== null; i++) {
          arr[i] = walker.value;
          walker = walker.next;
        }
        return arr;
      };
      Yallist.prototype.toArrayReverse = function() {
        var arr = new Array(this.length);
        for (var i = 0, walker = this.tail; walker !== null; i++) {
          arr[i] = walker.value;
          walker = walker.prev;
        }
        return arr;
      };
      Yallist.prototype.slice = function(from, to) {
        to = to || this.length;
        if (to < 0) {
          to += this.length;
        }
        from = from || 0;
        if (from < 0) {
          from += this.length;
        }
        var ret3 = new Yallist();
        if (to < from || to < 0) {
          return ret3;
        }
        if (from < 0) {
          from = 0;
        }
        if (to > this.length) {
          to = this.length;
        }
        for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
          walker = walker.next;
        }
        for (; walker !== null && i < to; i++, walker = walker.next) {
          ret3.push(walker.value);
        }
        return ret3;
      };
      Yallist.prototype.sliceReverse = function(from, to) {
        to = to || this.length;
        if (to < 0) {
          to += this.length;
        }
        from = from || 0;
        if (from < 0) {
          from += this.length;
        }
        var ret3 = new Yallist();
        if (to < from || to < 0) {
          return ret3;
        }
        if (from < 0) {
          from = 0;
        }
        if (to > this.length) {
          to = this.length;
        }
        for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
          walker = walker.prev;
        }
        for (; walker !== null && i > from; i--, walker = walker.prev) {
          ret3.push(walker.value);
        }
        return ret3;
      };
      Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
        if (start > this.length) {
          start = this.length - 1;
        }
        if (start < 0) {
          start = this.length + start;
        }
        for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
          walker = walker.next;
        }
        var ret3 = [];
        for (var i = 0; walker && i < deleteCount; i++) {
          ret3.push(walker.value);
          walker = this.removeNode(walker);
        }
        if (walker === null) {
          walker = this.tail;
        }
        if (walker !== this.head && walker !== this.tail) {
          walker = walker.prev;
        }
        for (var i = 0; i < nodes.length; i++) {
          walker = insert(this, walker, nodes[i]);
        }
        return ret3;
      };
      Yallist.prototype.reverse = function() {
        var head = this.head;
        var tail = this.tail;
        for (var walker = head; walker !== null; walker = walker.prev) {
          var p = walker.prev;
          walker.prev = walker.next;
          walker.next = p;
        }
        this.head = tail;
        this.tail = head;
        return this;
      };
      function insert(self2, node, value) {
        var inserted = node === self2.head ? new Node2(value, null, node, self2) : new Node2(value, node, node.next, self2);
        if (inserted.next === null) {
          self2.tail = inserted;
        }
        if (inserted.prev === null) {
          self2.head = inserted;
        }
        self2.length++;
        return inserted;
      }
      function push(self2, item) {
        self2.tail = new Node2(item, self2.tail, null, self2);
        if (!self2.head) {
          self2.head = self2.tail;
        }
        self2.length++;
      }
      function unshift(self2, item) {
        self2.head = new Node2(item, null, self2.head, self2);
        if (!self2.tail) {
          self2.tail = self2.head;
        }
        self2.length++;
      }
      function Node2(value, prev, next, list) {
        if (!(this instanceof Node2)) {
          return new Node2(value, prev, next, list);
        }
        this.list = list;
        this.value = value;
        if (prev) {
          prev.next = this;
          this.prev = prev;
        } else {
          this.prev = null;
        }
        if (next) {
          next.prev = this;
          this.next = next;
        } else {
          this.next = null;
        }
      }
      try {
        require_iterator2()(Yallist);
      } catch (er) {
      }
    }
  });
  var require_lru_cache2 = __commonJS2({
    "../../node_modules/.pnpm/lru-cache@6.0.0/node_modules/lru-cache/index.js"(exports, module2) {
      "use strict";
      var Yallist = require_yallist2();
      var MAX = Symbol("max");
      var LENGTH = Symbol("length");
      var LENGTH_CALCULATOR = Symbol("lengthCalculator");
      var ALLOW_STALE = Symbol("allowStale");
      var MAX_AGE = Symbol("maxAge");
      var DISPOSE = Symbol("dispose");
      var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
      var LRU_LIST = Symbol("lruList");
      var CACHE = Symbol("cache");
      var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
      var naiveLength = () => 1;
      var LRUCache2 = class {
        constructor(options) {
          if (typeof options === "number")
            options = { max: options };
          if (!options)
            options = {};
          if (options.max && (typeof options.max !== "number" || options.max < 0))
            throw new TypeError("max must be a non-negative number");
          const max2 = this[MAX] = options.max || Infinity;
          const lc = options.length || naiveLength;
          this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
          this[ALLOW_STALE] = options.stale || false;
          if (options.maxAge && typeof options.maxAge !== "number")
            throw new TypeError("maxAge must be a number");
          this[MAX_AGE] = options.maxAge || 0;
          this[DISPOSE] = options.dispose;
          this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
          this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
          this.reset();
        }
        // resize the cache when the max changes.
        set max(mL) {
          if (typeof mL !== "number" || mL < 0)
            throw new TypeError("max must be a non-negative number");
          this[MAX] = mL || Infinity;
          trim2(this);
        }
        get max() {
          return this[MAX];
        }
        set allowStale(allowStale) {
          this[ALLOW_STALE] = !!allowStale;
        }
        get allowStale() {
          return this[ALLOW_STALE];
        }
        set maxAge(mA) {
          if (typeof mA !== "number")
            throw new TypeError("maxAge must be a non-negative number");
          this[MAX_AGE] = mA;
          trim2(this);
        }
        get maxAge() {
          return this[MAX_AGE];
        }
        // resize the cache when the lengthCalculator changes.
        set lengthCalculator(lC) {
          if (typeof lC !== "function")
            lC = naiveLength;
          if (lC !== this[LENGTH_CALCULATOR]) {
            this[LENGTH_CALCULATOR] = lC;
            this[LENGTH] = 0;
            this[LRU_LIST].forEach((hit) => {
              hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
              this[LENGTH] += hit.length;
            });
          }
          trim2(this);
        }
        get lengthCalculator() {
          return this[LENGTH_CALCULATOR];
        }
        get length() {
          return this[LENGTH];
        }
        get itemCount() {
          return this[LRU_LIST].length;
        }
        rforEach(fn, thisp) {
          thisp = thisp || this;
          for (let walker = this[LRU_LIST].tail; walker !== null; ) {
            const prev = walker.prev;
            forEachStep(this, fn, walker, thisp);
            walker = prev;
          }
        }
        forEach(fn, thisp) {
          thisp = thisp || this;
          for (let walker = this[LRU_LIST].head; walker !== null; ) {
            const next = walker.next;
            forEachStep(this, fn, walker, thisp);
            walker = next;
          }
        }
        keys() {
          return this[LRU_LIST].toArray().map((k) => k.key);
        }
        values() {
          return this[LRU_LIST].toArray().map((k) => k.value);
        }
        reset() {
          if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
            this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
          }
          this[CACHE] = /* @__PURE__ */ new Map();
          this[LRU_LIST] = new Yallist();
          this[LENGTH] = 0;
        }
        dump() {
          return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
            k: hit.key,
            v: hit.value,
            e: hit.now + (hit.maxAge || 0)
          }).toArray().filter((h) => h);
        }
        dumpLru() {
          return this[LRU_LIST];
        }
        set(key, value, maxAge) {
          maxAge = maxAge || this[MAX_AGE];
          if (maxAge && typeof maxAge !== "number")
            throw new TypeError("maxAge must be a number");
          const now = maxAge ? Date.now() : 0;
          const len = this[LENGTH_CALCULATOR](value, key);
          if (this[CACHE].has(key)) {
            if (len > this[MAX]) {
              del(this, this[CACHE].get(key));
              return false;
            }
            const node = this[CACHE].get(key);
            const item = node.value;
            if (this[DISPOSE]) {
              if (!this[NO_DISPOSE_ON_SET])
                this[DISPOSE](key, item.value);
            }
            item.now = now;
            item.maxAge = maxAge;
            item.value = value;
            this[LENGTH] += len - item.length;
            item.length = len;
            this.get(key);
            trim2(this);
            return true;
          }
          const hit = new Entry(key, value, len, now, maxAge);
          if (hit.length > this[MAX]) {
            if (this[DISPOSE])
              this[DISPOSE](key, value);
            return false;
          }
          this[LENGTH] += hit.length;
          this[LRU_LIST].unshift(hit);
          this[CACHE].set(key, this[LRU_LIST].head);
          trim2(this);
          return true;
        }
        has(key) {
          if (!this[CACHE].has(key))
            return false;
          const hit = this[CACHE].get(key).value;
          return !isStale(this, hit);
        }
        get(key) {
          return get(this, key, true);
        }
        peek(key) {
          return get(this, key, false);
        }
        pop() {
          const node = this[LRU_LIST].tail;
          if (!node)
            return null;
          del(this, node);
          return node.value;
        }
        del(key) {
          del(this, this[CACHE].get(key));
        }
        load(arr) {
          this.reset();
          const now = Date.now();
          for (let l = arr.length - 1; l >= 0; l--) {
            const hit = arr[l];
            const expiresAt = hit.e || 0;
            if (expiresAt === 0)
              this.set(hit.k, hit.v);
            else {
              const maxAge = expiresAt - now;
              if (maxAge > 0) {
                this.set(hit.k, hit.v, maxAge);
              }
            }
          }
        }
        prune() {
          this[CACHE].forEach((value, key) => get(this, key, false));
        }
      };
      var get = (self2, key, doUse) => {
        const node = self2[CACHE].get(key);
        if (node) {
          const hit = node.value;
          if (isStale(self2, hit)) {
            del(self2, node);
            if (!self2[ALLOW_STALE])
              return void 0;
          } else {
            if (doUse) {
              if (self2[UPDATE_AGE_ON_GET])
                node.value.now = Date.now();
              self2[LRU_LIST].unshiftNode(node);
            }
          }
          return hit.value;
        }
      };
      var isStale = (self2, hit) => {
        if (!hit || !hit.maxAge && !self2[MAX_AGE])
          return false;
        const diff = Date.now() - hit.now;
        return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
      };
      var trim2 = (self2) => {
        if (self2[LENGTH] > self2[MAX]) {
          for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
            const prev = walker.prev;
            del(self2, walker);
            walker = prev;
          }
        }
      };
      var del = (self2, node) => {
        if (node) {
          const hit = node.value;
          if (self2[DISPOSE])
            self2[DISPOSE](hit.key, hit.value);
          self2[LENGTH] -= hit.length;
          self2[CACHE].delete(hit.key);
          self2[LRU_LIST].removeNode(node);
        }
      };
      var Entry = class {
        constructor(key, value, length, now, maxAge) {
          this.key = key;
          this.value = value;
          this.length = length;
          this.now = now;
          this.maxAge = maxAge || 0;
        }
      };
      var forEachStep = (self2, fn, node, thisp) => {
        let hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            hit = void 0;
        }
        if (hit)
          fn.call(thisp, hit.value, hit.key, self2);
      };
      module2.exports = LRUCache2;
    }
  });
  var require_range2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/classes/range.js"(exports, module2) {
      var Range = class {
        constructor(range, options) {
          options = parseOptions(options);
          if (range instanceof Range) {
            if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
              return range;
            } else {
              return new Range(range.raw, options);
            }
          }
          if (range instanceof Comparator) {
            this.raw = range.value;
            this.set = [[range]];
            this.format();
            return this;
          }
          this.options = options;
          this.loose = !!options.loose;
          this.includePrerelease = !!options.includePrerelease;
          this.raw = range;
          this.set = range.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
          if (!this.set.length) {
            throw new TypeError(`Invalid SemVer Range: ${range}`);
          }
          if (this.set.length > 1) {
            const first = this.set[0];
            this.set = this.set.filter((c) => !isNullSet(c[0]));
            if (this.set.length === 0) {
              this.set = [first];
            } else if (this.set.length > 1) {
              for (const c of this.set) {
                if (c.length === 1 && isAny(c[0])) {
                  this.set = [c];
                  break;
                }
              }
            }
          }
          this.format();
        }
        format() {
          this.range = this.set.map((comps) => {
            return comps.join(" ").trim();
          }).join("||").trim();
          return this.range;
        }
        toString() {
          return this.range;
        }
        parseRange(range) {
          range = range.trim();
          const memoOpts = Object.keys(this.options).join(",");
          const memoKey = `parseRange:${memoOpts}:${range}`;
          const cached = cache2.get(memoKey);
          if (cached) {
            return cached;
          }
          const loose = this.options.loose;
          const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
          range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
          debug2("hyphen replace", range);
          range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
          debug2("comparator trim", range);
          range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
          range = range.replace(re[t.CARETTRIM], caretTrimReplace);
          range = range.split(/\s+/).join(" ");
          let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
          if (loose) {
            rangeList = rangeList.filter((comp) => {
              debug2("loose invalid filter", comp, this.options);
              return !!comp.match(re[t.COMPARATORLOOSE]);
            });
          }
          debug2("range list", rangeList);
          const rangeMap = /* @__PURE__ */ new Map();
          const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
          for (const comp of comparators) {
            if (isNullSet(comp)) {
              return [comp];
            }
            rangeMap.set(comp.value, comp);
          }
          if (rangeMap.size > 1 && rangeMap.has("")) {
            rangeMap.delete("");
          }
          const result = [...rangeMap.values()];
          cache2.set(memoKey, result);
          return result;
        }
        intersects(range, options) {
          if (!(range instanceof Range)) {
            throw new TypeError("a Range is required");
          }
          return this.set.some((thisComparators) => {
            return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
              return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
                return rangeComparators.every((rangeComparator) => {
                  return thisComparator.intersects(rangeComparator, options);
                });
              });
            });
          });
        }
        // if ANY of the sets match ALL of its comparators, then pass
        test(version2) {
          if (!version2) {
            return false;
          }
          if (typeof version2 === "string") {
            try {
              version2 = new SemVer(version2, this.options);
            } catch (er) {
              return false;
            }
          }
          for (let i = 0; i < this.set.length; i++) {
            if (testSet(this.set[i], version2, this.options)) {
              return true;
            }
          }
          return false;
        }
      };
      module2.exports = Range;
      var LRU = require_lru_cache2();
      var cache2 = new LRU({ max: 1e3 });
      var parseOptions = require_parse_options2();
      var Comparator = require_comparator2();
      var debug2 = require_debug2();
      var SemVer = require_semver3();
      var {
        re,
        t,
        comparatorTrimReplace,
        tildeTrimReplace,
        caretTrimReplace
      } = require_re2();
      var isNullSet = (c) => c.value === "<0.0.0-0";
      var isAny = (c) => c.value === "";
      var isSatisfiable = (comparators, options) => {
        let result = true;
        const remainingComparators = comparators.slice();
        let testComparator = remainingComparators.pop();
        while (result && remainingComparators.length) {
          result = remainingComparators.every((otherComparator) => {
            return testComparator.intersects(otherComparator, options);
          });
          testComparator = remainingComparators.pop();
        }
        return result;
      };
      var parseComparator = (comp, options) => {
        debug2("comp", comp, options);
        comp = replaceCarets(comp, options);
        debug2("caret", comp);
        comp = replaceTildes(comp, options);
        debug2("tildes", comp);
        comp = replaceXRanges(comp, options);
        debug2("xrange", comp);
        comp = replaceStars(comp, options);
        debug2("stars", comp);
        return comp;
      };
      var isX = (id) => !id || id.toLowerCase() === "x" || id === "*";
      var replaceTildes = (comp, options) => comp.trim().split(/\s+/).map((c) => {
        return replaceTilde(c, options);
      }).join(" ");
      var replaceTilde = (comp, options) => {
        const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
        return comp.replace(r, (_, M, m, p, pr) => {
          debug2("tilde", comp, _, M, m, p, pr);
          let ret3;
          if (isX(M)) {
            ret3 = "";
          } else if (isX(m)) {
            ret3 = `>=${M}.0.0 <${+M + 1}.0.0-0`;
          } else if (isX(p)) {
            ret3 = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
          } else if (pr) {
            debug2("replaceTilde pr", pr);
            ret3 = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
          } else {
            ret3 = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
          }
          debug2("tilde return", ret3);
          return ret3;
        });
      };
      var replaceCarets = (comp, options) => comp.trim().split(/\s+/).map((c) => {
        return replaceCaret(c, options);
      }).join(" ");
      var replaceCaret = (comp, options) => {
        debug2("caret", comp, options);
        const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
        const z = options.includePrerelease ? "-0" : "";
        return comp.replace(r, (_, M, m, p, pr) => {
          debug2("caret", comp, _, M, m, p, pr);
          let ret3;
          if (isX(M)) {
            ret3 = "";
          } else if (isX(m)) {
            ret3 = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
          } else if (isX(p)) {
            if (M === "0") {
              ret3 = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
            } else {
              ret3 = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
            }
          } else if (pr) {
            debug2("replaceCaret pr", pr);
            if (M === "0") {
              if (m === "0") {
                ret3 = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
              } else {
                ret3 = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
              }
            } else {
              ret3 = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
            }
          } else {
            debug2("no pr");
            if (M === "0") {
              if (m === "0") {
                ret3 = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
              } else {
                ret3 = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
              }
            } else {
              ret3 = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
            }
          }
          debug2("caret return", ret3);
          return ret3;
        });
      };
      var replaceXRanges = (comp, options) => {
        debug2("replaceXRanges", comp, options);
        return comp.split(/\s+/).map((c) => {
          return replaceXRange(c, options);
        }).join(" ");
      };
      var replaceXRange = (comp, options) => {
        comp = comp.trim();
        const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
        return comp.replace(r, (ret3, gtlt, M, m, p, pr) => {
          debug2("xRange", comp, ret3, gtlt, M, m, p, pr);
          const xM = isX(M);
          const xm = xM || isX(m);
          const xp = xm || isX(p);
          const anyX = xp;
          if (gtlt === "=" && anyX) {
            gtlt = "";
          }
          pr = options.includePrerelease ? "-0" : "";
          if (xM) {
            if (gtlt === ">" || gtlt === "<") {
              ret3 = "<0.0.0-0";
            } else {
              ret3 = "*";
            }
          } else if (gtlt && anyX) {
            if (xm) {
              m = 0;
            }
            p = 0;
            if (gtlt === ">") {
              gtlt = ">=";
              if (xm) {
                M = +M + 1;
                m = 0;
                p = 0;
              } else {
                m = +m + 1;
                p = 0;
              }
            } else if (gtlt === "<=") {
              gtlt = "<";
              if (xm) {
                M = +M + 1;
              } else {
                m = +m + 1;
              }
            }
            if (gtlt === "<") {
              pr = "-0";
            }
            ret3 = `${gtlt + M}.${m}.${p}${pr}`;
          } else if (xm) {
            ret3 = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
          } else if (xp) {
            ret3 = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
          }
          debug2("xRange return", ret3);
          return ret3;
        });
      };
      var replaceStars = (comp, options) => {
        debug2("replaceStars", comp, options);
        return comp.trim().replace(re[t.STAR], "");
      };
      var replaceGTE0 = (comp, options) => {
        debug2("replaceGTE0", comp, options);
        return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
      };
      var hyphenReplace = (incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) => {
        if (isX(fM)) {
          from = "";
        } else if (isX(fm)) {
          from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
        } else if (isX(fp)) {
          from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
        } else if (fpr) {
          from = `>=${from}`;
        } else {
          from = `>=${from}${incPr ? "-0" : ""}`;
        }
        if (isX(tM)) {
          to = "";
        } else if (isX(tm)) {
          to = `<${+tM + 1}.0.0-0`;
        } else if (isX(tp)) {
          to = `<${tM}.${+tm + 1}.0-0`;
        } else if (tpr) {
          to = `<=${tM}.${tm}.${tp}-${tpr}`;
        } else if (incPr) {
          to = `<${tM}.${tm}.${+tp + 1}-0`;
        } else {
          to = `<=${to}`;
        }
        return `${from} ${to}`.trim();
      };
      var testSet = (set2, version2, options) => {
        for (let i = 0; i < set2.length; i++) {
          if (!set2[i].test(version2)) {
            return false;
          }
        }
        if (version2.prerelease.length && !options.includePrerelease) {
          for (let i = 0; i < set2.length; i++) {
            debug2(set2[i].semver);
            if (set2[i].semver === Comparator.ANY) {
              continue;
            }
            if (set2[i].semver.prerelease.length > 0) {
              const allowed = set2[i].semver;
              if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
                return true;
              }
            }
          }
          return false;
        }
        return true;
      };
    }
  });
  var require_comparator2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/classes/comparator.js"(exports, module2) {
      var ANY = Symbol("SemVer ANY");
      var Comparator = class {
        static get ANY() {
          return ANY;
        }
        constructor(comp, options) {
          options = parseOptions(options);
          if (comp instanceof Comparator) {
            if (comp.loose === !!options.loose) {
              return comp;
            } else {
              comp = comp.value;
            }
          }
          debug2("comparator", comp, options);
          this.options = options;
          this.loose = !!options.loose;
          this.parse(comp);
          if (this.semver === ANY) {
            this.value = "";
          } else {
            this.value = this.operator + this.semver.version;
          }
          debug2("comp", this);
        }
        parse(comp) {
          const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
          const m = comp.match(r);
          if (!m) {
            throw new TypeError(`Invalid comparator: ${comp}`);
          }
          this.operator = m[1] !== void 0 ? m[1] : "";
          if (this.operator === "=") {
            this.operator = "";
          }
          if (!m[2]) {
            this.semver = ANY;
          } else {
            this.semver = new SemVer(m[2], this.options.loose);
          }
        }
        toString() {
          return this.value;
        }
        test(version2) {
          debug2("Comparator.test", version2, this.options.loose);
          if (this.semver === ANY || version2 === ANY) {
            return true;
          }
          if (typeof version2 === "string") {
            try {
              version2 = new SemVer(version2, this.options);
            } catch (er) {
              return false;
            }
          }
          return cmp(version2, this.operator, this.semver, this.options);
        }
        intersects(comp, options) {
          if (!(comp instanceof Comparator)) {
            throw new TypeError("a Comparator is required");
          }
          if (!options || typeof options !== "object") {
            options = {
              loose: !!options,
              includePrerelease: false
            };
          }
          if (this.operator === "") {
            if (this.value === "") {
              return true;
            }
            return new Range(comp.value, options).test(this.value);
          } else if (comp.operator === "") {
            if (comp.value === "") {
              return true;
            }
            return new Range(this.value, options).test(comp.semver);
          }
          const sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
          const sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
          const sameSemVer = this.semver.version === comp.semver.version;
          const differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
          const oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && (this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<");
          const oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && (this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">");
          return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
        }
      };
      module2.exports = Comparator;
      var parseOptions = require_parse_options2();
      var { re, t } = require_re2();
      var cmp = require_cmp2();
      var debug2 = require_debug2();
      var SemVer = require_semver3();
      var Range = require_range2();
    }
  });
  var require_satisfies2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/functions/satisfies.js"(exports, module2) {
      var Range = require_range2();
      var satisfies = (version2, range, options) => {
        try {
          range = new Range(range, options);
        } catch (er) {
          return false;
        }
        return range.test(version2);
      };
      module2.exports = satisfies;
    }
  });
  var require_to_comparators2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/to-comparators.js"(exports, module2) {
      var Range = require_range2();
      var toComparators = (range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" "));
      module2.exports = toComparators;
    }
  });
  var require_max_satisfying2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/max-satisfying.js"(exports, module2) {
      var SemVer = require_semver3();
      var Range = require_range2();
      var maxSatisfying = (versions22, range, options) => {
        let max2 = null;
        let maxSV = null;
        let rangeObj = null;
        try {
          rangeObj = new Range(range, options);
        } catch (er) {
          return null;
        }
        versions22.forEach((v) => {
          if (rangeObj.test(v)) {
            if (!max2 || maxSV.compare(v) === -1) {
              max2 = v;
              maxSV = new SemVer(max2, options);
            }
          }
        });
        return max2;
      };
      module2.exports = maxSatisfying;
    }
  });
  var require_min_satisfying2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/min-satisfying.js"(exports, module2) {
      var SemVer = require_semver3();
      var Range = require_range2();
      var minSatisfying = (versions22, range, options) => {
        let min = null;
        let minSV = null;
        let rangeObj = null;
        try {
          rangeObj = new Range(range, options);
        } catch (er) {
          return null;
        }
        versions22.forEach((v) => {
          if (rangeObj.test(v)) {
            if (!min || minSV.compare(v) === 1) {
              min = v;
              minSV = new SemVer(min, options);
            }
          }
        });
        return min;
      };
      module2.exports = minSatisfying;
    }
  });
  var require_min_version2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/min-version.js"(exports, module2) {
      var SemVer = require_semver3();
      var Range = require_range2();
      var gt = require_gt2();
      var minVersion = (range, loose) => {
        range = new Range(range, loose);
        let minver = new SemVer("0.0.0");
        if (range.test(minver)) {
          return minver;
        }
        minver = new SemVer("0.0.0-0");
        if (range.test(minver)) {
          return minver;
        }
        minver = null;
        for (let i = 0; i < range.set.length; ++i) {
          const comparators = range.set[i];
          let setMin = null;
          comparators.forEach((comparator) => {
            const compver = new SemVer(comparator.semver.version);
            switch (comparator.operator) {
              case ">":
                if (compver.prerelease.length === 0) {
                  compver.patch++;
                } else {
                  compver.prerelease.push(0);
                }
                compver.raw = compver.format();
              case "":
              case ">=":
                if (!setMin || gt(compver, setMin)) {
                  setMin = compver;
                }
                break;
              case "<":
              case "<=":
                break;
              default:
                throw new Error(`Unexpected operation: ${comparator.operator}`);
            }
          });
          if (setMin && (!minver || gt(minver, setMin))) {
            minver = setMin;
          }
        }
        if (minver && range.test(minver)) {
          return minver;
        }
        return null;
      };
      module2.exports = minVersion;
    }
  });
  var require_valid22 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/valid.js"(exports, module2) {
      var Range = require_range2();
      var validRange = (range, options) => {
        try {
          return new Range(range, options).range || "*";
        } catch (er) {
          return null;
        }
      };
      module2.exports = validRange;
    }
  });
  var require_outside2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/outside.js"(exports, module2) {
      var SemVer = require_semver3();
      var Comparator = require_comparator2();
      var { ANY } = Comparator;
      var Range = require_range2();
      var satisfies = require_satisfies2();
      var gt = require_gt2();
      var lt = require_lt2();
      var lte = require_lte2();
      var gte = require_gte2();
      var outside = (version2, range, hilo, options) => {
        version2 = new SemVer(version2, options);
        range = new Range(range, options);
        let gtfn, ltefn, ltfn, comp, ecomp;
        switch (hilo) {
          case ">":
            gtfn = gt;
            ltefn = lte;
            ltfn = lt;
            comp = ">";
            ecomp = ">=";
            break;
          case "<":
            gtfn = lt;
            ltefn = gte;
            ltfn = gt;
            comp = "<";
            ecomp = "<=";
            break;
          default:
            throw new TypeError('Must provide a hilo val of "<" or ">"');
        }
        if (satisfies(version2, range, options)) {
          return false;
        }
        for (let i = 0; i < range.set.length; ++i) {
          const comparators = range.set[i];
          let high = null;
          let low = null;
          comparators.forEach((comparator) => {
            if (comparator.semver === ANY) {
              comparator = new Comparator(">=0.0.0");
            }
            high = high || comparator;
            low = low || comparator;
            if (gtfn(comparator.semver, high.semver, options)) {
              high = comparator;
            } else if (ltfn(comparator.semver, low.semver, options)) {
              low = comparator;
            }
          });
          if (high.operator === comp || high.operator === ecomp) {
            return false;
          }
          if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
            return false;
          } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
            return false;
          }
        }
        return true;
      };
      module2.exports = outside;
    }
  });
  var require_gtr2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/gtr.js"(exports, module2) {
      var outside = require_outside2();
      var gtr = (version2, range, options) => outside(version2, range, ">", options);
      module2.exports = gtr;
    }
  });
  var require_ltr2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/ltr.js"(exports, module2) {
      var outside = require_outside2();
      var ltr = (version2, range, options) => outside(version2, range, "<", options);
      module2.exports = ltr;
    }
  });
  var require_intersects2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/intersects.js"(exports, module2) {
      var Range = require_range2();
      var intersects = (r1, r2, options) => {
        r1 = new Range(r1, options);
        r2 = new Range(r2, options);
        return r1.intersects(r2);
      };
      module2.exports = intersects;
    }
  });
  var require_simplify2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/simplify.js"(exports, module2) {
      var satisfies = require_satisfies2();
      var compare = require_compare2();
      module2.exports = (versions22, range, options) => {
        const set2 = [];
        let first = null;
        let prev = null;
        const v = versions22.sort((a, b) => compare(a, b, options));
        for (const version2 of v) {
          const included = satisfies(version2, range, options);
          if (included) {
            prev = version2;
            if (!first) {
              first = version2;
            }
          } else {
            if (prev) {
              set2.push([first, prev]);
            }
            prev = null;
            first = null;
          }
        }
        if (first) {
          set2.push([first, null]);
        }
        const ranges = [];
        for (const [min, max2] of set2) {
          if (min === max2) {
            ranges.push(min);
          } else if (!max2 && min === v[0]) {
            ranges.push("*");
          } else if (!max2) {
            ranges.push(`>=${min}`);
          } else if (min === v[0]) {
            ranges.push(`<=${max2}`);
          } else {
            ranges.push(`${min} - ${max2}`);
          }
        }
        const simplified = ranges.join(" || ");
        const original = typeof range.raw === "string" ? range.raw : String(range);
        return simplified.length < original.length ? simplified : range;
      };
    }
  });
  var require_subset2 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/ranges/subset.js"(exports, module2) {
      var Range = require_range2();
      var Comparator = require_comparator2();
      var { ANY } = Comparator;
      var satisfies = require_satisfies2();
      var compare = require_compare2();
      var subset = (sub, dom, options = {}) => {
        if (sub === dom) {
          return true;
        }
        sub = new Range(sub, options);
        dom = new Range(dom, options);
        let sawNonNull = false;
        OUTER:
          for (const simpleSub of sub.set) {
            for (const simpleDom of dom.set) {
              const isSub = simpleSubset(simpleSub, simpleDom, options);
              sawNonNull = sawNonNull || isSub !== null;
              if (isSub) {
                continue OUTER;
              }
            }
            if (sawNonNull) {
              return false;
            }
          }
        return true;
      };
      var simpleSubset = (sub, dom, options) => {
        if (sub === dom) {
          return true;
        }
        if (sub.length === 1 && sub[0].semver === ANY) {
          if (dom.length === 1 && dom[0].semver === ANY) {
            return true;
          } else if (options.includePrerelease) {
            sub = [new Comparator(">=0.0.0-0")];
          } else {
            sub = [new Comparator(">=0.0.0")];
          }
        }
        if (dom.length === 1 && dom[0].semver === ANY) {
          if (options.includePrerelease) {
            return true;
          } else {
            dom = [new Comparator(">=0.0.0")];
          }
        }
        const eqSet = /* @__PURE__ */ new Set();
        let gt, lt;
        for (const c of sub) {
          if (c.operator === ">" || c.operator === ">=") {
            gt = higherGT(gt, c, options);
          } else if (c.operator === "<" || c.operator === "<=") {
            lt = lowerLT(lt, c, options);
          } else {
            eqSet.add(c.semver);
          }
        }
        if (eqSet.size > 1) {
          return null;
        }
        let gtltComp;
        if (gt && lt) {
          gtltComp = compare(gt.semver, lt.semver, options);
          if (gtltComp > 0) {
            return null;
          } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
            return null;
          }
        }
        for (const eq of eqSet) {
          if (gt && !satisfies(eq, String(gt), options)) {
            return null;
          }
          if (lt && !satisfies(eq, String(lt), options)) {
            return null;
          }
          for (const c of dom) {
            if (!satisfies(eq, String(c), options)) {
              return false;
            }
          }
          return true;
        }
        let higher, lower;
        let hasDomLT, hasDomGT;
        let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
        let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
        if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
          needDomLTPre = false;
        }
        for (const c of dom) {
          hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
          hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
          if (gt) {
            if (needDomGTPre) {
              if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
                needDomGTPre = false;
              }
            }
            if (c.operator === ">" || c.operator === ">=") {
              higher = higherGT(gt, c, options);
              if (higher === c && higher !== gt) {
                return false;
              }
            } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
              return false;
            }
          }
          if (lt) {
            if (needDomLTPre) {
              if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
                needDomLTPre = false;
              }
            }
            if (c.operator === "<" || c.operator === "<=") {
              lower = lowerLT(lt, c, options);
              if (lower === c && lower !== lt) {
                return false;
              }
            } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
              return false;
            }
          }
          if (!c.operator && (lt || gt) && gtltComp !== 0) {
            return false;
          }
        }
        if (gt && hasDomLT && !lt && gtltComp !== 0) {
          return false;
        }
        if (lt && hasDomGT && !gt && gtltComp !== 0) {
          return false;
        }
        if (needDomGTPre || needDomLTPre) {
          return false;
        }
        return true;
      };
      var higherGT = (a, b, options) => {
        if (!a) {
          return b;
        }
        const comp = compare(a.semver, b.semver, options);
        return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
      };
      var lowerLT = (a, b, options) => {
        if (!a) {
          return b;
        }
        const comp = compare(a.semver, b.semver, options);
        return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
      };
      module2.exports = subset;
    }
  });
  var require_semver22 = __commonJS2({
    "../../node_modules/.pnpm/semver@7.3.8/node_modules/semver/index.js"(exports, module2) {
      var internalRe = require_re2();
      var constants = require_constants2();
      var SemVer = require_semver3();
      var identifiers = require_identifiers2();
      var parse3 = require_parse2();
      var valid = require_valid3();
      var clean = require_clean2();
      var inc = require_inc2();
      var diff = require_diff2();
      var major = require_major2();
      var minor = require_minor2();
      var patch = require_patch2();
      var prerelease = require_prerelease2();
      var compare = require_compare2();
      var rcompare = require_rcompare2();
      var compareLoose = require_compare_loose2();
      var compareBuild = require_compare_build2();
      var sort = require_sort2();
      var rsort = require_rsort2();
      var gt = require_gt2();
      var lt = require_lt2();
      var eq = require_eq2();
      var neq = require_neq2();
      var gte = require_gte2();
      var lte = require_lte2();
      var cmp = require_cmp2();
      var coerce = require_coerce2();
      var Comparator = require_comparator2();
      var Range = require_range2();
      var satisfies = require_satisfies2();
      var toComparators = require_to_comparators2();
      var maxSatisfying = require_max_satisfying2();
      var minSatisfying = require_min_satisfying2();
      var minVersion = require_min_version2();
      var validRange = require_valid22();
      var outside = require_outside2();
      var gtr = require_gtr2();
      var ltr = require_ltr2();
      var intersects = require_intersects2();
      var simplifyRange = require_simplify2();
      var subset = require_subset2();
      module2.exports = {
        parse: parse3,
        valid,
        clean,
        inc,
        diff,
        major,
        minor,
        patch,
        prerelease,
        compare,
        rcompare,
        compareLoose,
        compareBuild,
        sort,
        rsort,
        gt,
        lt,
        eq,
        neq,
        gte,
        lte,
        cmp,
        coerce,
        Comparator,
        Range,
        satisfies,
        toComparators,
        maxSatisfying,
        minSatisfying,
        minVersion,
        validRange,
        outside,
        gtr,
        ltr,
        intersects,
        simplifyRange,
        subset,
        SemVer,
        re: internalRe.re,
        src: internalRe.src,
        tokens: internalRe.t,
        SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
        compareIdentifiers: identifiers.compareIdentifiers,
        rcompareIdentifiers: identifiers.rcompareIdentifiers
      };
    }
  });
  var capitalizeString = (str) => {
    if (!str.length) {
      return str;
    }
    return str[0].toUpperCase() + str.slice(1);
  };
  var chunkAndPadBytes = (bytes3, chunkSize) => {
    const chunks = [];
    for (let offset = 0; offset < bytes3.length; offset += chunkSize) {
      const chunk = new Uint8Array(chunkSize);
      chunk.set(bytes3.slice(offset, offset + chunkSize));
      chunks.push(chunk);
    }
    const lastChunk = chunks[chunks.length - 1];
    const remainingBytes = bytes3.length % chunkSize;
    const paddedChunkLength = remainingBytes + (8 - remainingBytes % 8) % 8;
    const newChunk = lastChunk.slice(0, paddedChunkLength);
    chunks[chunks.length - 1] = newChunk;
    return chunks;
  };
  var concatBytes = (arrays) => {
    const byteArrays = arrays.map((array2) => {
      if (array2 instanceof Uint8Array) {
        return array2;
      }
      return Uint8Array.from(array2);
    });
    const totalSize = byteArrays.reduce((accum, item) => accum + item.length, 0);
    const concatenated = new Uint8Array(totalSize);
    byteArrays.reduce((offset, object2) => {
      concatenated.set(object2, offset);
      return offset + object2.length;
    }, 0);
    return concatenated;
  };
  var concat2 = (arrays) => {
    const bytes3 = arrays.map((v) => getBytesCopy(v));
    return concatBytes(bytes3);
  };
  var import_semver2 = __toESM2(require_semver22(), 1);
  function getBuiltinVersions2() {
    return {
      FORC: "0.46.1",
      FUEL_CORE: "0.20.8",
      FUELS: "0.69.1"
    };
  }
  var versions2 = getBuiltinVersions2();
  var __defProp22 = Object.defineProperty;
  var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp22(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField3 = (obj, key, value) => {
    __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var ErrorCode2 = /* @__PURE__ */ ((ErrorCode22) => {
    ErrorCode22["NO_ABIS_FOUND"] = "no-abis-found";
    ErrorCode22["ABI_TYPES_AND_VALUES_MISMATCH"] = "abi-types-and-values-mismatch";
    ErrorCode22["ABI_MAIN_METHOD_MISSING"] = "abi-main-method-missing";
    ErrorCode22["INVALID_COMPONENT"] = "invalid-component";
    ErrorCode22["FRAGMENT_NOT_FOUND"] = "fragment-not-found";
    ErrorCode22["CONFIGURABLE_NOT_FOUND"] = "configurable-not-found";
    ErrorCode22["TYPE_NOT_FOUND"] = "type-not-found";
    ErrorCode22["TYPE_NOT_SUPPORTED"] = "type-not-supported";
    ErrorCode22["INVALID_DECODE_VALUE"] = "invalid-decode-value";
    ErrorCode22["JSON_ABI_ERROR"] = "json-abi-error";
    ErrorCode22["TYPE_ID_NOT_FOUND"] = "type-id-not-found";
    ErrorCode22["BIN_FILE_NOT_FOUND"] = "bin-file-not-found";
    ErrorCode22["CODER_NOT_FOUND"] = "coder-not-found";
    ErrorCode22["INVALID_DATA"] = "invalid-data";
    ErrorCode22["FUNCTION_NOT_FOUND"] = "function-not-found";
    ErrorCode22["INVALID_BECH32_ADDRESS"] = "invalid-bech32-address";
    ErrorCode22["INVALID_EVM_ADDRESS"] = "invalid-evm-address";
    ErrorCode22["INVALID_B256_ADDRESS"] = "invalid-b256-address";
    ErrorCode22["INVALID_URL"] = "invalid-url";
    ErrorCode22["CHAIN_INFO_CACHE_EMPTY"] = "chain-info-cache-empty";
    ErrorCode22["NODE_INFO_CACHE_EMPTY"] = "node-info-cache-empty";
    ErrorCode22["MISSING_PROVIDER"] = "missing-provider";
    ErrorCode22["INVALID_PUBLIC_KEY"] = "invalid-public-key";
    ErrorCode22["INSUFFICIENT_BALANCE"] = "insufficient-balance";
    ErrorCode22["WALLET_MANAGER_ERROR"] = "wallet-manager-error";
    ErrorCode22["HD_WALLET_ERROR"] = "hd-wallet-error";
    ErrorCode22["PARSE_FAILED"] = "parse-failed";
    ErrorCode22["ENCODE_ERROR"] = "encode-error";
    ErrorCode22["DECODE_ERROR"] = "decode-error";
    ErrorCode22["INVALID_CREDENTIALS"] = "invalid-credentials";
    ErrorCode22["ENV_DEPENDENCY_MISSING"] = "env-dependency-missing";
    ErrorCode22["INVALID_TTL"] = "invalid-ttl";
    ErrorCode22["INVALID_INPUT_PARAMETERS"] = "invalid-input-parameters";
    ErrorCode22["NOT_IMPLEMENTED"] = "not-implemented";
    ErrorCode22["NOT_SUPPORTED"] = "not-supported";
    ErrorCode22["CONVERTING_FAILED"] = "converting-error";
    ErrorCode22["ELEMENT_NOT_FOUND"] = "element-not-found";
    ErrorCode22["MISSING_REQUIRED_PARAMETER"] = "missing-required-parameter";
    ErrorCode22["UNEXPECTED_HEX_VALUE"] = "unexpected-hex-value";
    ErrorCode22["GAS_PRICE_TOO_LOW"] = "gas-price-too-low";
    ErrorCode22["GAS_LIMIT_TOO_LOW"] = "gas-limit-too-low";
    ErrorCode22["TRANSACTION_NOT_FOUND"] = "transaction-not-found";
    ErrorCode22["TRANSACTION_FAILED"] = "transaction-failed";
    ErrorCode22["INVALID_CONFIGURABLE_CONSTANTS"] = "invalid-configurable-constants";
    ErrorCode22["INVALID_TRANSACTION_INPUT"] = "invalid-transaction-input";
    ErrorCode22["INVALID_TRANSACTION_OUTPUT"] = "invalid-transaction-output";
    ErrorCode22["INVALID_TRANSACTION_STATUS"] = "invalid-transaction-status";
    ErrorCode22["INVALID_TRANSACTION_TYPE"] = "invalid-transaction-type";
    ErrorCode22["TRANSACTION_ERROR"] = "transaction-error";
    ErrorCode22["INVALID_RECEIPT_TYPE"] = "invalid-receipt-type";
    ErrorCode22["INVALID_WORD_LIST"] = "invalid-word-list";
    ErrorCode22["INVALID_MNEMONIC"] = "invalid-mnemonic";
    ErrorCode22["INVALID_ENTROPY"] = "invalid-entropy";
    ErrorCode22["INVALID_SEED"] = "invalid-seed";
    ErrorCode22["INVALID_CHECKSUM"] = "invalid-checksum";
    ErrorCode22["INVALID_PASSWORD"] = "invalid-password";
    ErrorCode22["ACCOUNT_REQUIRED"] = "account-required";
    ErrorCode22["LATEST_BLOCK_UNAVAILABLE"] = "latest-block-unavailable";
    ErrorCode22["ERROR_BUILDING_BLOCK_EXPLORER_URL"] = "error-building-block-explorer-url";
    ErrorCode22["UNSUPPORTED_FUEL_CLIENT_VERSION"] = "unsupported-fuel-client-version";
    ErrorCode22["VITEPRESS_PLUGIN_ERROR"] = "vitepress-plugin-error";
    ErrorCode22["INVALID_MULTICALL"] = "invalid-multicall";
    ErrorCode22["SCRIPT_REVERTED"] = "script-reverted";
    ErrorCode22["SCRIPT_RETURN_INVALID_TYPE"] = "script-return-invalid-type";
    return ErrorCode22;
  })(ErrorCode2 || {});
  var _FuelError2 = class extends Error {
    VERSIONS = versions2;
    static parse(e) {
      const error2 = e;
      if (error2.code === void 0) {
        throw new _FuelError2(
          "parse-failed",
          "Failed to parse the error object. The required 'code' property is missing."
        );
      }
      const enumValues = Object.values(ErrorCode2);
      const codeIsKnown = enumValues.includes(error2.code);
      if (!codeIsKnown) {
        throw new _FuelError2(
          "parse-failed",
          `Unknown error code: ${error2.code}. Accepted codes: ${enumValues.join(", ")}.`
        );
      }
      return new _FuelError2(error2.code, error2.message);
    }
    code;
    constructor(code, message) {
      super(message);
      this.code = code;
      this.name = "FuelError";
    }
    toObject() {
      const { code, name, message, VERSIONS } = this;
      return { code, name, message, VERSIONS };
    }
  };
  var FuelError2 = _FuelError2;
  __publicField3(FuelError2, "CODES", ErrorCode2);
  var normalizeString = (str) => {
    const transformations = [
      (s) => s.replace(/\s+/g, "-"),
      // spaces to -
      (s) => s.replace(/\./g, "-"),
      // dots to -
      (s) => s.replace(/_/g, "-"),
      // underscore to -
      (s) => s.replace(/-[a-z]/g, (match3) => match3.slice(-1).toUpperCase()),
      // delete '-' and capitalize the letter after them
      (s) => s.replace(/-/g, ""),
      // delete any '-' left
      (s) => s.replace(/^\d+/, ""),
      // removes leading digits
      (s) => s[0].toUpperCase() + s.slice(1)
      // capitalize first letter
    ];
    const output3 = transformations.reduce((s, t) => t(s), str);
    if (output3 === "") {
      const errMsg = `The provided string '${str}' results in an empty output after`.concat(
        ` normalization, therefore, it can't normalize string.`
      );
      throw new FuelError2(ErrorCode2.PARSE_FAILED, errMsg);
    }
    return output3;
  };

  // ../abi-typegen/dist/cli.mjs
  var import_path9 = __require2("path");
  var import_handlebars = __toESM(require_lib(), 1);

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_isPlaceholder.js
  function _isPlaceholder(a) {
    return a != null && typeof a === "object" && a["@@functional/placeholder"] === true;
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_curry1.js
  function _curry1(fn) {
    return function f1(a) {
      if (arguments.length === 0 || _isPlaceholder(a)) {
        return f1;
      } else {
        return fn.apply(this, arguments);
      }
    };
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_curry2.js
  function _curry2(fn) {
    return function f2(a, b) {
      switch (arguments.length) {
        case 0:
          return f2;
        case 1:
          return _isPlaceholder(a) ? f2 : _curry1(function(_b) {
            return fn(a, _b);
          });
        default:
          return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function(_a) {
            return fn(_a, b);
          }) : _isPlaceholder(b) ? _curry1(function(_b) {
            return fn(a, _b);
          }) : fn(a, b);
      }
    };
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_isArray.js
  var isArray_default = Array.isArray || function _isArray(val) {
    return val != null && val.length >= 0 && Object.prototype.toString.call(val) === "[object Array]";
  };

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_isTransformer.js
  function _isTransformer(obj) {
    return obj != null && typeof obj["@@transducer/step"] === "function";
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_dispatchable.js
  function _dispatchable(methodNames, transducerCreator, fn) {
    return function() {
      if (arguments.length === 0) {
        return fn();
      }
      var obj = arguments[arguments.length - 1];
      if (!isArray_default(obj)) {
        var idx = 0;
        while (idx < methodNames.length) {
          if (typeof obj[methodNames[idx]] === "function") {
            return obj[methodNames[idx]].apply(obj, Array.prototype.slice.call(arguments, 0, -1));
          }
          idx += 1;
        }
        if (_isTransformer(obj)) {
          var transducer = transducerCreator.apply(null, Array.prototype.slice.call(arguments, 0, -1));
          return transducer(obj);
        }
      }
      return fn.apply(this, arguments);
    };
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_xfBase.js
  var xfBase_default = {
    init: function() {
      return this.xf["@@transducer/init"]();
    },
    result: function(result) {
      return this.xf["@@transducer/result"](result);
    }
  };

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_arrayFromIterator.js
  function _arrayFromIterator(iter) {
    var list = [];
    var next;
    while (!(next = iter.next()).done) {
      list.push(next.value);
    }
    return list;
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_includesWith.js
  function _includesWith(pred, x, list) {
    var idx = 0;
    var len = list.length;
    while (idx < len) {
      if (pred(x, list[idx])) {
        return true;
      }
      idx += 1;
    }
    return false;
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_functionName.js
  function _functionName(f2) {
    var match3 = String(f2).match(/^function (\w*)/);
    return match3 == null ? "" : match3[1];
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_has.js
  function _has(prop, obj) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_objectIs.js
  function _objectIs(a, b) {
    if (a === b) {
      return a !== 0 || 1 / a === 1 / b;
    } else {
      return a !== a && b !== b;
    }
  }
  var objectIs_default = typeof Object.is === "function" ? Object.is : _objectIs;

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_isArguments.js
  var toString = Object.prototype.toString;
  var _isArguments = /* @__PURE__ */ function() {
    return toString.call(arguments) === "[object Arguments]" ? function _isArguments2(x) {
      return toString.call(x) === "[object Arguments]";
    } : function _isArguments2(x) {
      return _has("callee", x);
    };
  }();
  var isArguments_default = _isArguments;

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/keys.js
  var hasEnumBug = !/* @__PURE__ */ {
    toString: null
  }.propertyIsEnumerable("toString");
  var nonEnumerableProps = ["constructor", "valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];
  var hasArgsEnumBug = /* @__PURE__ */ function() {
    "use strict";
    return arguments.propertyIsEnumerable("length");
  }();
  var contains = function contains2(list, item) {
    var idx = 0;
    while (idx < list.length) {
      if (list[idx] === item) {
        return true;
      }
      idx += 1;
    }
    return false;
  };
  var keys = typeof Object.keys === "function" && !hasArgsEnumBug ? /* @__PURE__ */ _curry1(function keys2(obj) {
    return Object(obj) !== obj ? [] : Object.keys(obj);
  }) : /* @__PURE__ */ _curry1(function keys3(obj) {
    if (Object(obj) !== obj) {
      return [];
    }
    var prop, nIdx;
    var ks = [];
    var checkArgsLength = hasArgsEnumBug && isArguments_default(obj);
    for (prop in obj) {
      if (_has(prop, obj) && (!checkArgsLength || prop !== "length")) {
        ks[ks.length] = prop;
      }
    }
    if (hasEnumBug) {
      nIdx = nonEnumerableProps.length - 1;
      while (nIdx >= 0) {
        prop = nonEnumerableProps[nIdx];
        if (_has(prop, obj) && !contains(ks, prop)) {
          ks[ks.length] = prop;
        }
        nIdx -= 1;
      }
    }
    return ks;
  });
  var keys_default = keys;

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/type.js
  var type = /* @__PURE__ */ _curry1(function type2(val) {
    return val === null ? "Null" : val === void 0 ? "Undefined" : Object.prototype.toString.call(val).slice(8, -1);
  });
  var type_default = type;

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_equals.js
  function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
    var a = _arrayFromIterator(aIterator);
    var b = _arrayFromIterator(bIterator);
    function eq(_a, _b) {
      return _equals(_a, _b, stackA.slice(), stackB.slice());
    }
    return !_includesWith(function(b2, aItem) {
      return !_includesWith(eq, aItem, b2);
    }, b, a);
  }
  function _equals(a, b, stackA, stackB) {
    if (objectIs_default(a, b)) {
      return true;
    }
    var typeA = type_default(a);
    if (typeA !== type_default(b)) {
      return false;
    }
    if (typeof a["fantasy-land/equals"] === "function" || typeof b["fantasy-land/equals"] === "function") {
      return typeof a["fantasy-land/equals"] === "function" && a["fantasy-land/equals"](b) && typeof b["fantasy-land/equals"] === "function" && b["fantasy-land/equals"](a);
    }
    if (typeof a.equals === "function" || typeof b.equals === "function") {
      return typeof a.equals === "function" && a.equals(b) && typeof b.equals === "function" && b.equals(a);
    }
    switch (typeA) {
      case "Arguments":
      case "Array":
      case "Object":
        if (typeof a.constructor === "function" && _functionName(a.constructor) === "Promise") {
          return a === b;
        }
        break;
      case "Boolean":
      case "Number":
      case "String":
        if (!(typeof a === typeof b && objectIs_default(a.valueOf(), b.valueOf()))) {
          return false;
        }
        break;
      case "Date":
        if (!objectIs_default(a.valueOf(), b.valueOf())) {
          return false;
        }
        break;
      case "Error":
        return a.name === b.name && a.message === b.message;
      case "RegExp":
        if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
          return false;
        }
        break;
    }
    var idx = stackA.length - 1;
    while (idx >= 0) {
      if (stackA[idx] === a) {
        return stackB[idx] === b;
      }
      idx -= 1;
    }
    switch (typeA) {
      case "Map":
        if (a.size !== b.size) {
          return false;
        }
        return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));
      case "Set":
        if (a.size !== b.size) {
          return false;
        }
        return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));
      case "Arguments":
      case "Array":
      case "Object":
      case "Boolean":
      case "Number":
      case "String":
      case "Date":
      case "Error":
      case "RegExp":
      case "Int8Array":
      case "Uint8Array":
      case "Uint8ClampedArray":
      case "Int16Array":
      case "Uint16Array":
      case "Int32Array":
      case "Uint32Array":
      case "Float32Array":
      case "Float64Array":
      case "ArrayBuffer":
        break;
      default:
        return false;
    }
    var keysA = keys_default(a);
    if (keysA.length !== keys_default(b).length) {
      return false;
    }
    var extendedStackA = stackA.concat([a]);
    var extendedStackB = stackB.concat([b]);
    idx = keysA.length - 1;
    while (idx >= 0) {
      var key = keysA[idx];
      if (!(_has(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
        return false;
      }
      idx -= 1;
    }
    return true;
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/equals.js
  var equals = /* @__PURE__ */ _curry2(function equals2(a, b) {
    return _equals(a, b, [], []);
  });
  var equals_default = equals;

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_indexOf.js
  function _indexOf(list, a, idx) {
    var inf, item;
    if (typeof list.indexOf === "function") {
      switch (typeof a) {
        case "number":
          if (a === 0) {
            inf = 1 / a;
            while (idx < list.length) {
              item = list[idx];
              if (item === 0 && 1 / item === inf) {
                return idx;
              }
              idx += 1;
            }
            return -1;
          } else if (a !== a) {
            while (idx < list.length) {
              item = list[idx];
              if (typeof item === "number" && item !== item) {
                return idx;
              }
              idx += 1;
            }
            return -1;
          }
          return list.indexOf(a, idx);
        case "string":
        case "boolean":
        case "function":
        case "undefined":
          return list.indexOf(a, idx);
        case "object":
          if (a === null) {
            return list.indexOf(a, idx);
          }
      }
    }
    while (idx < list.length) {
      if (equals_default(list[idx], a)) {
        return idx;
      }
      idx += 1;
    }
    return -1;
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_includes.js
  function _includes(a, list) {
    return _indexOf(list, a, 0) >= 0;
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_toISOString.js
  var pad = function pad2(n) {
    return (n < 10 ? "0" : "") + n;
  };
  var _toISOString = typeof Date.prototype.toISOString === "function" ? function _toISOString2(d) {
    return d.toISOString();
  } : function _toISOString3(d) {
    return d.getUTCFullYear() + "-" + pad(d.getUTCMonth() + 1) + "-" + pad(d.getUTCDate()) + "T" + pad(d.getUTCHours()) + ":" + pad(d.getUTCMinutes()) + ":" + pad(d.getUTCSeconds()) + "." + (d.getUTCMilliseconds() / 1e3).toFixed(3).slice(2, 5) + "Z";
  };

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_isInteger.js
  var isInteger_default = Number.isInteger || function _isInteger(n) {
    return n << 0 === n;
  };

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_cloneRegExp.js
  function _cloneRegExp(pattern) {
    return new RegExp(pattern.source, pattern.flags ? pattern.flags : (pattern.global ? "g" : "") + (pattern.ignoreCase ? "i" : "") + (pattern.multiline ? "m" : "") + (pattern.sticky ? "y" : "") + (pattern.unicode ? "u" : "") + (pattern.dotAll ? "s" : ""));
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_clone.js
  function _clone(value, deep, map2) {
    map2 || (map2 = new _ObjectMap());
    if (_isPrimitive(value)) {
      return value;
    }
    var copy = function copy2(copiedValue) {
      var cachedCopy = map2.get(value);
      if (cachedCopy) {
        return cachedCopy;
      }
      map2.set(value, copiedValue);
      for (var key in value) {
        if (Object.prototype.hasOwnProperty.call(value, key)) {
          copiedValue[key] = deep ? _clone(value[key], true, map2) : value[key];
        }
      }
      return copiedValue;
    };
    switch (type_default(value)) {
      case "Object":
        return copy(Object.create(Object.getPrototypeOf(value)));
      case "Array":
        return copy([]);
      case "Date":
        return new Date(value.valueOf());
      case "RegExp":
        return _cloneRegExp(value);
      case "Int8Array":
      case "Uint8Array":
      case "Uint8ClampedArray":
      case "Int16Array":
      case "Uint16Array":
      case "Int32Array":
      case "Uint32Array":
      case "Float32Array":
      case "Float64Array":
      case "BigInt64Array":
      case "BigUint64Array":
        return value.slice();
      default:
        return value;
    }
  }
  function _isPrimitive(param) {
    var type3 = typeof param;
    return param == null || type3 != "object" && type3 != "function";
  }
  var _ObjectMap = /* @__PURE__ */ function() {
    function _ObjectMap2() {
      this.map = {};
      this.length = 0;
    }
    _ObjectMap2.prototype.set = function(key, value) {
      const hashedKey = this.hash(key);
      let bucket = this.map[hashedKey];
      if (!bucket) {
        this.map[hashedKey] = bucket = [];
      }
      bucket.push([key, value]);
      this.length += 1;
    };
    _ObjectMap2.prototype.hash = function(key) {
      let hashedKey = [];
      for (var value in key) {
        hashedKey.push(Object.prototype.toString.call(key[value]));
      }
      return hashedKey.join();
    };
    _ObjectMap2.prototype.get = function(key) {
      if (this.length <= 180) {
        for (const p in this.map) {
          const bucket2 = this.map[p];
          for (let i = 0; i < bucket2.length; i += 1) {
            const element = bucket2[i];
            if (element[0] === key) {
              return element[1];
            }
          }
        }
        return;
      }
      const hashedKey = this.hash(key);
      const bucket = this.map[hashedKey];
      if (!bucket) {
        return;
      }
      for (let i = 0; i < bucket.length; i += 1) {
        const element = bucket[i];
        if (element[0] === key) {
          return element[1];
        }
      }
    };
    return _ObjectMap2;
  }();

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/clone.js
  var clone = /* @__PURE__ */ _curry1(function clone2(value) {
    return value != null && typeof value.clone === "function" ? value.clone() : _clone(value, true);
  });
  var clone_default = clone;

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_identity.js
  function _identity(x) {
    return x;
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/identity.js
  var identity = /* @__PURE__ */ _curry1(_identity);
  var identity_default = identity;

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_Set.js
  var _Set = /* @__PURE__ */ function() {
    function _Set2() {
      this._nativeSet = typeof Set === "function" ? /* @__PURE__ */ new Set() : null;
      this._items = {};
    }
    _Set2.prototype.add = function(item) {
      return !hasOrAdd(item, true, this);
    };
    _Set2.prototype.has = function(item) {
      return hasOrAdd(item, false, this);
    };
    return _Set2;
  }();
  function hasOrAdd(item, shouldAdd, set2) {
    var type3 = typeof item;
    var prevSize, newSize;
    switch (type3) {
      case "string":
      case "number":
        if (item === 0 && 1 / item === -Infinity) {
          if (set2._items["-0"]) {
            return true;
          } else {
            if (shouldAdd) {
              set2._items["-0"] = true;
            }
            return false;
          }
        }
        if (set2._nativeSet !== null) {
          if (shouldAdd) {
            prevSize = set2._nativeSet.size;
            set2._nativeSet.add(item);
            newSize = set2._nativeSet.size;
            return newSize === prevSize;
          } else {
            return set2._nativeSet.has(item);
          }
        } else {
          if (!(type3 in set2._items)) {
            if (shouldAdd) {
              set2._items[type3] = {};
              set2._items[type3][item] = true;
            }
            return false;
          } else if (item in set2._items[type3]) {
            return true;
          } else {
            if (shouldAdd) {
              set2._items[type3][item] = true;
            }
            return false;
          }
        }
      case "boolean":
        if (type3 in set2._items) {
          var bIdx = item ? 1 : 0;
          if (set2._items[type3][bIdx]) {
            return true;
          } else {
            if (shouldAdd) {
              set2._items[type3][bIdx] = true;
            }
            return false;
          }
        } else {
          if (shouldAdd) {
            set2._items[type3] = item ? [false, true] : [true, false];
          }
          return false;
        }
      case "function":
        if (set2._nativeSet !== null) {
          if (shouldAdd) {
            prevSize = set2._nativeSet.size;
            set2._nativeSet.add(item);
            newSize = set2._nativeSet.size;
            return newSize === prevSize;
          } else {
            return set2._nativeSet.has(item);
          }
        } else {
          if (!(type3 in set2._items)) {
            if (shouldAdd) {
              set2._items[type3] = [item];
            }
            return false;
          }
          if (!_includes(item, set2._items[type3])) {
            if (shouldAdd) {
              set2._items[type3].push(item);
            }
            return false;
          }
          return true;
        }
      case "undefined":
        if (set2._items[type3]) {
          return true;
        } else {
          if (shouldAdd) {
            set2._items[type3] = true;
          }
          return false;
        }
      case "object":
        if (item === null) {
          if (!set2._items["null"]) {
            if (shouldAdd) {
              set2._items["null"] = true;
            }
            return false;
          }
          return true;
        }
      default:
        type3 = Object.prototype.toString.call(item);
        if (!(type3 in set2._items)) {
          if (shouldAdd) {
            set2._items[type3] = [item];
          }
          return false;
        }
        if (!_includes(item, set2._items[type3])) {
          if (shouldAdd) {
            set2._items[type3].push(item);
          }
          return false;
        }
        return true;
    }
  }
  var Set_default = _Set;

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/internal/_xuniqBy.js
  var XUniqBy = /* @__PURE__ */ function() {
    function XUniqBy2(f2, xf) {
      this.xf = xf;
      this.f = f2;
      this.set = new Set_default();
    }
    XUniqBy2.prototype["@@transducer/init"] = xfBase_default.init;
    XUniqBy2.prototype["@@transducer/result"] = xfBase_default.result;
    XUniqBy2.prototype["@@transducer/step"] = function(result, input) {
      return this.set.add(this.f(input)) ? this.xf["@@transducer/step"](result, input) : result;
    };
    return XUniqBy2;
  }();
  function _xuniqBy(f2) {
    return function(xf) {
      return new XUniqBy(f2, xf);
    };
  }

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/uniqBy.js
  var uniqBy = /* @__PURE__ */ _curry2(
    /* @__PURE__ */ _dispatchable([], _xuniqBy, function(fn, list) {
      var set2 = new Set_default();
      var result = [];
      var idx = 0;
      var appliedItem, item;
      while (idx < list.length) {
        item = list[idx];
        appliedItem = fn(item);
        if (set2.add(appliedItem)) {
          result.push(item);
        }
        idx += 1;
      }
      return result;
    })
  );
  var uniqBy_default = uniqBy;

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/uniq.js
  var uniq = /* @__PURE__ */ uniqBy_default(identity_default);
  var uniq_default = uniq;

  // ../../node_modules/.pnpm/ramda@0.29.0/node_modules/ramda/es/trim.js
  var hasProtoTrim = typeof String.prototype.trim === "function";

  // ../abi-typegen/dist/cli.mjs
  var import_path10 = __require2("path");
  var import_path11 = __require2("path");
  var import_fs3 = __require2("fs");
  var import_fs4 = __require2("fs");
  var __defProp4 = Object.defineProperty;
  var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField4 = (obj, key, value) => {
    __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  function findType(params) {
    const { types: types2, typeId } = params;
    const foundType = types2.find(({ rawAbiType: { typeId: tid } }) => tid === typeId);
    if (!foundType) {
      throw new FuelError(ErrorCode.TYPE_ID_NOT_FOUND, `Type ID not found: ${typeId}.`);
    }
    foundType.parseComponentsAttributes({ types: types2 });
    return foundType;
  }
  var Configurable = class {
    name;
    type;
    rawAbiConfigurable;
    constructor(params) {
      const { types: types2, rawAbiConfigurable } = params;
      this.name = rawAbiConfigurable.name;
      this.rawAbiConfigurable = rawAbiConfigurable;
      this.type = findType({ types: types2, typeId: rawAbiConfigurable.configurableType.type });
    }
  };
  function makeConfigurable(params) {
    const { types: types2, rawAbiConfigurable } = params;
    return new Configurable({ types: types2, rawAbiConfigurable });
  }
  function parseConfigurables(params) {
    const { types: types2, rawAbiConfigurables } = params;
    const configurables = rawAbiConfigurables.map(
      (rawAbiConfigurable) => makeConfigurable({ types: types2, rawAbiConfigurable })
    );
    return configurables;
  }
  function parseTypeArguments(params) {
    const { types: types2, typeArguments, parentTypeId, target } = params;
    const attributeKey = `${target}Label`;
    const buffer = [];
    let parentType;
    let parentLabel;
    if (parentTypeId !== void 0) {
      parentType = findType({ types: types2, typeId: parentTypeId });
      parentLabel = parentType.attributes[attributeKey];
    }
    typeArguments.forEach((typeArgument) => {
      let currentLabel;
      const currentTypeId = typeArgument.type;
      try {
        const currentType = findType({ types: types2, typeId: currentTypeId });
        currentLabel = currentType.attributes[attributeKey];
      } catch (_err) {
        currentLabel = "void";
      }
      if (typeArgument.typeArguments) {
        const nestedParsed = parseTypeArguments({
          types: types2,
          target,
          parentTypeId: typeArgument.type,
          typeArguments: typeArgument.typeArguments
        });
        buffer.push(nestedParsed);
      } else {
        buffer.push(`${currentLabel}`);
      }
    });
    let output3 = buffer.join(", ");
    if (parentLabel) {
      output3 = `${parentLabel}<${output3}>`;
    }
    return output3;
  }
  var Function2 = class {
    name;
    types;
    rawAbiFunction;
    attributes;
    constructor(params) {
      this.rawAbiFunction = params.rawAbiFunction;
      this.types = params.types;
      this.name = params.rawAbiFunction.name;
      this.attributes = {
        inputs: this.bundleInputTypes(),
        output: this.bundleOutputTypes(),
        prefixedInputs: this.bundleInputTypes(true)
      };
    }
    bundleInputTypes(shouldPrefixParams = false) {
      const { types: types2 } = this;
      const inputs = this.rawAbiFunction.inputs.map((input) => {
        const { name, type: typeId, typeArguments } = input;
        const type3 = findType({ types: types2, typeId });
        let typeDecl;
        if (typeArguments) {
          typeDecl = parseTypeArguments({
            types: types2,
            target: "input",
            parentTypeId: typeId,
            typeArguments
          });
        } else {
          typeDecl = type3.attributes.inputLabel;
        }
        if (shouldPrefixParams) {
          return `${name}: ${typeDecl}`;
        }
        return typeDecl;
      });
      return inputs.join(", ");
    }
    bundleOutputTypes() {
      return parseTypeArguments({
        types: this.types,
        target: "output",
        typeArguments: [this.rawAbiFunction.output]
      });
    }
    getDeclaration() {
      const { name } = this;
      const { prefixedInputs, output: output3 } = this.attributes;
      const decl = `${name}: InvokeFunction<[${prefixedInputs}], ${output3}>`;
      return decl;
    }
  };
  function makeFunction(params) {
    const { types: types2, rawAbiFunction } = params;
    return new Function2({ types: types2, rawAbiFunction });
  }
  function parseFunctions(params) {
    const { types: types2, rawAbiFunctions } = params;
    const functions = rawAbiFunctions.map(
      (rawAbiFunction) => makeFunction({ types: types2, rawAbiFunction })
    );
    return functions;
  }
  var AType = class {
    rawAbiType;
    attributes;
    requiredFuelsMembersImports;
    constructor(params) {
      this.rawAbiType = params.rawAbiType;
      this.attributes = {
        inputLabel: "unknown",
        outputLabel: "unknown"
      };
      this.requiredFuelsMembersImports = [];
    }
  };
  var _ArrayType = class extends AType {
    name = "array";
    static isSuitableFor(params) {
      return _ArrayType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(params) {
      const { types: types2 } = params;
      const { type: type3 } = this.rawAbiType;
      const arrayLen = Number(type3.match(_ArrayType.MATCH_REGEX)?.[1]);
      const inputs = [];
      const outputs = [];
      this.rawAbiType.components?.forEach((component) => {
        const { type: typeId, typeArguments } = component;
        if (!typeArguments) {
          const { attributes } = findType({ types: types2, typeId });
          inputs.push(attributes.inputLabel);
          outputs.push(attributes.outputLabel);
        } else {
          const inputLabel = parseTypeArguments({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "input"
            /* INPUT */
          });
          const outputLabel = parseTypeArguments({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "output"
            /* OUTPUT */
          });
          inputs.push(inputLabel);
          outputs.push(outputLabel);
        }
      });
      const inputTypes = Array(arrayLen).fill(inputs[0]).join(", ");
      const outputTypes = Array(arrayLen).fill(outputs[0]).join(", ");
      this.attributes = {
        inputLabel: `[${inputTypes}]`,
        outputLabel: `[${outputTypes}]`
      };
      return this.attributes;
    }
  };
  var ArrayType = _ArrayType;
  __publicField4(ArrayType, "swayType", "[_; 2]");
  __publicField4(ArrayType, "MATCH_REGEX", /^\[_; ([0-9]+)\]$/m);
  var _StrType = class extends AType {
    name = "str";
    static isSuitableFor(params) {
      return _StrType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: "string",
        outputLabel: "string"
      };
      return this.attributes;
    }
  };
  var StrType = _StrType;
  __publicField4(StrType, "swayType", "str[3]");
  __publicField4(StrType, "MATCH_REGEX", /^str\[(.+)\]$/m);
  var _B256Type = class extends StrType {
    name = "b256";
    static isSuitableFor(params) {
      return _B256Type.MATCH_REGEX.test(params.type);
    }
  };
  var B256Type = _B256Type;
  __publicField4(B256Type, "swayType", "b256");
  __publicField4(B256Type, "MATCH_REGEX", /^b256$/m);
  var _B512Type = class extends B256Type {
    name = "b512";
    static isSuitableFor(params) {
      return _B512Type.MATCH_REGEX.test(params.type);
    }
  };
  var B512Type = _B512Type;
  __publicField4(B512Type, "swayType", "struct B512");
  __publicField4(B512Type, "MATCH_REGEX", /^struct B512$/m);
  var _BoolType = class extends AType {
    name = "bool";
    static isSuitableFor(params) {
      return _BoolType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: "boolean",
        outputLabel: "boolean"
      };
      return this.attributes;
    }
  };
  var BoolType = _BoolType;
  __publicField4(BoolType, "swayType", "bool");
  __publicField4(BoolType, "MATCH_REGEX", /^bool$/m);
  var _BytesType = class extends ArrayType {
    name = "bytes";
    static isSuitableFor(params) {
      return _BytesType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "Bytes";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var BytesType = _BytesType;
  __publicField4(BytesType, "swayType", "struct Bytes");
  __publicField4(BytesType, "MATCH_REGEX", /^struct Bytes/m);
  function extractStructName(params) {
    const { rawAbiType, regex } = params;
    const match3 = rawAbiType.type.match(params.regex)?.[1];
    if (!match3) {
      let errorMessage = `Couldn't extract struct name with: '${regex}'.

`;
      errorMessage += `Check your JSON ABI.

[source]
`;
      errorMessage += `${JSON.stringify(rawAbiType, null, 2)}`;
      throw new FuelError(ErrorCode.JSON_ABI_ERROR, errorMessage);
    }
    return match3;
  }
  var _EnumType = class extends AType {
    name = "enum";
    static isSuitableFor(params) {
      const isAMatch = _EnumType.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _EnumType.IGNORE_REGEX.test(params.type);
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      const structName = this.getStructName();
      this.attributes = {
        structName,
        inputLabel: `${structName}Input`,
        outputLabel: `${structName}Output`
      };
      return this.attributes;
    }
    getStructName() {
      const name = extractStructName({
        rawAbiType: this.rawAbiType,
        regex: _EnumType.MATCH_REGEX
      });
      return name;
    }
    getNativeEnum(params) {
      const { types: types2 } = params;
      const typeHash = types2.reduce(
        (hash5, row) => ({
          ...hash5,
          [row.rawAbiType.typeId]: row
        }),
        {}
      );
      const { components } = this.rawAbiType;
      const enumComponents = components;
      if (!enumComponents.every(({ type: type3 }) => !typeHash[type3])) {
        return void 0;
      }
      return enumComponents.map(({ name }) => `${name} = '${name}'`).join(", ");
    }
    getStructContents(params) {
      const { types: types2, target } = params;
      const { components } = this.rawAbiType;
      const enumComponents = components;
      const attributeKey = `${target}Label`;
      const contents = enumComponents.map((component) => {
        const { name, type: typeId } = component;
        if (typeId === 0) {
          return `${name}: []`;
        }
        const { attributes } = findType({ types: types2, typeId });
        return `${name}: ${attributes[attributeKey]}`;
      });
      return contents.join(", ");
    }
  };
  var EnumType = _EnumType;
  __publicField4(EnumType, "swayType", "enum MyEnumName");
  __publicField4(EnumType, "MATCH_REGEX", /^enum (.+)$/m);
  __publicField4(EnumType, "IGNORE_REGEX", /^enum Option$/m);
  var _EvmAddressType = class extends AType {
    name = "evmAddress";
    static isSuitableFor(params) {
      return _EvmAddressType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "EvmAddress";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var EvmAddressType = _EvmAddressType;
  __publicField4(EvmAddressType, "swayType", "struct EvmAddress");
  __publicField4(EvmAddressType, "MATCH_REGEX", /^struct EvmAddress$/m);
  var _GenericType = class extends AType {
    name = "generic";
    static isSuitableFor(params) {
      return _GenericType.MATCH_REGEX.test(params.type);
    }
    getStructName() {
      const name = extractStructName({
        rawAbiType: this.rawAbiType,
        regex: _GenericType.MATCH_REGEX
      });
      return name;
    }
    parseComponentsAttributes(_params) {
      const label = this.getStructName();
      this.attributes = {
        inputLabel: label,
        outputLabel: label
      };
      return this.attributes;
    }
  };
  var GenericType = _GenericType;
  __publicField4(GenericType, "swayType", "generic T");
  __publicField4(GenericType, "MATCH_REGEX", /^generic ([^\s]+)$/m);
  var _OptionType = class extends AType {
    name = "option";
    static isSuitableFor(params) {
      return _OptionType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `Option`,
        outputLabel: `Option`
      };
      return this.attributes;
    }
  };
  var OptionType = _OptionType;
  __publicField4(OptionType, "swayType", "enum Option");
  __publicField4(OptionType, "MATCH_REGEX", /^enum Option$/m);
  var _U8Type = class extends AType {
    name = "u8";
    constructor(params) {
      super(params);
      this.attributes = {
        inputLabel: `BigNumberish`,
        outputLabel: `number`
      };
      this.requiredFuelsMembersImports = [this.attributes.inputLabel];
    }
    static isSuitableFor(params) {
      return _U8Type.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      return this.attributes;
    }
  };
  var U8Type = _U8Type;
  __publicField4(U8Type, "swayType", "u8");
  __publicField4(U8Type, "MATCH_REGEX", /^u8$/m);
  var _U64Type = class extends U8Type {
    name = "u64";
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `BigNumberish`,
        outputLabel: `BN`
      };
      this.requiredFuelsMembersImports = Object.values(this.attributes);
      return this.attributes;
    }
    static isSuitableFor(params) {
      return _U64Type.MATCH_REGEX.test(params.type);
    }
  };
  var U64Type = _U64Type;
  __publicField4(U64Type, "swayType", "u64");
  __publicField4(U64Type, "MATCH_REGEX", /^u64$/m);
  var _RawUntypedPtr = class extends U64Type {
    name = "rawUntypedPtr";
    static isSuitableFor(params) {
      return _RawUntypedPtr.MATCH_REGEX.test(params.type);
    }
  };
  var RawUntypedPtr = _RawUntypedPtr;
  __publicField4(RawUntypedPtr, "swayType", "raw untyped ptr");
  __publicField4(RawUntypedPtr, "MATCH_REGEX", /^raw untyped ptr$/m);
  var _RawUntypedSlice = class extends ArrayType {
    name = "rawUntypedSlice";
    static isSuitableFor(params) {
      return _RawUntypedSlice.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "RawSlice";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var RawUntypedSlice = _RawUntypedSlice;
  __publicField4(RawUntypedSlice, "swayType", "raw untyped slice");
  __publicField4(RawUntypedSlice, "MATCH_REGEX", /^raw untyped slice$/m);
  var _StdStringType = class extends AType {
    name = "stdString";
    static isSuitableFor(params) {
      return _StdStringType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "StdString";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var StdStringType = _StdStringType;
  __publicField4(StdStringType, "swayType", "struct String");
  __publicField4(StdStringType, "MATCH_REGEX", /^struct String/m);
  var _StrSliceType = class extends AType {
    name = "strSlice";
    static isSuitableFor(params) {
      return _StrSliceType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: "StrSlice",
        outputLabel: "StrSlice"
      };
      return this.attributes;
    }
  };
  var StrSliceType = _StrSliceType;
  __publicField4(StrSliceType, "swayType", "str");
  __publicField4(StrSliceType, "MATCH_REGEX", /^str$/m);
  var _StructType = class extends AType {
    name = "struct";
    static isSuitableFor(params) {
      const isAMatch = _StructType.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _StructType.IGNORE_REGEX.test(params.type);
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      const structName = this.getStructName();
      this.attributes = {
        structName,
        inputLabel: `${structName}Input`,
        outputLabel: `${structName}Output`
      };
      return this.attributes;
    }
    getStructName() {
      const name = extractStructName({
        rawAbiType: this.rawAbiType,
        regex: _StructType.MATCH_REGEX
      });
      return name;
    }
    getStructContents(params) {
      const { types: types2, target } = params;
      const { components } = this.rawAbiType;
      const structComponents = components;
      const members = structComponents.map((component) => {
        const { name, type: typeId, typeArguments } = component;
        const type3 = findType({ types: types2, typeId });
        let typeDecl;
        if (typeArguments) {
          typeDecl = parseTypeArguments({
            types: types2,
            target,
            parentTypeId: typeId,
            typeArguments
          });
        } else {
          const attributeKey = `${target}Label`;
          typeDecl = type3.attributes[attributeKey];
        }
        return `${name}: ${typeDecl}`;
      });
      return members.join(", ");
    }
    getStructDeclaration(params) {
      const { types: types2 } = params;
      const { typeParameters } = this.rawAbiType;
      if (typeParameters) {
        const structs = typeParameters.map((typeId) => findType({ types: types2, typeId }));
        const labels = structs.map(({ attributes: { inputLabel } }) => inputLabel);
        return `<${labels.join(", ")}>`;
      }
      return "";
    }
  };
  var StructType = _StructType;
  __publicField4(StructType, "swayType", "struct MyStruct");
  __publicField4(StructType, "MATCH_REGEX", /^struct (.+)$/m);
  __publicField4(StructType, "IGNORE_REGEX", /^struct (Vec|RawVec|EvmAddress|Bytes|String)$/m);
  var _TupleType = class extends AType {
    name = "tupple";
    static isSuitableFor(params) {
      return _TupleType.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(params) {
      const { types: types2 } = params;
      const inputs = [];
      const outputs = [];
      this.rawAbiType.components?.forEach((component) => {
        const { type: typeId, typeArguments } = component;
        if (!typeArguments) {
          const { attributes } = findType({ types: types2, typeId });
          inputs.push(attributes.inputLabel);
          outputs.push(attributes.outputLabel);
        } else {
          const inputLabel = parseTypeArguments({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "input"
            /* INPUT */
          });
          const outputLabel = parseTypeArguments({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "output"
            /* OUTPUT */
          });
          inputs.push(inputLabel);
          outputs.push(outputLabel);
        }
      });
      this.attributes = {
        inputLabel: `[${inputs.join(", ")}]`,
        outputLabel: `[${outputs.join(", ")}]`
      };
      return this.attributes;
    }
  };
  var TupleType = _TupleType;
  __publicField4(TupleType, "swayType", "(_, _, _)");
  __publicField4(TupleType, "MATCH_REGEX", /^\([_,\s]+\)$/m);
  var _U16Type = class extends U8Type {
    name = "u16";
    static isSuitableFor(params) {
      return _U16Type.MATCH_REGEX.test(params.type);
    }
  };
  var U16Type = _U16Type;
  __publicField4(U16Type, "swayType", "u16");
  __publicField4(U16Type, "MATCH_REGEX", /^u16$/m);
  var _U32Type = class extends U8Type {
    name = "u32";
    static isSuitableFor(params) {
      return _U32Type.MATCH_REGEX.test(params.type);
    }
  };
  var U32Type = _U32Type;
  __publicField4(U32Type, "swayType", "u32");
  __publicField4(U32Type, "MATCH_REGEX", /^u32$/m);
  var _VectorType = class extends ArrayType {
    name = "vector";
    static isSuitableFor(params) {
      const isAMatch = _VectorType.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _VectorType.IGNORE_REGEX.test(params.type);
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `Vec`,
        outputLabel: `Vec`
      };
      return this.attributes;
    }
  };
  var VectorType = _VectorType;
  __publicField4(VectorType, "swayType", "struct Vec");
  __publicField4(VectorType, "MATCH_REGEX", /^struct Vec/m);
  __publicField4(VectorType, "IGNORE_REGEX", /^struct RawVec$/m);
  var supportedTypes = [
    ArrayType,
    B256Type,
    B512Type,
    BoolType,
    BytesType,
    EnumType,
    GenericType,
    OptionType,
    RawUntypedPtr,
    RawUntypedSlice,
    StdStringType,
    StrType,
    StrSliceType,
    StructType,
    TupleType,
    U16Type,
    U32Type,
    U64Type,
    U8Type,
    VectorType,
    EvmAddressType
  ];
  function makeType(params) {
    const { rawAbiType } = params;
    const { type: type3 } = rawAbiType;
    const TypeClass = supportedTypes.find((tc) => tc.isSuitableFor({ type: type3 }));
    if (!TypeClass) {
      throw new FuelError(ErrorCode.TYPE_NOT_SUPPORTED, `Type not supported: ${type3}`);
    }
    return new TypeClass(params);
  }
  function shouldSkipAbiType(params) {
    const ignoreList = ["()", "struct RawVec"];
    const shouldSkip = ignoreList.indexOf(params.type) >= 0;
    return shouldSkip;
  }
  function parseTypes(params) {
    const types2 = [];
    params.rawAbiTypes.forEach((rawAbiType) => {
      const { type: type3 } = rawAbiType;
      const skip = shouldSkipAbiType({ type: type3 });
      if (!skip) {
        const parsedType = makeType({ rawAbiType });
        types2.push(parsedType);
      }
    });
    types2.forEach((type3) => {
      type3.parseComponentsAttributes({ types: types2 });
    });
    return types2;
  }
  var Abi = class {
    name;
    programType;
    filepath;
    outputDir;
    commonTypesInUse = [];
    rawContents;
    hexlifiedBinContents;
    storageSlotsContents;
    types;
    functions;
    configurables;
    constructor(params) {
      const {
        filepath,
        outputDir,
        rawContents,
        hexlifiedBinContents,
        programType,
        storageSlotsContents
      } = params;
      const abiNameRegex = /([^/]+)-abi\.json$/m;
      const abiName = filepath.match(abiNameRegex);
      const couldNotParseName = !abiName || abiName.length === 0;
      if (couldNotParseName) {
        throw new FuelError(
          ErrorCode.PARSE_FAILED,
          `Could not parse name from ABI file: ${filepath}.`
        );
      }
      const name = `${normalizeString(abiName[1])}Abi`;
      this.name = name;
      this.programType = programType;
      this.filepath = filepath;
      this.rawContents = rawContents;
      this.hexlifiedBinContents = hexlifiedBinContents;
      this.storageSlotsContents = storageSlotsContents;
      this.outputDir = outputDir;
      const { types: types2, functions, configurables } = this.parse();
      this.types = types2;
      this.functions = functions;
      this.configurables = configurables;
      this.computeCommonTypesInUse();
    }
    parse() {
      const {
        types: rawAbiTypes,
        functions: rawAbiFunctions,
        configurables: rawAbiConfigurables
      } = this.rawContents;
      const types2 = parseTypes({ rawAbiTypes });
      const functions = parseFunctions({ rawAbiFunctions, types: types2 });
      const configurables = parseConfigurables({ rawAbiConfigurables, types: types2 });
      return {
        types: types2,
        functions,
        configurables
      };
    }
    computeCommonTypesInUse() {
      const customTypesTable = {
        option: "Option",
        enum: "Enum",
        vector: "Vec"
      };
      this.commonTypesInUse = [];
      Object.keys(customTypesTable).forEach((typeName) => {
        const isInUse = !!this.types.find((t) => t.name === typeName);
        if (isInUse) {
          const commonTypeLabel = customTypesTable[typeName];
          this.commonTypesInUse.push(commonTypeLabel);
        }
      });
    }
  };
  var ProgramTypeEnum = /* @__PURE__ */ ((ProgramTypeEnum22) => {
    ProgramTypeEnum22["CONTRACT"] = "contract";
    ProgramTypeEnum22["SCRIPT"] = "script";
    ProgramTypeEnum22["PREDICATE"] = "predicate";
    return ProgramTypeEnum22;
  })(ProgramTypeEnum || {});
  var header_default = "/* Autogenerated file. Do not edit manually. */\n\n/* tslint:disable */\n/* eslint-disable */\n\n/*\n  Fuels version: {{FUELS}}\n  Forc version: {{FORC}}\n  Fuel-Core version: {{FUEL_CORE}}\n*/\n";
  function renderHbsTemplate(params) {
    const { data, template } = params;
    const options = {
      strict: true,
      noEscape: true
    };
    const renderTemplate = (0, import_handlebars.compile)(template, options);
    const renderHeaderTemplate = (0, import_handlebars.compile)(header_default, options);
    const text = renderTemplate({
      ...data,
      header: renderHeaderTemplate(versions)
    });
    return text.replace(/[\n]{3,}/gm, "\n\n");
  }
  var common_default = "{{header}}\n\n/*\n  Mimics Sway Enum, requires at least one Key-Value but\n  does not raise error on multiple pairs.\n  This is done in the abi-coder\n*/\nexport type Enum<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &\n  U[keyof U];\n\n/*\n  Mimics Sway Option and Vectors.\n  Vectors are treated like arrays in Typescript.\n*/\nexport type Option<T> = T | undefined;\n\nexport type Vec<T> = T[];\n";
  function renderCommonTemplate() {
    const text = renderHbsTemplate({ template: common_default });
    return text;
  }
  var common_default2 = "{{header}}\n\n{{#if isGeneratingContracts}}\n{{#each abis}}\nexport type { {{name}} } from './{{name}}';\n{{/each}}\n{{/if}}\n\n{{#each abis}}\nexport { {{name}}__factory } from './factories/{{name}}__factory';\n{{/each}}\n";
  function renderIndexTemplate(params) {
    const { abis } = params;
    const isGeneratingContracts = abis[0].programType === "contract";
    const text = renderHbsTemplate({
      template: common_default2,
      data: { abis, isGeneratingContracts }
    });
    return text;
  }
  var bytecode_default = "{{header}}\n\nexport default '{{hexlifiedBytecode}}'";
  function renderBytecodeTemplate(params) {
    const text = renderHbsTemplate({
      template: bytecode_default,
      data: {
        hexlifiedBytecode: params.hexlifiedBytecode
      }
    });
    return text;
  }
  function formatConfigurables(params) {
    const { configurables } = params;
    const formattedConfigurables = configurables.map((c) => {
      const {
        name,
        type: {
          attributes: { inputLabel }
        }
      } = c;
      return {
        configurableName: name,
        configurableType: inputLabel
      };
    });
    return { formattedConfigurables };
  }
  function formatEnums(params) {
    const { types: types2 } = params;
    const enums = types2.filter((t) => t.name === "enum").map((t) => {
      const et = t;
      const structName = et.getStructName();
      const inputValues = et.getStructContents({
        types: types2,
        target: "input"
        /* INPUT */
      });
      const outputValues = et.getStructContents({
        types: types2,
        target: "output"
        /* OUTPUT */
      });
      const inputNativeValues = et.getNativeEnum({ types: types2 });
      const outputNativeValues = et.getNativeEnum({ types: types2 });
      return {
        structName,
        inputValues,
        outputValues,
        recycleRef: inputValues === outputValues,
        // reduces duplication
        inputNativeValues,
        outputNativeValues
      };
    });
    return { enums };
  }
  var caseInsensitiveSort = (a, b) => a.toLowerCase().localeCompare(b.toLowerCase());
  function formatImports(params) {
    const { types: types2, baseMembers = [] } = params;
    const members = types2.flatMap((t) => t.requiredFuelsMembersImports);
    const imports = uniq_default(baseMembers.concat(members).sort(caseInsensitiveSort));
    return {
      imports: imports.length ? imports : void 0
    };
  }
  function formatStructs(params) {
    const { types: types2 } = params;
    const structs = types2.filter((t) => t.name === "struct").map((t) => {
      const st = t;
      const structName = st.getStructName();
      const inputValues = st.getStructContents({
        types: types2,
        target: "input"
        /* INPUT */
      });
      const outputValues = st.getStructContents({
        types: types2,
        target: "output"
        /* OUTPUT */
      });
      const typeAnnotations = st.getStructDeclaration({ types: types2 });
      return {
        structName,
        typeAnnotations,
        inputValues,
        outputValues,
        recycleRef: inputValues === outputValues
        // reduces duplication
      };
    });
    return { structs };
  }
  var dts_default = `{{header}}

{{#if imports}}
import type {
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
{{#if inputNativeValues}}
export enum {{structName}}Input { {{inputNativeValues}} };
{{else}}
export type {{structName}}Input = Enum<{ {{inputValues}} }>;
{{/if}}
{{#if outputNativeValues}}
export enum {{structName}}Output { {{outputNativeValues}} };
{{else}}
  {{#if recycleRef}}
export type {{structName}}Output = {{structName}}Input;
  {{else}}
export type {{structName}}Output = Enum<{ {{outputValues}} }>;
  {{/if}}
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

{{#if formattedConfigurables}}
export type {{capitalizedName}}Configurables = {
{{#each formattedConfigurables}}
  {{configurableName}}: {{configurableType}};
{{/each}}
};
{{/if}}

interface {{capitalizedName}}Interface extends Interface {
  functions: {
    {{#each functionsFragments}}
    {{this}}: FunctionFragment;
    {{/each}}
  };

  {{#each encoders}}
  encodeFunctionData(functionFragment: '{{functionName}}', values: [{{input}}]): Uint8Array;
  {{/each}}

  {{#each decoders}}
  decodeFunctionData(functionFragment: '{{functionName}}', data: BytesLike): DecodedValue;
  {{/each}}
}


export class {{capitalizedName}} extends Contract {
  interface: {{capitalizedName}}Interface;
  functions: {
    {{#each functionsTypedefs}}
    {{this}};
    {{/each}}
  };
}
`;
  function renderDtsTemplate(params) {
    const { name: capitalizedName, types: types2, functions, commonTypesInUse, configurables } = params.abi;
    const functionsTypedefs = functions.map((f2) => f2.getDeclaration());
    const functionsFragments = functions.map((f2) => f2.name);
    const encoders = functions.map((f2) => ({
      functionName: f2.name,
      input: f2.attributes.inputs
    }));
    const decoders = functions.map((f2) => ({
      functionName: f2.name
    }));
    const { enums } = formatEnums({ types: types2 });
    const { structs } = formatStructs({ types: types2 });
    const { imports } = formatImports({
      types: types2,
      baseMembers: [
        "Interface",
        "FunctionFragment",
        "DecodedValue",
        "Contract",
        "BytesLike",
        "InvokeFunction"
      ]
    });
    const { formattedConfigurables } = formatConfigurables({ configurables });
    const text = renderHbsTemplate({
      template: dts_default,
      data: {
        capitalizedName,
        commonTypesInUse: commonTypesInUse.join(", "),
        functionsTypedefs,
        functionsFragments,
        encoders,
        decoders,
        structs,
        enums,
        imports,
        formattedConfigurables
      }
    });
    return text;
  }
  var factory_default = '{{header}}\n\nimport { Interface, Contract, ContractFactory } from "fuels";\nimport type { Provider, Account, AbstractAddress, BytesLike, DeployContractOptions, StorageSlot } from "fuels";\nimport type { {{capitalizedName}}, {{capitalizedName}}Interface } from "../{{capitalizedName}}";\n\nconst _abi = {{abiJsonString}};\n\nconst _storageSlots: StorageSlot[] = {{storageSlotsJsonString}};\n\nexport class {{capitalizedName}}__factory {\n  static readonly abi = _abi;\n\n  static readonly storageSlots = _storageSlots;\n\n  static createInterface(): {{capitalizedName}}Interface {\n    return new Interface(_abi) as unknown as {{capitalizedName}}Interface\n  }\n\n  static connect(\n    id: string | AbstractAddress,\n    accountOrProvider: Account | Provider\n  ): {{capitalizedName}} {\n    return new Contract(id, _abi, accountOrProvider) as unknown as {{capitalizedName}}\n  }\n\n  static async deployContract(\n    bytecode: BytesLike,\n    wallet: Account,\n    options: DeployContractOptions = {}\n  ): Promise<{{capitalizedName}}> {\n    const factory = new ContractFactory(bytecode, _abi, wallet);\n\n    const { storageSlots } = {{capitalizedName}}__factory;\n\n    const contract = await factory.deployContract({\n      storageSlots,\n      ...options,\n    });\n\n    return contract as unknown as {{capitalizedName}};\n  }\n}\n';
  function renderFactoryTemplate(params) {
    const { name: capitalizedName, rawContents, storageSlotsContents } = params.abi;
    const abiJsonString = JSON.stringify(rawContents, null, 2);
    const storageSlotsJsonString = storageSlotsContents ?? "[]";
    const text = renderHbsTemplate({
      template: factory_default,
      data: { capitalizedName, abiJsonString, storageSlotsJsonString }
    });
    return text;
  }
  function assembleContracts(params) {
    const { abis, outputDir } = params;
    const files = [];
    const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);
    abis.forEach((abi) => {
      const { name } = abi;
      const dtsFilepath = `${outputDir}/${name}.d.ts`;
      const factoryFilepath = `${outputDir}/factories/${name}__factory.ts`;
      const hexBinFilePath = `${outputDir}/${name}.hex.ts`;
      const dts = {
        path: dtsFilepath,
        contents: renderDtsTemplate({ abi })
      };
      const factory = {
        path: factoryFilepath,
        contents: renderFactoryTemplate({ abi })
      };
      const hexBinFile = {
        path: hexBinFilePath,
        contents: renderBytecodeTemplate({
          hexlifiedBytecode: abi.hexlifiedBinContents
        })
      };
      files.push(dts);
      files.push(factory);
      files.push(hexBinFile);
    });
    const indexFile = {
      path: `${outputDir}/index.ts`,
      contents: renderIndexTemplate({ abis })
    };
    files.push(indexFile);
    if (usesCommonTypes) {
      const commonsFilepath = (0, import_path9.join)(outputDir, "common.d.ts");
      const file = {
        path: commonsFilepath,
        contents: renderCommonTemplate()
      };
      files.push(file);
    }
    return files;
  }
  var factory_default2 = `{{header}}

{{#if imports}}
import {
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
{{#if inputNativeValues}}
export enum {{structName}}Input { {{inputNativeValues}} };
{{else}}
export type {{structName}}Input = Enum<{ {{inputValues}} }>;
{{/if}}
{{#if outputNativeValues}}
export enum {{structName}}Output { {{outputNativeValues}} };
{{else}}
  {{#if recycleRef}}
export type {{structName}}Output = {{structName}}Input;
  {{else}}
export type {{structName}}Output = Enum<{ {{outputValues}} }>;
  {{/if}}
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

export type {{capitalizedName}}Configurables = {
{{#each formattedConfigurables}}
  {{configurableName}}: {{configurableType}};
{{/each}}
};

type {{capitalizedName}}Inputs = [{{inputs}}];

const _abi = {{abiJsonString}}

const _bin = '{{hexlifiedBinString}}'

export class {{capitalizedName}}__factory {

  static readonly abi = _abi
  static readonly bin = _bin;

  static createInstance(provider: Provider, configurables?: {{capitalizedName}}Configurables) {

    const { abi, bin } = {{capitalizedName}}__factory

    const predicate = new Predicate(bin, provider, abi, configurables);

    return predicate;

  }

}
`;
  function renderFactoryTemplate2(params) {
    const { abi } = params;
    const { types: types2, configurables } = abi;
    const {
      rawContents,
      name: capitalizedName,
      hexlifiedBinContents: hexlifiedBinString
    } = params.abi;
    const abiJsonString = JSON.stringify(rawContents, null, 2);
    const func = abi.functions.find((f2) => f2.name === "main");
    if (!func) {
      throw new FuelError(ErrorCode.ABI_MAIN_METHOD_MISSING, `ABI doesn't have a 'main()' method.`);
    }
    const { enums } = formatEnums({ types: types2 });
    const { structs } = formatStructs({ types: types2 });
    const { imports } = formatImports({ types: types2, baseMembers: ["Predicate", "Provider"] });
    const { formattedConfigurables } = formatConfigurables({ configurables });
    const { prefixedInputs: inputs, output: output3 } = func.attributes;
    const text = renderHbsTemplate({
      template: factory_default2,
      data: {
        inputs,
        output: output3,
        structs,
        enums,
        abiJsonString,
        hexlifiedBinString,
        capitalizedName,
        imports,
        formattedConfigurables
      }
    });
    return text;
  }
  function assemblePredicates(params) {
    const { abis, outputDir } = params;
    const files = [];
    const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);
    abis.forEach((abi) => {
      const { name } = abi;
      const factoryFilepath = `${outputDir}/factories/${name}__factory.ts`;
      const factory = {
        path: factoryFilepath,
        contents: renderFactoryTemplate2({ abi })
      };
      files.push(factory);
    });
    const indexFile = {
      path: `${outputDir}/index.ts`,
      contents: renderIndexTemplate({ abis })
    };
    files.push(indexFile);
    if (usesCommonTypes) {
      const commonsFilepath = (0, import_path10.join)(outputDir, "common.d.ts");
      const file = {
        path: commonsFilepath,
        contents: renderCommonTemplate()
      };
      files.push(file);
    }
    return files;
  }
  var factory_default3 = `{{header}}

{{#if imports}}
import {
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
{{#if inputNativeValues}}
export enum {{structName}}Input { {{inputNativeValues}} };
{{else}}
export type {{structName}}Input = Enum<{ {{inputValues}} }>;
{{/if}}
{{#if outputNativeValues}}
export enum {{structName}}Output { {{outputNativeValues}} };
{{else}}
  {{#if recycleRef}}
export type {{structName}}Output = {{structName}}Input;
  {{else}}
export type {{structName}}Output = Enum<{ {{outputValues}} }>;
  {{/if}}
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

type {{capitalizedName}}Inputs = [{{inputs}}];
type {{capitalizedName}}Output = {{output}};

{{#if formattedConfigurables}}
export type {{capitalizedName}}Configurables = {
{{#each formattedConfigurables}}
  {{configurableName}}: {{configurableType}};
{{/each}}
};
{{/if}}

const _abi = {{abiJsonString}}

const _bin = '{{hexlifiedBinString}}'

export class {{capitalizedName}}__factory {

  static readonly abi = _abi
  static readonly bin = _bin

  static createInstance(wallet: Account) {

    const { abi, bin } = {{capitalizedName}}__factory

    const script = new Script<
      {{capitalizedName}}Inputs,
      {{capitalizedName}}Output
    >(bin, abi, wallet);

    return script;

  }

}
`;
  function renderFactoryTemplate3(params) {
    const { abi } = params;
    const { types: types2, configurables } = abi;
    const {
      rawContents,
      name: capitalizedName,
      hexlifiedBinContents: hexlifiedBinString
    } = params.abi;
    const abiJsonString = JSON.stringify(rawContents, null, 2);
    const func = abi.functions.find((f2) => f2.name === "main");
    if (!func) {
      throw new FuelError(ErrorCode.ABI_MAIN_METHOD_MISSING, `ABI doesn't have a 'main()' method.`);
    }
    const { enums } = formatEnums({ types: types2 });
    const { structs } = formatStructs({ types: types2 });
    const { imports } = formatImports({ types: types2, baseMembers: ["Script", "Account"] });
    const { formattedConfigurables } = formatConfigurables({ configurables });
    const { prefixedInputs: inputs, output: output3 } = func.attributes;
    const text = renderHbsTemplate({
      template: factory_default3,
      data: {
        inputs,
        output: output3,
        structs,
        enums,
        abiJsonString,
        hexlifiedBinString,
        capitalizedName,
        imports,
        formattedConfigurables
      }
    });
    return text;
  }
  function assembleScripts(params) {
    const { abis, outputDir } = params;
    const files = [];
    const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);
    abis.forEach((abi) => {
      const { name } = abi;
      const factoryFilepath = `${outputDir}/factories/${name}__factory.ts`;
      const factory = {
        path: factoryFilepath,
        contents: renderFactoryTemplate3({ abi })
      };
      files.push(factory);
    });
    const indexFile = {
      path: `${outputDir}/index.ts`,
      contents: renderIndexTemplate({ abis })
    };
    files.push(indexFile);
    if (usesCommonTypes) {
      const commonsFilepath = (0, import_path11.join)(outputDir, "common.d.ts");
      const file = {
        path: commonsFilepath,
        contents: renderCommonTemplate()
      };
      files.push(file);
    }
    return files;
  }
  var upperFirst = (s) => s[0].toUpperCase() + s.slice(1);
  function validateBinFile(params) {
    const { abiFilepath, binFilepath, binExists, programType } = params;
    const isScript = programType === "script";
    if (!binExists && isScript) {
      throw new FuelError(
        ErrorCode.BIN_FILE_NOT_FOUND,
        [
          `Could not find BIN file for counterpart ${upperFirst(programType)} ABI.`,
          `  - ABI: ${abiFilepath}`,
          `  - BIN: ${binFilepath}`,
          programType
        ].join("\n")
      );
    }
  }
  var AbiTypeGen = class {
    abis;
    abiFiles;
    binFiles;
    storageSlotsFiles;
    outputDir;
    files;
    constructor(params) {
      const { abiFiles, binFiles, outputDir, programType, storageSlotsFiles } = params;
      this.outputDir = outputDir;
      this.abiFiles = abiFiles;
      this.binFiles = binFiles;
      this.storageSlotsFiles = storageSlotsFiles;
      this.abis = this.abiFiles.map((abiFile) => {
        const binFilepath = abiFile.path.replace("-abi.json", ".bin");
        const relatedBinFile = this.binFiles.find(({ path: path4 }) => path4 === binFilepath);
        const storageSlotFilepath = abiFile.path.replace("-abi.json", "-storage_slots.json");
        const relatedStorageSlotsFile = this.storageSlotsFiles.find(
          ({ path: path4 }) => path4 === storageSlotFilepath
        );
        if (!relatedBinFile) {
          validateBinFile({
            abiFilepath: abiFile.path,
            binExists: !!relatedBinFile,
            binFilepath,
            programType
          });
        }
        const abi = new Abi({
          filepath: abiFile.path,
          rawContents: JSON.parse(abiFile.contents),
          hexlifiedBinContents: relatedBinFile?.contents,
          storageSlotsContents: relatedStorageSlotsFile?.contents,
          outputDir,
          programType
        });
        return abi;
      });
      this.files = this.getAssembledFiles({ programType });
    }
    getAssembledFiles(params) {
      const { abis, outputDir } = this;
      const { programType } = params;
      switch (programType) {
        case "contract":
          return assembleContracts({ abis, outputDir });
        case "script":
          return assembleScripts({ abis, outputDir });
        case "predicate":
          return assemblePredicates({ abis, outputDir });
        default:
          throw new FuelError(
            ErrorCode.INVALID_INPUT_PARAMETERS,
            `Invalid Typegen programType: ${programType}. Must be one of ${Object.values(
              ProgramTypeEnum
            )}`
          );
      }
    }
  };
  var collectBinFilepaths = (params) => {
    const { filepaths, programType } = params;
    const binFiles = filepaths.map((abiFilepath) => {
      const binFilepath = abiFilepath.replace("-abi.json", ".bin");
      const binExists = (0, import_fs3.existsSync)(binFilepath);
      validateBinFile({ abiFilepath, binFilepath, binExists, programType });
      const bin = {
        path: binFilepath,
        contents: hexlify((0, import_fs3.readFileSync)(binFilepath))
      };
      return bin;
    });
    return binFiles;
  };
  var collectStorageSlotsFilepaths = (params) => {
    const { filepaths, programType } = params;
    const storageSlotsFiles = [];
    if (programType !== "contract") {
      return storageSlotsFiles;
    }
    filepaths.forEach((abiFilepath) => {
      const storageSlotsFilepath = abiFilepath.replace("-abi.json", "-storage_slots.json");
      const storageSlotsExists = (0, import_fs4.existsSync)(storageSlotsFilepath);
      if (storageSlotsExists) {
        const storageSlots = {
          path: storageSlotsFilepath,
          contents: (0, import_fs4.readFileSync)(storageSlotsFilepath, "utf-8")
        };
        storageSlotsFiles.push(storageSlots);
      }
    });
    return storageSlotsFiles;
  };
  function runTypegen(params) {
    const { cwd, inputs, output: output3, silent, programType, filepaths: inputFilepaths } = params;
    const cwdBasename = (0, import_path8.basename)(cwd);
    function log2(...args) {
      if (!silent) {
        process.stdout.write(`${args.join(" ")}
`);
      }
    }
    let filepaths = [];
    if (!inputFilepaths?.length && inputs?.length) {
      filepaths = inputs.flatMap((i) => globSync(i, { cwd }));
    } else if (inputFilepaths?.length) {
      filepaths = inputFilepaths;
    } else {
      throw new FuelError(
        ErrorCode.MISSING_REQUIRED_PARAMETER,
        `At least one parameter should be supplied: 'input' or 'filepaths'.`
      );
    }
    const abiFiles = filepaths.map((filepath) => {
      const abi = {
        path: filepath,
        contents: (0, import_fs2.readFileSync)(filepath, "utf-8")
      };
      return abi;
    });
    if (!abiFiles.length) {
      throw new FuelError(ErrorCode.NO_ABIS_FOUND, `no ABI found at '${inputs}'`);
    }
    const binFiles = collectBinFilepaths({ filepaths, programType });
    const storageSlotsFiles = collectStorageSlotsFilepaths({ filepaths, programType });
    const abiTypeGen = new AbiTypeGen({
      outputDir: output3,
      abiFiles,
      binFiles,
      storageSlotsFiles,
      programType
    });
    log2("Generating files..\n");
    import_mkdirp.default.sync(`${output3}/factories`);
    abiTypeGen.files.forEach((file) => {
      import_rimraf.default.sync(file.path);
      (0, import_fs2.writeFileSync)(file.path, file.contents);
      const trimPathRegex = new RegExp(`^.+${cwdBasename}/`, "m");
      log2(` - ${file.path.replace(trimPathRegex, "")}`);
    });
    log2("\nDone.\u26A1");
  }
  function resolveProgramType(params) {
    const { contract, script, predicate } = params;
    const noneSpecified = !contract && !script && !predicate;
    if (contract || noneSpecified) {
      return "contract";
    }
    if (predicate) {
      return "predicate";
    }
    return "script";
  }
  function runCliAction(options) {
    const { inputs, output: output3, silent, contract, script, predicate } = options;
    const cwd = process.cwd();
    const programType = resolveProgramType({ contract, script, predicate });
    try {
      runTypegen({
        cwd,
        inputs,
        output: output3,
        programType,
        silent: !!silent
      });
    } catch (err) {
      process.stderr.write(`error: ${err.message}
`);
      process.exit(1);
    }
  }
  function configureCliOptions(program2) {
    return program2.requiredOption("-i, --inputs <path|glob...>", "Input paths/globals to your ABI JSON files").requiredOption("-o, --output <dir>", "Directory path for generated files").addOption(
      new Option("-c, --contract", "Generate types for Contracts [default]").conflicts(["script", "predicate"]).implies({ script: void 0, predicate: void 0 })
    ).addOption(
      new Option("-s, --script", "Generate types for Scripts").conflicts(["contract", "predicate"]).implies({ contract: void 0, predicate: void 0 })
    ).addOption(
      new Option("-p, --predicate", "Generate types for Predicates").conflicts(["contract", "script"]).implies({ contract: void 0, script: void 0 })
    ).option("-S, --silent", "Omit output messages").action(runCliAction);
  }

  // ../versions/dist/cli.mjs
  var import_chalk = __toESM(require_source(), 1);
  var import_cli_table = __toESM(require_lib2(), 1);
  var import_chalk2 = __toESM(require_source(), 1);
  var import_semver3 = __toESM(require_semver2(), 1);
  var import_chalk3 = __toESM(require_source(), 1);
  var import_child_process = __require2("child_process");
  var colorizeUserVersion = (params) => {
    const { version: version2, isGt, isOk } = params;
    if (isGt) {
      return (0, import_chalk2.cyan)(version2);
    }
    if (isOk) {
      return (0, import_chalk2.green)(version2);
    }
    return (0, import_chalk2.red)(version2);
  };
  function getBuiltinVersions3() {
    return {
      FORC: "0.46.1",
      FUEL_CORE: "0.20.8",
      FUELS: "0.69.1"
    };
  }
  function compareSystemVersions(params) {
    const { systemForcVersion, systemFuelCoreVersion } = params;
    const versions3 = getBuiltinVersions3();
    const systemForcIsGt = import_semver3.default.gt(systemForcVersion, versions3.FORC);
    const systemFuelCoreIsGt = import_semver3.default.gt(systemFuelCoreVersion, versions3.FUEL_CORE);
    const systemForcIsEq = import_semver3.default.eq(systemForcVersion, versions3.FORC);
    const systemFuelCoreIsEq = import_semver3.default.eq(systemFuelCoreVersion, versions3.FUEL_CORE);
    return {
      systemForcIsGt,
      systemFuelCoreIsGt,
      systemForcIsEq,
      systemFuelCoreIsEq
    };
  }
  var fuelUpLink = "https://github.com/fuellabs/fuelup";
  var stdio = "ignore";
  function getSystemForc() {
    let systemForcVersion = null;
    let error2 = null;
    try {
      const reg = /[^0-9.]+/g;
      systemForcVersion = (0, import_child_process.execSync)("forc --version", { stdio }).toString().replace(reg, "");
    } catch (err) {
      error2 = err;
    }
    return {
      error: error2,
      systemForcVersion
    };
  }
  function getSystemFuelCore() {
    let systemFuelCoreVersion = null;
    let error2 = null;
    try {
      const reg = /[^0-9.]+/g;
      systemFuelCoreVersion = (0, import_child_process.execSync)("fuel-core --version", { stdio }).toString().replace(reg, "");
    } catch (err) {
      error2 = err;
    }
    return {
      error: error2,
      systemFuelCoreVersion
    };
  }
  function getSystemVersions() {
    const { error: error2 } = console;
    const { error: errorForc, systemForcVersion } = getSystemForc();
    const { error: errorCore, systemFuelCoreVersion } = getSystemFuelCore();
    const err = errorForc ?? errorCore;
    if (err) {
      error2("Make sure you have Forc and Fuel-Core installed.");
      error2(`  ${(0, import_chalk3.green)(fuelUpLink)}`);
      throw err;
    }
    return {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      systemForcVersion,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      systemFuelCoreVersion
    };
  }
  function runVersions() {
    const { error: error2, info } = console;
    const supportedVersions = getBuiltinVersions3();
    const cliTable = new import_cli_table.default({
      head: ["", (0, import_chalk.bold)("Supported"), (0, import_chalk.bold)(`Yours / System`)]
    });
    const { systemForcVersion, systemFuelCoreVersion } = getSystemVersions();
    const comparisons = compareSystemVersions({
      systemForcVersion,
      systemFuelCoreVersion
    });
    const userForcColorized = colorizeUserVersion({
      version: systemForcVersion,
      isGt: comparisons.systemForcIsGt,
      isOk: comparisons.systemForcIsEq
    });
    const userFuelCoreColorized = colorizeUserVersion({
      version: systemFuelCoreVersion,
      isGt: comparisons.systemFuelCoreIsGt,
      isOk: comparisons.systemFuelCoreIsEq
    });
    cliTable.push(["Forc", supportedVersions.FORC, userForcColorized]);
    cliTable.push(["Fuel-Core", supportedVersions.FUEL_CORE, userFuelCoreColorized]);
    const someIsGt = comparisons.systemForcIsGt || comparisons.systemFuelCoreIsGt;
    const bothAreExact = comparisons.systemForcIsEq && comparisons.systemFuelCoreIsEq;
    if (someIsGt) {
      info(`Your system's components are newer than the ones supported!`);
      info(cliTable.toString());
      process.exit(0);
    } else if (bothAreExact) {
      info(`You have all the right versions! \u26A1`);
      info(cliTable.toString());
      process.exit(0);
    } else {
      error2(`You're using outdated versions \u2014 update them with:`);
      error2(`  ${(0, import_chalk.green)(fuelUpLink)}`);
      error2(cliTable.toString());
      process.exit(1);
    }
  }

  // src/cli/utils/logger.ts
  var import_chalk4 = __toESM(require_source());
  var loggingConfig = {
    isDebugEnabled: false,
    isLoggingEnabled: true
  };
  function configureLogging(params) {
    loggingConfig.isLoggingEnabled = params.isLoggingEnabled;
    loggingConfig.isDebugEnabled = params.isDebugEnabled && loggingConfig.isLoggingEnabled;
  }
  function log(...data) {
    if (loggingConfig.isLoggingEnabled) {
      process.stdout.write(`${data.join(" ")}
`);
    }
  }
  function debug(...data) {
    if (loggingConfig.isDebugEnabled) {
      log(data);
    }
  }
  function error(...data) {
    process.stderr.write(`${import_chalk4.default.red(data.join(" "))}
`);
  }

  // src/cli/config/forcUtils.ts
  var import_fs5 = __require2("fs");
  var import_lodash = __toESM(require_lodash());
  var import_path12 = __require2("path");
  var import_toml = __toESM(require_toml());
  var forcFiles = /* @__PURE__ */ new Map();
  var swayFiles = /* @__PURE__ */ new Map();
  function readForcToml(path4) {
    const forcPath = (0, import_path12.join)(path4, "./Forc.toml");
    if (!(0, import_fs5.existsSync)(forcPath)) {
      throw new Error(`Toml file not found:
  ${forcPath}`);
    }
    if (!forcFiles.has(forcPath)) {
      const forcFile = (0, import_fs5.readFileSync)(forcPath, "utf8");
      const tomlParsed = import_toml.default.parse(forcFile);
      forcFiles.set(forcPath, tomlParsed);
    }
    const tomlContents = forcFiles.get(forcPath);
    return tomlContents;
  }
  function readSwayType(path4) {
    const forcToml = readForcToml(path4);
    const entryFile = forcToml.project.entry || "main.sw";
    const swayEntryPath = (0, import_path12.join)(path4, "src", entryFile);
    if (!swayFiles.has(swayEntryPath)) {
      const swayFile = (0, import_fs5.readFileSync)(swayEntryPath, "utf8");
      const [swayType] = swayFile.split(";\n");
      swayFiles.set(swayEntryPath, swayType);
    }
    return swayFiles.get(swayEntryPath);
  }
  function getContractName(contractPath) {
    const { project } = readForcToml(contractPath);
    return project.name;
  }
  function getContractCamelCase(contractPath) {
    const projectName = getContractName(contractPath);
    return (0, import_lodash.default)(projectName);
  }
  function getBinaryPath(contractPath) {
    const projectName = getContractName(contractPath);
    return (0, import_path12.join)(contractPath, `/out/debug/${projectName}.bin`);
  }
  function getABIPath(contractPath) {
    const projectName = getContractName(contractPath);
    return (0, import_path12.join)(contractPath, `/out/debug/${projectName}-abi.json`);
  }
  function getABIPaths(paths) {
    return Promise.all(paths.map((path4) => getABIPath(path4)));
  }
  var getStorageSlotsPath = (contractPath) => {
    const projectName = getContractName(contractPath);
    return (0, import_path12.join)(contractPath, `/out/debug/${projectName}-storage_slots.json`);
  };

  // ../address/dist/configs.mjs
  var ZeroBytes32 = "0x0000000000000000000000000000000000000000000000000000000000000000";
  var BaseAssetId = ZeroBytes32;

  // ../math/dist/index.mjs
  var import_bn = __toESM(require_bn(), 1);
  var DEFAULT_PRECISION = 9;
  var DEFAULT_MIN_PRECISION = 3;
  var DECIMAL_UNITS = 9;
  function toFixed(value, options) {
    const { precision = DEFAULT_PRECISION, minPrecision = DEFAULT_MIN_PRECISION } = options || {};
    const [valueUnits = "0", valueDecimals = "0"] = String(value || "0.0").split(".");
    const groupRegex = /(\d)(?=(\d{3})+\b)/g;
    const units = valueUnits.replace(groupRegex, "$1,");
    let decimals = valueDecimals.slice(0, precision);
    if (minPrecision < precision) {
      const trimmedDecimal = decimals.match(/.*[1-9]{1}/);
      const lastNonZeroIndex = trimmedDecimal?.[0].length || 0;
      const keepChars = Math.max(minPrecision, lastNonZeroIndex);
      decimals = decimals.slice(0, keepChars);
    }
    const decimalPortion = decimals ? `.${decimals}` : "";
    return `${units}${decimalPortion}`;
  }
  var BN = class extends import_bn.default {
    constructor(value, base, endian) {
      if (BN.isBN(value)) {
        super(value.toArray(), base, endian);
        return;
      }
      if (typeof value === "string" && value.slice(0, 2) === "0x") {
        super(value.substring(2), base || "hex", endian);
        return;
      }
      const defaultValue = value == null ? 0 : value;
      super(defaultValue, base, endian);
    }
    // ANCHOR: HELPERS
    // make sure we always include `0x` in hex strings
    toString(base, length) {
      const output3 = super.toString(base, length);
      if (base === 16 || base === "hex") {
        return `0x${output3}`;
      }
      return output3;
    }
    toHex(bytesPadding) {
      const bytes3 = bytesPadding || 0;
      const bytesLength = bytes3 * 2;
      if (this.isNeg()) {
        throw new FuelError(ErrorCode.CONVERTING_FAILED, "Cannot convert negative value to hex.");
      }
      if (bytesPadding && this.byteLength() > bytesPadding) {
        throw new FuelError(
          ErrorCode.CONVERTING_FAILED,
          `Provided value ${this} is too large. It should fit within ${bytesPadding} bytes.`
        );
      }
      return this.toString(16, bytesLength);
    }
    toBytes(bytesPadding) {
      if (this.isNeg()) {
        throw new FuelError(ErrorCode.CONVERTING_FAILED, "Cannot convert negative value to bytes.");
      }
      return Uint8Array.from(this.toArray(void 0, bytesPadding));
    }
    toJSON() {
      return this.toString(16);
    }
    valueOf() {
      return this.toString();
    }
    format(options) {
      const {
        units = DECIMAL_UNITS,
        precision = DEFAULT_PRECISION,
        minPrecision = DEFAULT_MIN_PRECISION
      } = options || {};
      const formattedUnits = this.formatUnits(units);
      const formattedFixed = toFixed(formattedUnits, { precision, minPrecision });
      if (!parseFloat(formattedFixed)) {
        const [, originalDecimals = "0"] = formattedUnits.split(".");
        const firstNonZero = originalDecimals.match(/[1-9]/);
        if (firstNonZero && firstNonZero.index && firstNonZero.index + 1 > precision) {
          const [valueUnits = "0"] = formattedFixed.split(".");
          return `${valueUnits}.${originalDecimals.slice(0, firstNonZero.index + 1)}`;
        }
      }
      return formattedFixed;
    }
    formatUnits(units = DECIMAL_UNITS) {
      const valueUnits = this.toString().slice(0, units * -1);
      const valueDecimals = this.toString().slice(units * -1);
      const length = valueDecimals.length;
      const defaultDecimals = Array.from({ length: units - length }).fill("0").join("");
      const integerPortion = valueUnits ? `${valueUnits}.` : "0.";
      return `${integerPortion}${defaultDecimals}${valueDecimals}`;
    }
    // END ANCHOR: HELPERS
    // ANCHOR: OVERRIDES to accept better inputs
    add(v) {
      return this.caller(v, "add");
    }
    pow(v) {
      return this.caller(v, "pow");
    }
    sub(v) {
      return this.caller(v, "sub");
    }
    div(v) {
      return this.caller(v, "div");
    }
    mul(v) {
      return this.caller(v, "mul");
    }
    mod(v) {
      return this.caller(v, "mod");
    }
    divRound(v) {
      return this.caller(v, "divRound");
    }
    lt(v) {
      return this.caller(v, "lt");
    }
    lte(v) {
      return this.caller(v, "lte");
    }
    gt(v) {
      return this.caller(v, "gt");
    }
    gte(v) {
      return this.caller(v, "gte");
    }
    eq(v) {
      return this.caller(v, "eq");
    }
    cmp(v) {
      return this.caller(v, "cmp");
    }
    // END ANCHOR: OVERRIDES to accept better inputs
    // ANCHOR: OVERRIDES to output our BN type
    sqr() {
      return new BN(super.sqr().toArray());
    }
    neg() {
      return new BN(super.neg().toArray());
    }
    abs() {
      return new BN(super.abs().toArray());
    }
    toTwos(width) {
      return new BN(super.toTwos(width).toArray());
    }
    fromTwos(width) {
      return new BN(super.fromTwos(width).toArray());
    }
    // END ANCHOR: OVERRIDES to output our BN type
    // ANCHOR: OVERRIDES to avoid losing references
    caller(v, methodName) {
      const output3 = super[methodName](new BN(v));
      if (BN.isBN(output3)) {
        return new BN(output3.toArray());
      }
      if (typeof output3 === "boolean") {
        return output3;
      }
      return output3;
    }
    clone() {
      return new BN(this.toArray());
    }
    mulTo(num, out) {
      const output3 = new import_bn.default(this.toArray()).mulTo(num, out);
      return new BN(output3.toArray());
    }
    egcd(p) {
      const { a, b, gcd } = new import_bn.default(this.toArray()).egcd(p);
      return {
        a: new BN(a.toArray()),
        b: new BN(b.toArray()),
        gcd: new BN(gcd.toArray())
      };
    }
    divmod(num, mode, positive) {
      const { div, mod } = new import_bn.default(this.toArray()).divmod(new BN(num), mode, positive);
      return {
        div: new BN(div?.toArray()),
        mod: new BN(mod?.toArray())
      };
    }
    // END ANCHOR: OVERRIDES to avoid losing references
  };
  var bn = (value, base, endian) => new BN(value, base, endian);
  bn.parseUnits = (value, units = DECIMAL_UNITS) => {
    const valueToParse = value === "." ? "0." : value;
    const [valueUnits = "0", valueDecimals = "0"] = valueToParse.split(".");
    const length = valueDecimals.length;
    if (length > units) {
      throw new FuelError(
        ErrorCode.CONVERTING_FAILED,
        `Decimal can't have more than ${units} digits.`
      );
    }
    const decimals = Array.from({ length: units }).fill("0");
    decimals.splice(0, length, valueDecimals);
    const amount = `${valueUnits.replaceAll(",", "")}${decimals.join("")}`;
    return bn(amount);
  };
  function toNumber2(value) {
    return bn(value).toNumber();
  }
  function toHex(value, bytesPadding) {
    return bn(value).toHex(bytesPadding);
  }
  function toBytes2(value, bytesPadding) {
    return bn(value).toBytes(bytesPadding);
  }
  function max(...numbers) {
    return numbers.reduce((prev, cur) => bn(cur).gt(prev) ? bn(cur) : prev, bn(0));
  }

  // ../../node_modules/.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/esm/_assert.js
  function number2(n) {
    if (!Number.isSafeInteger(n) || n < 0)
      throw new Error(`Wrong positive integer: ${n}`);
  }
  function bool2(b) {
    if (typeof b !== "boolean")
      throw new Error(`Expected boolean, not ${b}`);
  }
  function bytes2(b, ...lengths) {
    if (!(b instanceof Uint8Array))
      throw new Error("Expected Uint8Array");
    if (lengths.length > 0 && !lengths.includes(b.length))
      throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
  }
  function hash2(hash5) {
    if (typeof hash5 !== "function" || typeof hash5.create !== "function")
      throw new Error("Hash should be wrapped by utils.wrapConstructor");
    number2(hash5.outputLen);
    number2(hash5.blockLen);
  }
  function exists2(instance, checkFinished = true) {
    if (instance.destroyed)
      throw new Error("Hash instance has been destroyed");
    if (checkFinished && instance.finished)
      throw new Error("Hash#digest() has already been called");
  }
  function output2(out, instance) {
    bytes2(out);
    const min = instance.outputLen;
    if (out.length < min) {
      throw new Error(`digestInto() expects output buffer of length at least ${min}`);
    }
  }
  var assert3 = {
    number: number2,
    bool: bool2,
    bytes: bytes2,
    hash: hash2,
    exists: exists2,
    output: output2
  };
  var assert_default2 = assert3;

  // ../../node_modules/.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/esm/cryptoNode.js
  var nc = __toESM(__require2("crypto"), 1);
  var crypto2 = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : void 0;

  // ../../node_modules/.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/esm/utils.js
  var u8a = (a) => a instanceof Uint8Array;
  var u322 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
  var createView2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
  var rotr = (word, shift) => word << 32 - shift | word >>> shift;
  var isLE2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
  if (!isLE2)
    throw new Error("Non little-endian hardware is not supported");
  var hexes2 = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
  function utf8ToBytes2(str) {
    if (typeof str !== "string")
      throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
    return new Uint8Array(new TextEncoder().encode(str));
  }
  function toBytes3(data) {
    if (typeof data === "string")
      data = utf8ToBytes2(data);
    if (!u8a(data))
      throw new Error(`expected Uint8Array, got ${typeof data}`);
    return data;
  }
  var Hash2 = class {
    // Safe version that clones internal state
    clone() {
      return this._cloneInto();
    }
  };
  var isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;
  function checkOpts(defaults2, opts) {
    if (opts !== void 0 && (typeof opts !== "object" || !isPlainObject(opts)))
      throw new Error("Options should be object or undefined");
    const merged = Object.assign(defaults2, opts);
    return merged;
  }
  function wrapConstructor2(hashCons) {
    const hashC = (msg) => hashCons().update(toBytes3(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = () => hashCons();
    return hashC;
  }
  function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts) => hashCons(opts).update(toBytes3(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts) => hashCons(opts);
    return hashC;
  }

  // ../../node_modules/.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/esm/_sha2.js
  function setBigUint642(view, byteOffset, value, isLE3) {
    if (typeof view.setBigUint64 === "function")
      return view.setBigUint64(byteOffset, value, isLE3);
    const _32n3 = BigInt(32);
    const _u32_max = BigInt(4294967295);
    const wh = Number(value >> _32n3 & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE3 ? 4 : 0;
    const l = isLE3 ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE3);
    view.setUint32(byteOffset + l, wl, isLE3);
  }
  var SHA22 = class extends Hash2 {
    constructor(blockLen, outputLen, padOffset, isLE3) {
      super();
      this.blockLen = blockLen;
      this.outputLen = outputLen;
      this.padOffset = padOffset;
      this.isLE = isLE3;
      this.finished = false;
      this.length = 0;
      this.pos = 0;
      this.destroyed = false;
      this.buffer = new Uint8Array(blockLen);
      this.view = createView2(this.buffer);
    }
    update(data) {
      assert_default2.exists(this);
      const { view, buffer, blockLen } = this;
      data = toBytes3(data);
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        if (take === blockLen) {
          const dataView = createView2(data);
          for (; blockLen <= len - pos; pos += blockLen)
            this.process(dataView, pos);
          continue;
        }
        buffer.set(data.subarray(pos, pos + take), this.pos);
        this.pos += take;
        pos += take;
        if (this.pos === blockLen) {
          this.process(view, 0);
          this.pos = 0;
        }
      }
      this.length += data.length;
      this.roundClean();
      return this;
    }
    digestInto(out) {
      assert_default2.exists(this);
      assert_default2.output(out, this);
      this.finished = true;
      const { buffer, view, blockLen, isLE: isLE3 } = this;
      let { pos } = this;
      buffer[pos++] = 128;
      this.buffer.subarray(pos).fill(0);
      if (this.padOffset > blockLen - pos) {
        this.process(view, 0);
        pos = 0;
      }
      for (let i = pos; i < blockLen; i++)
        buffer[i] = 0;
      setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE3);
      this.process(view, 0);
      const oview = createView2(out);
      const len = this.outputLen;
      if (len % 4)
        throw new Error("_sha2: outputLen should be aligned to 32bit");
      const outLen = len / 4;
      const state = this.get();
      if (outLen > state.length)
        throw new Error("_sha2: outputLen bigger than state");
      for (let i = 0; i < outLen; i++)
        oview.setUint32(4 * i, state[i], isLE3);
    }
    digest() {
      const { buffer, outputLen } = this;
      this.digestInto(buffer);
      const res = buffer.slice(0, outputLen);
      this.destroy();
      return res;
    }
    _cloneInto(to) {
      to || (to = new this.constructor());
      to.set(...this.get());
      const { blockLen, buffer, length, finished, destroyed, pos } = this;
      to.length = length;
      to.pos = pos;
      to.finished = finished;
      to.destroyed = destroyed;
      if (length % blockLen)
        to.buffer.set(buffer);
      return to;
    }
  };

  // ../../node_modules/.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/esm/sha256.js
  var Chi = (a, b, c) => a & b ^ ~a & c;
  var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
  var SHA256_K = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var IV = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  var SHA256_W = new Uint32Array(64);
  var SHA256 = class extends SHA22 {
    constructor() {
      super(64, 32, 8, false);
      this.A = IV[0] | 0;
      this.B = IV[1] | 0;
      this.C = IV[2] | 0;
      this.D = IV[3] | 0;
      this.E = IV[4] | 0;
      this.F = IV[5] | 0;
      this.G = IV[6] | 0;
      this.H = IV[7] | 0;
    }
    get() {
      const { A, B, C, D, E, F, G, H } = this;
      return [A, B, C, D, E, F, G, H];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
      this.A = A | 0;
      this.B = B | 0;
      this.C = C | 0;
      this.D = D | 0;
      this.E = E | 0;
      this.F = F | 0;
      this.G = G | 0;
      this.H = H | 0;
    }
    process(view, offset) {
      for (let i = 0; i < 16; i++, offset += 4)
        SHA256_W[i] = view.getUint32(offset, false);
      for (let i = 16; i < 64; i++) {
        const W15 = SHA256_W[i - 15];
        const W2 = SHA256_W[i - 2];
        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
      }
      let { A, B, C, D, E, F, G, H } = this;
      for (let i = 0; i < 64; i++) {
        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
        const T2 = sigma0 + Maj(A, B, C) | 0;
        H = G;
        G = F;
        F = E;
        E = D + T1 | 0;
        D = C;
        C = B;
        B = A;
        A = T1 + T2 | 0;
      }
      A = A + this.A | 0;
      B = B + this.B | 0;
      C = C + this.C | 0;
      D = D + this.D | 0;
      E = E + this.E | 0;
      F = F + this.F | 0;
      G = G + this.G | 0;
      H = H + this.H | 0;
      this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
      SHA256_W.fill(0);
    }
    destroy() {
      this.set(0, 0, 0, 0, 0, 0, 0, 0);
      this.buffer.fill(0);
    }
  };
  var SHA224 = class extends SHA256 {
    constructor() {
      super();
      this.A = 3238371032 | 0;
      this.B = 914150663 | 0;
      this.C = 812702999 | 0;
      this.D = 4144912697 | 0;
      this.E = 4290775857 | 0;
      this.F = 1750603025 | 0;
      this.G = 1694076839 | 0;
      this.H = 3204075428 | 0;
      this.outputLen = 28;
    }
  };
  var sha2562 = wrapConstructor2(() => new SHA256());
  var sha224 = wrapConstructor2(() => new SHA224());

  // ../../node_modules/.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/esm/hmac.js
  var HMAC = class extends Hash2 {
    constructor(hash5, _key) {
      super();
      this.finished = false;
      this.destroyed = false;
      assert_default2.hash(hash5);
      const key = toBytes3(_key);
      this.iHash = hash5.create();
      if (typeof this.iHash.update !== "function")
        throw new Error("Expected instance of class which extends utils.Hash");
      this.blockLen = this.iHash.blockLen;
      this.outputLen = this.iHash.outputLen;
      const blockLen = this.blockLen;
      const pad3 = new Uint8Array(blockLen);
      pad3.set(key.length > blockLen ? hash5.create().update(key).digest() : key);
      for (let i = 0; i < pad3.length; i++)
        pad3[i] ^= 54;
      this.iHash.update(pad3);
      this.oHash = hash5.create();
      for (let i = 0; i < pad3.length; i++)
        pad3[i] ^= 54 ^ 92;
      this.oHash.update(pad3);
      pad3.fill(0);
    }
    update(buf) {
      assert_default2.exists(this);
      this.iHash.update(buf);
      return this;
    }
    digestInto(out) {
      assert_default2.exists(this);
      assert_default2.bytes(out, this.outputLen);
      this.finished = true;
      this.iHash.digestInto(out);
      this.oHash.update(out);
      this.oHash.digestInto(out);
      this.destroy();
    }
    digest() {
      const out = new Uint8Array(this.oHash.outputLen);
      this.digestInto(out);
      return out;
    }
    _cloneInto(to) {
      to || (to = Object.create(Object.getPrototypeOf(this), {}));
      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
      to = to;
      to.finished = finished;
      to.destroyed = destroyed;
      to.blockLen = blockLen;
      to.outputLen = outputLen;
      to.oHash = oHash._cloneInto(to.oHash);
      to.iHash = iHash._cloneInto(to.iHash);
      return to;
    }
    destroy() {
      this.destroyed = true;
      this.oHash.destroy();
      this.iHash.destroy();
    }
  };
  var hmac = (hash5, key, message) => new HMAC(hash5, key).update(message).digest();
  hmac.create = (hash5, key) => new HMAC(hash5, key);

  // ../../node_modules/.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/esm/pbkdf2.js
  function pbkdf2Init(hash5, _password, _salt, _opts) {
    assert_default2.hash(hash5);
    const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
    const { c, dkLen, asyncTick } = opts;
    assert_default2.number(c);
    assert_default2.number(dkLen);
    assert_default2.number(asyncTick);
    if (c < 1)
      throw new Error("PBKDF2: iterations (c) should be >= 1");
    const password = toBytes3(_password);
    const salt = toBytes3(_salt);
    const DK = new Uint8Array(dkLen);
    const PRF = hmac.create(hash5, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
  }
  function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW)
      prfW.destroy();
    u.fill(0);
    return DK;
  }
  function pbkdf22(hash5, password, salt, opts) {
    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash5, password, salt, opts);
    let prfW;
    const arr = new Uint8Array(4);
    const view = createView2(arr);
    const u = new Uint8Array(PRF.outputLen);
    for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
      const Ti = DK.subarray(pos, pos + PRF.outputLen);
      view.setInt32(0, ti, false);
      (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
      Ti.set(u.subarray(0, Ti.length));
      for (let ui = 1; ui < c; ui++) {
        PRF._cloneInto(prfW).update(u).digestInto(u);
        for (let i = 0; i < Ti.length; i++)
          Ti[i] ^= u[i];
      }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
  }

  // ../../node_modules/.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/esm/scrypt.js
  var rotl2 = (a, b) => a << b | a >>> 32 - b;
  function XorAndSalsa(prev, pi, input, ii, out, oi) {
    let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
    let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
    let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
    let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
    let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
    let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
    let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
    let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
    let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
    for (let i = 0; i < 8; i += 2) {
      x04 ^= rotl2(x00 + x12 | 0, 7);
      x08 ^= rotl2(x04 + x00 | 0, 9);
      x12 ^= rotl2(x08 + x04 | 0, 13);
      x00 ^= rotl2(x12 + x08 | 0, 18);
      x09 ^= rotl2(x05 + x01 | 0, 7);
      x13 ^= rotl2(x09 + x05 | 0, 9);
      x01 ^= rotl2(x13 + x09 | 0, 13);
      x05 ^= rotl2(x01 + x13 | 0, 18);
      x14 ^= rotl2(x10 + x06 | 0, 7);
      x02 ^= rotl2(x14 + x10 | 0, 9);
      x06 ^= rotl2(x02 + x14 | 0, 13);
      x10 ^= rotl2(x06 + x02 | 0, 18);
      x03 ^= rotl2(x15 + x11 | 0, 7);
      x07 ^= rotl2(x03 + x15 | 0, 9);
      x11 ^= rotl2(x07 + x03 | 0, 13);
      x15 ^= rotl2(x11 + x07 | 0, 18);
      x01 ^= rotl2(x00 + x03 | 0, 7);
      x02 ^= rotl2(x01 + x00 | 0, 9);
      x03 ^= rotl2(x02 + x01 | 0, 13);
      x00 ^= rotl2(x03 + x02 | 0, 18);
      x06 ^= rotl2(x05 + x04 | 0, 7);
      x07 ^= rotl2(x06 + x05 | 0, 9);
      x04 ^= rotl2(x07 + x06 | 0, 13);
      x05 ^= rotl2(x04 + x07 | 0, 18);
      x11 ^= rotl2(x10 + x09 | 0, 7);
      x08 ^= rotl2(x11 + x10 | 0, 9);
      x09 ^= rotl2(x08 + x11 | 0, 13);
      x10 ^= rotl2(x09 + x08 | 0, 18);
      x12 ^= rotl2(x15 + x14 | 0, 7);
      x13 ^= rotl2(x12 + x15 | 0, 9);
      x14 ^= rotl2(x13 + x12 | 0, 13);
      x15 ^= rotl2(x14 + x13 | 0, 18);
    }
    out[oi++] = y00 + x00 | 0;
    out[oi++] = y01 + x01 | 0;
    out[oi++] = y02 + x02 | 0;
    out[oi++] = y03 + x03 | 0;
    out[oi++] = y04 + x04 | 0;
    out[oi++] = y05 + x05 | 0;
    out[oi++] = y06 + x06 | 0;
    out[oi++] = y07 + x07 | 0;
    out[oi++] = y08 + x08 | 0;
    out[oi++] = y09 + x09 | 0;
    out[oi++] = y10 + x10 | 0;
    out[oi++] = y11 + x11 | 0;
    out[oi++] = y12 + x12 | 0;
    out[oi++] = y13 + x13 | 0;
    out[oi++] = y14 + x14 | 0;
    out[oi++] = y15 + x15 | 0;
  }
  function BlockMix(input, ii, out, oi, r) {
    let head = oi + 0;
    let tail = oi + 16 * r;
    for (let i = 0; i < 16; i++)
      out[tail + i] = input[ii + (2 * r - 1) * 16 + i];
    for (let i = 0; i < r; i++, head += 16, ii += 16) {
      XorAndSalsa(out, tail, input, ii, out, head);
      if (i > 0)
        tail += 16;
      XorAndSalsa(out, head, input, ii += 16, out, tail);
    }
  }
  function scryptInit(password, salt, _opts) {
    const opts = checkOpts({
      dkLen: 32,
      asyncTick: 10,
      maxmem: 1024 ** 3 + 1024
    }, _opts);
    const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
    assert_default2.number(N);
    assert_default2.number(r);
    assert_default2.number(p);
    assert_default2.number(dkLen);
    assert_default2.number(asyncTick);
    assert_default2.number(maxmem);
    if (onProgress !== void 0 && typeof onProgress !== "function")
      throw new Error("progressCb should be function");
    const blockSize = 128 * r;
    const blockSize32 = blockSize / 4;
    if (N <= 1 || (N & N - 1) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {
      throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
    }
    if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {
      throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
    }
    if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
      throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
    }
    const memUsed = blockSize * (N + p);
    if (memUsed > maxmem) {
      throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
    }
    const B = pbkdf22(sha2562, password, salt, { c: 1, dkLen: blockSize * p });
    const B32 = u322(B);
    const V = u322(new Uint8Array(blockSize * N));
    const tmp = u322(new Uint8Array(blockSize));
    let blockMixCb = () => {
    };
    if (onProgress) {
      const totalBlockMix = 2 * N * p;
      const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
      let blockMixCnt = 0;
      blockMixCb = () => {
        blockMixCnt++;
        if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
          onProgress(blockMixCnt / totalBlockMix);
      };
    }
    return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
  }
  function scryptOutput(password, dkLen, B, V, tmp) {
    const res = pbkdf22(sha2562, password, B, { c: 1, dkLen });
    B.fill(0);
    V.fill(0);
    tmp.fill(0);
    return res;
  }
  function scrypt2(password, salt, opts) {
    const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
    for (let pi = 0; pi < p; pi++) {
      const Pi2 = blockSize32 * pi;
      for (let i = 0; i < blockSize32; i++)
        V[i] = B32[Pi2 + i];
      for (let i = 0, pos = 0; i < N - 1; i++) {
        BlockMix(V, pos, V, pos += blockSize32, r);
        blockMixCb();
      }
      BlockMix(V, (N - 1) * blockSize32, B32, Pi2, r);
      blockMixCb();
      for (let i = 0; i < N; i++) {
        const j = B32[Pi2 + blockSize32 - 16] % N;
        for (let k = 0; k < blockSize32; k++)
          tmp[k] = B32[Pi2 + k] ^ V[j * blockSize32 + k];
        BlockMix(tmp, 0, B32, Pi2, r);
        blockMixCb();
      }
    }
    return scryptOutput(password, dkLen, B, V, tmp);
  }

  // ../../node_modules/.pnpm/ethereum-cryptography@2.1.2/node_modules/ethereum-cryptography/esm/utils.js
  var assertBool = assert_default2.bool;
  var assertBytes = assert_default2.bytes;
  function wrapHash(hash5) {
    return (msg) => {
      assert_default2.bytes(msg);
      return hash5(msg);
    };
  }
  var crypto3 = (() => {
    const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
    const nodeRequire = typeof module !== "undefined" && typeof module.require === "function" && module.require.bind(module);
    return {
      node: nodeRequire && !webCrypto ? nodeRequire("crypto") : void 0,
      web: webCrypto
    };
  })();

  // ../../node_modules/.pnpm/ethereum-cryptography@2.1.2/node_modules/ethereum-cryptography/esm/scrypt.js
  function scryptSync2(password, salt, n, p, r, dkLen, onProgress) {
    assertBytes(password);
    assertBytes(salt);
    return scrypt2(password, salt, { N: n, r, p, dkLen, onProgress });
  }

  // ../../node_modules/.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/esm/_u64.js
  var U32_MASK642 = BigInt(2 ** 32 - 1);
  var _32n2 = BigInt(32);
  function fromBig2(n, le = false) {
    if (le)
      return { h: Number(n & U32_MASK642), l: Number(n >> _32n2 & U32_MASK642) };
    return { h: Number(n >> _32n2 & U32_MASK642) | 0, l: Number(n & U32_MASK642) | 0 };
  }
  function split2(lst, le = false) {
    let Ah = new Uint32Array(lst.length);
    let Al = new Uint32Array(lst.length);
    for (let i = 0; i < lst.length; i++) {
      const { h, l } = fromBig2(lst[i], le);
      [Ah[i], Al[i]] = [h, l];
    }
    return [Ah, Al];
  }
  var toBig2 = (h, l) => BigInt(h >>> 0) << _32n2 | BigInt(l >>> 0);
  var shrSH2 = (h, l, s) => h >>> s;
  var shrSL2 = (h, l, s) => h << 32 - s | l >>> s;
  var rotrSH2 = (h, l, s) => h >>> s | l << 32 - s;
  var rotrSL2 = (h, l, s) => h << 32 - s | l >>> s;
  var rotrBH2 = (h, l, s) => h << 64 - s | l >>> s - 32;
  var rotrBL2 = (h, l, s) => h >>> s - 32 | l << 64 - s;
  var rotr32H2 = (h, l) => l;
  var rotr32L2 = (h, l) => h;
  var rotlSH2 = (h, l, s) => h << s | l >>> 32 - s;
  var rotlSL2 = (h, l, s) => l << s | h >>> 32 - s;
  var rotlBH2 = (h, l, s) => l << s - 32 | h >>> 64 - s;
  var rotlBL2 = (h, l, s) => h << s - 32 | l >>> 64 - s;
  function add2(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
  }
  var add3L2 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
  var add3H2 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
  var add4L2 = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
  var add4H2 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
  var add5L2 = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
  var add5H2 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
  var u642 = {
    fromBig: fromBig2,
    split: split2,
    toBig: toBig2,
    shrSH: shrSH2,
    shrSL: shrSL2,
    rotrSH: rotrSH2,
    rotrSL: rotrSL2,
    rotrBH: rotrBH2,
    rotrBL: rotrBL2,
    rotr32H: rotr32H2,
    rotr32L: rotr32L2,
    rotlSH: rotlSH2,
    rotlSL: rotlSL2,
    rotlBH: rotlBH2,
    rotlBL: rotlBL2,
    add: add2,
    add3L: add3L2,
    add3H: add3H2,
    add4L: add4L2,
    add4H: add4H2,
    add5H: add5H2,
    add5L: add5L2
  };
  var u64_default2 = u642;

  // ../../node_modules/.pnpm/@noble+hashes@1.3.1/node_modules/@noble/hashes/esm/sha3.js
  var [SHA3_PI2, SHA3_ROTL2, _SHA3_IOTA2] = [[], [], []];
  var _0n2 = BigInt(0);
  var _1n2 = BigInt(1);
  var _2n2 = BigInt(2);
  var _7n2 = BigInt(7);
  var _256n2 = BigInt(256);
  var _0x71n2 = BigInt(113);
  for (let round = 0, R = _1n2, x = 1, y = 0; round < 24; round++) {
    [x, y] = [y, (2 * x + 3 * y) % 5];
    SHA3_PI2.push(2 * (5 * y + x));
    SHA3_ROTL2.push((round + 1) * (round + 2) / 2 % 64);
    let t = _0n2;
    for (let j = 0; j < 7; j++) {
      R = (R << _1n2 ^ (R >> _7n2) * _0x71n2) % _256n2;
      if (R & _2n2)
        t ^= _1n2 << (_1n2 << BigInt(j)) - _1n2;
    }
    _SHA3_IOTA2.push(t);
  }
  var [SHA3_IOTA_H2, SHA3_IOTA_L2] = u64_default2.split(_SHA3_IOTA2, true);
  var rotlH2 = (h, l, s) => s > 32 ? u64_default2.rotlBH(h, l, s) : u64_default2.rotlSH(h, l, s);
  var rotlL2 = (h, l, s) => s > 32 ? u64_default2.rotlBL(h, l, s) : u64_default2.rotlSL(h, l, s);
  function keccakP2(s, rounds = 24) {
    const B = new Uint32Array(5 * 2);
    for (let round = 24 - rounds; round < 24; round++) {
      for (let x = 0; x < 10; x++)
        B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
      for (let x = 0; x < 10; x += 2) {
        const idx1 = (x + 8) % 10;
        const idx0 = (x + 2) % 10;
        const B0 = B[idx0];
        const B1 = B[idx0 + 1];
        const Th = rotlH2(B0, B1, 1) ^ B[idx1];
        const Tl = rotlL2(B0, B1, 1) ^ B[idx1 + 1];
        for (let y = 0; y < 50; y += 10) {
          s[x + y] ^= Th;
          s[x + y + 1] ^= Tl;
        }
      }
      let curH = s[2];
      let curL = s[3];
      for (let t = 0; t < 24; t++) {
        const shift = SHA3_ROTL2[t];
        const Th = rotlH2(curH, curL, shift);
        const Tl = rotlL2(curH, curL, shift);
        const PI = SHA3_PI2[t];
        curH = s[PI];
        curL = s[PI + 1];
        s[PI] = Th;
        s[PI + 1] = Tl;
      }
      for (let y = 0; y < 50; y += 10) {
        for (let x = 0; x < 10; x++)
          B[x] = s[y + x];
        for (let x = 0; x < 10; x++)
          s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
      }
      s[0] ^= SHA3_IOTA_H2[round];
      s[1] ^= SHA3_IOTA_L2[round];
    }
    B.fill(0);
  }
  var Keccak2 = class extends Hash2 {
    // NOTE: we accept arguments in bytes instead of bits here.
    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
      super();
      this.blockLen = blockLen;
      this.suffix = suffix;
      this.outputLen = outputLen;
      this.enableXOF = enableXOF;
      this.rounds = rounds;
      this.pos = 0;
      this.posOut = 0;
      this.finished = false;
      this.destroyed = false;
      assert_default2.number(outputLen);
      if (0 >= this.blockLen || this.blockLen >= 200)
        throw new Error("Sha3 supports only keccak-f1600 function");
      this.state = new Uint8Array(200);
      this.state32 = u322(this.state);
    }
    keccak() {
      keccakP2(this.state32, this.rounds);
      this.posOut = 0;
      this.pos = 0;
    }
    update(data) {
      assert_default2.exists(this);
      const { blockLen, state } = this;
      data = toBytes3(data);
      const len = data.length;
      for (let pos = 0; pos < len; ) {
        const take = Math.min(blockLen - this.pos, len - pos);
        for (let i = 0; i < take; i++)
          state[this.pos++] ^= data[pos++];
        if (this.pos === blockLen)
          this.keccak();
      }
      return this;
    }
    finish() {
      if (this.finished)
        return;
      this.finished = true;
      const { state, suffix, pos, blockLen } = this;
      state[pos] ^= suffix;
      if ((suffix & 128) !== 0 && pos === blockLen - 1)
        this.keccak();
      state[blockLen - 1] ^= 128;
      this.keccak();
    }
    writeInto(out) {
      assert_default2.exists(this, false);
      assert_default2.bytes(out);
      this.finish();
      const bufferOut = this.state;
      const { blockLen } = this;
      for (let pos = 0, len = out.length; pos < len; ) {
        if (this.posOut >= blockLen)
          this.keccak();
        const take = Math.min(blockLen - this.posOut, len - pos);
        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
        this.posOut += take;
        pos += take;
      }
      return out;
    }
    xofInto(out) {
      if (!this.enableXOF)
        throw new Error("XOF is not possible for this instance");
      return this.writeInto(out);
    }
    xof(bytes3) {
      assert_default2.number(bytes3);
      return this.xofInto(new Uint8Array(bytes3));
    }
    digestInto(out) {
      assert_default2.output(out, this);
      if (this.finished)
        throw new Error("digest() was already called");
      this.writeInto(out);
      this.destroy();
      return out;
    }
    digest() {
      return this.digestInto(new Uint8Array(this.outputLen));
    }
    destroy() {
      this.destroyed = true;
      this.state.fill(0);
    }
    _cloneInto(to) {
      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
      to || (to = new Keccak2(blockLen, suffix, outputLen, enableXOF, rounds));
      to.state32.set(this.state32);
      to.pos = this.pos;
      to.posOut = this.posOut;
      to.finished = this.finished;
      to.rounds = rounds;
      to.suffix = suffix;
      to.outputLen = outputLen;
      to.enableXOF = enableXOF;
      to.destroyed = this.destroyed;
      return to;
    }
  };
  var gen2 = (suffix, blockLen, outputLen) => wrapConstructor2(() => new Keccak2(blockLen, suffix, outputLen));
  var sha3_2242 = gen2(6, 144, 224 / 8);
  var sha3_2562 = gen2(6, 136, 256 / 8);
  var sha3_3842 = gen2(6, 104, 384 / 8);
  var sha3_5122 = gen2(6, 72, 512 / 8);
  var keccak_2242 = gen2(1, 144, 224 / 8);
  var keccak_2562 = gen2(1, 136, 256 / 8);
  var keccak_3842 = gen2(1, 104, 384 / 8);
  var keccak_5122 = gen2(1, 72, 512 / 8);
  var genShake2 = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak2(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
  var shake1282 = genShake2(31, 168, 128 / 8);
  var shake2562 = genShake2(31, 136, 256 / 8);

  // ../../node_modules/.pnpm/ethereum-cryptography@2.1.2/node_modules/ethereum-cryptography/esm/keccak.js
  var keccak224 = wrapHash(keccak_2242);
  var keccak2562 = (() => {
    const k = wrapHash(keccak_2562);
    k.create = keccak_2562.create;
    return k;
  })();
  var keccak384 = wrapHash(keccak_3842);
  var keccak512 = wrapHash(keccak_5122);

  // ../crypto/dist/index.mjs
  var import_crypto9 = __toESM(__require2("crypto"), 1);
  var import_crypto10 = __toESM(__require2("crypto"), 1);
  var import_crypto11 = __toESM(__require2("crypto"), 1);
  var scrypt3 = (params) => {
    const { password, salt, n, p, r, dklen } = params;
    const derivedKey = scryptSync2(password, salt, n, r, p, dklen);
    return derivedKey;
  };
  var keccak2563 = (data) => keccak2562(data);
  var bufferFromString = (string2, encoding = "base64") => Uint8Array.from(Buffer.from(string2, encoding));
  var randomBytes3 = (length) => {
    const randomValues = Uint8Array.from(import_crypto10.default.randomBytes(length));
    return randomValues;
  };
  var stringFromBuffer = (buffer, encoding = "base64") => Buffer.from(buffer).toString(encoding);
  var ALGORITHM = "aes-256-ctr";
  var keyFromPassword = (password, saltBuffer) => {
    const passBuffer = bufferFromString(String(password).normalize("NFKC"), "utf-8");
    const key = pbkdf2(passBuffer, saltBuffer, 1e5, 32, "sha256");
    return getBytesCopy(key);
  };
  var encrypt = async (password, data) => {
    const iv = randomBytes3(16);
    const salt = randomBytes3(32);
    const secret = keyFromPassword(password, salt);
    const dataBuffer = Uint8Array.from(Buffer.from(JSON.stringify(data), "utf-8"));
    const cipher = await import_crypto9.default.createCipheriv(ALGORITHM, secret, iv);
    let cipherData = cipher.update(dataBuffer);
    cipherData = Buffer.concat([cipherData, cipher.final()]);
    return {
      data: stringFromBuffer(cipherData),
      iv: stringFromBuffer(iv),
      salt: stringFromBuffer(salt)
    };
  };
  var decrypt = async (password, keystore) => {
    const iv = bufferFromString(keystore.iv);
    const salt = bufferFromString(keystore.salt);
    const secret = keyFromPassword(password, salt);
    const encryptedText = bufferFromString(keystore.data);
    const decipher = await import_crypto9.default.createDecipheriv(ALGORITHM, secret, iv);
    const decrypted = decipher.update(encryptedText);
    const deBuff = Buffer.concat([decrypted, decipher.final()]);
    const decryptedData = Buffer.from(deBuff).toString("utf-8");
    try {
      return JSON.parse(decryptedData);
    } catch {
      throw new FuelError(ErrorCode.INVALID_CREDENTIALS, "Invalid credentials.");
    }
  };
  async function encryptJsonWalletData(data, key, iv) {
    const cipher = await import_crypto11.default.createCipheriv("aes-128-ctr", key.subarray(0, 16), iv);
    const encrypted = Buffer.concat([cipher.update(data), cipher.final()]);
    return new Uint8Array(encrypted);
  }
  async function decryptJsonWalletData(data, key, iv) {
    const decipher = import_crypto11.default.createDecipheriv("aes-128-ctr", key.subarray(0, 16), iv);
    const decrypted = await Buffer.concat([decipher.update(data), decipher.final()]);
    return new Uint8Array(decrypted);
  }
  var api = {
    bufferFromString,
    stringFromBuffer,
    decrypt,
    encrypt,
    keyFromPassword,
    randomBytes: randomBytes3,
    scrypt: scrypt3,
    keccak256: keccak2563,
    decryptJsonWalletData,
    encryptJsonWalletData
  };
  var node_default = api;
  var {
    bufferFromString: bufferFromString2,
    decrypt: decrypt2,
    encrypt: encrypt2,
    keyFromPassword: keyFromPassword2,
    randomBytes: randomBytes22,
    stringFromBuffer: stringFromBuffer2,
    scrypt: scrypt22,
    keccak256: keccak25622,
    decryptJsonWalletData: decryptJsonWalletData2,
    encryptJsonWalletData: encryptJsonWalletData2
  } = node_default;

  // ../interfaces/dist/index.mjs
  var AbstractAddress = class {
  };
  var AbstractAccount = class {
  };
  var AbstractProgram = class {
  };
  var AbstractContract = class extends AbstractProgram {
  };

  // ../address/dist/index.mjs
  var import_bech32 = __toESM(require_dist(), 1);
  var FUEL_BECH32_HRP_PREFIX = "fuel";
  function fromBech32(address) {
    return import_bech32.bech32m.decode(address);
  }
  function toBech32(address) {
    return import_bech32.bech32m.encode(
      FUEL_BECH32_HRP_PREFIX,
      import_bech32.bech32m.toWords(getBytesCopy(hexlify(address)))
    );
  }
  function isBech32(address) {
    return typeof address === "string" && address.indexOf(FUEL_BECH32_HRP_PREFIX + 1) === 0 && fromBech32(address).prefix === FUEL_BECH32_HRP_PREFIX;
  }
  function isB256(address) {
    return address.length === 66 && /(0x)[0-9a-f]{64}$/i.test(address);
  }
  function isPublicKey(address) {
    return address.length === 130 && /(0x)[0-9a-f]{128}$/i.test(address);
  }
  function isEvmAddress(address) {
    return address.length === 42 && /(0x)[0-9a-f]{40}$/i.test(address);
  }
  function getBytesFromBech32(address) {
    return new Uint8Array(import_bech32.bech32m.fromWords(fromBech32(address).words));
  }
  function toB256(address) {
    if (!isBech32(address)) {
      throw new FuelError(
        FuelError.CODES.INVALID_BECH32_ADDRESS,
        `Invalid Bech32 Address: ${address}.`
      );
    }
    return hexlify(getBytesFromBech32(address));
  }
  function normalizeBech32(address) {
    const { words } = fromBech32(address);
    return import_bech32.bech32m.encode(FUEL_BECH32_HRP_PREFIX, words);
  }
  var addressify = (addressLike) => {
    if (addressLike instanceof AbstractAccount) {
      return addressLike.address;
    }
    if (addressLike instanceof AbstractContract) {
      return addressLike.id;
    }
    return addressLike;
  };
  var getRandomB256 = () => hexlify(randomBytes22(32));
  var clearFirst12BytesFromB256 = (b256) => {
    let bytes3;
    try {
      if (!isB256(b256)) {
        throw new FuelError(
          FuelError.CODES.INVALID_BECH32_ADDRESS,
          `Invalid Bech32 Address: ${b256}.`
        );
      }
      bytes3 = getBytesFromBech32(toBech32(b256));
      bytes3 = hexlify(bytes3.fill(0, 0, 12));
    } catch (error2) {
      throw new FuelError(
        FuelError.CODES.PARSE_FAILED,
        `Cannot generate EVM Address B256 from: ${b256}.`
      );
    }
    return bytes3;
  };
  var padFirst12BytesOfEvmAddress = (address) => {
    if (!isEvmAddress(address)) {
      throw new FuelError(FuelError.CODES.INVALID_EVM_ADDRESS, "Invalid EVM address format.");
    }
    return address.replace("0x", "0x000000000000000000000000");
  };
  var Address = class extends AbstractAddress {
    // #region address-2
    bech32Address;
    // #endregion address-2
    /**
     * @param address - A Bech32 address
     */
    constructor(address) {
      super();
      this.bech32Address = normalizeBech32(address);
      if (!isBech32(this.bech32Address)) {
        throw new FuelError(
          FuelError.CODES.INVALID_BECH32_ADDRESS,
          `Invalid Bech32 Address: ${address}.`
        );
      }
    }
    /**
     * Returns the `bech32Address` property
     *
     * @returns The `bech32Address` property
     */
    toAddress() {
      return this.bech32Address;
    }
    /**
     * Converts and returns the `bech32Address` property to a 256 bit hash string
     *
     * @returns The `bech32Address` property as a 256 bit hash string
     */
    toB256() {
      return toB256(this.bech32Address);
    }
    /**
     * Converts and returns the `bech32Address` property to a byte array
     *
     * @returns The `bech32Address` property as a byte array
     */
    toBytes() {
      return getBytesFromBech32(this.bech32Address);
    }
    /**
     * Converts
     *
     * @returns The `bech32Address` property as a 256 bit hash string
     */
    toHexString() {
      return this.toB256();
    }
    /**
     * Converts and returns the `bech32Address` property as a string
     *
     * @returns The `bech32Address` property as a string
     */
    toString() {
      return this.bech32Address;
    }
    /**
     * Converts and returns the `bech32Address` property as a string
     *
     * @returns The `bech32Address` property as a string
     */
    toJSON() {
      return this.bech32Address;
    }
    /**
     * Clears the first 12 bytes of the `bech32Address` property and returns it as a `EvmAddress`
     *
     * @returns The `bech32Address` property as an {@link EvmAddress | `EvmAddress`}
     */
    toEvmAddress() {
      const b256Address = toB256(this.bech32Address);
      return {
        value: clearFirst12BytesFromB256(b256Address)
      };
    }
    /**
     * Wraps the `bech32Address` property and returns as an `AssetId`.
     *
     * @returns The `bech32Address` property as an {@link AssetId | `AssetId`}
     */
    toAssetId() {
      return {
        value: this.toB256()
      };
    }
    /**
     * Returns the value of the `bech32Address` property
     *
     * @returns The value of `bech32Address` property
     */
    valueOf() {
      return this.bech32Address;
    }
    /**
     * Compares this the `bech32Address` property to another for direct equality
     *
     * @param other - Another address to compare against
     * @returns The equality of the comparison
     */
    equals(other) {
      return this.bech32Address === other.bech32Address;
    }
    /**
     * Takes a Public Key, hashes it, and creates an `Address`
     *
     * @param publicKey - A wallets public key
     * @returns A new `Address` instance
     */
    static fromPublicKey(publicKey) {
      if (!isPublicKey(publicKey)) {
        throw new FuelError(FuelError.CODES.INVALID_PUBLIC_KEY, `Invalid Public Key: ${publicKey}.`);
      }
      const b256Address = sha256(hexlify(getBytesCopy(publicKey)));
      return new Address(toBech32(b256Address));
    }
    /**
     * Takes a B256 Address and creates an `Address`
     *
     * @param b256Address - A b256 hash
     * @returns A new `Address` instance
     */
    static fromB256(b256Address) {
      if (!isB256(b256Address)) {
        throw new FuelError(
          FuelError.CODES.INVALID_B256_ADDRESS,
          `Invalid B256 Address: ${b256Address}.`
        );
      }
      return new Address(toBech32(b256Address));
    }
    /**
     * Creates an `Address` with a randomized `bech32Address` property
     *
     * @returns A new `Address` instance
     */
    static fromRandom() {
      return this.fromB256(getRandomB256());
    }
    /**
     * Takes an ambiguous string and attempts to create an `Address`
     *
     * @param address - An ambiguous string
     * @returns A new `Address` instance
     */
    static fromString(address) {
      return isBech32(address) ? new Address(address) : this.fromB256(address);
    }
    /**
     * Takes an ambiguous string or address and creates an `Address`
     *
     * @returns a new `Address` instance
     */
    static fromAddressOrString(address) {
      return typeof address === "string" ? this.fromString(address) : address;
    }
    /**
     * Takes a dynamic string or `AbstractAddress` and creates an `Address`
     *
     * @param addressId - A string containing Bech32, B256, or Public Key
     * @throws Error - Unknown address if the format is not recognised
     * @returns A new `Address` instance
     */
    static fromDynamicInput(address) {
      if (typeof address !== "string" && "toB256" in address) {
        return Address.fromB256(address.toB256());
      }
      if (isPublicKey(address)) {
        return Address.fromPublicKey(address);
      }
      if (isBech32(address)) {
        return new Address(address);
      }
      if (isB256(address)) {
        return Address.fromB256(address);
      }
      if (isEvmAddress(address)) {
        return Address.fromEvmAddress(address);
      }
      throw new FuelError(
        FuelError.CODES.PARSE_FAILED,
        `Unknown address format: only 'Bech32', 'B256', or 'Public Key (512)' are supported.`
      );
    }
    /**
     * Takes an Evm Address and returns back an `Address`
     *
     * @returns A new `Address` instance
     */
    static fromEvmAddress(evmAddress) {
      if (!isEvmAddress(evmAddress)) {
        throw new FuelError(
          FuelError.CODES.INVALID_EVM_ADDRESS,
          `Invalid Evm Address: ${evmAddress}.`
        );
      }
      const paddedAddress = padFirst12BytesOfEvmAddress(evmAddress);
      return new Address(toBech32(paddedAddress));
    }
  };

  // ../abi-coder/dist/index.mjs
  var __defProp5 = Object.defineProperty;
  var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField5 = (obj, key, value) => {
    __defNormalProp5(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var __accessCheck2 = (obj, member, msg) => {
    if (!member.has(obj))
      throw TypeError("Cannot " + msg);
  };
  var __privateAdd2 = (obj, member, value) => {
    if (member.has(obj))
      throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  };
  var __privateMethod2 = (obj, member, method) => {
    __accessCheck2(obj, member, "access private method");
    return method;
  };
  var Coder = class {
    name;
    type;
    encodedLength;
    constructor(name, type3, encodedLength) {
      this.name = name;
      this.type = type3;
      this.encodedLength = encodedLength;
    }
    throwError(errorCode, message) {
      throw new FuelError(errorCode, message);
    }
  };
  var U64Coder = class extends Coder {
    constructor() {
      super("u64", "u64", 8);
    }
    encode(value) {
      let bytes3;
      try {
        bytes3 = toBytes2(value, 8);
      } catch (error2) {
        this.throwError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);
      }
      return bytes3;
    }
    decode(data, offset) {
      let bytes3 = data.slice(offset, offset + 8);
      bytes3 = bytes3.slice(0, 8);
      return [bn(bytes3), offset + 8];
    }
  };
  var OPTION_CODER_TYPE = "enum Option";
  var VEC_CODER_TYPE = "struct Vec";
  var BYTES_CODER_TYPE = "struct Bytes";
  var STD_STRING_CODER_TYPE = "struct String";
  var stringRegEx = /str\[(?<length>[0-9]+)\]/;
  var arrayRegEx = /\[(?<item>[\w\s\\[\]]+);\s*(?<length>[0-9]+)\]/;
  var structRegEx = /^struct (?<name>\w+)$/;
  var enumRegEx = /^enum (?<name>\w+)$/;
  var tupleRegEx = /^\((?<items>.*)\)$/;
  var genericRegEx = /^generic (?<name>\w+)$/;
  var WORD_SIZE = 8;
  var BYTES_32 = 32;
  var ASSET_ID_LEN = BYTES_32;
  var CONTRACT_ID_LEN = BYTES_32;
  var ADDRESS_LEN = BYTES_32;
  var NONCE_LEN = BYTES_32;
  var UTXO_LEN = WORD_SIZE * 5;
  var TX_POINTER_LEN = WORD_SIZE * 2;
  var calculateVmTxMemory = ({ maxInputs }) => BYTES_32 + // Tx ID
  WORD_SIZE + // Tx size
  // Asset ID/Balance coin input pairs
  maxInputs * (ASSET_ID_LEN + WORD_SIZE);
  var SCRIPT_FIXED_SIZE = WORD_SIZE + // Identifier
  WORD_SIZE + // Gas price
  WORD_SIZE + // Gas limit
  WORD_SIZE + // Maturity
  WORD_SIZE + // Script size
  WORD_SIZE + // Script data size
  WORD_SIZE + // Inputs size
  WORD_SIZE + // Outputs size
  WORD_SIZE + // Witnesses size
  BYTES_32;
  var INPUT_COIN_FIXED_SIZE = WORD_SIZE + // Identifier
  UTXO_LEN + // Utxo Length
  ADDRESS_LEN + // Owner
  WORD_SIZE + // Amount
  ASSET_ID_LEN + // Asset id
  TX_POINTER_LEN + // TxPointer
  WORD_SIZE + // Witnesses index
  WORD_SIZE + // Maturity
  WORD_SIZE + // Predicate size
  WORD_SIZE + // Predicate data size
  WORD_SIZE;
  var INPUT_MESSAGE_FIXED_SIZE = WORD_SIZE + // Identifier
  ADDRESS_LEN + // Sender
  ADDRESS_LEN + // Recipient
  WORD_SIZE + // Amount
  NONCE_LEN + // Nonce
  WORD_SIZE + // witness_index
  WORD_SIZE + // Data size
  WORD_SIZE + // Predicate size
  WORD_SIZE + // Predicate data size
  WORD_SIZE;
  var VEC_PROPERTY_SPACE = 3;
  var BASE_VECTOR_OFFSET = VEC_PROPERTY_SPACE * WORD_SIZE;
  var RAW_SLICE_PROPERTY_SPACE = 2;
  var BASE_RAW_SLICE_OFFSET = RAW_SLICE_PROPERTY_SPACE * WORD_SIZE;
  function concatWithDynamicData(items) {
    const topLevelData = {};
    let totalIndex = 0;
    const objects = items.map((item) => {
      const dynamicData = item.dynamicData;
      if (dynamicData) {
        Object.entries(dynamicData).forEach(([pointerIndex, vData]) => {
          topLevelData[parseInt(pointerIndex, 10) + totalIndex] = vData;
        });
      }
      const byteArray = getBytesCopy(item);
      totalIndex += byteArray.byteLength / WORD_SIZE;
      return byteArray;
    });
    const length = objects.reduce((accum, item) => accum + item.length, 0);
    const result = new Uint8Array(length);
    objects.reduce((offset, object2) => {
      result.set(object2, offset);
      return offset + object2.length;
    }, 0);
    if (Object.keys(topLevelData).length) {
      result.dynamicData = topLevelData;
    }
    return result;
  }
  function unpackDynamicData(results, baseOffset, dataOffset) {
    if (!results.dynamicData) {
      return concat2([results]);
    }
    let cumulativeDynamicByteLength = 0;
    let updatedResults = results;
    Object.entries(results.dynamicData).forEach(([pointerIndex, vData]) => {
      const pointerOffset = parseInt(pointerIndex, 10) * WORD_SIZE;
      const adjustedValue = new U64Coder().encode(
        dataOffset + baseOffset + cumulativeDynamicByteLength
      );
      updatedResults.set(adjustedValue, pointerOffset);
      const dataToAppend = vData.dynamicData ? (
        // unpack child dynamic data
        unpackDynamicData(
          vData,
          baseOffset,
          dataOffset + vData.byteLength + cumulativeDynamicByteLength
        )
      ) : vData;
      updatedResults = concat2([updatedResults, dataToAppend]);
      cumulativeDynamicByteLength += dataToAppend.byteLength;
    });
    return updatedResults;
  }
  var chunkByLength = (data, length = WORD_SIZE) => {
    const chunks = [];
    let offset = 0;
    let chunk = data.slice(offset, offset + length);
    while (chunk.length) {
      chunks.push(chunk);
      offset += length;
      chunk = data.slice(offset, offset + length);
    }
    return chunks;
  };
  var isPointerType = (type3) => {
    switch (type3) {
      case "u8":
      case "u16":
      case "u32":
      case "u64":
      case "bool": {
        return false;
      }
      default: {
        return true;
      }
    }
  };
  var isHeapType = (type3) => type3 === VEC_CODER_TYPE || type3 === BYTES_CODER_TYPE || type3 === STD_STRING_CODER_TYPE;
  function findOrThrow(arr, predicate, throwFn = () => {
    throw new FuelError(ErrorCode.ELEMENT_NOT_FOUND, "Element not found in the array.");
  }) {
    const found = arr.find(predicate);
    if (found === void 0) {
      throwFn();
    }
    return found;
  }
  var ArrayCoder = class extends Coder {
    coder;
    length;
    constructor(coder, length) {
      super("array", `[${coder.type}; ${length}]`, length * coder.encodedLength);
      this.coder = coder;
      this.length = length;
    }
    encode(value) {
      if (!Array.isArray(value)) {
        this.throwError(ErrorCode.ENCODE_ERROR, `Expected array value.`);
      }
      if (this.length !== value.length) {
        this.throwError(ErrorCode.ENCODE_ERROR, `Types/values length mismatch.`);
      }
      return concatWithDynamicData(Array.from(value).map((v) => this.coder.encode(v)));
    }
    decode(data, offset) {
      let newOffset = offset;
      const decodedValue = Array(this.length).fill(0).map(() => {
        let decoded;
        [decoded, newOffset] = this.coder.decode(data, newOffset);
        return decoded;
      });
      return [decodedValue, newOffset];
    }
  };
  var B256Coder = class extends Coder {
    constructor() {
      super("b256", "b256", 32);
    }
    encode(value) {
      let encodedValue;
      try {
        encodedValue = getBytesCopy(value);
      } catch (error2) {
        this.throwError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);
      }
      if (encodedValue.length !== 32) {
        this.throwError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);
      }
      return encodedValue;
    }
    decode(data, offset) {
      let bytes3 = data.slice(offset, offset + 32);
      const decoded = bn(bytes3);
      if (decoded.isZero()) {
        bytes3 = new Uint8Array(32);
      }
      if (bytes3.length !== 32) {
        this.throwError(ErrorCode.DECODE_ERROR, `'Invalid size for b256'.`);
      }
      return [toHex(bytes3, 32), offset + 32];
    }
  };
  var B512Coder = class extends Coder {
    constructor() {
      super("b512", "struct B512", 64);
    }
    encode(value) {
      let encodedValue;
      try {
        encodedValue = getBytesCopy(value);
      } catch (error2) {
        this.throwError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);
      }
      if (encodedValue.length !== 64) {
        this.throwError(ErrorCode.ENCODE_ERROR, `Invalid ${this.type}.`);
      }
      return encodedValue;
    }
    decode(data, offset) {
      let bytes3 = data.slice(offset, offset + 64);
      const decoded = bn(bytes3);
      if (decoded.isZero()) {
        bytes3 = new Uint8Array(64);
      }
      if (bytes3.length !== 64) {
        this.throwError(ErrorCode.DECODE_ERROR, `Invalid size for b512.`);
      }
      return [toHex(bytes3, 64), offset + 64];
    }
  };
  var BooleanCoder = class extends Coder {
    constructor() {
      super("boolean", "boolean", 8);
    }
    encode(value) {
      const isTrueBool = value === true || value === false;
      if (!isTrueBool) {
        this.throwError(ErrorCode.ENCODE_ERROR, `Invalid boolean value.`);
      }
      return toBytes2(value ? 1 : 0, 8);
    }
    decode(data, offset) {
      const bytes3 = bn(data.slice(offset, offset + 8));
      if (bytes3.isZero()) {
        return [false, offset + 8];
      }
      if (!bytes3.eq(bn(1))) {
        this.throwError(ErrorCode.DECODE_ERROR, `Invalid boolean value.`);
      }
      return [true, offset + 8];
    }
  };
  var isFullyNativeEnum = (enumCoders) => Object.values(enumCoders).every(
    // @ts-expect-error complicated types
    ({ type: type3, coders }) => type3 === "()" && JSON.stringify(coders) === JSON.stringify([])
  );
  var EnumCoder = class extends Coder {
    name;
    coders;
    #caseIndexCoder;
    #encodedValueSize;
    constructor(name, coders) {
      const caseIndexCoder = new U64Coder();
      const encodedValueSize = Object.values(coders).reduce(
        (max2, coder) => Math.max(max2, coder.encodedLength),
        0
      );
      super("enum", `enum ${name}`, caseIndexCoder.encodedLength + encodedValueSize);
      this.name = name;
      this.coders = coders;
      this.#caseIndexCoder = caseIndexCoder;
      this.#encodedValueSize = encodedValueSize;
    }
    #encodeNativeEnum(value) {
      const valueCoder = this.coders[value];
      const encodedValue = valueCoder.encode([]);
      const caseIndex = Object.keys(this.coders).indexOf(value);
      const padding = new Uint8Array(this.#encodedValueSize - valueCoder.encodedLength);
      return concat2([this.#caseIndexCoder.encode(caseIndex), padding, encodedValue]);
    }
    encode(value) {
      if (typeof value === "string" && this.coders[value]) {
        return this.#encodeNativeEnum(value);
      }
      const [caseKey, ...empty] = Object.keys(value);
      if (!caseKey) {
        throw new FuelError(ErrorCode.INVALID_DECODE_VALUE, "A field for the case must be provided.");
      }
      if (empty.length !== 0) {
        throw new FuelError(ErrorCode.INVALID_DECODE_VALUE, "Only one field must be provided.");
      }
      const valueCoder = this.coders[caseKey];
      const caseIndex = Object.keys(this.coders).indexOf(caseKey);
      const encodedValue = valueCoder.encode(value[caseKey]);
      const padding = new Uint8Array(this.#encodedValueSize - valueCoder.encodedLength);
      return concatWithDynamicData([this.#caseIndexCoder.encode(caseIndex), padding, encodedValue]);
    }
    #decodeNativeEnum(caseKey, newOffset) {
      return [caseKey, newOffset];
    }
    decode(data, offset) {
      let newOffset = offset;
      let decoded;
      [decoded, newOffset] = new U64Coder().decode(data, newOffset);
      const caseIndex = toNumber2(decoded);
      const caseKey = Object.keys(this.coders)[caseIndex];
      if (!caseKey) {
        throw new FuelError(
          ErrorCode.INVALID_DECODE_VALUE,
          `Invalid caseIndex "${caseIndex}". Valid cases: ${Object.keys(this.coders)}.`
        );
      }
      const valueCoder = this.coders[caseKey];
      const padding = this.#encodedValueSize - valueCoder.encodedLength;
      newOffset += padding;
      [decoded, newOffset] = valueCoder.decode(data, newOffset);
      if (isFullyNativeEnum(this.coders)) {
        return this.#decodeNativeEnum(caseKey, newOffset);
      }
      return [{ [caseKey]: decoded }, newOffset];
    }
  };
  var NumberCoder = class extends Coder {
    // This is to align the bits to the total bytes
    // See https://github.com/FuelLabs/fuel-specs/blob/master/specs/protocol/abi.md#unsigned-integers
    length;
    baseType;
    constructor(baseType) {
      super("number", baseType, 8);
      this.baseType = baseType;
      switch (baseType) {
        case "u8":
          this.length = 1;
          break;
        case "u16":
          this.length = 2;
          break;
        case "u32":
        default:
          this.length = 4;
          break;
      }
    }
    encode(value) {
      let bytes3;
      try {
        bytes3 = toBytes2(value);
      } catch (error2) {
        this.throwError(ErrorCode.ENCODE_ERROR, `Invalid ${this.baseType}.`);
      }
      if (bytes3.length > this.length) {
        this.throwError(ErrorCode.ENCODE_ERROR, `Invalid ${this.baseType}, too many bytes.`);
      }
      return toBytes2(bytes3, 8);
    }
    decode(data, offset) {
      let bytes3 = data.slice(offset, offset + 8);
      bytes3 = bytes3.slice(8 - this.length, 8);
      return [toNumber2(bytes3), offset + 8];
    }
  };
  var StringCoder = class extends Coder {
    length;
    #paddingLength;
    constructor(length) {
      let paddingLength = (8 - length) % 8;
      paddingLength = paddingLength < 0 ? paddingLength + 8 : paddingLength;
      super("string", `str[${length}]`, length + paddingLength);
      this.length = length;
      this.#paddingLength = paddingLength;
    }
    encode(value) {
      if (this.length !== value.length) {
        this.throwError(ErrorCode.ENCODE_ERROR, `Value length mismatch during encode.`);
      }
      const encoded = toUtf8Bytes(value);
      const padding = new Uint8Array(this.#paddingLength);
      return concat2([encoded, padding]);
    }
    decode(data, offset) {
      const bytes3 = data.slice(offset, offset + this.length);
      const value = toUtf8String(bytes3);
      const padding = this.#paddingLength;
      return [value, offset + this.length + padding];
    }
  };
  var OptionCoder = class extends EnumCoder {
    encode(value) {
      const result = super.encode(this.toSwayOption(value));
      return result;
    }
    toSwayOption(input) {
      if (input !== void 0) {
        return { Some: input };
      }
      return { None: [] };
    }
    decode(data, offset) {
      const [decoded, newOffset] = super.decode(data, offset);
      return [this.toOption(decoded), newOffset];
    }
    toOption(output3) {
      if (output3 && "Some" in output3) {
        return output3.Some;
      }
      return void 0;
    }
  };
  var StructCoder = class extends Coder {
    name;
    coders;
    constructor(name, coders) {
      const encodedLength = Object.values(coders).reduce(
        (acc, coder) => acc + coder.encodedLength,
        0
      );
      super("struct", `struct ${name}`, encodedLength);
      this.name = name;
      this.coders = coders;
    }
    encode(value) {
      const encodedFields = Object.keys(this.coders).map((fieldName) => {
        const fieldCoder = this.coders[fieldName];
        const fieldValue = value[fieldName];
        if (!(fieldCoder instanceof OptionCoder) && fieldValue == null) {
          this.throwError(
            ErrorCode.ENCODE_ERROR,
            `Invalid ${this.type}. Field "${fieldName}" not present.`
          );
        }
        const encoded = fieldCoder.encode(fieldValue);
        return encoded;
      });
      return concatWithDynamicData([concatWithDynamicData(encodedFields)]);
    }
    decode(data, offset) {
      let newOffset = offset;
      const decodedValue = Object.keys(this.coders).reduce((obj, fieldName) => {
        const fieldCoder = this.coders[fieldName];
        let decoded;
        [decoded, newOffset] = fieldCoder.decode(data, newOffset);
        obj[fieldName] = decoded;
        return obj;
      }, {});
      return [decodedValue, newOffset];
    }
  };
  var TupleCoder = class extends Coder {
    coders;
    constructor(coders) {
      const encodedLength = coders.reduce((acc, coder) => acc + coder.encodedLength, 0);
      super("tuple", `(${coders.map((coder) => coder.type).join(", ")})`, encodedLength);
      this.coders = coders;
    }
    encode(value) {
      if (this.coders.length !== value.length) {
        this.throwError(ErrorCode.ENCODE_ERROR, `Types/values length mismatch.`);
      }
      return concatWithDynamicData(this.coders.map((coder, i) => coder.encode(value[i])));
    }
    decode(data, offset) {
      let newOffset = offset;
      const decodedValue = this.coders.map((coder) => {
        let decoded;
        [decoded, newOffset] = coder.decode(data, newOffset);
        return decoded;
      });
      return [decodedValue, newOffset];
    }
  };
  var VecCoder = class extends Coder {
    coder;
    constructor(coder) {
      super("struct", `struct Vec`, coder.encodedLength + BASE_VECTOR_OFFSET);
      this.coder = coder;
    }
    encode(value) {
      if (!Array.isArray(value)) {
        this.throwError(ErrorCode.ENCODE_ERROR, `Expected array value.`);
      }
      const parts = [];
      const pointer = new U64Coder().encode(BASE_VECTOR_OFFSET);
      pointer.dynamicData = {
        0: concatWithDynamicData(Array.from(value).map((v) => this.coder.encode(v)))
      };
      parts.push(pointer);
      parts.push(new U64Coder().encode(value.length));
      parts.push(new U64Coder().encode(value.length));
      return concatWithDynamicData(parts);
    }
    decode(data, offset) {
      const len = data.slice(16, 24);
      const length = bn(new U64Coder().decode(len, 0)[0]).toNumber();
      const vectorRawData = data.slice(
        BASE_VECTOR_OFFSET,
        BASE_VECTOR_OFFSET + length * this.coder.encodedLength
      );
      return [
        chunkByLength(vectorRawData, this.coder.encodedLength).map(
          (chunk) => this.coder.decode(chunk, 0)[0]
        ),
        offset + BASE_VECTOR_OFFSET
      ];
    }
  };
  var _getPaddedData;
  var getPaddedData_fn;
  var ByteCoder = class extends Coder {
    constructor() {
      super("struct", "struct Bytes", BASE_VECTOR_OFFSET);
      __privateAdd2(this, _getPaddedData);
    }
    encode(value) {
      if (!Array.isArray(value)) {
        this.throwError(ErrorCode.ENCODE_ERROR, `Expected array value.`);
      }
      const parts = [];
      const pointer = new U64Coder().encode(BASE_VECTOR_OFFSET);
      const data = __privateMethod2(this, _getPaddedData, getPaddedData_fn).call(this, value);
      pointer.dynamicData = {
        0: concatWithDynamicData([data])
      };
      parts.push(pointer);
      parts.push(new U64Coder().encode(data.byteLength));
      parts.push(new U64Coder().encode(value.length));
      return concatWithDynamicData(parts);
    }
    decode(data, offset) {
      const len = data.slice(16, 24);
      const length = bn(new U64Coder().decode(len, 0)[0]).toNumber();
      const byteData = data.slice(BASE_VECTOR_OFFSET, BASE_VECTOR_OFFSET + length * 8);
      return [byteData, offset + BASE_VECTOR_OFFSET];
    }
  };
  _getPaddedData = /* @__PURE__ */ new WeakSet();
  getPaddedData_fn = function(value) {
    const data = [Uint8Array.from(value)];
    const paddingLength = (WORD_SIZE - value.length % WORD_SIZE) % WORD_SIZE;
    if (paddingLength) {
      data.push(new Uint8Array(paddingLength));
    }
    return concat2(data);
  };
  __publicField5(ByteCoder, "memorySize", 1);
  var RawSliceCoder = class extends Coder {
    constructor() {
      super("raw untyped slice", "raw untyped slice", BASE_RAW_SLICE_OFFSET);
    }
    encode(value) {
      if (!Array.isArray(value)) {
        this.throwError(ErrorCode.ENCODE_ERROR, `Expected array value.`);
      }
      const parts = [];
      const coder = new U64Coder();
      const pointer = new U64Coder().encode(BASE_RAW_SLICE_OFFSET);
      pointer.dynamicData = {
        0: concatWithDynamicData(value.map((v) => coder.encode(v)))
      };
      parts.push(pointer);
      parts.push(new U64Coder().encode(value.length * WORD_SIZE));
      return concatWithDynamicData(parts);
    }
    decode(data, offset) {
      const internalCoder = new ArrayCoder(new U64Coder(), data.length / 8);
      const decoded = internalCoder.decode(data, offset);
      return decoded;
    }
  };
  var _getPaddedData2;
  var getPaddedData_fn2;
  var StdStringCoder = class extends Coder {
    constructor() {
      super("struct", "struct String", 1);
      __privateAdd2(this, _getPaddedData2);
    }
    encode(value) {
      const parts = [];
      const pointer = new U64Coder().encode(BASE_VECTOR_OFFSET);
      const data = __privateMethod2(this, _getPaddedData2, getPaddedData_fn2).call(this, value);
      pointer.dynamicData = {
        0: concatWithDynamicData([data])
      };
      parts.push(pointer);
      parts.push(new U64Coder().encode(data.byteLength));
      parts.push(new U64Coder().encode(value.length));
      return concatWithDynamicData(parts);
    }
    decode(data, offset) {
      const len = data.slice(16, 24);
      const length = bn(new U64Coder().decode(len, 0)[0]).toNumber();
      const byteData = data.slice(BASE_VECTOR_OFFSET, BASE_VECTOR_OFFSET + length);
      const value = toUtf8String(byteData);
      return [value, offset + BASE_VECTOR_OFFSET];
    }
  };
  _getPaddedData2 = /* @__PURE__ */ new WeakSet();
  getPaddedData_fn2 = function(value) {
    const data = [toUtf8Bytes(value)];
    const paddingLength = (WORD_SIZE - value.length % WORD_SIZE) % WORD_SIZE;
    if (paddingLength) {
      data.push(new Uint8Array(paddingLength));
    }
    return concat2(data);
  };
  __publicField5(StdStringCoder, "memorySize", 1);
  var ResolvedAbiType = class {
    abi;
    name;
    type;
    originalTypeArguments;
    components;
    constructor(abi, argument) {
      this.abi = abi;
      const type3 = findOrThrow(
        abi.types,
        (t) => t.typeId === argument.type,
        () => {
          throw new FuelError(
            ErrorCode.TYPE_NOT_FOUND,
            `Type does not exist in the provided abi: ${JSON.stringify({
              argument,
              abi: this.abi
            })}`
          );
        }
      );
      this.name = argument.name;
      this.type = type3.type;
      this.originalTypeArguments = argument.typeArguments;
      this.components = ResolvedAbiType.getResolvedGenericComponents(
        abi,
        argument,
        type3.components,
        type3.typeParameters ?? ResolvedAbiType.getImplicitGenericTypeParameters(abi, type3.components)
      );
    }
    static getResolvedGenericComponents(abi, arg, components, typeParameters) {
      if (components === null) {
        return null;
      }
      if (typeParameters === null || typeParameters.length === 0) {
        return components.map((c) => new ResolvedAbiType(abi, c));
      }
      const typeParametersAndArgsMap = typeParameters.reduce(
        (obj, typeParameter, typeParameterIndex) => {
          const o = { ...obj };
          o[typeParameter] = structuredClone(
            arg.typeArguments?.[typeParameterIndex]
          );
          return o;
        },
        {}
      );
      const resolvedComponents = this.resolveGenericArgTypes(
        abi,
        components,
        typeParametersAndArgsMap
      );
      return resolvedComponents.map((c) => new ResolvedAbiType(abi, c));
    }
    static resolveGenericArgTypes(abi, args, typeParametersAndArgsMap) {
      return args.map((arg) => {
        if (typeParametersAndArgsMap[arg.type] !== void 0) {
          return {
            ...typeParametersAndArgsMap[arg.type],
            name: arg.name
          };
        }
        if (arg.typeArguments) {
          return {
            ...structuredClone(arg),
            typeArguments: this.resolveGenericArgTypes(
              abi,
              arg.typeArguments,
              typeParametersAndArgsMap
            )
          };
        }
        const argType = findOrThrow(abi.types, (t) => t.typeId === arg.type);
        const implicitTypeParameters = this.getImplicitGenericTypeParameters(abi, argType.components);
        if (implicitTypeParameters && implicitTypeParameters.length > 0) {
          return {
            ...structuredClone(arg),
            typeArguments: implicitTypeParameters.map((itp) => typeParametersAndArgsMap[itp])
          };
        }
        return arg;
      });
    }
    static getImplicitGenericTypeParameters(abi, args, implicitGenericParametersParam) {
      if (!Array.isArray(args)) {
        return null;
      }
      const implicitGenericParameters = implicitGenericParametersParam ?? [];
      args.forEach((a) => {
        const argType = findOrThrow(abi.types, (t) => t.typeId === a.type);
        if (genericRegEx.test(argType.type)) {
          implicitGenericParameters.push(argType.typeId);
          return;
        }
        if (!Array.isArray(a.typeArguments)) {
          return;
        }
        this.getImplicitGenericTypeParameters(abi, a.typeArguments, implicitGenericParameters);
      });
      return implicitGenericParameters.length > 0 ? implicitGenericParameters : null;
    }
    getSignature() {
      const prefix = this.getArgSignaturePrefix();
      const content = this.getArgSignatureContent();
      return `${prefix}${content}`;
    }
    getArgSignaturePrefix() {
      const structMatch = structRegEx.test(this.type);
      if (structMatch) {
        return "s";
      }
      const arrayMatch = arrayRegEx.test(this.type);
      if (arrayMatch) {
        return "a";
      }
      const enumMatch = enumRegEx.test(this.type);
      if (enumMatch) {
        return "e";
      }
      return "";
    }
    getArgSignatureContent() {
      if (this.type === "raw untyped ptr") {
        return "rawptr";
      }
      if (this.type === "raw untyped slice") {
        return "rawslice";
      }
      const strMatch = stringRegEx.exec(this.type)?.groups;
      if (strMatch) {
        return `str[${strMatch.length}]`;
      }
      if (this.components === null) {
        return this.type;
      }
      const arrayMatch = arrayRegEx.exec(this.type)?.groups;
      if (arrayMatch) {
        return `[${this.components[0].getSignature()};${arrayMatch.length}]`;
      }
      const typeArgumentsSignature = this.originalTypeArguments !== null ? `<${this.originalTypeArguments.map((a) => new ResolvedAbiType(this.abi, a).getSignature()).join(",")}>` : "";
      const componentsSignature = `(${this.components.map((c) => c.getSignature()).join(",")})`;
      return `${typeArgumentsSignature}${componentsSignature}`;
    }
  };
  var AbiCoder = class {
    static getCoder(abi, argument) {
      const resolvedAbiType = new ResolvedAbiType(abi, argument);
      return AbiCoder.getCoderImpl(resolvedAbiType);
    }
    static encode(abi, argument, value) {
      return this.getCoder(abi, argument).encode(value);
    }
    static decode(abi, argument, data, offset) {
      return this.getCoder(abi, argument).decode(data, offset);
    }
    static getCoderImpl(resolvedAbiType) {
      switch (resolvedAbiType.type) {
        case "u8":
        case "u16":
        case "u32":
          return new NumberCoder(resolvedAbiType.type);
        case "u64":
        case "raw untyped ptr":
          return new U64Coder();
        case "raw untyped slice":
          return new RawSliceCoder();
        case "bool":
          return new BooleanCoder();
        case "b256":
          return new B256Coder();
        case "struct B512":
          return new B512Coder();
        case BYTES_CODER_TYPE:
          return new ByteCoder();
        case STD_STRING_CODER_TYPE:
          return new StdStringCoder();
        default:
          break;
      }
      const stringMatch = stringRegEx.exec(resolvedAbiType.type)?.groups;
      if (stringMatch) {
        const length = parseInt(stringMatch.length, 10);
        return new StringCoder(length);
      }
      const components = resolvedAbiType.components;
      const arrayMatch = arrayRegEx.exec(resolvedAbiType.type)?.groups;
      if (arrayMatch) {
        const length = parseInt(arrayMatch.length, 10);
        const arg = components[0];
        if (!arg) {
          throw new FuelError(
            ErrorCode.INVALID_COMPONENT,
            `The provided Array type is missing an item of 'component'.`
          );
        }
        const arrayElementCoder = AbiCoder.getCoderImpl(arg);
        return new ArrayCoder(arrayElementCoder, length);
      }
      if (resolvedAbiType.type === VEC_CODER_TYPE) {
        const arg = findOrThrow(components, (c) => c.name === "buf").originalTypeArguments?.[0];
        if (!arg) {
          throw new FuelError(
            ErrorCode.INVALID_COMPONENT,
            `The provided Vec type is missing the 'type argument'.`
          );
        }
        const argType = new ResolvedAbiType(resolvedAbiType.abi, arg);
        const itemCoder = AbiCoder.getCoderImpl(argType);
        return new VecCoder(itemCoder);
      }
      const structMatch = structRegEx.exec(resolvedAbiType.type)?.groups;
      if (structMatch) {
        const coders = AbiCoder.getCoders(components);
        return new StructCoder(structMatch.name, coders);
      }
      const enumMatch = enumRegEx.exec(resolvedAbiType.type)?.groups;
      if (enumMatch) {
        const coders = AbiCoder.getCoders(components);
        const isOptionEnum = resolvedAbiType.type === OPTION_CODER_TYPE;
        if (isOptionEnum) {
          return new OptionCoder(enumMatch.name, coders);
        }
        return new EnumCoder(enumMatch.name, coders);
      }
      const tupleMatch = tupleRegEx.exec(resolvedAbiType.type)?.groups;
      if (tupleMatch) {
        const coders = components.map((component) => AbiCoder.getCoderImpl(component));
        return new TupleCoder(coders);
      }
      if (resolvedAbiType.type === "str") {
        throw new FuelError(
          ErrorCode.INVALID_DATA,
          "String slices can not be decoded from logs. Convert the slice to `str[N]` with `__to_str_array`"
        );
      }
      throw new FuelError(
        ErrorCode.CODER_NOT_FOUND,
        `Coder not found: ${JSON.stringify(resolvedAbiType)}.`
      );
    }
    static getCoders(components) {
      return components.reduce((obj, component) => {
        const o = obj;
        o[component.name] = AbiCoder.getCoderImpl(component);
        return o;
      }, {});
    }
  };
  var FunctionFragment = class {
    signature;
    selector;
    name;
    jsonFn;
    attributes;
    isInputDataPointer;
    outputMetadata;
    jsonAbi;
    constructor(jsonAbi, name) {
      this.jsonAbi = jsonAbi;
      this.jsonFn = findOrThrow(this.jsonAbi.functions, (f2) => f2.name === name);
      this.name = name;
      this.signature = FunctionFragment.getSignature(this.jsonAbi, this.jsonFn);
      this.selector = FunctionFragment.getFunctionSelector(this.signature);
      this.isInputDataPointer = this.#isInputDataPointer();
      this.outputMetadata = {
        isHeapType: this.#isOutputDataHeap(),
        encodedLength: this.#getOutputEncodedLength()
      };
      this.attributes = this.jsonFn.attributes ?? [];
    }
    static getSignature(abi, fn) {
      const inputsSignatures = fn.inputs.map(
        (input) => new ResolvedAbiType(abi, input).getSignature()
      );
      return `${fn.name}(${inputsSignatures.join(",")})`;
    }
    static getFunctionSelector(functionSignature) {
      const hashedFunctionSignature = sha256(bufferFromString2(functionSignature, "utf-8"));
      return bn(hashedFunctionSignature.slice(0, 10)).toHex(8);
    }
    #isInputDataPointer() {
      const inputTypes = this.jsonFn.inputs.map(
        (i) => this.jsonAbi.types.find((t) => t.typeId === i.type)
      );
      return this.jsonFn.inputs.length > 1 || isPointerType(inputTypes[0]?.type || "");
    }
    #isOutputDataHeap() {
      const outputType = findOrThrow(this.jsonAbi.types, (t) => t.typeId === this.jsonFn.output.type);
      return isHeapType(outputType?.type || "");
    }
    #getOutputEncodedLength() {
      try {
        const heapCoder = AbiCoder.getCoder(this.jsonAbi, this.jsonFn.output);
        if (heapCoder instanceof VecCoder) {
          return heapCoder.coder.encodedLength;
        }
        if (heapCoder instanceof ByteCoder) {
          return ByteCoder.memorySize;
        }
        return heapCoder.encodedLength;
      } catch (e) {
        return 0;
      }
    }
    encodeArguments(values, offset = 0) {
      FunctionFragment.verifyArgsAndInputsAlign(values, this.jsonFn.inputs, this.jsonAbi);
      const shallowCopyValues = values.slice();
      const nonEmptyInputs = this.jsonFn.inputs.filter(
        (x) => findOrThrow(this.jsonAbi.types, (t) => t.typeId === x.type).type !== "()"
      );
      if (Array.isArray(values) && nonEmptyInputs.length !== values.length) {
        shallowCopyValues.length = this.jsonFn.inputs.length;
        shallowCopyValues.fill(void 0, values.length);
      }
      const coders = nonEmptyInputs.map((t) => AbiCoder.getCoder(this.jsonAbi, t));
      const coder = new TupleCoder(coders);
      const results = coder.encode(shallowCopyValues);
      return unpackDynamicData(results, offset, results.byteLength);
    }
    static verifyArgsAndInputsAlign(args, inputs, abi) {
      if (args.length === inputs.length) {
        return;
      }
      const inputTypes = inputs.map((i) => findOrThrow(abi.types, (t) => t.typeId === i.type));
      const optionalInputs = inputTypes.filter(
        (x) => x.type === OPTION_CODER_TYPE || x.type === "()"
      );
      if (optionalInputs.length === inputTypes.length) {
        return;
      }
      if (inputTypes.length - optionalInputs.length === args.length) {
        return;
      }
      const errorMsg = `Mismatch between provided arguments and expected ABI inputs. Provided ${args.length} arguments, but expected ${inputs.length - optionalInputs.length} (excluding ${optionalInputs.length} optional inputs).`;
      throw new FuelError(ErrorCode.ABI_TYPES_AND_VALUES_MISMATCH, errorMsg);
    }
    decodeArguments(data) {
      const bytes3 = getBytesCopy(data);
      const nonEmptyInputs = this.jsonFn.inputs.filter(
        (x) => findOrThrow(this.jsonAbi.types, (t) => t.typeId === x.type).type !== "()"
      );
      if (nonEmptyInputs.length === 0) {
        if (bytes3.length === 0) {
          return void 0;
        }
        throw new FuelError(
          ErrorCode.DECODE_ERROR,
          `Types/values length mismatch during decode. ${JSON.stringify({
            count: {
              types: this.jsonFn.inputs.length,
              nonEmptyInputs: nonEmptyInputs.length,
              values: bytes3.length
            },
            value: {
              args: this.jsonFn.inputs,
              nonEmptyInputs,
              values: bytes3
            }
          })}`
        );
      }
      const result = nonEmptyInputs.reduce(
        (obj, input) => {
          const coder = AbiCoder.getCoder(this.jsonAbi, input);
          const [decodedValue, decodedValueByteSize] = coder.decode(bytes3, obj.offset);
          return {
            decoded: [...obj.decoded, decodedValue],
            offset: obj.offset + decodedValueByteSize
          };
        },
        { decoded: [], offset: 0 }
      );
      return result.decoded;
    }
    decodeOutput(data) {
      const outputAbiType = findOrThrow(
        this.jsonAbi.types,
        (t) => t.typeId === this.jsonFn.output.type
      );
      if (outputAbiType.type === "()") {
        return [void 0, 0];
      }
      const bytes3 = getBytesCopy(data);
      const coder = AbiCoder.getCoder(this.jsonAbi, this.jsonFn.output);
      if (outputAbiType.type === "raw untyped slice") {
        coder.length = bytes3.length / 8;
      }
      return coder.decode(bytes3, 0);
    }
  };
  var Interface = class {
    functions;
    configurables;
    /*
      TODO: Refactor so that there's no need for externalLoggedTypes
    
      This is dedicated to external contracts added via `<base-invocation-scope.ts>.addContracts()` method.
      This is used to decode logs from contracts other than the main contract
      we're interacting with.
      */
    externalLoggedTypes;
    jsonAbi;
    constructor(jsonAbi) {
      this.jsonAbi = jsonAbi;
      this.externalLoggedTypes = {};
      this.functions = Object.fromEntries(
        this.jsonAbi.functions.map((x) => [x.name, new FunctionFragment(this.jsonAbi, x.name)])
      );
      this.configurables = Object.fromEntries(this.jsonAbi.configurables.map((x) => [x.name, x]));
    }
    /**
     * Returns function fragment for a dynamic input.
     * @param nameOrSignatureOrSelector - name (e.g. 'transfer'), signature (e.g. 'transfer(address,uint256)') or selector (e.g. '0x00000000a9059cbb') of the function fragment
     */
    getFunction(nameOrSignatureOrSelector) {
      const fn = Object.values(this.functions).find(
        (f2) => f2.name === nameOrSignatureOrSelector || f2.signature === nameOrSignatureOrSelector || f2.selector === nameOrSignatureOrSelector
      );
      if (fn !== void 0) {
        return fn;
      }
      throw new FuelError(
        ErrorCode.FUNCTION_NOT_FOUND,
        `function ${nameOrSignatureOrSelector} not found: ${JSON.stringify(fn)}.`
      );
    }
    decodeFunctionData(functionFragment, data) {
      const fragment = typeof functionFragment === "string" ? this.getFunction(functionFragment) : functionFragment;
      if (!fragment) {
        throw new FuelError(ErrorCode.FRAGMENT_NOT_FOUND, "Fragment not found.");
      }
      return fragment.decodeArguments(data);
    }
    encodeFunctionData(functionFragment, values, offset = 0) {
      const fragment = typeof functionFragment === "string" ? this.getFunction(functionFragment) : functionFragment;
      if (!fragment) {
        throw new FuelError(ErrorCode.FRAGMENT_NOT_FOUND, "Fragment not found.");
      }
      return fragment.encodeArguments(values, offset);
    }
    // Decode the result of a function call
    decodeFunctionResult(functionFragment, data) {
      const fragment = typeof functionFragment === "string" ? this.getFunction(functionFragment) : functionFragment;
      return fragment.decodeOutput(data);
    }
    decodeLog(data, logId, receiptId) {
      const isExternalLoggedType = this.externalLoggedTypes[receiptId];
      if (isExternalLoggedType) {
        const externalInterface = this.externalLoggedTypes[receiptId];
        return externalInterface.decodeLog(data, logId, receiptId);
      }
      const { loggedType } = findOrThrow(this.jsonAbi.loggedTypes, (type3) => type3.logId === logId);
      return AbiCoder.decode(this.jsonAbi, loggedType, getBytesCopy(data), 0);
    }
    updateExternalLoggedTypes(id, loggedTypes) {
      this.externalLoggedTypes[id] = loggedTypes;
    }
    encodeConfigurable(name, value) {
      const configurable = findOrThrow(
        this.jsonAbi.configurables,
        (c) => c.name === name,
        () => {
          throw new FuelError(
            ErrorCode.CONFIGURABLE_NOT_FOUND,
            `A configurable with the '${name}' was not found in the ABI.`
          );
        }
      );
      return AbiCoder.encode(this.jsonAbi, configurable.configurableType, value);
    }
    getTypeById(typeId) {
      return findOrThrow(
        this.jsonAbi.types,
        (t) => t.typeId === typeId,
        () => {
          throw new FuelError(
            ErrorCode.TYPE_NOT_FOUND,
            `Type with typeId '${typeId}' doesn't exist in the ABI.`
          );
        }
      );
    }
  };

  // ../transactions/dist/index.mjs
  var ByteArrayCoder = class extends Coder {
    length;
    #paddingLength;
    constructor(length) {
      const paddingLength = (8 - length % 8) % 8;
      const encodedLength = length + paddingLength;
      super(
        "ByteArray",
        // While this might sound like a [u8; N] coder it's actually not.
        // A [u8; N] coder would pad every u8 to 8 bytes which would
        // make every u8 have the same size as a u64.
        // We are packing four u8s into u64s here, avoiding this padding.
        `[u64; ${encodedLength / 4}]`,
        encodedLength
      );
      this.length = length;
      this.#paddingLength = paddingLength;
    }
    encode(value) {
      const parts = [];
      const data = getBytesCopy(value);
      parts.push(data);
      if (this.#paddingLength) {
        parts.push(new Uint8Array(this.#paddingLength));
      }
      return concat2(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = [hexlify(data.slice(o, o + this.length)), o + this.length];
      const value = decoded;
      if (this.#paddingLength) {
        [decoded, o] = [null, o + this.#paddingLength];
      }
      return [value, o];
    }
  };
  var TxPointerCoder = class extends StructCoder {
    constructor() {
      super("TxPointer", {
        blockHeight: new NumberCoder("u32"),
        txIndex: new NumberCoder("u16")
      });
    }
  };
  var UtxoIdCoder = class extends StructCoder {
    constructor() {
      super("UtxoId", {
        transactionId: new B256Coder(),
        outputIndex: new NumberCoder("u8")
      });
    }
  };
  var InputType = /* @__PURE__ */ ((InputType2) => {
    InputType2[InputType2["Coin"] = 0] = "Coin";
    InputType2[InputType2["Contract"] = 1] = "Contract";
    InputType2[InputType2["Message"] = 2] = "Message";
    return InputType2;
  })(InputType || {});
  var InputCoinCoder = class extends Coder {
    constructor() {
      super("InputCoin", "struct InputCoin", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new UtxoIdCoder().encode(value.utxoID));
      parts.push(new B256Coder().encode(value.owner));
      parts.push(new U64Coder().encode(value.amount));
      parts.push(new B256Coder().encode(value.assetId));
      parts.push(new TxPointerCoder().encode(value.txPointer));
      parts.push(new NumberCoder("u8").encode(value.witnessIndex));
      parts.push(new NumberCoder("u32").encode(value.maturity));
      parts.push(new U64Coder().encode(value.predicateGasUsed));
      parts.push(new NumberCoder("u32").encode(value.predicateLength));
      parts.push(new NumberCoder("u32").encode(value.predicateDataLength));
      parts.push(new ByteArrayCoder(value.predicateLength).encode(value.predicate));
      parts.push(new ByteArrayCoder(value.predicateDataLength).encode(value.predicateData));
      return concat2(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new UtxoIdCoder().decode(data, o);
      const utxoID = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const owner = decoded;
      [decoded, o] = new U64Coder().decode(data, o);
      const amount = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const assetId = decoded;
      [decoded, o] = new TxPointerCoder().decode(data, o);
      const txPointer = decoded;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const witnessIndex = Number(decoded);
      [decoded, o] = new NumberCoder("u32").decode(data, o);
      const maturity = decoded;
      [decoded, o] = new U64Coder().decode(data, o);
      const predicateGasUsed = decoded;
      [decoded, o] = new NumberCoder("u32").decode(data, o);
      const predicateLength = decoded;
      [decoded, o] = new NumberCoder("u32").decode(data, o);
      const predicateDataLength = decoded;
      [decoded, o] = new ByteArrayCoder(predicateLength).decode(data, o);
      const predicate = decoded;
      [decoded, o] = new ByteArrayCoder(predicateDataLength).decode(data, o);
      const predicateData = decoded;
      return [
        {
          type: 0,
          utxoID,
          owner,
          amount,
          assetId,
          txPointer,
          witnessIndex,
          maturity,
          predicateGasUsed,
          predicateLength,
          predicateDataLength,
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          predicate,
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          predicateData
        },
        o
      ];
    }
  };
  var InputContractCoder = class extends Coder {
    constructor() {
      super("InputContract", "struct InputContract", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new UtxoIdCoder().encode(value.utxoID));
      parts.push(new B256Coder().encode(value.balanceRoot));
      parts.push(new B256Coder().encode(value.stateRoot));
      parts.push(new TxPointerCoder().encode(value.txPointer));
      parts.push(new B256Coder().encode(value.contractID));
      return concat2(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new UtxoIdCoder().decode(data, o);
      const utxoID = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const balanceRoot = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const stateRoot = decoded;
      [decoded, o] = new TxPointerCoder().decode(data, o);
      const txPointer = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const contractID = decoded;
      return [
        {
          type: 1,
          utxoID,
          balanceRoot,
          stateRoot,
          txPointer,
          contractID
        },
        o
      ];
    }
  };
  var InputMessageCoder = class extends Coder {
    constructor() {
      super("InputMessage", "struct InputMessage", 0);
    }
    static getMessageId(value) {
      const parts = [];
      parts.push(new ByteArrayCoder(32).encode(value.sender));
      parts.push(new ByteArrayCoder(32).encode(value.recipient));
      parts.push(new ByteArrayCoder(32).encode(value.nonce));
      parts.push(new U64Coder().encode(value.amount));
      parts.push(getBytesCopy(value.data || "0x"));
      return sha256(concat2(parts));
    }
    static encodeData(messageData) {
      const bytes3 = getBytesCopy(messageData || "0x");
      const dataLength2 = bytes3.length;
      return new ByteArrayCoder(dataLength2).encode(bytes3);
    }
    encode(value) {
      const parts = [];
      const data = InputMessageCoder.encodeData(value.data);
      parts.push(new ByteArrayCoder(32).encode(value.sender));
      parts.push(new ByteArrayCoder(32).encode(value.recipient));
      parts.push(new U64Coder().encode(value.amount));
      parts.push(new ByteArrayCoder(32).encode(value.nonce));
      parts.push(new NumberCoder("u8").encode(value.witnessIndex));
      parts.push(new U64Coder().encode(value.predicateGasUsed));
      parts.push(new NumberCoder("u16").encode(data.length));
      parts.push(new NumberCoder("u16").encode(value.predicateLength));
      parts.push(new NumberCoder("u16").encode(value.predicateDataLength));
      parts.push(new ByteArrayCoder(data.length).encode(data));
      parts.push(new ByteArrayCoder(value.predicateLength).encode(value.predicate));
      parts.push(new ByteArrayCoder(value.predicateDataLength).encode(value.predicateData));
      return concat2(parts);
    }
    static decodeData(messageData) {
      const bytes3 = getBytesCopy(messageData);
      const dataLength2 = bytes3.length;
      const [data] = new ByteArrayCoder(dataLength2).decode(bytes3, 0);
      return getBytesCopy(data);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new B256Coder().decode(data, o);
      const sender = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const recipient = decoded;
      [decoded, o] = new U64Coder().decode(data, o);
      const amount = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const nonce = decoded;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const witnessIndex = Number(decoded);
      [decoded, o] = new U64Coder().decode(data, o);
      const predicateGasUsed = decoded;
      [decoded, o] = new NumberCoder("u16").decode(data, o);
      const predicateLength = decoded;
      [decoded, o] = new NumberCoder("u16").decode(data, o);
      const dataLength2 = decoded;
      [decoded, o] = new NumberCoder("u16").decode(data, o);
      const predicateDataLength = decoded;
      [decoded, o] = new ByteArrayCoder(dataLength2).decode(data, o);
      const messageData = decoded;
      [decoded, o] = new ByteArrayCoder(predicateLength).decode(data, o);
      const predicate = decoded;
      [decoded, o] = new ByteArrayCoder(predicateDataLength).decode(data, o);
      const predicateData = decoded;
      return [
        {
          type: 2,
          sender,
          recipient,
          amount,
          witnessIndex,
          nonce,
          predicateGasUsed,
          dataLength: dataLength2,
          predicateLength,
          predicateDataLength,
          data: messageData,
          predicate,
          predicateData
        },
        o
      ];
    }
  };
  var InputCoder = class extends Coder {
    constructor() {
      super("Input", "struct Input", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new NumberCoder("u8").encode(value.type));
      const { type: type3 } = value;
      switch (type3) {
        case 0: {
          parts.push(new InputCoinCoder().encode(value));
          break;
        }
        case 1: {
          parts.push(new InputContractCoder().encode(value));
          break;
        }
        case 2: {
          parts.push(new InputMessageCoder().encode(value));
          break;
        }
        default: {
          throw new FuelError(
            ErrorCode.INVALID_TRANSACTION_INPUT,
            `Invalid transaction input type: ${type3}.`
          );
        }
      }
      return concat2(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const type3 = decoded;
      switch (type3) {
        case 0: {
          [decoded, o] = new InputCoinCoder().decode(data, o);
          return [decoded, o];
        }
        case 1: {
          [decoded, o] = new InputContractCoder().decode(data, o);
          return [decoded, o];
        }
        case 2: {
          [decoded, o] = new InputMessageCoder().decode(data, o);
          return [decoded, o];
        }
        default: {
          throw new FuelError(
            ErrorCode.INVALID_TRANSACTION_INPUT,
            `Invalid transaction input type: ${type3}.`
          );
        }
      }
    }
  };
  var OutputType = /* @__PURE__ */ ((OutputType2) => {
    OutputType2[OutputType2["Coin"] = 0] = "Coin";
    OutputType2[OutputType2["Contract"] = 1] = "Contract";
    OutputType2[OutputType2["Change"] = 2] = "Change";
    OutputType2[OutputType2["Variable"] = 3] = "Variable";
    OutputType2[OutputType2["ContractCreated"] = 4] = "ContractCreated";
    return OutputType2;
  })(OutputType || {});
  var OutputCoinCoder = class extends Coder {
    constructor() {
      super("OutputCoin", "struct OutputCoin", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new B256Coder().encode(value.to));
      parts.push(new U64Coder().encode(value.amount));
      parts.push(new B256Coder().encode(value.assetId));
      return concat2(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new B256Coder().decode(data, o);
      const to = decoded;
      [decoded, o] = new U64Coder().decode(data, o);
      const amount = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const assetId = decoded;
      return [
        {
          type: 0,
          to,
          amount,
          assetId
        },
        o
      ];
    }
  };
  var OutputContractCoder = class extends Coder {
    constructor() {
      super("OutputContract", "struct OutputContract", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new NumberCoder("u8").encode(value.inputIndex));
      parts.push(new B256Coder().encode(value.balanceRoot));
      parts.push(new B256Coder().encode(value.stateRoot));
      return concat2(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const inputIndex = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const balanceRoot = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const stateRoot = decoded;
      return [
        {
          type: 1,
          inputIndex,
          balanceRoot,
          stateRoot
        },
        o
      ];
    }
  };
  var OutputChangeCoder = class extends Coder {
    constructor() {
      super("OutputChange", "struct OutputChange", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new B256Coder().encode(value.to));
      parts.push(new U64Coder().encode(value.amount));
      parts.push(new B256Coder().encode(value.assetId));
      return concat2(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new B256Coder().decode(data, o);
      const to = decoded;
      [decoded, o] = new U64Coder().decode(data, o);
      const amount = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const assetId = decoded;
      return [
        {
          type: 2,
          to,
          amount,
          assetId
        },
        o
      ];
    }
  };
  var OutputVariableCoder = class extends Coder {
    constructor() {
      super("OutputVariable", "struct OutputVariable", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new B256Coder().encode(value.to));
      parts.push(new U64Coder().encode(value.amount));
      parts.push(new B256Coder().encode(value.assetId));
      return concat2(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new B256Coder().decode(data, o);
      const to = decoded;
      [decoded, o] = new U64Coder().decode(data, o);
      const amount = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const assetId = decoded;
      return [
        {
          type: 3,
          to,
          amount,
          assetId
        },
        o
      ];
    }
  };
  var OutputContractCreatedCoder = class extends Coder {
    constructor() {
      super("OutputContractCreated", "struct OutputContractCreated", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new B256Coder().encode(value.contractId));
      parts.push(new B256Coder().encode(value.stateRoot));
      return concat2(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new B256Coder().decode(data, o);
      const contractId = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const stateRoot = decoded;
      return [
        {
          type: 4,
          contractId,
          stateRoot
        },
        o
      ];
    }
  };
  var OutputCoder = class extends Coder {
    constructor() {
      super("Output", " struct Output", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new NumberCoder("u8").encode(value.type));
      const { type: type3 } = value;
      switch (type3) {
        case 0: {
          parts.push(new OutputCoinCoder().encode(value));
          break;
        }
        case 1: {
          parts.push(new OutputContractCoder().encode(value));
          break;
        }
        case 2: {
          parts.push(new OutputChangeCoder().encode(value));
          break;
        }
        case 3: {
          parts.push(new OutputVariableCoder().encode(value));
          break;
        }
        case 4: {
          parts.push(new OutputContractCreatedCoder().encode(value));
          break;
        }
        default: {
          throw new FuelError(
            ErrorCode.INVALID_TRANSACTION_OUTPUT,
            `Invalid transaction output type: ${type3}.`
          );
        }
      }
      return concat2(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const type3 = decoded;
      switch (type3) {
        case 0: {
          [decoded, o] = new OutputCoinCoder().decode(data, o);
          return [decoded, o];
        }
        case 1: {
          [decoded, o] = new OutputContractCoder().decode(data, o);
          return [decoded, o];
        }
        case 2: {
          [decoded, o] = new OutputChangeCoder().decode(data, o);
          return [decoded, o];
        }
        case 3: {
          [decoded, o] = new OutputVariableCoder().decode(data, o);
          return [decoded, o];
        }
        case 4: {
          [decoded, o] = new OutputContractCreatedCoder().decode(data, o);
          return [decoded, o];
        }
        default: {
          throw new FuelError(
            ErrorCode.INVALID_TRANSACTION_OUTPUT,
            `Invalid transaction output type: ${type3}.`
          );
        }
      }
    }
  };
  var ReceiptType = /* @__PURE__ */ ((ReceiptType2) => {
    ReceiptType2[ReceiptType2["Call"] = 0] = "Call";
    ReceiptType2[ReceiptType2["Return"] = 1] = "Return";
    ReceiptType2[ReceiptType2["ReturnData"] = 2] = "ReturnData";
    ReceiptType2[ReceiptType2["Panic"] = 3] = "Panic";
    ReceiptType2[ReceiptType2["Revert"] = 4] = "Revert";
    ReceiptType2[ReceiptType2["Log"] = 5] = "Log";
    ReceiptType2[ReceiptType2["LogData"] = 6] = "LogData";
    ReceiptType2[ReceiptType2["Transfer"] = 7] = "Transfer";
    ReceiptType2[ReceiptType2["TransferOut"] = 8] = "TransferOut";
    ReceiptType2[ReceiptType2["ScriptResult"] = 9] = "ScriptResult";
    ReceiptType2[ReceiptType2["MessageOut"] = 10] = "MessageOut";
    ReceiptType2[ReceiptType2["Mint"] = 11] = "Mint";
    ReceiptType2[ReceiptType2["Burn"] = 12] = "Burn";
    return ReceiptType2;
  })(ReceiptType || {});
  var ReceiptMessageOutCoder = class extends Coder {
    constructor() {
      super("ReceiptMessageOut", "struct ReceiptMessageOut", 0);
    }
    static getMessageId(value) {
      const parts = [];
      parts.push(new ByteArrayCoder(32).encode(value.sender));
      parts.push(new ByteArrayCoder(32).encode(value.recipient));
      parts.push(new ByteArrayCoder(32).encode(value.nonce));
      parts.push(new U64Coder().encode(value.amount));
      parts.push(getBytesCopy(value.data || "0x"));
      return sha256(concat2(parts));
    }
    encode(value) {
      const parts = [];
      parts.push(new B256Coder().encode(value.sender));
      parts.push(new B256Coder().encode(value.recipient));
      parts.push(new U64Coder().encode(value.amount));
      parts.push(new B256Coder().encode(value.nonce));
      parts.push(new NumberCoder("u16").encode(value.data.length));
      parts.push(new B256Coder().encode(value.digest));
      parts.push(new ByteArrayCoder(value.data.length).encode(value.data));
      return concat2(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new B256Coder().decode(data, o);
      const sender = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const recipient = decoded;
      [decoded, o] = new U64Coder().decode(data, o);
      const amount = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const nonce = decoded;
      [decoded, o] = new NumberCoder("u16").decode(data, o);
      const len = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const digest = decoded;
      [decoded, o] = new ByteArrayCoder(len).decode(data, o);
      const messageData = getBytesCopy(decoded);
      const receiptMessageOut = {
        type: 10,
        messageId: "",
        sender,
        recipient,
        amount,
        nonce,
        digest,
        data: messageData
      };
      receiptMessageOut.messageId = ReceiptMessageOutCoder.getMessageId(receiptMessageOut);
      return [receiptMessageOut, o];
    }
  };
  var getAssetIdForMintAndBurnReceipts = (contractId, subId) => {
    const contractIdBytes = getBytesCopy(contractId);
    const subIdBytes = getBytesCopy(subId);
    return sha256(concat2([contractIdBytes, subIdBytes]));
  };
  var ReceiptMintCoder = class extends Coder {
    constructor() {
      super("ReceiptMint", "struct ReceiptMint", 0);
    }
    static getAssetId(contractId, subId) {
      return getAssetIdForMintAndBurnReceipts(contractId, subId);
    }
    encode(value) {
      const parts = [];
      parts.push(new B256Coder().encode(value.subId));
      parts.push(new B256Coder().encode(value.contractId));
      parts.push(new U64Coder().encode(value.val));
      parts.push(new U64Coder().encode(value.pc));
      parts.push(new U64Coder().encode(value.is));
      return concat2(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new B256Coder().decode(data, o);
      const subId = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const contractId = decoded;
      [decoded, o] = new U64Coder().decode(data, o);
      const val = decoded;
      [decoded, o] = new U64Coder().decode(data, o);
      const pc = decoded;
      [decoded, o] = new U64Coder().decode(data, o);
      const is = decoded;
      const assetId = ReceiptMintCoder.getAssetId(contractId, subId);
      const receiptMint = {
        type: 11,
        subId,
        contractId,
        val,
        pc,
        is,
        assetId
      };
      return [receiptMint, o];
    }
  };
  var ReceiptBurnCoder = class extends Coder {
    constructor() {
      super("ReceiptBurn", "struct ReceiptBurn", 0);
    }
    static getAssetId(contractId, subId) {
      return getAssetIdForMintAndBurnReceipts(contractId, subId);
    }
    encode(value) {
      const parts = [];
      parts.push(new B256Coder().encode(value.subId));
      parts.push(new B256Coder().encode(value.contractId));
      parts.push(new U64Coder().encode(value.val));
      parts.push(new U64Coder().encode(value.pc));
      parts.push(new U64Coder().encode(value.is));
      return concat2(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new B256Coder().decode(data, o);
      const subId = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const contractId = decoded;
      [decoded, o] = new U64Coder().decode(data, o);
      const val = decoded;
      [decoded, o] = new U64Coder().decode(data, o);
      const pc = decoded;
      [decoded, o] = new U64Coder().decode(data, o);
      const is = decoded;
      const assetId = ReceiptMintCoder.getAssetId(contractId, subId);
      const receiptBurn = {
        type: 12,
        subId,
        contractId,
        val,
        pc,
        is,
        assetId
      };
      return [receiptBurn, o];
    }
  };
  var StorageSlotCoder = class extends StructCoder {
    constructor() {
      super("StorageSlot", {
        key: new B256Coder(),
        value: new B256Coder()
      });
    }
  };
  var WitnessCoder = class extends Coder {
    constructor() {
      super(
        "Witness",
        // Types of dynamic length are not supported in the ABI
        "unknown",
        0
      );
    }
    encode(value) {
      const parts = [];
      parts.push(new NumberCoder("u16").encode(value.dataLength));
      parts.push(new ByteArrayCoder(value.dataLength).encode(value.data));
      return concat2(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new NumberCoder("u16").decode(data, o);
      const dataLength2 = decoded;
      [decoded, o] = new ByteArrayCoder(dataLength2).decode(data, o);
      const witnessData = decoded;
      return [
        {
          dataLength: dataLength2,
          data: witnessData,
          offset
        },
        o
      ];
    }
  };
  var TransactionType = /* @__PURE__ */ ((TransactionType2) => {
    TransactionType2[TransactionType2["Script"] = 0] = "Script";
    TransactionType2[TransactionType2["Create"] = 1] = "Create";
    TransactionType2[TransactionType2["Mint"] = 2] = "Mint";
    return TransactionType2;
  })(TransactionType || {});
  var TransactionScriptCoder = class extends Coder {
    constructor() {
      super("TransactionScript", "struct TransactionScript", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new U64Coder().encode(value.gasPrice));
      parts.push(new U64Coder().encode(value.gasLimit));
      parts.push(new NumberCoder("u32").encode(value.maturity));
      parts.push(new NumberCoder("u16").encode(value.scriptLength));
      parts.push(new NumberCoder("u16").encode(value.scriptDataLength));
      parts.push(new NumberCoder("u8").encode(value.inputsCount));
      parts.push(new NumberCoder("u8").encode(value.outputsCount));
      parts.push(new NumberCoder("u8").encode(value.witnessesCount));
      parts.push(new B256Coder().encode(value.receiptsRoot));
      parts.push(new ByteArrayCoder(value.scriptLength).encode(value.script));
      parts.push(new ByteArrayCoder(value.scriptDataLength).encode(value.scriptData));
      parts.push(new ArrayCoder(new InputCoder(), value.inputsCount).encode(value.inputs));
      parts.push(new ArrayCoder(new OutputCoder(), value.outputsCount).encode(value.outputs));
      parts.push(new ArrayCoder(new WitnessCoder(), value.witnessesCount).encode(value.witnesses));
      return concat2(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new U64Coder().decode(data, o);
      const gasPrice = decoded;
      [decoded, o] = new U64Coder().decode(data, o);
      const gasLimit = decoded;
      [decoded, o] = new NumberCoder("u32").decode(data, o);
      const maturity = decoded;
      [decoded, o] = new NumberCoder("u16").decode(data, o);
      const scriptLength = decoded;
      [decoded, o] = new NumberCoder("u16").decode(data, o);
      const scriptDataLength = decoded;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const inputsCount = decoded;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const outputsCount = decoded;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const witnessesCount = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const receiptsRoot = decoded;
      [decoded, o] = new ByteArrayCoder(scriptLength).decode(data, o);
      const script = decoded;
      [decoded, o] = new ByteArrayCoder(scriptDataLength).decode(data, o);
      const scriptData = decoded;
      [decoded, o] = new ArrayCoder(new InputCoder(), inputsCount).decode(data, o);
      const inputs = decoded;
      [decoded, o] = new ArrayCoder(new OutputCoder(), outputsCount).decode(data, o);
      const outputs = decoded;
      [decoded, o] = new ArrayCoder(new WitnessCoder(), witnessesCount).decode(data, o);
      const witnesses = decoded;
      return [
        {
          type: 0,
          gasPrice,
          gasLimit,
          maturity,
          scriptLength,
          scriptDataLength,
          inputsCount,
          outputsCount,
          witnessesCount,
          receiptsRoot,
          script,
          scriptData,
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          inputs,
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          outputs,
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          witnesses
        },
        o
      ];
    }
  };
  var TransactionCreateCoder = class extends Coder {
    constructor() {
      super("TransactionCreate", "struct TransactionCreate", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new U64Coder().encode(value.gasPrice));
      parts.push(new U64Coder().encode(value.gasLimit));
      parts.push(new NumberCoder("u32").encode(value.maturity));
      parts.push(new NumberCoder("u16").encode(value.bytecodeLength));
      parts.push(new NumberCoder("u8").encode(value.bytecodeWitnessIndex));
      parts.push(new NumberCoder("u16").encode(value.storageSlotsCount));
      parts.push(new NumberCoder("u8").encode(value.inputsCount));
      parts.push(new NumberCoder("u8").encode(value.outputsCount));
      parts.push(new NumberCoder("u8").encode(value.witnessesCount));
      parts.push(new B256Coder().encode(value.salt));
      parts.push(
        new ArrayCoder(new StorageSlotCoder(), value.storageSlotsCount).encode(value.storageSlots)
      );
      parts.push(new ArrayCoder(new InputCoder(), value.inputsCount).encode(value.inputs));
      parts.push(new ArrayCoder(new OutputCoder(), value.outputsCount).encode(value.outputs));
      parts.push(new ArrayCoder(new WitnessCoder(), value.witnessesCount).encode(value.witnesses));
      return concat2(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new U64Coder().decode(data, o);
      const gasPrice = decoded;
      [decoded, o] = new U64Coder().decode(data, o);
      const gasLimit = decoded;
      [decoded, o] = new NumberCoder("u32").decode(data, o);
      const maturity = decoded;
      [decoded, o] = new NumberCoder("u16").decode(data, o);
      const bytecodeLength = decoded;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const bytecodeWitnessIndex = decoded;
      [decoded, o] = new NumberCoder("u16").decode(data, o);
      const storageSlotsCount = decoded;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const inputsCount = decoded;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const outputsCount = decoded;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const witnessesCount = decoded;
      [decoded, o] = new B256Coder().decode(data, o);
      const salt = decoded;
      [decoded, o] = new ArrayCoder(new StorageSlotCoder(), storageSlotsCount).decode(data, o);
      const storageSlots = decoded;
      [decoded, o] = new ArrayCoder(new InputCoder(), inputsCount).decode(data, o);
      const inputs = decoded;
      [decoded, o] = new ArrayCoder(new OutputCoder(), outputsCount).decode(data, o);
      const outputs = decoded;
      [decoded, o] = new ArrayCoder(new WitnessCoder(), witnessesCount).decode(data, o);
      const witnesses = decoded;
      return [
        {
          type: 1,
          gasPrice,
          gasLimit,
          maturity,
          bytecodeLength,
          bytecodeWitnessIndex,
          storageSlotsCount,
          inputsCount,
          outputsCount,
          witnessesCount,
          salt,
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          storageSlots,
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          inputs,
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          outputs,
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-ignore
          witnesses
        },
        o
      ];
    }
  };
  var TransactionMintCoder = class extends Coder {
    constructor() {
      super("TransactionMint", "struct TransactionMint", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new TxPointerCoder().encode(value.txPointer));
      parts.push(new NumberCoder("u8").encode(value.outputsCount));
      parts.push(new ArrayCoder(new OutputCoder(), value.outputsCount).encode(value.outputs));
      return concat2(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new TxPointerCoder().decode(data, o);
      const txPointer = decoded;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const outputsCount = decoded;
      [decoded, o] = new ArrayCoder(new OutputCoder(), outputsCount).decode(data, o);
      const outputs = decoded;
      return [
        {
          type: 2,
          outputsCount,
          outputs,
          txPointer
        },
        o
      ];
    }
  };
  var TransactionCoder = class extends Coder {
    constructor() {
      super("Transaction", "struct Transaction", 0);
    }
    encode(value) {
      const parts = [];
      parts.push(new NumberCoder("u8").encode(value.type));
      const { type: type3 } = value;
      switch (value.type) {
        case 0: {
          parts.push(
            new TransactionScriptCoder().encode(value)
          );
          break;
        }
        case 1: {
          parts.push(
            new TransactionCreateCoder().encode(value)
          );
          break;
        }
        case 2: {
          parts.push(new TransactionMintCoder().encode(value));
          break;
        }
        default: {
          throw new FuelError(
            ErrorCode.INVALID_TRANSACTION_TYPE,
            `Invalid transaction type: ${type3}`
          );
        }
      }
      return concat2(parts);
    }
    decode(data, offset) {
      let decoded;
      let o = offset;
      [decoded, o] = new NumberCoder("u8").decode(data, o);
      const type3 = decoded;
      switch (type3) {
        case 0: {
          [decoded, o] = new TransactionScriptCoder().decode(data, o);
          return [decoded, o];
        }
        case 1: {
          [decoded, o] = new TransactionCreateCoder().decode(data, o);
          return [decoded, o];
        }
        case 2: {
          [decoded, o] = new TransactionMintCoder().decode(data, o);
          return [decoded, o];
        }
        default: {
          throw new FuelError(
            ErrorCode.INVALID_TRANSACTION_TYPE,
            `Invalid transaction type: ${type3}`
          );
        }
      }
    }
  };

  // ../providers/dist/index.mjs
  var import_graphql_request = __toESM(require_dist2(), 1);

  // ../../node_modules/.pnpm/tslib@2.6.0/node_modules/tslib/tslib.es6.mjs
  var __assign = function() {
    __assign = Object.assign || function __assign2(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/devAssert.mjs
  function devAssert(condition, message) {
    const booleanCondition = Boolean(condition);
    if (!booleanCondition) {
      throw new Error(message);
    }
  }

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/isObjectLike.mjs
  function isObjectLike(value) {
    return typeof value == "object" && value !== null;
  }

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/invariant.mjs
  function invariant(condition, message) {
    const booleanCondition = Boolean(condition);
    if (!booleanCondition) {
      throw new Error(
        message != null ? message : "Unexpected invariant triggered."
      );
    }
  }

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/location.mjs
  var LineRegExp = /\r\n|[\n\r]/g;
  function getLocation(source, position) {
    let lastLineStart = 0;
    let line = 1;
    for (const match3 of source.body.matchAll(LineRegExp)) {
      typeof match3.index === "number" || invariant(false);
      if (match3.index >= position) {
        break;
      }
      lastLineStart = match3.index + match3[0].length;
      line += 1;
    }
    return {
      line,
      column: position + 1 - lastLineStart
    };
  }

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/printLocation.mjs
  function printLocation(location) {
    return printSourceLocation(
      location.source,
      getLocation(location.source, location.start)
    );
  }
  function printSourceLocation(source, sourceLocation) {
    const firstLineColumnOffset = source.locationOffset.column - 1;
    const body = "".padStart(firstLineColumnOffset) + source.body;
    const lineIndex = sourceLocation.line - 1;
    const lineOffset = source.locationOffset.line - 1;
    const lineNum = sourceLocation.line + lineOffset;
    const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
    const columnNum = sourceLocation.column + columnOffset;
    const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
    const lines = body.split(/\r\n|[\n\r]/g);
    const locationLine = lines[lineIndex];
    if (locationLine.length > 120) {
      const subLineIndex = Math.floor(columnNum / 80);
      const subLineColumnNum = columnNum % 80;
      const subLines = [];
      for (let i = 0; i < locationLine.length; i += 80) {
        subLines.push(locationLine.slice(i, i + 80));
      }
      return locationStr + printPrefixedLines([
        [`${lineNum} |`, subLines[0]],
        ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
        ["|", "^".padStart(subLineColumnNum)],
        ["|", subLines[subLineIndex + 1]]
      ]);
    }
    return locationStr + printPrefixedLines([
      // Lines specified like this: ["prefix", "string"],
      [`${lineNum - 1} |`, lines[lineIndex - 1]],
      [`${lineNum} |`, locationLine],
      ["|", "^".padStart(columnNum)],
      [`${lineNum + 1} |`, lines[lineIndex + 1]]
    ]);
  }
  function printPrefixedLines(lines) {
    const existingLines = lines.filter(([_, line]) => line !== void 0);
    const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
    return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
  }

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/error/GraphQLError.mjs
  function toNormalizedOptions(args) {
    const firstArg = args[0];
    if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
      return {
        nodes: firstArg,
        source: args[1],
        positions: args[2],
        path: args[3],
        originalError: args[4],
        extensions: args[5]
      };
    }
    return firstArg;
  }
  var GraphQLError = class extends Error {
    /**
     * An array of `{ line, column }` locations within the source GraphQL document
     * which correspond to this error.
     *
     * Errors during validation often contain multiple locations, for example to
     * point out two things with the same name. Errors during execution include a
     * single location, the field which produced the error.
     *
     * Enumerable, and appears in the result of JSON.stringify().
     */
    /**
     * An array describing the JSON-path into the execution response which
     * corresponds to this error. Only included for errors during execution.
     *
     * Enumerable, and appears in the result of JSON.stringify().
     */
    /**
     * An array of GraphQL AST Nodes corresponding to this error.
     */
    /**
     * The source GraphQL document for the first location of this error.
     *
     * Note that if this Error represents more than one node, the source may not
     * represent nodes after the first node.
     */
    /**
     * An array of character offsets within the source GraphQL document
     * which correspond to this error.
     */
    /**
     * The original error thrown from a field resolver during execution.
     */
    /**
     * Extension fields to add to the formatted error.
     */
    /**
     * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
     */
    constructor(message, ...rawArgs) {
      var _this$nodes, _nodeLocations$, _ref;
      const { nodes, source, positions, path: path4, originalError, extensions } = toNormalizedOptions(rawArgs);
      super(message);
      this.name = "GraphQLError";
      this.path = path4 !== null && path4 !== void 0 ? path4 : void 0;
      this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
      this.nodes = undefinedIfEmpty(
        Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
      );
      const nodeLocations = undefinedIfEmpty(
        (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
      );
      this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
      this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
      this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
      const originalExtensions = isObjectLike(
        originalError === null || originalError === void 0 ? void 0 : originalError.extensions
      ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
      this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
      Object.defineProperties(this, {
        message: {
          writable: true,
          enumerable: true
        },
        name: {
          enumerable: false
        },
        nodes: {
          enumerable: false
        },
        source: {
          enumerable: false
        },
        positions: {
          enumerable: false
        },
        originalError: {
          enumerable: false
        }
      });
      if (originalError !== null && originalError !== void 0 && originalError.stack) {
        Object.defineProperty(this, "stack", {
          value: originalError.stack,
          writable: true,
          configurable: true
        });
      } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, GraphQLError);
      } else {
        Object.defineProperty(this, "stack", {
          value: Error().stack,
          writable: true,
          configurable: true
        });
      }
    }
    get [Symbol.toStringTag]() {
      return "GraphQLError";
    }
    toString() {
      let output3 = this.message;
      if (this.nodes) {
        for (const node of this.nodes) {
          if (node.loc) {
            output3 += "\n\n" + printLocation(node.loc);
          }
        }
      } else if (this.source && this.locations) {
        for (const location of this.locations) {
          output3 += "\n\n" + printSourceLocation(this.source, location);
        }
      }
      return output3;
    }
    toJSON() {
      const formattedError = {
        message: this.message
      };
      if (this.locations != null) {
        formattedError.locations = this.locations;
      }
      if (this.path != null) {
        formattedError.path = this.path;
      }
      if (this.extensions != null && Object.keys(this.extensions).length > 0) {
        formattedError.extensions = this.extensions;
      }
      return formattedError;
    }
  };
  function undefinedIfEmpty(array2) {
    return array2 === void 0 || array2.length === 0 ? void 0 : array2;
  }

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/error/syntaxError.mjs
  function syntaxError(source, position, description) {
    return new GraphQLError(`Syntax Error: ${description}`, {
      source,
      positions: [position]
    });
  }

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/ast.mjs
  var Location = class {
    /**
     * The character offset at which this Node begins.
     */
    /**
     * The character offset at which this Node ends.
     */
    /**
     * The Token at which this Node begins.
     */
    /**
     * The Token at which this Node ends.
     */
    /**
     * The Source document the AST represents.
     */
    constructor(startToken, endToken, source) {
      this.start = startToken.start;
      this.end = endToken.end;
      this.startToken = startToken;
      this.endToken = endToken;
      this.source = source;
    }
    get [Symbol.toStringTag]() {
      return "Location";
    }
    toJSON() {
      return {
        start: this.start,
        end: this.end
      };
    }
  };
  var Token = class {
    /**
     * The kind of Token.
     */
    /**
     * The character offset at which this Node begins.
     */
    /**
     * The character offset at which this Node ends.
     */
    /**
     * The 1-indexed line number on which this Token appears.
     */
    /**
     * The 1-indexed column number at which this Token begins.
     */
    /**
     * For non-punctuation tokens, represents the interpreted value of the token.
     *
     * Note: is undefined for punctuation tokens, but typed as string for
     * convenience in the parser.
     */
    /**
     * Tokens exist as nodes in a double-linked-list amongst all tokens
     * including ignored tokens. <SOF> is always the first node and <EOF>
     * the last.
     */
    constructor(kind, start, end, line, column, value) {
      this.kind = kind;
      this.start = start;
      this.end = end;
      this.line = line;
      this.column = column;
      this.value = value;
      this.prev = null;
      this.next = null;
    }
    get [Symbol.toStringTag]() {
      return "Token";
    }
    toJSON() {
      return {
        kind: this.kind,
        value: this.value,
        line: this.line,
        column: this.column
      };
    }
  };
  var QueryDocumentKeys = {
    Name: [],
    Document: ["definitions"],
    OperationDefinition: [
      "name",
      "variableDefinitions",
      "directives",
      "selectionSet"
    ],
    VariableDefinition: ["variable", "type", "defaultValue", "directives"],
    Variable: ["name"],
    SelectionSet: ["selections"],
    Field: ["alias", "name", "arguments", "directives", "selectionSet"],
    Argument: ["name", "value"],
    FragmentSpread: ["name", "directives"],
    InlineFragment: ["typeCondition", "directives", "selectionSet"],
    FragmentDefinition: [
      "name",
      // Note: fragment variable definitions are deprecated and will removed in v17.0.0
      "variableDefinitions",
      "typeCondition",
      "directives",
      "selectionSet"
    ],
    IntValue: [],
    FloatValue: [],
    StringValue: [],
    BooleanValue: [],
    NullValue: [],
    EnumValue: [],
    ListValue: ["values"],
    ObjectValue: ["fields"],
    ObjectField: ["name", "value"],
    Directive: ["name", "arguments"],
    NamedType: ["name"],
    ListType: ["type"],
    NonNullType: ["type"],
    SchemaDefinition: ["description", "directives", "operationTypes"],
    OperationTypeDefinition: ["type"],
    ScalarTypeDefinition: ["description", "name", "directives"],
    ObjectTypeDefinition: [
      "description",
      "name",
      "interfaces",
      "directives",
      "fields"
    ],
    FieldDefinition: ["description", "name", "arguments", "type", "directives"],
    InputValueDefinition: [
      "description",
      "name",
      "type",
      "defaultValue",
      "directives"
    ],
    InterfaceTypeDefinition: [
      "description",
      "name",
      "interfaces",
      "directives",
      "fields"
    ],
    UnionTypeDefinition: ["description", "name", "directives", "types"],
    EnumTypeDefinition: ["description", "name", "directives", "values"],
    EnumValueDefinition: ["description", "name", "directives"],
    InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
    DirectiveDefinition: ["description", "name", "arguments", "locations"],
    SchemaExtension: ["directives", "operationTypes"],
    ScalarTypeExtension: ["name", "directives"],
    ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
    InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
    UnionTypeExtension: ["name", "directives", "types"],
    EnumTypeExtension: ["name", "directives", "values"],
    InputObjectTypeExtension: ["name", "directives", "fields"]
  };
  var kindValues = new Set(Object.keys(QueryDocumentKeys));
  var OperationTypeNode;
  (function(OperationTypeNode2) {
    OperationTypeNode2["QUERY"] = "query";
    OperationTypeNode2["MUTATION"] = "mutation";
    OperationTypeNode2["SUBSCRIPTION"] = "subscription";
  })(OperationTypeNode || (OperationTypeNode = {}));

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/directiveLocation.mjs
  var DirectiveLocation;
  (function(DirectiveLocation2) {
    DirectiveLocation2["QUERY"] = "QUERY";
    DirectiveLocation2["MUTATION"] = "MUTATION";
    DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
    DirectiveLocation2["FIELD"] = "FIELD";
    DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
    DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
    DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
    DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
    DirectiveLocation2["SCHEMA"] = "SCHEMA";
    DirectiveLocation2["SCALAR"] = "SCALAR";
    DirectiveLocation2["OBJECT"] = "OBJECT";
    DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
    DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
    DirectiveLocation2["INTERFACE"] = "INTERFACE";
    DirectiveLocation2["UNION"] = "UNION";
    DirectiveLocation2["ENUM"] = "ENUM";
    DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
    DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
    DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
  })(DirectiveLocation || (DirectiveLocation = {}));

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/kinds.mjs
  var Kind;
  (function(Kind2) {
    Kind2["NAME"] = "Name";
    Kind2["DOCUMENT"] = "Document";
    Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
    Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
    Kind2["SELECTION_SET"] = "SelectionSet";
    Kind2["FIELD"] = "Field";
    Kind2["ARGUMENT"] = "Argument";
    Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
    Kind2["INLINE_FRAGMENT"] = "InlineFragment";
    Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
    Kind2["VARIABLE"] = "Variable";
    Kind2["INT"] = "IntValue";
    Kind2["FLOAT"] = "FloatValue";
    Kind2["STRING"] = "StringValue";
    Kind2["BOOLEAN"] = "BooleanValue";
    Kind2["NULL"] = "NullValue";
    Kind2["ENUM"] = "EnumValue";
    Kind2["LIST"] = "ListValue";
    Kind2["OBJECT"] = "ObjectValue";
    Kind2["OBJECT_FIELD"] = "ObjectField";
    Kind2["DIRECTIVE"] = "Directive";
    Kind2["NAMED_TYPE"] = "NamedType";
    Kind2["LIST_TYPE"] = "ListType";
    Kind2["NON_NULL_TYPE"] = "NonNullType";
    Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
    Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
    Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
    Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
    Kind2["FIELD_DEFINITION"] = "FieldDefinition";
    Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
    Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
    Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
    Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
    Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
    Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
    Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
    Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
    Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
    Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
    Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
    Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
    Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
    Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
  })(Kind || (Kind = {}));

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/characterClasses.mjs
  function isWhiteSpace(code) {
    return code === 9 || code === 32;
  }
  function isDigit(code) {
    return code >= 48 && code <= 57;
  }
  function isLetter(code) {
    return code >= 97 && code <= 122 || // A-Z
    code >= 65 && code <= 90;
  }
  function isNameStart(code) {
    return isLetter(code) || code === 95;
  }
  function isNameContinue(code) {
    return isLetter(code) || isDigit(code) || code === 95;
  }

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/blockString.mjs
  function dedentBlockStringLines(lines) {
    var _firstNonEmptyLine2;
    let commonIndent = Number.MAX_SAFE_INTEGER;
    let firstNonEmptyLine = null;
    let lastNonEmptyLine = -1;
    for (let i = 0; i < lines.length; ++i) {
      var _firstNonEmptyLine;
      const line = lines[i];
      const indent = leadingWhitespace(line);
      if (indent === line.length) {
        continue;
      }
      firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i;
      lastNonEmptyLine = i;
      if (i !== 0 && indent < commonIndent) {
        commonIndent = indent;
      }
    }
    return lines.map((line, i) => i === 0 ? line : line.slice(commonIndent)).slice(
      (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
      lastNonEmptyLine + 1
    );
  }
  function leadingWhitespace(str) {
    let i = 0;
    while (i < str.length && isWhiteSpace(str.charCodeAt(i))) {
      ++i;
    }
    return i;
  }

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/tokenKind.mjs
  var TokenKind;
  (function(TokenKind2) {
    TokenKind2["SOF"] = "<SOF>";
    TokenKind2["EOF"] = "<EOF>";
    TokenKind2["BANG"] = "!";
    TokenKind2["DOLLAR"] = "$";
    TokenKind2["AMP"] = "&";
    TokenKind2["PAREN_L"] = "(";
    TokenKind2["PAREN_R"] = ")";
    TokenKind2["SPREAD"] = "...";
    TokenKind2["COLON"] = ":";
    TokenKind2["EQUALS"] = "=";
    TokenKind2["AT"] = "@";
    TokenKind2["BRACKET_L"] = "[";
    TokenKind2["BRACKET_R"] = "]";
    TokenKind2["BRACE_L"] = "{";
    TokenKind2["PIPE"] = "|";
    TokenKind2["BRACE_R"] = "}";
    TokenKind2["NAME"] = "Name";
    TokenKind2["INT"] = "Int";
    TokenKind2["FLOAT"] = "Float";
    TokenKind2["STRING"] = "String";
    TokenKind2["BLOCK_STRING"] = "BlockString";
    TokenKind2["COMMENT"] = "Comment";
  })(TokenKind || (TokenKind = {}));

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/lexer.mjs
  var Lexer = class {
    /**
     * The previously focused non-ignored token.
     */
    /**
     * The currently focused non-ignored token.
     */
    /**
     * The (1-indexed) line containing the current token.
     */
    /**
     * The character offset at which the current line begins.
     */
    constructor(source) {
      const startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0);
      this.source = source;
      this.lastToken = startOfFileToken;
      this.token = startOfFileToken;
      this.line = 1;
      this.lineStart = 0;
    }
    get [Symbol.toStringTag]() {
      return "Lexer";
    }
    /**
     * Advances the token stream to the next non-ignored token.
     */
    advance() {
      this.lastToken = this.token;
      const token = this.token = this.lookahead();
      return token;
    }
    /**
     * Looks ahead and returns the next non-ignored token, but does not change
     * the state of Lexer.
     */
    lookahead() {
      let token = this.token;
      if (token.kind !== TokenKind.EOF) {
        do {
          if (token.next) {
            token = token.next;
          } else {
            const nextToken = readNextToken(this, token.end);
            token.next = nextToken;
            nextToken.prev = token;
            token = nextToken;
          }
        } while (token.kind === TokenKind.COMMENT);
      }
      return token;
    }
  };
  function isPunctuatorTokenKind(kind) {
    return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
  }
  function isUnicodeScalarValue(code) {
    return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
  }
  function isSupplementaryCodePoint(body, location) {
    return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
  }
  function isLeadingSurrogate(code) {
    return code >= 55296 && code <= 56319;
  }
  function isTrailingSurrogate(code) {
    return code >= 56320 && code <= 57343;
  }
  function printCodePointAt(lexer, location) {
    const code = lexer.source.body.codePointAt(location);
    if (code === void 0) {
      return TokenKind.EOF;
    } else if (code >= 32 && code <= 126) {
      const char = String.fromCodePoint(code);
      return char === '"' ? `'"'` : `"${char}"`;
    }
    return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
  }
  function createToken(lexer, kind, start, end, value) {
    const line = lexer.line;
    const col = 1 + start - lexer.lineStart;
    return new Token(kind, start, end, line, col, value);
  }
  function readNextToken(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start;
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      switch (code) {
        case 65279:
        case 9:
        case 32:
        case 44:
          ++position;
          continue;
        case 10:
          ++position;
          ++lexer.line;
          lexer.lineStart = position;
          continue;
        case 13:
          if (body.charCodeAt(position + 1) === 10) {
            position += 2;
          } else {
            ++position;
          }
          ++lexer.line;
          lexer.lineStart = position;
          continue;
        case 35:
          return readComment(lexer, position);
        case 33:
          return createToken(lexer, TokenKind.BANG, position, position + 1);
        case 36:
          return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
        case 38:
          return createToken(lexer, TokenKind.AMP, position, position + 1);
        case 40:
          return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
        case 41:
          return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
        case 46:
          if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
            return createToken(lexer, TokenKind.SPREAD, position, position + 3);
          }
          break;
        case 58:
          return createToken(lexer, TokenKind.COLON, position, position + 1);
        case 61:
          return createToken(lexer, TokenKind.EQUALS, position, position + 1);
        case 64:
          return createToken(lexer, TokenKind.AT, position, position + 1);
        case 91:
          return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
        case 93:
          return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
        case 123:
          return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
        case 124:
          return createToken(lexer, TokenKind.PIPE, position, position + 1);
        case 125:
          return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
        case 34:
          if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
            return readBlockString(lexer, position);
          }
          return readString(lexer, position);
      }
      if (isDigit(code) || code === 45) {
        return readNumber(lexer, position, code);
      }
      if (isNameStart(code)) {
        return readName(lexer, position);
      }
      throw syntaxError(
        lexer.source,
        position,
        code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`
      );
    }
    return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
  }
  function readComment(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start + 1;
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if (code === 10 || code === 13) {
        break;
      }
      if (isUnicodeScalarValue(code)) {
        ++position;
      } else if (isSupplementaryCodePoint(body, position)) {
        position += 2;
      } else {
        break;
      }
    }
    return createToken(
      lexer,
      TokenKind.COMMENT,
      start,
      position,
      body.slice(start + 1, position)
    );
  }
  function readNumber(lexer, start, firstCode) {
    const body = lexer.source.body;
    let position = start;
    let code = firstCode;
    let isFloat = false;
    if (code === 45) {
      code = body.charCodeAt(++position);
    }
    if (code === 48) {
      code = body.charCodeAt(++position);
      if (isDigit(code)) {
        throw syntaxError(
          lexer.source,
          position,
          `Invalid number, unexpected digit after 0: ${printCodePointAt(
            lexer,
            position
          )}.`
        );
      }
    } else {
      position = readDigits(lexer, position, code);
      code = body.charCodeAt(position);
    }
    if (code === 46) {
      isFloat = true;
      code = body.charCodeAt(++position);
      position = readDigits(lexer, position, code);
      code = body.charCodeAt(position);
    }
    if (code === 69 || code === 101) {
      isFloat = true;
      code = body.charCodeAt(++position);
      if (code === 43 || code === 45) {
        code = body.charCodeAt(++position);
      }
      position = readDigits(lexer, position, code);
      code = body.charCodeAt(position);
    }
    if (code === 46 || isNameStart(code)) {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid number, expected digit but got: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
    return createToken(
      lexer,
      isFloat ? TokenKind.FLOAT : TokenKind.INT,
      start,
      position,
      body.slice(start, position)
    );
  }
  function readDigits(lexer, start, firstCode) {
    if (!isDigit(firstCode)) {
      throw syntaxError(
        lexer.source,
        start,
        `Invalid number, expected digit but got: ${printCodePointAt(
          lexer,
          start
        )}.`
      );
    }
    const body = lexer.source.body;
    let position = start + 1;
    while (isDigit(body.charCodeAt(position))) {
      ++position;
    }
    return position;
  }
  function readString(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start + 1;
    let chunkStart = position;
    let value = "";
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if (code === 34) {
        value += body.slice(chunkStart, position);
        return createToken(lexer, TokenKind.STRING, start, position + 1, value);
      }
      if (code === 92) {
        value += body.slice(chunkStart, position);
        const escape2 = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
        value += escape2.value;
        position += escape2.size;
        chunkStart = position;
        continue;
      }
      if (code === 10 || code === 13) {
        break;
      }
      if (isUnicodeScalarValue(code)) {
        ++position;
      } else if (isSupplementaryCodePoint(body, position)) {
        position += 2;
      } else {
        throw syntaxError(
          lexer.source,
          position,
          `Invalid character within String: ${printCodePointAt(
            lexer,
            position
          )}.`
        );
      }
    }
    throw syntaxError(lexer.source, position, "Unterminated string.");
  }
  function readEscapedUnicodeVariableWidth(lexer, position) {
    const body = lexer.source.body;
    let point = 0;
    let size = 3;
    while (size < 12) {
      const code = body.charCodeAt(position + size++);
      if (code === 125) {
        if (size < 5 || !isUnicodeScalarValue(point)) {
          break;
        }
        return {
          value: String.fromCodePoint(point),
          size
        };
      }
      point = point << 4 | readHexDigit(code);
      if (point < 0) {
        break;
      }
    }
    throw syntaxError(
      lexer.source,
      position,
      `Invalid Unicode escape sequence: "${body.slice(
        position,
        position + size
      )}".`
    );
  }
  function readEscapedUnicodeFixedWidth(lexer, position) {
    const body = lexer.source.body;
    const code = read16BitHexCode(body, position + 2);
    if (isUnicodeScalarValue(code)) {
      return {
        value: String.fromCodePoint(code),
        size: 6
      };
    }
    if (isLeadingSurrogate(code)) {
      if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
        const trailingCode = read16BitHexCode(body, position + 8);
        if (isTrailingSurrogate(trailingCode)) {
          return {
            value: String.fromCodePoint(code, trailingCode),
            size: 12
          };
        }
      }
    }
    throw syntaxError(
      lexer.source,
      position,
      `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
    );
  }
  function read16BitHexCode(body, position) {
    return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
  }
  function readHexDigit(code) {
    return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
  }
  function readEscapedCharacter(lexer, position) {
    const body = lexer.source.body;
    const code = body.charCodeAt(position + 1);
    switch (code) {
      case 34:
        return {
          value: '"',
          size: 2
        };
      case 92:
        return {
          value: "\\",
          size: 2
        };
      case 47:
        return {
          value: "/",
          size: 2
        };
      case 98:
        return {
          value: "\b",
          size: 2
        };
      case 102:
        return {
          value: "\f",
          size: 2
        };
      case 110:
        return {
          value: "\n",
          size: 2
        };
      case 114:
        return {
          value: "\r",
          size: 2
        };
      case 116:
        return {
          value: "	",
          size: 2
        };
    }
    throw syntaxError(
      lexer.source,
      position,
      `Invalid character escape sequence: "${body.slice(
        position,
        position + 2
      )}".`
    );
  }
  function readBlockString(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let lineStart = lexer.lineStart;
    let position = start + 3;
    let chunkStart = position;
    let currentLine = "";
    const blockLines = [];
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
        currentLine += body.slice(chunkStart, position);
        blockLines.push(currentLine);
        const token = createToken(
          lexer,
          TokenKind.BLOCK_STRING,
          start,
          position + 3,
          // Return a string of the lines joined with U+000A.
          dedentBlockStringLines(blockLines).join("\n")
        );
        lexer.line += blockLines.length - 1;
        lexer.lineStart = lineStart;
        return token;
      }
      if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
        currentLine += body.slice(chunkStart, position);
        chunkStart = position + 1;
        position += 4;
        continue;
      }
      if (code === 10 || code === 13) {
        currentLine += body.slice(chunkStart, position);
        blockLines.push(currentLine);
        if (code === 13 && body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        currentLine = "";
        chunkStart = position;
        lineStart = position;
        continue;
      }
      if (isUnicodeScalarValue(code)) {
        ++position;
      } else if (isSupplementaryCodePoint(body, position)) {
        position += 2;
      } else {
        throw syntaxError(
          lexer.source,
          position,
          `Invalid character within String: ${printCodePointAt(
            lexer,
            position
          )}.`
        );
      }
    }
    throw syntaxError(lexer.source, position, "Unterminated string.");
  }
  function readName(lexer, start) {
    const body = lexer.source.body;
    const bodyLength = body.length;
    let position = start + 1;
    while (position < bodyLength) {
      const code = body.charCodeAt(position);
      if (isNameContinue(code)) {
        ++position;
      } else {
        break;
      }
    }
    return createToken(
      lexer,
      TokenKind.NAME,
      start,
      position,
      body.slice(start, position)
    );
  }

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/inspect.mjs
  var MAX_ARRAY_LENGTH = 10;
  var MAX_RECURSIVE_DEPTH = 2;
  function inspect(value) {
    return formatValue(value, []);
  }
  function formatValue(value, seenValues) {
    switch (typeof value) {
      case "string":
        return JSON.stringify(value);
      case "function":
        return value.name ? `[function ${value.name}]` : "[function]";
      case "object":
        return formatObjectValue(value, seenValues);
      default:
        return String(value);
    }
  }
  function formatObjectValue(value, previouslySeenValues) {
    if (value === null) {
      return "null";
    }
    if (previouslySeenValues.includes(value)) {
      return "[Circular]";
    }
    const seenValues = [...previouslySeenValues, value];
    if (isJSONable(value)) {
      const jsonValue = value.toJSON();
      if (jsonValue !== value) {
        return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
      }
    } else if (Array.isArray(value)) {
      return formatArray(value, seenValues);
    }
    return formatObject(value, seenValues);
  }
  function isJSONable(value) {
    return typeof value.toJSON === "function";
  }
  function formatObject(object2, seenValues) {
    const entries = Object.entries(object2);
    if (entries.length === 0) {
      return "{}";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
      return "[" + getObjectTag(object2) + "]";
    }
    const properties = entries.map(
      ([key, value]) => key + ": " + formatValue(value, seenValues)
    );
    return "{ " + properties.join(", ") + " }";
  }
  function formatArray(array2, seenValues) {
    if (array2.length === 0) {
      return "[]";
    }
    if (seenValues.length > MAX_RECURSIVE_DEPTH) {
      return "[Array]";
    }
    const len = Math.min(MAX_ARRAY_LENGTH, array2.length);
    const remaining = array2.length - len;
    const items = [];
    for (let i = 0; i < len; ++i) {
      items.push(formatValue(array2[i], seenValues));
    }
    if (remaining === 1) {
      items.push("... 1 more item");
    } else if (remaining > 1) {
      items.push(`... ${remaining} more items`);
    }
    return "[" + items.join(", ") + "]";
  }
  function getObjectTag(object2) {
    const tag = Object.prototype.toString.call(object2).replace(/^\[object /, "").replace(/]$/, "");
    if (tag === "Object" && typeof object2.constructor === "function") {
      const name = object2.constructor.name;
      if (typeof name === "string" && name !== "") {
        return name;
      }
    }
    return tag;
  }

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/jsutils/instanceOf.mjs
  var instanceOf = (
    /* c8 ignore next 6 */
    // FIXME: https://github.com/graphql/graphql-js/issues/2317
    // eslint-disable-next-line no-undef
    process.env.NODE_ENV === "production" ? function instanceOf2(value, constructor) {
      return value instanceof constructor;
    } : function instanceOf3(value, constructor) {
      if (value instanceof constructor) {
        return true;
      }
      if (typeof value === "object" && value !== null) {
        var _value$constructor;
        const className = constructor.prototype[Symbol.toStringTag];
        const valueClassName = (
          // We still need to support constructor's name to detect conflicts with older versions of this library.
          Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
        );
        if (className === valueClassName) {
          const stringifiedValue = inspect(value);
          throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
        }
      }
      return false;
    }
  );

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/source.mjs
  var Source = class {
    constructor(body, name = "GraphQL request", locationOffset = {
      line: 1,
      column: 1
    }) {
      typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
      this.body = body;
      this.name = name;
      this.locationOffset = locationOffset;
      this.locationOffset.line > 0 || devAssert(
        false,
        "line in locationOffset is 1-indexed and must be positive."
      );
      this.locationOffset.column > 0 || devAssert(
        false,
        "column in locationOffset is 1-indexed and must be positive."
      );
    }
    get [Symbol.toStringTag]() {
      return "Source";
    }
  };
  function isSource(source) {
    return instanceOf(source, Source);
  }

  // ../../node_modules/.pnpm/graphql@16.6.0/node_modules/graphql/language/parser.mjs
  function parse(source, options) {
    const parser = new Parser(source, options);
    return parser.parseDocument();
  }
  var Parser = class {
    constructor(source, options = {}) {
      const sourceObj = isSource(source) ? source : new Source(source);
      this._lexer = new Lexer(sourceObj);
      this._options = options;
      this._tokenCounter = 0;
    }
    /**
     * Converts a name lex token into a name parse node.
     */
    parseName() {
      const token = this.expectToken(TokenKind.NAME);
      return this.node(token, {
        kind: Kind.NAME,
        value: token.value
      });
    }
    // Implements the parsing rules in the Document section.
    /**
     * Document : Definition+
     */
    parseDocument() {
      return this.node(this._lexer.token, {
        kind: Kind.DOCUMENT,
        definitions: this.many(
          TokenKind.SOF,
          this.parseDefinition,
          TokenKind.EOF
        )
      });
    }
    /**
     * Definition :
     *   - ExecutableDefinition
     *   - TypeSystemDefinition
     *   - TypeSystemExtension
     *
     * ExecutableDefinition :
     *   - OperationDefinition
     *   - FragmentDefinition
     *
     * TypeSystemDefinition :
     *   - SchemaDefinition
     *   - TypeDefinition
     *   - DirectiveDefinition
     *
     * TypeDefinition :
     *   - ScalarTypeDefinition
     *   - ObjectTypeDefinition
     *   - InterfaceTypeDefinition
     *   - UnionTypeDefinition
     *   - EnumTypeDefinition
     *   - InputObjectTypeDefinition
     */
    parseDefinition() {
      if (this.peek(TokenKind.BRACE_L)) {
        return this.parseOperationDefinition();
      }
      const hasDescription = this.peekDescription();
      const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
      if (keywordToken.kind === TokenKind.NAME) {
        switch (keywordToken.value) {
          case "schema":
            return this.parseSchemaDefinition();
          case "scalar":
            return this.parseScalarTypeDefinition();
          case "type":
            return this.parseObjectTypeDefinition();
          case "interface":
            return this.parseInterfaceTypeDefinition();
          case "union":
            return this.parseUnionTypeDefinition();
          case "enum":
            return this.parseEnumTypeDefinition();
          case "input":
            return this.parseInputObjectTypeDefinition();
          case "directive":
            return this.parseDirectiveDefinition();
        }
        if (hasDescription) {
          throw syntaxError(
            this._lexer.source,
            this._lexer.token.start,
            "Unexpected description, descriptions are supported only on type definitions."
          );
        }
        switch (keywordToken.value) {
          case "query":
          case "mutation":
          case "subscription":
            return this.parseOperationDefinition();
          case "fragment":
            return this.parseFragmentDefinition();
          case "extend":
            return this.parseTypeSystemExtension();
        }
      }
      throw this.unexpected(keywordToken);
    }
    // Implements the parsing rules in the Operations section.
    /**
     * OperationDefinition :
     *  - SelectionSet
     *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
     */
    parseOperationDefinition() {
      const start = this._lexer.token;
      if (this.peek(TokenKind.BRACE_L)) {
        return this.node(start, {
          kind: Kind.OPERATION_DEFINITION,
          operation: OperationTypeNode.QUERY,
          name: void 0,
          variableDefinitions: [],
          directives: [],
          selectionSet: this.parseSelectionSet()
        });
      }
      const operation = this.parseOperationType();
      let name;
      if (this.peek(TokenKind.NAME)) {
        name = this.parseName();
      }
      return this.node(start, {
        kind: Kind.OPERATION_DEFINITION,
        operation,
        name,
        variableDefinitions: this.parseVariableDefinitions(),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    /**
     * OperationType : one of query mutation subscription
     */
    parseOperationType() {
      const operationToken = this.expectToken(TokenKind.NAME);
      switch (operationToken.value) {
        case "query":
          return OperationTypeNode.QUERY;
        case "mutation":
          return OperationTypeNode.MUTATION;
        case "subscription":
          return OperationTypeNode.SUBSCRIPTION;
      }
      throw this.unexpected(operationToken);
    }
    /**
     * VariableDefinitions : ( VariableDefinition+ )
     */
    parseVariableDefinitions() {
      return this.optionalMany(
        TokenKind.PAREN_L,
        this.parseVariableDefinition,
        TokenKind.PAREN_R
      );
    }
    /**
     * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
     */
    parseVariableDefinition() {
      return this.node(this._lexer.token, {
        kind: Kind.VARIABLE_DEFINITION,
        variable: this.parseVariable(),
        type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
        defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
        directives: this.parseConstDirectives()
      });
    }
    /**
     * Variable : $ Name
     */
    parseVariable() {
      const start = this._lexer.token;
      this.expectToken(TokenKind.DOLLAR);
      return this.node(start, {
        kind: Kind.VARIABLE,
        name: this.parseName()
      });
    }
    /**
     * ```
     * SelectionSet : { Selection+ }
     * ```
     */
    parseSelectionSet() {
      return this.node(this._lexer.token, {
        kind: Kind.SELECTION_SET,
        selections: this.many(
          TokenKind.BRACE_L,
          this.parseSelection,
          TokenKind.BRACE_R
        )
      });
    }
    /**
     * Selection :
     *   - Field
     *   - FragmentSpread
     *   - InlineFragment
     */
    parseSelection() {
      return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
    }
    /**
     * Field : Alias? Name Arguments? Directives? SelectionSet?
     *
     * Alias : Name :
     */
    parseField() {
      const start = this._lexer.token;
      const nameOrAlias = this.parseName();
      let alias;
      let name;
      if (this.expectOptionalToken(TokenKind.COLON)) {
        alias = nameOrAlias;
        name = this.parseName();
      } else {
        name = nameOrAlias;
      }
      return this.node(start, {
        kind: Kind.FIELD,
        alias,
        name,
        arguments: this.parseArguments(false),
        directives: this.parseDirectives(false),
        selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
      });
    }
    /**
     * Arguments[Const] : ( Argument[?Const]+ )
     */
    parseArguments(isConst) {
      const item = isConst ? this.parseConstArgument : this.parseArgument;
      return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
    }
    /**
     * Argument[Const] : Name : Value[?Const]
     */
    parseArgument(isConst = false) {
      const start = this._lexer.token;
      const name = this.parseName();
      this.expectToken(TokenKind.COLON);
      return this.node(start, {
        kind: Kind.ARGUMENT,
        name,
        value: this.parseValueLiteral(isConst)
      });
    }
    parseConstArgument() {
      return this.parseArgument(true);
    }
    // Implements the parsing rules in the Fragments section.
    /**
     * Corresponds to both FragmentSpread and InlineFragment in the spec.
     *
     * FragmentSpread : ... FragmentName Directives?
     *
     * InlineFragment : ... TypeCondition? Directives? SelectionSet
     */
    parseFragment() {
      const start = this._lexer.token;
      this.expectToken(TokenKind.SPREAD);
      const hasTypeCondition = this.expectOptionalKeyword("on");
      if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
        return this.node(start, {
          kind: Kind.FRAGMENT_SPREAD,
          name: this.parseFragmentName(),
          directives: this.parseDirectives(false)
        });
      }
      return this.node(start, {
        kind: Kind.INLINE_FRAGMENT,
        typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    /**
     * FragmentDefinition :
     *   - fragment FragmentName on TypeCondition Directives? SelectionSet
     *
     * TypeCondition : NamedType
     */
    parseFragmentDefinition() {
      const start = this._lexer.token;
      this.expectKeyword("fragment");
      if (this._options.allowLegacyFragmentVariables === true) {
        return this.node(start, {
          kind: Kind.FRAGMENT_DEFINITION,
          name: this.parseFragmentName(),
          variableDefinitions: this.parseVariableDefinitions(),
          typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet()
        });
      }
      return this.node(start, {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    /**
     * FragmentName : Name but not `on`
     */
    parseFragmentName() {
      if (this._lexer.token.value === "on") {
        throw this.unexpected();
      }
      return this.parseName();
    }
    // Implements the parsing rules in the Values section.
    /**
     * Value[Const] :
     *   - [~Const] Variable
     *   - IntValue
     *   - FloatValue
     *   - StringValue
     *   - BooleanValue
     *   - NullValue
     *   - EnumValue
     *   - ListValue[?Const]
     *   - ObjectValue[?Const]
     *
     * BooleanValue : one of `true` `false`
     *
     * NullValue : `null`
     *
     * EnumValue : Name but not `true`, `false` or `null`
     */
    parseValueLiteral(isConst) {
      const token = this._lexer.token;
      switch (token.kind) {
        case TokenKind.BRACKET_L:
          return this.parseList(isConst);
        case TokenKind.BRACE_L:
          return this.parseObject(isConst);
        case TokenKind.INT:
          this.advanceLexer();
          return this.node(token, {
            kind: Kind.INT,
            value: token.value
          });
        case TokenKind.FLOAT:
          this.advanceLexer();
          return this.node(token, {
            kind: Kind.FLOAT,
            value: token.value
          });
        case TokenKind.STRING:
        case TokenKind.BLOCK_STRING:
          return this.parseStringLiteral();
        case TokenKind.NAME:
          this.advanceLexer();
          switch (token.value) {
            case "true":
              return this.node(token, {
                kind: Kind.BOOLEAN,
                value: true
              });
            case "false":
              return this.node(token, {
                kind: Kind.BOOLEAN,
                value: false
              });
            case "null":
              return this.node(token, {
                kind: Kind.NULL
              });
            default:
              return this.node(token, {
                kind: Kind.ENUM,
                value: token.value
              });
          }
        case TokenKind.DOLLAR:
          if (isConst) {
            this.expectToken(TokenKind.DOLLAR);
            if (this._lexer.token.kind === TokenKind.NAME) {
              const varName = this._lexer.token.value;
              throw syntaxError(
                this._lexer.source,
                token.start,
                `Unexpected variable "$${varName}" in constant value.`
              );
            } else {
              throw this.unexpected(token);
            }
          }
          return this.parseVariable();
        default:
          throw this.unexpected();
      }
    }
    parseConstValueLiteral() {
      return this.parseValueLiteral(true);
    }
    parseStringLiteral() {
      const token = this._lexer.token;
      this.advanceLexer();
      return this.node(token, {
        kind: Kind.STRING,
        value: token.value,
        block: token.kind === TokenKind.BLOCK_STRING
      });
    }
    /**
     * ListValue[Const] :
     *   - [ ]
     *   - [ Value[?Const]+ ]
     */
    parseList(isConst) {
      const item = () => this.parseValueLiteral(isConst);
      return this.node(this._lexer.token, {
        kind: Kind.LIST,
        values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
      });
    }
    /**
     * ```
     * ObjectValue[Const] :
     *   - { }
     *   - { ObjectField[?Const]+ }
     * ```
     */
    parseObject(isConst) {
      const item = () => this.parseObjectField(isConst);
      return this.node(this._lexer.token, {
        kind: Kind.OBJECT,
        fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
      });
    }
    /**
     * ObjectField[Const] : Name : Value[?Const]
     */
    parseObjectField(isConst) {
      const start = this._lexer.token;
      const name = this.parseName();
      this.expectToken(TokenKind.COLON);
      return this.node(start, {
        kind: Kind.OBJECT_FIELD,
        name,
        value: this.parseValueLiteral(isConst)
      });
    }
    // Implements the parsing rules in the Directives section.
    /**
     * Directives[Const] : Directive[?Const]+
     */
    parseDirectives(isConst) {
      const directives = [];
      while (this.peek(TokenKind.AT)) {
        directives.push(this.parseDirective(isConst));
      }
      return directives;
    }
    parseConstDirectives() {
      return this.parseDirectives(true);
    }
    /**
     * ```
     * Directive[Const] : @ Name Arguments[?Const]?
     * ```
     */
    parseDirective(isConst) {
      const start = this._lexer.token;
      this.expectToken(TokenKind.AT);
      return this.node(start, {
        kind: Kind.DIRECTIVE,
        name: this.parseName(),
        arguments: this.parseArguments(isConst)
      });
    }
    // Implements the parsing rules in the Types section.
    /**
     * Type :
     *   - NamedType
     *   - ListType
     *   - NonNullType
     */
    parseTypeReference() {
      const start = this._lexer.token;
      let type3;
      if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
        const innerType = this.parseTypeReference();
        this.expectToken(TokenKind.BRACKET_R);
        type3 = this.node(start, {
          kind: Kind.LIST_TYPE,
          type: innerType
        });
      } else {
        type3 = this.parseNamedType();
      }
      if (this.expectOptionalToken(TokenKind.BANG)) {
        return this.node(start, {
          kind: Kind.NON_NULL_TYPE,
          type: type3
        });
      }
      return type3;
    }
    /**
     * NamedType : Name
     */
    parseNamedType() {
      return this.node(this._lexer.token, {
        kind: Kind.NAMED_TYPE,
        name: this.parseName()
      });
    }
    // Implements the parsing rules in the Type Definition section.
    peekDescription() {
      return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
    }
    /**
     * Description : StringValue
     */
    parseDescription() {
      if (this.peekDescription()) {
        return this.parseStringLiteral();
      }
    }
    /**
     * ```
     * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
     * ```
     */
    parseSchemaDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("schema");
      const directives = this.parseConstDirectives();
      const operationTypes = this.many(
        TokenKind.BRACE_L,
        this.parseOperationTypeDefinition,
        TokenKind.BRACE_R
      );
      return this.node(start, {
        kind: Kind.SCHEMA_DEFINITION,
        description,
        directives,
        operationTypes
      });
    }
    /**
     * OperationTypeDefinition : OperationType : NamedType
     */
    parseOperationTypeDefinition() {
      const start = this._lexer.token;
      const operation = this.parseOperationType();
      this.expectToken(TokenKind.COLON);
      const type3 = this.parseNamedType();
      return this.node(start, {
        kind: Kind.OPERATION_TYPE_DEFINITION,
        operation,
        type: type3
      });
    }
    /**
     * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
     */
    parseScalarTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("scalar");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: Kind.SCALAR_TYPE_DEFINITION,
        description,
        name,
        directives
      });
    }
    /**
     * ObjectTypeDefinition :
     *   Description?
     *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
     */
    parseObjectTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("type");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      return this.node(start, {
        kind: Kind.OBJECT_TYPE_DEFINITION,
        description,
        name,
        interfaces,
        directives,
        fields
      });
    }
    /**
     * ImplementsInterfaces :
     *   - implements `&`? NamedType
     *   - ImplementsInterfaces & NamedType
     */
    parseImplementsInterfaces() {
      return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
    }
    /**
     * ```
     * FieldsDefinition : { FieldDefinition+ }
     * ```
     */
    parseFieldsDefinition() {
      return this.optionalMany(
        TokenKind.BRACE_L,
        this.parseFieldDefinition,
        TokenKind.BRACE_R
      );
    }
    /**
     * FieldDefinition :
     *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
     */
    parseFieldDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      const name = this.parseName();
      const args = this.parseArgumentDefs();
      this.expectToken(TokenKind.COLON);
      const type3 = this.parseTypeReference();
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: Kind.FIELD_DEFINITION,
        description,
        name,
        arguments: args,
        type: type3,
        directives
      });
    }
    /**
     * ArgumentsDefinition : ( InputValueDefinition+ )
     */
    parseArgumentDefs() {
      return this.optionalMany(
        TokenKind.PAREN_L,
        this.parseInputValueDef,
        TokenKind.PAREN_R
      );
    }
    /**
     * InputValueDefinition :
     *   - Description? Name : Type DefaultValue? Directives[Const]?
     */
    parseInputValueDef() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      const name = this.parseName();
      this.expectToken(TokenKind.COLON);
      const type3 = this.parseTypeReference();
      let defaultValue;
      if (this.expectOptionalToken(TokenKind.EQUALS)) {
        defaultValue = this.parseConstValueLiteral();
      }
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: Kind.INPUT_VALUE_DEFINITION,
        description,
        name,
        type: type3,
        defaultValue,
        directives
      });
    }
    /**
     * InterfaceTypeDefinition :
     *   - Description? interface Name Directives[Const]? FieldsDefinition?
     */
    parseInterfaceTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("interface");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      return this.node(start, {
        kind: Kind.INTERFACE_TYPE_DEFINITION,
        description,
        name,
        interfaces,
        directives,
        fields
      });
    }
    /**
     * UnionTypeDefinition :
     *   - Description? union Name Directives[Const]? UnionMemberTypes?
     */
    parseUnionTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("union");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const types2 = this.parseUnionMemberTypes();
      return this.node(start, {
        kind: Kind.UNION_TYPE_DEFINITION,
        description,
        name,
        directives,
        types: types2
      });
    }
    /**
     * UnionMemberTypes :
     *   - = `|`? NamedType
     *   - UnionMemberTypes | NamedType
     */
    parseUnionMemberTypes() {
      return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
    }
    /**
     * EnumTypeDefinition :
     *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
     */
    parseEnumTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("enum");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const values = this.parseEnumValuesDefinition();
      return this.node(start, {
        kind: Kind.ENUM_TYPE_DEFINITION,
        description,
        name,
        directives,
        values
      });
    }
    /**
     * ```
     * EnumValuesDefinition : { EnumValueDefinition+ }
     * ```
     */
    parseEnumValuesDefinition() {
      return this.optionalMany(
        TokenKind.BRACE_L,
        this.parseEnumValueDefinition,
        TokenKind.BRACE_R
      );
    }
    /**
     * EnumValueDefinition : Description? EnumValue Directives[Const]?
     */
    parseEnumValueDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      const name = this.parseEnumValueName();
      const directives = this.parseConstDirectives();
      return this.node(start, {
        kind: Kind.ENUM_VALUE_DEFINITION,
        description,
        name,
        directives
      });
    }
    /**
     * EnumValue : Name but not `true`, `false` or `null`
     */
    parseEnumValueName() {
      if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
        throw syntaxError(
          this._lexer.source,
          this._lexer.token.start,
          `${getTokenDesc(
            this._lexer.token
          )} is reserved and cannot be used for an enum value.`
        );
      }
      return this.parseName();
    }
    /**
     * InputObjectTypeDefinition :
     *   - Description? input Name Directives[Const]? InputFieldsDefinition?
     */
    parseInputObjectTypeDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("input");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const fields = this.parseInputFieldsDefinition();
      return this.node(start, {
        kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
        description,
        name,
        directives,
        fields
      });
    }
    /**
     * ```
     * InputFieldsDefinition : { InputValueDefinition+ }
     * ```
     */
    parseInputFieldsDefinition() {
      return this.optionalMany(
        TokenKind.BRACE_L,
        this.parseInputValueDef,
        TokenKind.BRACE_R
      );
    }
    /**
     * TypeSystemExtension :
     *   - SchemaExtension
     *   - TypeExtension
     *
     * TypeExtension :
     *   - ScalarTypeExtension
     *   - ObjectTypeExtension
     *   - InterfaceTypeExtension
     *   - UnionTypeExtension
     *   - EnumTypeExtension
     *   - InputObjectTypeDefinition
     */
    parseTypeSystemExtension() {
      const keywordToken = this._lexer.lookahead();
      if (keywordToken.kind === TokenKind.NAME) {
        switch (keywordToken.value) {
          case "schema":
            return this.parseSchemaExtension();
          case "scalar":
            return this.parseScalarTypeExtension();
          case "type":
            return this.parseObjectTypeExtension();
          case "interface":
            return this.parseInterfaceTypeExtension();
          case "union":
            return this.parseUnionTypeExtension();
          case "enum":
            return this.parseEnumTypeExtension();
          case "input":
            return this.parseInputObjectTypeExtension();
        }
      }
      throw this.unexpected(keywordToken);
    }
    /**
     * ```
     * SchemaExtension :
     *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
     *  - extend schema Directives[Const]
     * ```
     */
    parseSchemaExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("schema");
      const directives = this.parseConstDirectives();
      const operationTypes = this.optionalMany(
        TokenKind.BRACE_L,
        this.parseOperationTypeDefinition,
        TokenKind.BRACE_R
      );
      if (directives.length === 0 && operationTypes.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.SCHEMA_EXTENSION,
        directives,
        operationTypes
      });
    }
    /**
     * ScalarTypeExtension :
     *   - extend scalar Name Directives[Const]
     */
    parseScalarTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("scalar");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      if (directives.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.SCALAR_TYPE_EXTENSION,
        name,
        directives
      });
    }
    /**
     * ObjectTypeExtension :
     *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
     *  - extend type Name ImplementsInterfaces? Directives[Const]
     *  - extend type Name ImplementsInterfaces
     */
    parseObjectTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("type");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.OBJECT_TYPE_EXTENSION,
        name,
        interfaces,
        directives,
        fields
      });
    }
    /**
     * InterfaceTypeExtension :
     *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
     *  - extend interface Name ImplementsInterfaces? Directives[Const]
     *  - extend interface Name ImplementsInterfaces
     */
    parseInterfaceTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("interface");
      const name = this.parseName();
      const interfaces = this.parseImplementsInterfaces();
      const directives = this.parseConstDirectives();
      const fields = this.parseFieldsDefinition();
      if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.INTERFACE_TYPE_EXTENSION,
        name,
        interfaces,
        directives,
        fields
      });
    }
    /**
     * UnionTypeExtension :
     *   - extend union Name Directives[Const]? UnionMemberTypes
     *   - extend union Name Directives[Const]
     */
    parseUnionTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("union");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const types2 = this.parseUnionMemberTypes();
      if (directives.length === 0 && types2.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.UNION_TYPE_EXTENSION,
        name,
        directives,
        types: types2
      });
    }
    /**
     * EnumTypeExtension :
     *   - extend enum Name Directives[Const]? EnumValuesDefinition
     *   - extend enum Name Directives[Const]
     */
    parseEnumTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("enum");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const values = this.parseEnumValuesDefinition();
      if (directives.length === 0 && values.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.ENUM_TYPE_EXTENSION,
        name,
        directives,
        values
      });
    }
    /**
     * InputObjectTypeExtension :
     *   - extend input Name Directives[Const]? InputFieldsDefinition
     *   - extend input Name Directives[Const]
     */
    parseInputObjectTypeExtension() {
      const start = this._lexer.token;
      this.expectKeyword("extend");
      this.expectKeyword("input");
      const name = this.parseName();
      const directives = this.parseConstDirectives();
      const fields = this.parseInputFieldsDefinition();
      if (directives.length === 0 && fields.length === 0) {
        throw this.unexpected();
      }
      return this.node(start, {
        kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
        name,
        directives,
        fields
      });
    }
    /**
     * ```
     * DirectiveDefinition :
     *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
     * ```
     */
    parseDirectiveDefinition() {
      const start = this._lexer.token;
      const description = this.parseDescription();
      this.expectKeyword("directive");
      this.expectToken(TokenKind.AT);
      const name = this.parseName();
      const args = this.parseArgumentDefs();
      const repeatable = this.expectOptionalKeyword("repeatable");
      this.expectKeyword("on");
      const locations = this.parseDirectiveLocations();
      return this.node(start, {
        kind: Kind.DIRECTIVE_DEFINITION,
        description,
        name,
        arguments: args,
        repeatable,
        locations
      });
    }
    /**
     * DirectiveLocations :
     *   - `|`? DirectiveLocation
     *   - DirectiveLocations | DirectiveLocation
     */
    parseDirectiveLocations() {
      return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
    }
    /*
     * DirectiveLocation :
     *   - ExecutableDirectiveLocation
     *   - TypeSystemDirectiveLocation
     *
     * ExecutableDirectiveLocation : one of
     *   `QUERY`
     *   `MUTATION`
     *   `SUBSCRIPTION`
     *   `FIELD`
     *   `FRAGMENT_DEFINITION`
     *   `FRAGMENT_SPREAD`
     *   `INLINE_FRAGMENT`
     *
     * TypeSystemDirectiveLocation : one of
     *   `SCHEMA`
     *   `SCALAR`
     *   `OBJECT`
     *   `FIELD_DEFINITION`
     *   `ARGUMENT_DEFINITION`
     *   `INTERFACE`
     *   `UNION`
     *   `ENUM`
     *   `ENUM_VALUE`
     *   `INPUT_OBJECT`
     *   `INPUT_FIELD_DEFINITION`
     */
    parseDirectiveLocation() {
      const start = this._lexer.token;
      const name = this.parseName();
      if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
        return name;
      }
      throw this.unexpected(start);
    }
    // Core parsing utility functions
    /**
     * Returns a node that, if configured to do so, sets a "loc" field as a
     * location object, used to identify the place in the source that created a
     * given parsed object.
     */
    node(startToken, node) {
      if (this._options.noLocation !== true) {
        node.loc = new Location(
          startToken,
          this._lexer.lastToken,
          this._lexer.source
        );
      }
      return node;
    }
    /**
     * Determines if the next token is of a given kind
     */
    peek(kind) {
      return this._lexer.token.kind === kind;
    }
    /**
     * If the next token is of the given kind, return that token after advancing the lexer.
     * Otherwise, do not change the parser state and throw an error.
     */
    expectToken(kind) {
      const token = this._lexer.token;
      if (token.kind === kind) {
        this.advanceLexer();
        return token;
      }
      throw syntaxError(
        this._lexer.source,
        token.start,
        `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`
      );
    }
    /**
     * If the next token is of the given kind, return "true" after advancing the lexer.
     * Otherwise, do not change the parser state and return "false".
     */
    expectOptionalToken(kind) {
      const token = this._lexer.token;
      if (token.kind === kind) {
        this.advanceLexer();
        return true;
      }
      return false;
    }
    /**
     * If the next token is a given keyword, advance the lexer.
     * Otherwise, do not change the parser state and throw an error.
     */
    expectKeyword(value) {
      const token = this._lexer.token;
      if (token.kind === TokenKind.NAME && token.value === value) {
        this.advanceLexer();
      } else {
        throw syntaxError(
          this._lexer.source,
          token.start,
          `Expected "${value}", found ${getTokenDesc(token)}.`
        );
      }
    }
    /**
     * If the next token is a given keyword, return "true" after advancing the lexer.
     * Otherwise, do not change the parser state and return "false".
     */
    expectOptionalKeyword(value) {
      const token = this._lexer.token;
      if (token.kind === TokenKind.NAME && token.value === value) {
        this.advanceLexer();
        return true;
      }
      return false;
    }
    /**
     * Helper function for creating an error when an unexpected lexed token is encountered.
     */
    unexpected(atToken) {
      const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
      return syntaxError(
        this._lexer.source,
        token.start,
        `Unexpected ${getTokenDesc(token)}.`
      );
    }
    /**
     * Returns a possibly empty list of parse nodes, determined by the parseFn.
     * This list begins with a lex token of openKind and ends with a lex token of closeKind.
     * Advances the parser to the next lex token after the closing token.
     */
    any(openKind, parseFn, closeKind) {
      this.expectToken(openKind);
      const nodes = [];
      while (!this.expectOptionalToken(closeKind)) {
        nodes.push(parseFn.call(this));
      }
      return nodes;
    }
    /**
     * Returns a list of parse nodes, determined by the parseFn.
     * It can be empty only if open token is missing otherwise it will always return non-empty list
     * that begins with a lex token of openKind and ends with a lex token of closeKind.
     * Advances the parser to the next lex token after the closing token.
     */
    optionalMany(openKind, parseFn, closeKind) {
      if (this.expectOptionalToken(openKind)) {
        const nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (!this.expectOptionalToken(closeKind));
        return nodes;
      }
      return [];
    }
    /**
     * Returns a non-empty list of parse nodes, determined by the parseFn.
     * This list begins with a lex token of openKind and ends with a lex token of closeKind.
     * Advances the parser to the next lex token after the closing token.
     */
    many(openKind, parseFn, closeKind) {
      this.expectToken(openKind);
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    /**
     * Returns a non-empty list of parse nodes, determined by the parseFn.
     * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
     * Advances the parser to the next lex token after last item in the list.
     */
    delimitedMany(delimiterKind, parseFn) {
      this.expectOptionalToken(delimiterKind);
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (this.expectOptionalToken(delimiterKind));
      return nodes;
    }
    advanceLexer() {
      const { maxTokens } = this._options;
      const token = this._lexer.advance();
      if (maxTokens !== void 0 && token.kind !== TokenKind.EOF) {
        ++this._tokenCounter;
        if (this._tokenCounter > maxTokens) {
          throw syntaxError(
            this._lexer.source,
            token.start,
            `Document contains more that ${maxTokens} tokens. Parsing aborted.`
          );
        }
      }
    }
  };
  function getTokenDesc(token) {
    const value = token.value;
    return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
  }
  function getTokenKindDesc(kind) {
    return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
  }

  // ../../node_modules/.pnpm/graphql-tag@2.12.6_graphql@16.6.0/node_modules/graphql-tag/lib/index.js
  var docCache = /* @__PURE__ */ new Map();
  var fragmentSourceMap = /* @__PURE__ */ new Map();
  var printFragmentWarnings = true;
  var experimentalFragmentVariables = false;
  function normalize2(string2) {
    return string2.replace(/[\s,]+/g, " ").trim();
  }
  function cacheKeyFromLoc(loc) {
    return normalize2(loc.source.body.substring(loc.start, loc.end));
  }
  function processFragments(ast) {
    var seenKeys = /* @__PURE__ */ new Set();
    var definitions = [];
    ast.definitions.forEach(function(fragmentDefinition) {
      if (fragmentDefinition.kind === "FragmentDefinition") {
        var fragmentName = fragmentDefinition.name.value;
        var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
        var sourceKeySet = fragmentSourceMap.get(fragmentName);
        if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
          if (printFragmentWarnings) {
            console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
          }
        } else if (!sourceKeySet) {
          fragmentSourceMap.set(fragmentName, sourceKeySet = /* @__PURE__ */ new Set());
        }
        sourceKeySet.add(sourceKey);
        if (!seenKeys.has(sourceKey)) {
          seenKeys.add(sourceKey);
          definitions.push(fragmentDefinition);
        }
      } else {
        definitions.push(fragmentDefinition);
      }
    });
    return __assign(__assign({}, ast), { definitions });
  }
  function stripLoc(doc) {
    var workSet = new Set(doc.definitions);
    workSet.forEach(function(node) {
      if (node.loc)
        delete node.loc;
      Object.keys(node).forEach(function(key) {
        var value = node[key];
        if (value && typeof value === "object") {
          workSet.add(value);
        }
      });
    });
    var loc = doc.loc;
    if (loc) {
      delete loc.startToken;
      delete loc.endToken;
    }
    return doc;
  }
  function parseDocument(source) {
    var cacheKey = normalize2(source);
    if (!docCache.has(cacheKey)) {
      var parsed = parse(source, {
        experimentalFragmentVariables,
        allowLegacyFragmentVariables: experimentalFragmentVariables
      });
      if (!parsed || parsed.kind !== "Document") {
        throw new Error("Not a valid GraphQL document.");
      }
      docCache.set(cacheKey, stripLoc(processFragments(parsed)));
    }
    return docCache.get(cacheKey);
  }
  function gql(literals) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (typeof literals === "string") {
      literals = [literals];
    }
    var result = literals[0];
    args.forEach(function(arg, i) {
      if (arg && arg.kind === "Document") {
        result += arg.loc.source.body;
      } else {
        result += arg;
      }
      result += literals[i + 1];
    });
    return parseDocument(result);
  }
  function resetCaches() {
    docCache.clear();
    fragmentSourceMap.clear();
  }
  function disableFragmentWarnings() {
    printFragmentWarnings = false;
  }
  function enableExperimentalFragmentVariables() {
    experimentalFragmentVariables = true;
  }
  function disableExperimentalFragmentVariables() {
    experimentalFragmentVariables = false;
  }
  var extras = {
    gql,
    resetCaches,
    disableFragmentWarnings,
    enableExperimentalFragmentVariables,
    disableExperimentalFragmentVariables
  };
  (function(gql_1) {
    gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
  })(gql || (gql = {}));
  gql["default"] = gql;
  var lib_default2 = gql;

  // ../transactions/dist/configs.mjs
  var CONTRACT_MAX_SIZE = 16 * 1024;
  var MAX_SCRIPT_LENGTH = 1024 * 1024 * 1024;
  var MAX_SCRIPT_DATA_LENGTH = 1024 * 1024 * 1024;
  var MAX_PREDICATE_LENGTH = 1024 * 1024;
  var MAX_PREDICATE_DATA_LENGTH = 1024 * 1024;
  var FAILED_REQUIRE_SIGNAL = "0xffffffffffff0000";
  var FAILED_TRANSFER_TO_ADDRESS_SIGNAL = "0xffffffffffff0001";
  var FAILED_SEND_MESSAGE_SIGNAL = "0xffffffffffff0002";
  var FAILED_ASSERT_EQ_SIGNAL = "0xffffffffffff0003";
  var FAILED_ASSERT_SIGNAL = "0xffffffffffff0004";
  var FAILED_UNKNOWN_SIGNAL = "0x0";

  // ../providers/dist/index.mjs
  var import_tai64 = __toESM(require_lib4(), 1);
  var __defProp6 = Object.defineProperty;
  var __defNormalProp6 = (obj, key, value) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField6 = (obj, key, value) => {
    __defNormalProp6(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var __accessCheck3 = (obj, member, msg) => {
    if (!member.has(obj))
      throw TypeError("Cannot " + msg);
  };
  var __privateAdd3 = (obj, member, value) => {
    if (member.has(obj))
      throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
  };
  var __privateMethod3 = (obj, member, method) => {
    __accessCheck3(obj, member, "access private method");
    return method;
  };
  var coinQuantityfy = (coinQuantityLike) => {
    let assetId;
    let amount;
    let max2;
    if (Array.isArray(coinQuantityLike)) {
      amount = coinQuantityLike[0];
      assetId = coinQuantityLike[1] ?? BaseAssetId;
      max2 = coinQuantityLike[2] ?? void 0;
    } else {
      amount = coinQuantityLike.amount;
      assetId = coinQuantityLike.assetId ?? BaseAssetId;
      max2 = coinQuantityLike.max ?? void 0;
    }
    return {
      assetId: hexlify(assetId),
      amount: bn(amount),
      max: max2 ? bn(max2) : void 0
    };
  };
  var addAmountToAsset = (params) => {
    const { amount, assetId, coinQuantities } = params;
    const assetIdx = coinQuantities.findIndex((coinQuantity) => coinQuantity.assetId === assetId);
    if (assetIdx !== -1) {
      coinQuantities[assetIdx].amount = coinQuantities[assetIdx].amount.add(amount);
    } else {
      coinQuantities.push({ assetId, amount });
    }
    return coinQuantities;
  };
  var ReceiptFragmentFragmentDoc = lib_default2`
    fragment receiptFragment on Receipt {
  contract {
    id
    bytecode
    salt
  }
  pc
  is
  to {
    id
    bytecode
    salt
  }
  toAddress
  amount
  assetId
  gas
  param1
  param2
  val
  ptr
  digest
  reason
  ra
  rb
  rc
  rd
  len
  receiptType
  result
  gasUsed
  data
  sender
  recipient
  nonce
  contractId
  subId
}
    `;
  var TransactionFragmentFragmentDoc = lib_default2`
    fragment transactionFragment on Transaction {
  id
  rawPayload
  gasPrice
  receipts {
    ...receiptFragment
  }
  status {
    type: __typename
    ... on SubmittedStatus {
      time
    }
    ... on SuccessStatus {
      block {
        id
      }
      time
      programState {
        returnType
        data
      }
    }
    ... on FailureStatus {
      block {
        id
      }
      time
      reason
    }
  }
}
    ${ReceiptFragmentFragmentDoc}`;
  var CoinFragmentFragmentDoc = lib_default2`
    fragment coinFragment on Coin {
  __typename
  utxoId
  owner
  amount
  assetId
  maturity
  blockCreated
  txCreatedIdx
}
    `;
  var MessageCoinFragmentFragmentDoc = lib_default2`
    fragment messageCoinFragment on MessageCoin {
  __typename
  sender
  recipient
  nonce
  amount
  assetId
  daHeight
}
    `;
  var MessageFragmentFragmentDoc = lib_default2`
    fragment messageFragment on Message {
  amount
  sender
  recipient
  data
  nonce
  daHeight
}
    `;
  var MessageProofFragmentFragmentDoc = lib_default2`
    fragment messageProofFragment on MessageProof {
  messageProof {
    proofSet
    proofIndex
  }
  blockProof {
    proofSet
    proofIndex
  }
  messageBlockHeader {
    id
    daHeight
    transactionsCount
    transactionsRoot
    height
    prevRoot
    time
    applicationHash
    messageReceiptRoot
    messageReceiptCount
  }
  commitBlockHeader {
    id
    daHeight
    transactionsCount
    transactionsRoot
    height
    prevRoot
    time
    applicationHash
    messageReceiptRoot
    messageReceiptCount
  }
  sender
  recipient
  nonce
  amount
  data
}
    `;
  var BalanceFragmentFragmentDoc = lib_default2`
    fragment balanceFragment on Balance {
  owner
  amount
  assetId
}
    `;
  var ConsensusParametersFragmentFragmentDoc = lib_default2`
    fragment consensusParametersFragment on ConsensusParameters {
  contractMaxSize
  maxInputs
  maxOutputs
  maxWitnesses
  maxGasPerTx
  maxScriptLength
  maxScriptDataLength
  maxStorageSlots
  maxPredicateLength
  maxPredicateDataLength
  maxGasPerPredicate
  gasPriceFactor
  gasPerByte
  maxMessageDataLength
  chainId
}
    `;
  var BlockFragmentFragmentDoc = lib_default2`
    fragment blockFragment on Block {
  id
  header {
    height
    time
  }
  transactions {
    id
  }
}
    `;
  var ChainInfoFragmentFragmentDoc = lib_default2`
    fragment chainInfoFragment on ChainInfo {
  name
  baseChainHeight
  peerCount
  consensusParameters {
    ...consensusParametersFragment
  }
  latestBlock {
    ...blockFragment
  }
}
    ${ConsensusParametersFragmentFragmentDoc}
${BlockFragmentFragmentDoc}`;
  var ContractBalanceFragmentFragmentDoc = lib_default2`
    fragment contractBalanceFragment on ContractBalance {
  contract
  amount
  assetId
}
    `;
  var PageInfoFragmentFragmentDoc = lib_default2`
    fragment pageInfoFragment on PageInfo {
  hasPreviousPage
  hasNextPage
  startCursor
  endCursor
}
    `;
  var NodeInfoFragmentFragmentDoc = lib_default2`
    fragment nodeInfoFragment on NodeInfo {
  utxoValidation
  vmBacktrace
  minGasPrice
  maxTx
  maxDepth
  nodeVersion
}
    `;
  var GetVersionDocument = lib_default2`
    query getVersion {
  nodeInfo {
    nodeVersion
  }
}
    `;
  var GetNodeInfoDocument = lib_default2`
    query getNodeInfo {
  nodeInfo {
    ...nodeInfoFragment
  }
}
    ${NodeInfoFragmentFragmentDoc}`;
  var GetChainDocument = lib_default2`
    query getChain {
  chain {
    ...chainInfoFragment
  }
}
    ${ChainInfoFragmentFragmentDoc}`;
  var GetTransactionDocument = lib_default2`
    query getTransaction($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    ...transactionFragment
  }
}
    ${TransactionFragmentFragmentDoc}`;
  var GetTransactionWithReceiptsDocument = lib_default2`
    query getTransactionWithReceipts($transactionId: TransactionId!) {
  transaction(id: $transactionId) {
    ...transactionFragment
    receipts {
      ...receiptFragment
    }
  }
}
    ${TransactionFragmentFragmentDoc}
${ReceiptFragmentFragmentDoc}`;
  var GetTransactionsDocument = lib_default2`
    query getTransactions($after: String, $before: String, $first: Int, $last: Int) {
  transactions(after: $after, before: $before, first: $first, last: $last) {
    edges {
      node {
        ...transactionFragment
      }
    }
  }
}
    ${TransactionFragmentFragmentDoc}`;
  var GetTransactionsByOwnerDocument = lib_default2`
    query getTransactionsByOwner($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  transactionsByOwner(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    pageInfo {
      ...pageInfoFragment
    }
    edges {
      node {
        ...transactionFragment
      }
    }
  }
}
    ${PageInfoFragmentFragmentDoc}
${TransactionFragmentFragmentDoc}`;
  var EstimatePredicatesDocument = lib_default2`
    query estimatePredicates($encodedTransaction: HexString!) {
  estimatePredicates(tx: $encodedTransaction) {
    ...transactionFragment
  }
}
    ${TransactionFragmentFragmentDoc}`;
  var GetBlockDocument = lib_default2`
    query getBlock($blockId: BlockId, $blockHeight: U64) {
  block(id: $blockId, height: $blockHeight) {
    ...blockFragment
  }
}
    ${BlockFragmentFragmentDoc}`;
  var GetBlockWithTransactionsDocument = lib_default2`
    query getBlockWithTransactions($blockId: BlockId, $blockHeight: U64) {
  block(id: $blockId, height: $blockHeight) {
    ...blockFragment
    transactions {
      ...transactionFragment
    }
  }
}
    ${BlockFragmentFragmentDoc}
${TransactionFragmentFragmentDoc}`;
  var GetBlocksDocument = lib_default2`
    query getBlocks($after: String, $before: String, $first: Int, $last: Int) {
  blocks(after: $after, before: $before, first: $first, last: $last) {
    edges {
      node {
        ...blockFragment
      }
    }
  }
}
    ${BlockFragmentFragmentDoc}`;
  var GetCoinDocument = lib_default2`
    query getCoin($coinId: UtxoId!) {
  coin(utxoId: $coinId) {
    ...coinFragment
  }
}
    ${CoinFragmentFragmentDoc}`;
  var GetCoinsDocument = lib_default2`
    query getCoins($filter: CoinFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  coins(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    edges {
      node {
        ...coinFragment
      }
    }
  }
}
    ${CoinFragmentFragmentDoc}`;
  var GetCoinsToSpendDocument = lib_default2`
    query getCoinsToSpend($owner: Address!, $queryPerAsset: [SpendQueryElementInput!]!, $excludedIds: ExcludeInput) {
  coinsToSpend(
    owner: $owner
    queryPerAsset: $queryPerAsset
    excludedIds: $excludedIds
  ) {
    ...coinFragment
    ...messageCoinFragment
  }
}
    ${CoinFragmentFragmentDoc}
${MessageCoinFragmentFragmentDoc}`;
  var GetContractDocument = lib_default2`
    query getContract($contractId: ContractId!) {
  contract(id: $contractId) {
    bytecode
    id
  }
}
    `;
  var GetContractBalanceDocument = lib_default2`
    query getContractBalance($contract: ContractId!, $asset: AssetId!) {
  contractBalance(contract: $contract, asset: $asset) {
    ...contractBalanceFragment
  }
}
    ${ContractBalanceFragmentFragmentDoc}`;
  var GetBalanceDocument = lib_default2`
    query getBalance($owner: Address!, $assetId: AssetId!) {
  balance(owner: $owner, assetId: $assetId) {
    ...balanceFragment
  }
}
    ${BalanceFragmentFragmentDoc}`;
  var GetBalancesDocument = lib_default2`
    query getBalances($filter: BalanceFilterInput!, $after: String, $before: String, $first: Int, $last: Int) {
  balances(
    filter: $filter
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    edges {
      node {
        ...balanceFragment
      }
    }
  }
}
    ${BalanceFragmentFragmentDoc}`;
  var GetMessagesDocument = lib_default2`
    query getMessages($owner: Address!, $after: String, $before: String, $first: Int, $last: Int) {
  messages(
    owner: $owner
    after: $after
    before: $before
    first: $first
    last: $last
  ) {
    edges {
      node {
        ...messageFragment
      }
    }
  }
}
    ${MessageFragmentFragmentDoc}`;
  var GetMessageProofDocument = lib_default2`
    query getMessageProof($transactionId: TransactionId!, $messageId: MessageId!, $commitBlockId: BlockId, $commitBlockHeight: U32) {
  messageProof(
    transactionId: $transactionId
    messageId: $messageId
    commitBlockId: $commitBlockId
    commitBlockHeight: $commitBlockHeight
  ) {
    ...messageProofFragment
  }
}
    ${MessageProofFragmentFragmentDoc}`;
  var GetMessageStatusDocument = lib_default2`
    query getMessageStatus($nonce: Nonce!) {
  messageStatus(nonce: $nonce) {
    state
  }
}
    `;
  var DryRunDocument = lib_default2`
    mutation dryRun($encodedTransaction: HexString!, $utxoValidation: Boolean) {
  dryRun(tx: $encodedTransaction, utxoValidation: $utxoValidation) {
    ...receiptFragment
  }
}
    ${ReceiptFragmentFragmentDoc}`;
  var SubmitDocument = lib_default2`
    mutation submit($encodedTransaction: HexString!) {
  submit(tx: $encodedTransaction) {
    id
  }
}
    `;
  var ProduceBlocksDocument = lib_default2`
    mutation produceBlocks($startTimestamp: Tai64Timestamp, $blocksToProduce: U64!) {
  produceBlocks(
    blocksToProduce: $blocksToProduce
    startTimestamp: $startTimestamp
  )
}
    `;
  var defaultWrapper = (action, _operationName, _operationType) => action();
  function getSdk(client, withWrapper = defaultWrapper) {
    return {
      getVersion(variables, requestHeaders) {
        return withWrapper((wrappedRequestHeaders) => client.request(GetVersionDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getVersion", "query");
      },
      getNodeInfo(variables, requestHeaders) {
        return withWrapper((wrappedRequestHeaders) => client.request(GetNodeInfoDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getNodeInfo", "query");
      },
      getChain(variables, requestHeaders) {
        return withWrapper((wrappedRequestHeaders) => client.request(GetChainDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getChain", "query");
      },
      getTransaction(variables, requestHeaders) {
        return withWrapper((wrappedRequestHeaders) => client.request(GetTransactionDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getTransaction", "query");
      },
      getTransactionWithReceipts(variables, requestHeaders) {
        return withWrapper((wrappedRequestHeaders) => client.request(GetTransactionWithReceiptsDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getTransactionWithReceipts", "query");
      },
      getTransactions(variables, requestHeaders) {
        return withWrapper((wrappedRequestHeaders) => client.request(GetTransactionsDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getTransactions", "query");
      },
      getTransactionsByOwner(variables, requestHeaders) {
        return withWrapper((wrappedRequestHeaders) => client.request(GetTransactionsByOwnerDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getTransactionsByOwner", "query");
      },
      estimatePredicates(variables, requestHeaders) {
        return withWrapper((wrappedRequestHeaders) => client.request(EstimatePredicatesDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "estimatePredicates", "query");
      },
      getBlock(variables, requestHeaders) {
        return withWrapper((wrappedRequestHeaders) => client.request(GetBlockDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getBlock", "query");
      },
      getBlockWithTransactions(variables, requestHeaders) {
        return withWrapper((wrappedRequestHeaders) => client.request(GetBlockWithTransactionsDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getBlockWithTransactions", "query");
      },
      getBlocks(variables, requestHeaders) {
        return withWrapper((wrappedRequestHeaders) => client.request(GetBlocksDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getBlocks", "query");
      },
      getCoin(variables, requestHeaders) {
        return withWrapper((wrappedRequestHeaders) => client.request(GetCoinDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getCoin", "query");
      },
      getCoins(variables, requestHeaders) {
        return withWrapper((wrappedRequestHeaders) => client.request(GetCoinsDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getCoins", "query");
      },
      getCoinsToSpend(variables, requestHeaders) {
        return withWrapper((wrappedRequestHeaders) => client.request(GetCoinsToSpendDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getCoinsToSpend", "query");
      },
      getContract(variables, requestHeaders) {
        return withWrapper((wrappedRequestHeaders) => client.request(GetContractDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getContract", "query");
      },
      getContractBalance(variables, requestHeaders) {
        return withWrapper((wrappedRequestHeaders) => client.request(GetContractBalanceDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getContractBalance", "query");
      },
      getBalance(variables, requestHeaders) {
        return withWrapper((wrappedRequestHeaders) => client.request(GetBalanceDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getBalance", "query");
      },
      getBalances(variables, requestHeaders) {
        return withWrapper((wrappedRequestHeaders) => client.request(GetBalancesDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getBalances", "query");
      },
      getMessages(variables, requestHeaders) {
        return withWrapper((wrappedRequestHeaders) => client.request(GetMessagesDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getMessages", "query");
      },
      getMessageProof(variables, requestHeaders) {
        return withWrapper((wrappedRequestHeaders) => client.request(GetMessageProofDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getMessageProof", "query");
      },
      getMessageStatus(variables, requestHeaders) {
        return withWrapper((wrappedRequestHeaders) => client.request(GetMessageStatusDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "getMessageStatus", "query");
      },
      dryRun(variables, requestHeaders) {
        return withWrapper((wrappedRequestHeaders) => client.request(DryRunDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "dryRun", "mutation");
      },
      submit(variables, requestHeaders) {
        return withWrapper((wrappedRequestHeaders) => client.request(SubmitDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "submit", "mutation");
      },
      produceBlocks(variables, requestHeaders) {
        return withWrapper((wrappedRequestHeaders) => client.request(ProduceBlocksDocument, variables, { ...requestHeaders, ...wrappedRequestHeaders }), "produceBlocks", "mutation");
      }
    };
  }
  var cache = {};
  var DEFAULT_TTL_IN_MS = 30 * 1e3;
  var MemoryCache = class {
    ttl;
    constructor(ttlInMs = DEFAULT_TTL_IN_MS) {
      this.ttl = ttlInMs;
      if (typeof ttlInMs !== "number" || this.ttl <= 0) {
        throw new FuelError(
          ErrorCode.INVALID_TTL,
          `Invalid TTL: ${this.ttl}. Use a value greater than zero.`
        );
      }
    }
    get(value, isAutoExpiring = true) {
      const key = hexlify(value);
      if (cache[key]) {
        if (!isAutoExpiring || cache[key].expires > Date.now()) {
          return cache[key].value;
        }
        this.del(value);
      }
      return void 0;
    }
    set(value) {
      const expiresAt = Date.now() + this.ttl;
      const key = hexlify(value);
      cache[key] = {
        expires: expiresAt,
        value
      };
      return expiresAt;
    }
    getAllData() {
      return Object.keys(cache).reduce((list, key) => {
        const data = this.get(key, false);
        if (data) {
          list.push(data);
        }
        return list;
      }, []);
    }
    getActiveData() {
      return Object.keys(cache).reduce((list, key) => {
        const data = this.get(key);
        if (data) {
          list.push(data);
        }
        return list;
      }, []);
    }
    del(value) {
      const key = hexlify(value);
      delete cache[key];
    }
  };
  var inputify = (value) => {
    const { type: type3 } = value;
    switch (value.type) {
      case InputType.Coin: {
        const predicate = getBytesCopy(value.predicate ?? "0x");
        const predicateData = getBytesCopy(value.predicateData ?? "0x");
        return {
          type: InputType.Coin,
          utxoID: {
            transactionId: hexlify(getBytesCopy(value.id).slice(0, 32)),
            outputIndex: getBytesCopy(value.id)[32]
          },
          owner: hexlify(value.owner),
          amount: bn(value.amount),
          assetId: hexlify(value.assetId),
          txPointer: {
            blockHeight: toNumber2(getBytesCopy(value.txPointer).slice(0, 8)),
            txIndex: toNumber2(getBytesCopy(value.txPointer).slice(8, 16))
          },
          witnessIndex: value.witnessIndex,
          maturity: value.maturity ?? 0,
          predicateGasUsed: bn(value.predicateGasUsed),
          predicateLength: predicate.length,
          predicateDataLength: predicateData.length,
          predicate: hexlify(predicate),
          predicateData: hexlify(predicateData)
        };
      }
      case InputType.Contract: {
        return {
          type: InputType.Contract,
          utxoID: {
            transactionId: ZeroBytes32,
            outputIndex: 0
          },
          balanceRoot: ZeroBytes32,
          stateRoot: ZeroBytes32,
          txPointer: {
            blockHeight: toNumber2(getBytesCopy(value.txPointer).slice(0, 8)),
            txIndex: toNumber2(getBytesCopy(value.txPointer).slice(8, 16))
          },
          contractID: hexlify(value.contractId)
        };
      }
      case InputType.Message: {
        const predicate = getBytesCopy(value.predicate ?? "0x");
        const predicateData = getBytesCopy(value.predicateData ?? "0x");
        const data = getBytesCopy(value.data ?? "0x");
        return {
          type: InputType.Message,
          sender: hexlify(value.sender),
          recipient: hexlify(value.recipient),
          amount: bn(value.amount),
          nonce: hexlify(value.nonce),
          witnessIndex: value.witnessIndex,
          predicateGasUsed: bn(value.predicateGasUsed),
          predicateLength: predicate.length,
          predicateDataLength: predicateData.length,
          predicate: hexlify(predicate),
          predicateData: hexlify(predicateData),
          data: hexlify(data),
          dataLength: data.length
        };
      }
      default: {
        throw new FuelError(
          ErrorCode.INVALID_TRANSACTION_INPUT,
          `Invalid transaction input type: ${type3}.`
        );
      }
    }
  };
  var outputify = (value) => {
    const { type: type3 } = value;
    switch (type3) {
      case OutputType.Coin: {
        return {
          type: OutputType.Coin,
          to: hexlify(value.to),
          amount: bn(value.amount),
          assetId: hexlify(value.assetId)
        };
      }
      case OutputType.Contract: {
        return {
          type: OutputType.Contract,
          inputIndex: value.inputIndex,
          balanceRoot: ZeroBytes32,
          stateRoot: ZeroBytes32
        };
      }
      case OutputType.Change: {
        return {
          type: OutputType.Change,
          to: hexlify(value.to),
          amount: bn(0),
          assetId: hexlify(value.assetId)
        };
      }
      case OutputType.Variable: {
        return {
          type: OutputType.Variable,
          to: ZeroBytes32,
          amount: bn(0),
          assetId: ZeroBytes32
        };
      }
      case OutputType.ContractCreated: {
        return {
          type: OutputType.ContractCreated,
          contractId: hexlify(value.contractId),
          stateRoot: hexlify(value.stateRoot)
        };
      }
      default: {
        throw new FuelError(
          ErrorCode.INVALID_TRANSACTION_INPUT,
          `Invalid transaction output type: ${type3}.`
        );
      }
    }
  };
  var isCoin = (resource) => "id" in resource;
  var doesReceiptHaveMissingOutputVariables = (receipt) => receipt.type === ReceiptType.Revert && receipt.val.toString("hex") === FAILED_TRANSFER_TO_ADDRESS_SIGNAL;
  var doesReceiptHaveMissingContractId = (receipt) => receipt.type === ReceiptType.Panic && receipt.contractId !== "0x0000000000000000000000000000000000000000000000000000000000000000";
  var getReceiptsWithMissingData = (receipts) => receipts.reduce(
    (memo, receipt) => {
      if (doesReceiptHaveMissingOutputVariables(receipt)) {
        memo.missingOutputVariables.push(receipt);
      }
      if (doesReceiptHaveMissingContractId(receipt)) {
        memo.missingOutputContractIds.push(receipt);
      }
      return memo;
    },
    {
      missingOutputVariables: [],
      missingOutputContractIds: []
    }
  );
  var hexOrZero = (hex) => hex || ZeroBytes32;
  function assembleReceiptByType(receipt) {
    const { receiptType } = receipt;
    switch (receiptType) {
      case "CALL": {
        const callReceipt = {
          type: ReceiptType.Call,
          from: hexOrZero(receipt.contract?.id),
          to: hexOrZero(receipt?.to?.id),
          amount: bn(receipt.amount),
          assetId: hexOrZero(receipt.assetId),
          gas: bn(receipt.gas),
          param1: bn(receipt.param1),
          param2: bn(receipt.param2),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return callReceipt;
      }
      case "RETURN": {
        const returnReceipt = {
          type: ReceiptType.Return,
          id: hexOrZero(receipt.contract?.id),
          val: bn(receipt.val),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return returnReceipt;
      }
      case "RETURN_DATA": {
        const returnDataReceipt = {
          type: ReceiptType.ReturnData,
          id: hexOrZero(receipt.contract?.id),
          ptr: bn(receipt.ptr),
          len: bn(receipt.len),
          digest: hexOrZero(receipt.digest),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return returnDataReceipt;
      }
      case "PANIC": {
        const panicReceipt = {
          type: ReceiptType.Panic,
          id: hexOrZero(receipt.contract?.id),
          reason: bn(receipt.reason),
          pc: bn(receipt.pc),
          is: bn(receipt.is),
          contractId: hexOrZero(receipt.contractId)
        };
        return panicReceipt;
      }
      case "REVERT": {
        const revertReceipt = {
          type: ReceiptType.Revert,
          id: hexOrZero(receipt.contract?.id),
          val: bn(receipt.ra),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return revertReceipt;
      }
      case "LOG": {
        const logReceipt = {
          type: ReceiptType.Log,
          id: hexOrZero(receipt.contract?.id),
          val0: bn(receipt.ra),
          val1: bn(receipt.rb),
          val2: bn(receipt.rc),
          val3: bn(receipt.rd),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return logReceipt;
      }
      case "LOG_DATA": {
        const logDataReceipt = {
          type: ReceiptType.LogData,
          id: hexOrZero(receipt.contract?.id),
          val0: bn(receipt.ra),
          val1: bn(receipt.rb),
          ptr: bn(receipt.ptr),
          len: bn(receipt.len),
          digest: hexOrZero(receipt.digest),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return logDataReceipt;
      }
      case "TRANSFER": {
        const transferReceipt = {
          type: ReceiptType.Transfer,
          from: hexOrZero(receipt.contract?.id),
          to: hexOrZero(receipt.toAddress || receipt?.to?.id),
          amount: bn(receipt.amount),
          assetId: hexOrZero(receipt.assetId),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return transferReceipt;
      }
      case "TRANSFER_OUT": {
        const transferOutReceipt = {
          type: ReceiptType.TransferOut,
          from: hexOrZero(receipt.contract?.id),
          to: hexOrZero(receipt.toAddress || receipt.to?.id),
          amount: bn(receipt.amount),
          assetId: hexOrZero(receipt.assetId),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return transferOutReceipt;
      }
      case "SCRIPT_RESULT": {
        const scriptResultReceipt = {
          type: ReceiptType.ScriptResult,
          result: bn(receipt.result),
          gasUsed: bn(receipt.gasUsed)
        };
        return scriptResultReceipt;
      }
      case "MESSAGE_OUT": {
        const sender = hexOrZero(receipt.sender);
        const recipient = hexOrZero(receipt.recipient);
        const nonce = hexOrZero(receipt.nonce);
        const amount = bn(receipt.amount);
        const data = receipt.data ? getBytesCopy(receipt.data) : Uint8Array.from([]);
        const digest = hexOrZero(receipt.digest);
        const messageId = ReceiptMessageOutCoder.getMessageId({
          sender,
          recipient,
          nonce,
          amount,
          data
        });
        const receiptMessageOut = {
          type: ReceiptType.MessageOut,
          sender,
          recipient,
          amount,
          nonce,
          data,
          digest,
          messageId
        };
        return receiptMessageOut;
      }
      case "MINT": {
        const contractId = hexOrZero(receipt.contract?.id);
        const subId = hexOrZero(receipt.subId);
        const assetId = ReceiptMintCoder.getAssetId(contractId, subId);
        const mintReceipt = {
          type: ReceiptType.Mint,
          subId,
          contractId,
          assetId,
          val: bn(receipt.val),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return mintReceipt;
      }
      case "BURN": {
        const contractId = hexOrZero(receipt.contract?.id);
        const subId = hexOrZero(receipt.subId);
        const assetId = ReceiptBurnCoder.getAssetId(contractId, subId);
        const burnReceipt = {
          type: ReceiptType.Burn,
          subId,
          contractId,
          assetId,
          val: bn(receipt.val),
          pc: bn(receipt.pc),
          is: bn(receipt.is)
        };
        return burnReceipt;
      }
      default:
        throw new FuelError(ErrorCode.INVALID_RECEIPT_TYPE, `Invalid receipt type: ${receiptType}.`);
    }
  }
  var calculatePriceWithFactor = (gasUsed, gasPrice, priceFactor) => bn(Math.ceil(gasUsed.toNumber() / priceFactor.toNumber()) * gasPrice.toNumber());
  var getGasUsedFromReceipts = (receipts) => {
    const scriptResult = receipts.filter(
      (receipt) => receipt.type === ReceiptType.ScriptResult
    );
    const gasUsed = scriptResult.reduce((prev, receipt) => prev.add(receipt.gasUsed), bn(0));
    return gasUsed;
  };
  var calculateTxChargeableBytes = (params) => {
    const { transactionWitnesses, transactionBytes } = params;
    const txChargeableBytes = bn(transactionWitnesses?.[0]?.offset || transactionBytes.length);
    return txChargeableBytes;
  };
  var calculateTransactionFee = ({
    gasPrice,
    gasUsed,
    gasLimit,
    gasPerByte,
    gasPriceFactor,
    chargeableBytes
  }) => {
    const bytesGas = chargeableBytes.mul(gasPerByte.toNumber());
    const minGas = bytesGas;
    const maxGas = bytesGas.add(gasLimit);
    const minGasToPay = bn(Math.ceil(minGas.mul(gasPrice).toNumber() / gasPriceFactor.toNumber()));
    const maxGasToPay = bn(Math.ceil(maxGas.mul(gasPrice).toNumber() / gasPriceFactor.toNumber()));
    const feeFromGasUsed = bn(
      Math.ceil(gasUsed.mul(gasPrice).toNumber() / gasPriceFactor.toNumber())
    );
    const minFee = minGasToPay.add(feeFromGasUsed);
    const maxFee = maxGasToPay.add(feeFromGasUsed);
    return {
      minFee,
      maxFee,
      minGasToPay,
      maxGasToPay,
      feeFromGasUsed
    };
  };
  function normalize3(object2) {
    Object.keys(object2).forEach((key) => {
      switch (object2[key]?.constructor.name) {
        case "Uint8Array":
          object2[key] = hexlify(object2[key]);
          break;
        case "Array":
          object2[key] = normalize3(object2[key]);
          break;
        case "BN":
          object2[key] = object2[key].toHex();
          break;
        case "Address":
          object2[key] = object2[key].toB256();
          break;
        case "Object":
          object2[key] = normalize3(object2[key]);
          break;
        default:
          break;
      }
    });
    return object2;
  }
  function normalizeJSON(root) {
    return normalize3(clone_default(root));
  }
  function sleep(time) {
    return new Promise((resolve4) => {
      setTimeout(() => {
        resolve4(true);
      }, time);
    });
  }
  var fromUnixToTai64 = (unixTimestampMs) => (BigInt(unixTimestampMs) + BigInt(2 ** 62) + BigInt(10)).toString();
  var ChangeOutputCollisionError = class extends Error {
    name = "ChangeOutputCollisionError";
    message = 'A ChangeOutput with the same "assetId" already exists for a different "to" address';
  };
  var NoWitnessAtIndexError = class extends Error {
    constructor(index) {
      super();
      this.index = index;
      this.message = `Witness at index "${index}" was not found`;
    }
    name = "NoWitnessAtIndexError";
  };
  var witnessify = (value) => {
    const data = getBytesCopy(value);
    return {
      data: hexlify(data),
      dataLength: data.length
    };
  };
  var BaseTransactionRequest = class {
    /** Gas price for transaction */
    gasPrice;
    /** Gas limit for transaction */
    gasLimit;
    /** Block until which tx cannot be included */
    maturity;
    /** List of inputs */
    inputs = [];
    /** List of outputs */
    outputs = [];
    /** List of witnesses */
    witnesses = [];
    /**
     * Constructor for initializing a base transaction request.
     *
     * @param baseTransactionRequest - Optional object containing properties to initialize the transaction request.
     */
    constructor({
      gasPrice,
      gasLimit,
      maturity,
      inputs,
      outputs,
      witnesses
    } = {}) {
      this.gasPrice = bn(gasPrice);
      this.gasLimit = bn(gasLimit);
      this.maturity = maturity ?? 0;
      this.inputs = inputs ?? [];
      this.outputs = outputs ?? [];
      this.witnesses = witnesses ?? [];
    }
    /**
     * Method to obtain the base transaction details.
     *
     * @returns The base transaction details.
     */
    getBaseTransaction() {
      const inputs = this.inputs?.map(inputify) ?? [];
      const outputs = this.outputs?.map(outputify) ?? [];
      const witnesses = this.witnesses?.map(witnessify) ?? [];
      return {
        gasPrice: this.gasPrice,
        gasLimit: this.gasLimit,
        maturity: this.maturity,
        inputs,
        outputs,
        witnesses,
        inputsCount: inputs.length,
        outputsCount: outputs.length,
        witnessesCount: witnesses.length
      };
    }
    /**
     * Converts the transaction request to a byte array.
     *
     * @returns The transaction bytes.
     */
    toTransactionBytes() {
      return new TransactionCoder().encode(this.toTransaction());
    }
    /**
     * @hidden
     *
     * Pushes an input to the list without any side effects and returns the index
     */
    pushInput(input) {
      this.inputs.push(input);
      return this.inputs.length - 1;
    }
    /**
     * @hidden
     *
     * Pushes an output to the list without any side effects and returns the index
     */
    pushOutput(output3) {
      this.outputs.push(output3);
      return this.outputs.length - 1;
    }
    /**
     * @hidden
     *
     * Creates an empty witness without any side effects and returns the index
     */
    createWitness() {
      this.witnesses.push("0x");
      return this.witnesses.length - 1;
    }
    /**
     * Updates the witness for a given owner and signature.
     *
     * @param address - The address to get the coin input witness index for.
     * @param signature - The signature to update the witness with.
     */
    updateWitnessByOwner(address, signature) {
      const witnessIndex = this.getCoinInputWitnessIndexByOwner(address);
      if (typeof witnessIndex === "number") {
        this.updateWitness(witnessIndex, signature);
      }
    }
    /**
     * Updates an existing witness without any side effects.
     *
     * @param index - The index of the witness to update.
     * @param witness - The new witness.
     * @throws If the witness does not exist.
     */
    updateWitness(index, witness) {
      if (!this.witnesses[index]) {
        throw new NoWitnessAtIndexError(index);
      }
      this.witnesses[index] = witness;
    }
    /**
     * Gets the coin inputs for a transaction.
     *
     * @returns The coin inputs.
     */
    getCoinInputs() {
      return this.inputs.filter(
        (input) => input.type === InputType.Coin
      );
    }
    /**
     * Gets the coin outputs for a transaction.
     *
     * @returns The coin outputs.
     */
    getCoinOutputs() {
      return this.outputs.filter(
        (output3) => output3.type === OutputType.Coin
      );
    }
    /**
     * Gets the change outputs for a transaction.
     *
     * @returns The change outputs.
     */
    getChangeOutputs() {
      return this.outputs.filter(
        (output3) => output3.type === OutputType.Change
      );
    }
    /**
     * @hidden
     *
     * Returns the witnessIndex of the found CoinInput.
     */
    getCoinInputWitnessIndexByOwner(owner) {
      const ownerAddress = addressify(owner);
      const found = this.inputs.find((input) => {
        switch (input.type) {
          case InputType.Coin:
            return hexlify(input.owner) === ownerAddress.toB256();
          case InputType.Message:
            return hexlify(input.recipient) === ownerAddress.toB256();
          default:
            return false;
        }
      });
      return found?.witnessIndex;
    }
    /**
     * Adds a single coin input to the transaction and a change output for the related
     * assetId, if one it was not added yet.
     *
     * @param coin - Coin resource.
     * @param predicate - Predicate bytes.
     * @param predicateData - Predicate data bytes.
     */
    addCoinInput(coin, predicate) {
      const { assetId, owner, amount } = coin;
      let witnessIndex;
      if (predicate) {
        witnessIndex = 0;
      } else {
        witnessIndex = this.getCoinInputWitnessIndexByOwner(owner);
        if (typeof witnessIndex !== "number") {
          witnessIndex = this.createWitness();
        }
      }
      const input = {
        ...coin,
        type: InputType.Coin,
        owner: owner.toB256(),
        amount,
        assetId,
        txPointer: "0x00000000000000000000000000000000",
        witnessIndex,
        predicate: predicate?.bytes,
        predicateData: predicate?.predicateData
      };
      this.pushInput(input);
      this.addChangeOutput(owner, assetId);
    }
    /**
     * Adds a single message input to the transaction and a change output for the
     * baseAssetId, if one it was not added yet.
     *
     * @param message - Message resource.
     * @param predicate - Predicate bytes.
     * @param predicateData - Predicate data bytes.
     */
    addMessageInput(message, predicate) {
      const { recipient, sender, amount } = message;
      const assetId = BaseAssetId;
      let witnessIndex;
      if (predicate) {
        witnessIndex = 0;
      } else {
        witnessIndex = this.getCoinInputWitnessIndexByOwner(recipient);
        if (typeof witnessIndex !== "number") {
          witnessIndex = this.createWitness();
        }
      }
      const input = {
        ...message,
        type: InputType.Message,
        sender: sender.toB256(),
        recipient: recipient.toB256(),
        amount,
        witnessIndex,
        predicate: predicate?.bytes,
        predicateData: predicate?.predicateData
      };
      this.pushInput(input);
      this.addChangeOutput(recipient, assetId);
    }
    /**
     * Adds a single resource to the transaction by adding a coin/message input and a
     * change output for the related assetId, if one it was not added yet.
     *
     * @param resource - The resource to add.
     * @returns This transaction.
     */
    addResource(resource) {
      if (isCoin(resource)) {
        this.addCoinInput(resource);
      } else {
        this.addMessageInput(resource);
      }
      return this;
    }
    /**
     * Adds multiple resources to the transaction by adding coin/message inputs and change
     * outputs from the related assetIds.
     *
     * @param resources - The resources to add.
     * @returns This transaction.
     */
    addResources(resources) {
      resources.forEach((resource) => this.addResource(resource));
      return this;
    }
    /**
     * Adds multiple resources to the transaction by adding coin/message inputs and change
     * outputs from the related assetIds.
     *
     * @param resources - The resources to add.
     * @returns This transaction.
     */
    addPredicateResource(resource, predicate) {
      if (isCoin(resource)) {
        this.addCoinInput(resource, predicate);
      } else {
        this.addMessageInput(resource, predicate);
      }
      return this;
    }
    /**
     * Adds multiple predicate coin/message inputs to the transaction and change outputs
     * from the related assetIds.
     *
     * @param resources - The resources to add.
     * @returns This transaction.
     */
    addPredicateResources(resources, predicate) {
      resources.forEach((resource) => this.addPredicateResource(resource, predicate));
      return this;
    }
    /**
     * Adds a coin output to the transaction.
     *
     * @param to - Address of the owner.
     * @param amount - Amount of coin.
     * @param assetId - Asset ID of coin.
     */
    addCoinOutput(to, amount, assetId = BaseAssetId) {
      this.pushOutput({
        type: OutputType.Coin,
        to: addressify(to).toB256(),
        amount,
        assetId
      });
      return this;
    }
    /**
     * Adds multiple coin outputs to the transaction.
     *
     * @param to - Address of the destination.
     * @param quantities - Quantities of coins.
     */
    addCoinOutputs(to, quantities) {
      quantities.map(coinQuantityfy).forEach((quantity) => {
        this.pushOutput({
          type: OutputType.Coin,
          to: addressify(to).toB256(),
          amount: quantity.amount,
          assetId: quantity.assetId
        });
      });
      return this;
    }
    /**
     * Adds a change output to the transaction.
     *
     * @param to - Address of the owner.
     * @param assetId - Asset ID of coin.
     */
    addChangeOutput(to, assetId = BaseAssetId) {
      const changeOutput = this.getChangeOutputs().find(
        (output3) => hexlify(output3.assetId) === assetId
      );
      if (changeOutput && hexlify(changeOutput.to) !== addressify(to).toB256()) {
        throw new ChangeOutputCollisionError();
      }
      if (!changeOutput) {
        this.pushOutput({
          type: OutputType.Change,
          to: addressify(to).toB256(),
          assetId
        });
      }
    }
    /**
     * @hidden
     */
    byteSize() {
      return this.toTransactionBytes().length;
    }
    /**
     * Return the minimum amount in native coins required to create
     * a transaction. This is required even if the gasPrice is 0.
     *
     * @returns The minimum amount in coins required to create a transaction.
     */
    calculateFee(gasPriceFactor) {
      const gasFee = calculatePriceWithFactor(this.gasLimit, this.gasPrice, gasPriceFactor);
      return {
        assetId: BaseAssetId,
        amount: gasFee.isZero() ? bn(1) : gasFee
      };
    }
    /**
     * Funds the transaction with fake UTXOs for each assetId and amount in the
     * quantities array.
     *
     * @param quantities - CoinQuantity Array.
     */
    fundWithFakeUtxos(quantities) {
      const hasBaseAssetId = quantities.some(({ assetId }) => assetId === BaseAssetId);
      if (!hasBaseAssetId) {
        quantities.push({ assetId: BaseAssetId, amount: bn(1) });
      }
      const owner = getRandomB256();
      this.inputs = this.inputs.filter((input) => input.type === InputType.Contract);
      this.outputs = this.outputs.filter((output3) => output3.type !== OutputType.Change);
      const fakeResources = quantities.map(({ assetId, amount }, idx) => ({
        id: `${ZeroBytes32}0${idx}`,
        amount,
        assetId,
        owner: Address.fromB256(owner),
        maturity: 0,
        blockCreated: bn(1),
        txCreatedIdx: bn(1)
      }));
      this.addResources(fakeResources);
    }
    /**
     * Retrieves an array of CoinQuantity for each coin output present in the transaction.
     * a transaction.
     *
     * @returns  CoinQuantity array.
     */
    getCoinOutputsQuantities() {
      const coinsQuantities = this.getCoinOutputs().map(({ amount, assetId }) => ({
        amount: bn(amount),
        assetId: assetId.toString()
      }));
      return coinsQuantities;
    }
    /**
     * Return the minimum amount in native coins required to create
     * a transaction.
     *
     * @returns The transaction as a JSON object.
     */
    toJSON() {
      return normalizeJSON(this);
    }
    /**
     * @hidden
     *
     * Determines whether the transaction has a predicate input.
     *
     * @returns Whether the transaction has a predicate input.
     */
    hasPredicateInput() {
      return Boolean(
        this.inputs.find(
          (input) => "predicate" in input && input.predicate && input.predicate !== getBytesCopy("0x")
        )
      );
    }
  };
  var getStorageValue = (value) => {
    const v = new Uint8Array(32);
    v.set(getBytesCopy(value));
    return v;
  };
  var storageSlotify = (storageSlot) => {
    let key;
    let value;
    if (Array.isArray(storageSlot)) {
      key = storageSlot[0];
      value = storageSlot[1];
    } else {
      key = storageSlot.key;
      value = storageSlot.value;
    }
    return {
      key: hexlify(key),
      value: hexlify(getStorageValue(value))
    };
  };
  var CreateTransactionRequest = class extends BaseTransactionRequest {
    static from(obj) {
      if (obj instanceof this) {
        return obj;
      }
      return new this(obj);
    }
    /** Type of the transaction */
    type = TransactionType.Create;
    /** Witness index of contract bytecode to create */
    bytecodeWitnessIndex;
    /** Salt */
    salt;
    /** List of storage slots to initialize */
    storageSlots;
    /**
     * Creates an instance `CreateTransactionRequest`.
     *
     * @param createTransactionRequestLike - The initial values for the instance
     */
    constructor({
      bytecodeWitnessIndex,
      salt,
      storageSlots,
      ...rest
    } = {}) {
      super(rest);
      this.bytecodeWitnessIndex = bytecodeWitnessIndex ?? 0;
      this.salt = hexlify(salt ?? ZeroBytes32);
      this.storageSlots = [...storageSlots ?? []];
    }
    /**
     * Converts the transaction request to a `TransactionCreate`.
     *
     * @returns The transaction create object.
     */
    toTransaction() {
      const baseTransaction = this.getBaseTransaction();
      const bytecodeWitnessIndex = this.bytecodeWitnessIndex;
      const storageSlots = this.storageSlots?.map(storageSlotify) ?? [];
      return {
        type: TransactionType.Create,
        ...baseTransaction,
        bytecodeLength: baseTransaction.witnesses[bytecodeWitnessIndex].dataLength / 4,
        bytecodeWitnessIndex,
        storageSlotsCount: storageSlots.length,
        salt: this.salt ? hexlify(this.salt) : ZeroBytes32,
        storageSlots
      };
    }
    /**
     * Get contract created outputs for the transaction.
     *
     * @returns An array of contract created transaction request outputs.
     */
    getContractCreatedOutputs() {
      return this.outputs.filter(
        (output3) => output3.type === OutputType.ContractCreated
      );
    }
    /**
     * Adds a contract created output to the transaction request.
     *
     * @param contractId - The contract ID.
     * @param stateRoot - The state root.
     */
    addContractCreatedOutput(contractId, stateRoot) {
      this.pushOutput({
        type: OutputType.ContractCreated,
        contractId,
        stateRoot
      });
    }
  };
  var returnZeroScript = {
    /*
        Opcode::RET(REG_ZERO)
        Opcode::NOOP
      */
    // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281
    bytes: getBytesCopy("0x24000000"),
    encodeScriptData: () => new Uint8Array(0)
  };
  var withdrawScript = {
    /*
            The following code loads some basic values into registers and calls SMO to create an output message
    
            5040C010 	- ADDI r16 $is i16   [r16 now points to memory 16 bytes from the start of this program (start of receiver data)]
            5D44C006	- LW r17 $is i6      [r17 set to the 6th word in this program (6*8=48 bytes from the start of this program)]
            4C400011	- SMO r16 r0 r0 r17  [send message out to address starting at memory position r16 with amount in r17]
            24000000	- RET                [return 0]
            00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000 [recipient address]
            00000000 00000000 [amount value]
        */
    // TODO: Don't use hardcoded scripts: https://github.com/FuelLabs/fuels-ts/issues/281
    bytes: getBytesCopy("0x5040C0105D44C0064C40001124000000"),
    encodeScriptData: () => new Uint8Array(0)
  };
  var ScriptTransactionRequest = class extends BaseTransactionRequest {
    static from(obj) {
      if (obj instanceof this) {
        return obj;
      }
      return new this(obj);
    }
    /** Type of the transaction */
    type = TransactionType.Script;
    /** Script to execute */
    script;
    /** Script input data (parameters) */
    scriptData;
    /**
     * Constructor for `ScriptTransactionRequest`.
     *
     * @param scriptTransactionRequestLike - The initial values for the instance.
     */
    constructor({ script, scriptData, ...rest } = {}) {
      super(rest);
      this.script = getBytesCopy(script ?? returnZeroScript.bytes);
      this.scriptData = getBytesCopy(scriptData ?? returnZeroScript.encodeScriptData());
    }
    /**
     * Converts the transaction request to a `TransactionScript`.
     *
     * @returns The transaction script object.
     */
    toTransaction() {
      const script = getBytesCopy(this.script ?? "0x");
      const scriptData = getBytesCopy(this.scriptData ?? "0x");
      return {
        type: TransactionType.Script,
        ...super.getBaseTransaction(),
        scriptLength: script.length,
        scriptDataLength: scriptData.length,
        receiptsRoot: ZeroBytes32,
        script: hexlify(script),
        scriptData: hexlify(scriptData)
      };
    }
    /**
     * Get contract inputs for the transaction.
     *
     * @returns An array of contract transaction request inputs.
     */
    getContractInputs() {
      return this.inputs.filter(
        (input) => input.type === InputType.Contract
      );
    }
    /**
     * Get contract outputs for the transaction.
     *
     * @returns An array of contract transaction request outputs.
     */
    getContractOutputs() {
      return this.outputs.filter(
        (output3) => output3.type === OutputType.Contract
      );
    }
    /**
     * Get variable outputs for the transaction.
     *
     * @returns An array of variable transaction request outputs.
     */
    getVariableOutputs() {
      return this.outputs.filter(
        (output3) => output3.type === OutputType.Variable
      );
    }
    /**
     * Set the script and its data.
     *
     * @param script - The abstract script request.
     * @param data - The script data.
     */
    setScript(script, data) {
      this.scriptData = script.encodeScriptData(data);
      this.script = script.bytes;
    }
    /**
     * Adds variable outputs to the transaction request.
     *
     * @param numberOfVariables - The number of variables to add.
     * @returns The new length of the outputs array.
     */
    addVariableOutputs(numberOfVariables = 1) {
      let outputsNumber = numberOfVariables;
      while (outputsNumber) {
        this.pushOutput({
          type: OutputType.Variable
        });
        outputsNumber -= 1;
      }
      return this.outputs.length - 1;
    }
    /**
     * Adds a contract input and output to the transaction request.
     *
     * @param contract - The contract ID.
     * @returns The current instance of the `ScriptTransactionRequest`.
     */
    addContractInputAndOutput(contract) {
      const contractAddress = addressify(contract);
      if (this.getContractInputs().find((i) => i.contractId === contractAddress.toB256())) {
        return this;
      }
      const inputIndex = super.pushInput({
        type: InputType.Contract,
        contractId: contractAddress.toB256(),
        txPointer: "0x00000000000000000000000000000000"
      });
      this.pushOutput({
        type: OutputType.Contract,
        inputIndex
      });
      return this;
    }
    /**
     * Sets the data for the transaction request.
     *
     * @param abi - Script JSON ABI.
     * @param args - The input arguments.
     * @returns The current instance of the `ScriptTransactionRequest`.
     */
    setData(abi, args) {
      const abiInterface = new Interface(abi);
      this.scriptData = abiInterface.functions.main.encodeArguments(args);
      return this;
    }
  };
  var transactionRequestify = (obj) => {
    if (obj instanceof ScriptTransactionRequest || obj instanceof CreateTransactionRequest) {
      return obj;
    }
    const { type: type3 } = obj;
    switch (obj.type) {
      case TransactionType.Script: {
        return ScriptTransactionRequest.from(obj);
      }
      case TransactionType.Create: {
        return CreateTransactionRequest.from(obj);
      }
      default: {
        throw new FuelError(ErrorCode.INVALID_TRANSACTION_TYPE, `Invalid transaction type: ${type3}.`);
      }
    }
  };
  var fromTai64ToDate = (tai64Timestamp) => {
    const timestamp = import_tai64.TAI64.fromString(tai64Timestamp, 10).toUnix();
    return new Date(timestamp * 1e3);
  };
  var getFunctionCall = ({ abi, receipt, rawPayload, maxInputs }) => {
    const abiInterface = new Interface(abi);
    const callFunctionSelector = receipt.param1.toHex(8);
    const functionFragment = abiInterface.getFunction(callFunctionSelector);
    const inputs = functionFragment.jsonFn.inputs;
    let encodedArgs;
    if (functionFragment.isInputDataPointer) {
      if (rawPayload) {
        const argsOffset = bn(receipt.param2).sub(calculateVmTxMemory({ maxInputs: maxInputs.toNumber() })).toNumber();
        encodedArgs = `0x${rawPayload.slice(2).slice(argsOffset * 2)}`;
      }
    } else {
      encodedArgs = receipt.param2.toHex();
    }
    let argumentsProvided;
    if (encodedArgs) {
      const data = functionFragment.decodeArguments(encodedArgs);
      if (data) {
        argumentsProvided = inputs.reduce((prev, input, index) => {
          const value = data[index];
          const name = input.name;
          if (name) {
            return {
              ...prev,
              // reparse to remove bn
              [name]: JSON.parse(JSON.stringify(value))
            };
          }
          return prev;
        }, {});
      }
    }
    const call2 = {
      functionSignature: functionFragment.signature,
      functionName: functionFragment.name,
      argumentsProvided,
      ...receipt.amount?.isZero() ? {} : { amount: receipt.amount, assetId: receipt.assetId }
    };
    return call2;
  };
  function getInputsByType(inputs, type3) {
    return inputs.filter((i) => i.type === type3);
  }
  function getInputsCoin(inputs) {
    return getInputsByType(inputs, InputType.Coin);
  }
  function getInputsMessage(inputs) {
    return getInputsByType(inputs, InputType.Message);
  }
  function getInputsContract(inputs) {
    return getInputsByType(inputs, InputType.Contract);
  }
  function getInputFromAssetId(inputs, assetId) {
    const coinInputs = getInputsCoin(inputs);
    const messageInputs = getInputsMessage(inputs);
    const coinInput = coinInputs.find((i) => i.assetId === assetId);
    const messageInput = messageInputs.find(
      (_) => assetId === "0x0000000000000000000000000000000000000000000000000000000000000000"
    );
    return coinInput || messageInput;
  }
  function getInputContractFromIndex(inputs, inputIndex) {
    if (inputIndex == null) {
      return void 0;
    }
    const contractInput = inputs?.[inputIndex];
    if (!contractInput) {
      return void 0;
    }
    if (contractInput.type !== InputType.Contract) {
      throw new FuelError(
        ErrorCode.INVALID_TRANSACTION_INPUT,
        `Contract input should be of type 'contract'.`
      );
    }
    return contractInput;
  }
  function getInputAccountAddress(input) {
    if (input.type === InputType.Coin) {
      return input.owner.toString();
    }
    if (input.type === InputType.Message) {
      return input.recipient.toString();
    }
    return "";
  }
  function getOutputsByType(outputs, type3) {
    return outputs.filter((o) => o.type === type3);
  }
  function getOutputsContractCreated(outputs) {
    return getOutputsByType(outputs, OutputType.ContractCreated);
  }
  function getOutputsCoin(outputs) {
    return getOutputsByType(outputs, OutputType.Coin);
  }
  function getOutputsChange(outputs) {
    return getOutputsByType(outputs, OutputType.Change);
  }
  function getOutputsContract(outputs) {
    return getOutputsByType(outputs, OutputType.Contract);
  }
  function getReceiptsByType(receipts, type3) {
    return (receipts ?? []).filter((r) => r.type === type3);
  }
  function getTransactionTypeName(transactionType) {
    switch (transactionType) {
      case TransactionType.Mint:
        return "Mint";
      case TransactionType.Create:
        return "Create";
      case TransactionType.Script:
        return "Script";
      default:
        throw new FuelError(
          ErrorCode.INVALID_TRANSACTION_TYPE,
          `Invalid transaction type: ${transactionType}.`
        );
    }
  }
  function isType(transactionType, type3) {
    const txType = getTransactionTypeName(transactionType);
    return txType === type3;
  }
  function isTypeMint(transactionType) {
    return isType(
      transactionType,
      "Mint"
      /* Mint */
    );
  }
  function isTypeCreate(transactionType) {
    return isType(
      transactionType,
      "Create"
      /* Create */
    );
  }
  function isTypeScript(transactionType) {
    return isType(
      transactionType,
      "Script"
      /* Script */
    );
  }
  function hasSameAssetId(a) {
    return (b) => a.assetId === b.assetId;
  }
  function getReceiptsCall(receipts) {
    return getReceiptsByType(receipts, ReceiptType.Call);
  }
  function getReceiptsMessageOut(receipts) {
    return getReceiptsByType(receipts, ReceiptType.MessageOut);
  }
  var mergeAssets = (op1, op2) => {
    const assets1 = op1.assetsSent || [];
    const assets2 = op2.assetsSent || [];
    const filtered = assets2.filter((c) => !assets1.some(hasSameAssetId(c)));
    return assets1.map((coin) => {
      const asset = assets2.find(hasSameAssetId(coin));
      if (!asset) {
        return coin;
      }
      return { ...coin, amount: bn(coin.amount).add(asset.amount) };
    }).concat(filtered);
  };
  function isSameOperation(a, b) {
    return a.name === b.name && a.from?.address === b.from?.address && a.to?.address === b.to?.address && a.from?.type === b.from?.type && a.to?.type === b.to?.type;
  }
  function addOperation(operations, toAdd) {
    const ops = operations.map((op) => {
      if (!isSameOperation(op, toAdd)) {
        return null;
      }
      let newOp = { ...op };
      if (toAdd.assetsSent?.length) {
        newOp = {
          ...newOp,
          assetsSent: op.assetsSent?.length ? mergeAssets(op, toAdd) : toAdd.assetsSent
        };
      }
      if (toAdd.calls?.length) {
        newOp = {
          ...newOp,
          calls: [...op.calls || [], ...toAdd.calls || []]
        };
      }
      return newOp;
    }).filter(Boolean);
    return ops.length ? ops : [...operations, toAdd];
  }
  function getReceiptsTransferOut(receipts) {
    return getReceiptsByType(receipts, ReceiptType.TransferOut);
  }
  function getContractTransferOperations({ receipts }) {
    const transferOutReceipts = getReceiptsTransferOut(receipts);
    const contractTransferOperations = transferOutReceipts.reduce(
      (prevContractTransferOps, receipt) => {
        const newContractTransferOps = addOperation(prevContractTransferOps, {
          name: "Contract transfer",
          from: {
            type: 0,
            address: receipt.from
          },
          to: {
            type: 1,
            address: receipt.to
          },
          assetsSent: [
            {
              amount: receipt.amount,
              assetId: receipt.assetId
            }
          ]
        });
        return newContractTransferOps;
      },
      []
    );
    return contractTransferOperations;
  }
  function getWithdrawFromFuelOperations({
    inputs,
    receipts
  }) {
    const messageOutReceipts = getReceiptsMessageOut(receipts);
    const withdrawFromFuelOperations = messageOutReceipts.reduce(
      (prevWithdrawFromFuelOps, receipt) => {
        const assetId = "0x0000000000000000000000000000000000000000000000000000000000000000";
        const input = getInputFromAssetId(inputs, assetId);
        if (input) {
          const inputAddress = getInputAccountAddress(input);
          const newWithdrawFromFuelOps = addOperation(prevWithdrawFromFuelOps, {
            name: "Withdraw from Fuel",
            from: {
              type: 1,
              address: inputAddress
            },
            to: {
              type: 1,
              address: receipt.recipient.toString(),
              chain: "ethereum"
              /* ethereum */
            },
            assetsSent: [
              {
                amount: receipt.amount,
                assetId
              }
            ]
          });
          return newWithdrawFromFuelOps;
        }
        return prevWithdrawFromFuelOps;
      },
      []
    );
    return withdrawFromFuelOperations;
  }
  function getContractCallOperations({
    inputs,
    outputs,
    receipts,
    abiMap,
    rawPayload,
    maxInputs
  }) {
    const contractCallReceipts = getReceiptsCall(receipts);
    const contractOutputs = getOutputsContract(outputs);
    const contractCallOperations = contractOutputs.reduce((prevOutputCallOps, output3) => {
      const contractInput = getInputContractFromIndex(inputs, output3.inputIndex);
      if (contractInput) {
        const newCallOps = contractCallReceipts.reduce((prevContractCallOps, receipt) => {
          if (receipt.to === contractInput.contractID) {
            const input = getInputFromAssetId(inputs, receipt.assetId);
            if (input) {
              const inputAddress = getInputAccountAddress(input);
              const calls = [];
              const abi = abiMap?.[contractInput.contractID];
              if (abi) {
                calls.push(
                  getFunctionCall({
                    abi,
                    receipt,
                    rawPayload,
                    maxInputs
                  })
                );
              }
              const newContractCallOps = addOperation(prevContractCallOps, {
                name: "Contract call",
                from: {
                  type: 1,
                  address: inputAddress
                },
                to: {
                  type: 0,
                  address: receipt.to
                },
                // if no amount is forwarded to the contract, skip showing assetsSent
                assetsSent: receipt.amount?.isZero() ? void 0 : [
                  {
                    amount: receipt.amount,
                    assetId: receipt.assetId
                  }
                ],
                calls
              });
              return newContractCallOps;
            }
          }
          return prevContractCallOps;
        }, prevOutputCallOps);
        return newCallOps;
      }
      return prevOutputCallOps;
    }, []);
    return contractCallOperations;
  }
  function getTransferOperations({
    inputs,
    outputs,
    receipts
  }) {
    const coinOutputs = getOutputsCoin(outputs);
    const [transferReceipt] = getReceiptsByType(
      receipts,
      ReceiptType.Transfer
    );
    let operations = [];
    if (transferReceipt) {
      const changeOutputs = getOutputsChange(outputs);
      changeOutputs.forEach((output3) => {
        const { assetId } = output3;
        const [contractInput] = getInputsContract(inputs);
        const utxo = getInputFromAssetId(inputs, assetId);
        if (utxo && contractInput) {
          const inputAddress = getInputAccountAddress(utxo);
          operations = addOperation(operations, {
            name: "Transfer asset",
            from: {
              type: 1,
              address: inputAddress
            },
            to: {
              type: 0,
              address: contractInput.contractID
            },
            assetsSent: [
              {
                assetId: assetId.toString(),
                amount: transferReceipt.amount
              }
            ]
          });
        }
      });
    } else {
      coinOutputs.forEach((output3) => {
        const input = getInputFromAssetId(inputs, output3.assetId);
        if (input) {
          const inputAddress = getInputAccountAddress(input);
          operations = addOperation(operations, {
            name: "Transfer asset",
            from: {
              type: 1,
              address: inputAddress
            },
            to: {
              type: 1,
              address: output3.to.toString()
            },
            assetsSent: [
              {
                assetId: output3.assetId.toString(),
                amount: output3.amount
              }
            ]
          });
        }
      });
    }
    return operations;
  }
  function getPayProducerOperations(outputs) {
    const coinOutputs = getOutputsCoin(outputs);
    const payProducerOperations = coinOutputs.reduce((prev, output3) => {
      const operations = addOperation(prev, {
        name: "Pay network fee to block producer",
        from: {
          type: 1,
          address: "Network"
        },
        to: {
          type: 1,
          address: output3.to.toString()
        },
        assetsSent: [
          {
            assetId: output3.assetId.toString(),
            amount: output3.amount
          }
        ]
      });
      return operations;
    }, []);
    return payProducerOperations;
  }
  function getContractCreatedOperations({ inputs, outputs }) {
    const contractCreatedOutputs = getOutputsContractCreated(outputs);
    const input = getInputsCoin(inputs)[0];
    const fromAddress = getInputAccountAddress(input);
    const contractCreatedOperations = contractCreatedOutputs.reduce((prev, contractCreatedOutput) => {
      const operations = addOperation(prev, {
        name: "Contract created",
        from: {
          type: 1,
          address: fromAddress
        },
        to: {
          type: 0,
          address: contractCreatedOutput?.contractId || ""
        }
      });
      return operations;
    }, []);
    return contractCreatedOperations;
  }
  function getOperations({
    transactionType,
    inputs,
    outputs,
    receipts,
    abiMap,
    rawPayload,
    maxInputs
  }) {
    if (isTypeCreate(transactionType)) {
      return [
        ...getContractCreatedOperations({ inputs, outputs }),
        ...getTransferOperations({ inputs, outputs, receipts })
      ];
    }
    if (isTypeScript(transactionType)) {
      return [
        ...getTransferOperations({ inputs, outputs, receipts }),
        ...getContractCallOperations({
          inputs,
          outputs,
          receipts,
          abiMap,
          rawPayload,
          maxInputs
        }),
        ...getContractTransferOperations({ receipts }),
        ...getWithdrawFromFuelOperations({ inputs, receipts })
      ];
    }
    return [...getPayProducerOperations(outputs)];
  }
  var processGqlReceipt = (gqlReceipt) => {
    const receipt = assembleReceiptByType(gqlReceipt);
    switch (receipt.type) {
      case ReceiptType.ReturnData: {
        return {
          ...receipt,
          data: gqlReceipt.data || "0x"
        };
      }
      case ReceiptType.LogData: {
        return {
          ...receipt,
          data: gqlReceipt.data || "0x"
        };
      }
      default:
        return receipt;
    }
  };
  var extractMintedAssetsFromReceipts = (receipts) => {
    const mintedAssets = [];
    receipts.forEach((receipt) => {
      if (receipt.type === ReceiptType.Mint) {
        mintedAssets.push({
          subId: receipt.subId,
          contractId: receipt.contractId,
          assetId: receipt.assetId,
          amount: receipt.val
        });
      }
    });
    return mintedAssets;
  };
  var extractBurnedAssetsFromReceipts = (receipts) => {
    const burnedAssets = [];
    receipts.forEach((receipt) => {
      if (receipt.type === ReceiptType.Burn) {
        burnedAssets.push({
          subId: receipt.subId,
          contractId: receipt.contractId,
          assetId: receipt.assetId,
          amount: receipt.val
        });
      }
    });
    return burnedAssets;
  };
  var getTransactionStatusName = (gqlStatus) => {
    switch (gqlStatus) {
      case "FailureStatus":
        return "failure";
      case "SuccessStatus":
        return "success";
      case "SubmittedStatus":
        return "submitted";
      case "SqueezedOutStatus":
        return "squeezedout";
      default:
        throw new FuelError(
          ErrorCode.INVALID_TRANSACTION_STATUS,
          `Invalid transaction status: ${gqlStatus}.`
        );
    }
  };
  var processGraphqlStatus = (gqlTransactionStatus) => {
    let time;
    let blockId;
    let status;
    let isStatusFailure = false;
    let isStatusSuccess = false;
    let isStatusPending = false;
    if (gqlTransactionStatus?.type) {
      status = getTransactionStatusName(gqlTransactionStatus.type);
      switch (gqlTransactionStatus.type) {
        case "SuccessStatus":
          time = gqlTransactionStatus.time;
          blockId = gqlTransactionStatus.block.id;
          isStatusSuccess = true;
          break;
        case "FailureStatus":
          time = gqlTransactionStatus.time;
          blockId = gqlTransactionStatus.block.id;
          isStatusFailure = true;
          break;
        case "SubmittedStatus":
          time = gqlTransactionStatus.time;
          isStatusPending = true;
          break;
        default:
      }
    }
    const processedGraphqlStatus = {
      time,
      blockId,
      status,
      isStatusFailure,
      isStatusSuccess,
      isStatusPending
    };
    return processedGraphqlStatus;
  };
  function assembleTransactionSummary(params) {
    const {
      receipts,
      gasPerByte,
      gasPriceFactor,
      transaction,
      transactionBytes,
      id,
      gqlTransactionStatus,
      abiMap = {},
      maxInputs
    } = params;
    const { gasLimit = bn(0), witnesses } = transaction;
    const gasPrice = bn(transaction.gasPrice);
    const gasUsed = getGasUsedFromReceipts(receipts);
    const chargeableBytes = calculateTxChargeableBytes({
      transactionBytes,
      transactionWitnesses: witnesses
    });
    const { minFee: fee } = calculateTransactionFee({
      gasUsed,
      gasPrice,
      gasLimit,
      gasPerByte,
      gasPriceFactor,
      chargeableBytes
    });
    const operations = getOperations({
      transactionType: transaction.type,
      inputs: transaction.inputs || [],
      outputs: transaction.outputs || [],
      receipts,
      rawPayload: hexlify(transactionBytes),
      abiMap,
      maxInputs
    });
    const typeName = getTransactionTypeName(transaction.type);
    const { isStatusFailure, isStatusPending, isStatusSuccess, blockId, status, time } = processGraphqlStatus(gqlTransactionStatus);
    const mintedAssets = extractMintedAssetsFromReceipts(receipts);
    const burnedAssets = extractBurnedAssetsFromReceipts(receipts);
    let date2;
    if (time) {
      date2 = fromTai64ToDate(time);
    }
    const transactionSummary = {
      id,
      fee,
      gasUsed,
      operations,
      type: typeName,
      blockId,
      time,
      status,
      receipts,
      mintedAssets,
      burnedAssets,
      isTypeMint: isTypeMint(transaction.type),
      isTypeCreate: isTypeCreate(transaction.type),
      isTypeScript: isTypeScript(transaction.type),
      isStatusFailure,
      isStatusSuccess,
      isStatusPending,
      date: date2,
      transaction
    };
    return transactionSummary;
  }
  var STATUS_POLLING_INTERVAL_MAX_MS = 5e3;
  var STATUS_POLLING_INTERVAL_MIN_MS = 1e3;
  var TransactionResponse2 = class {
    /** Transaction ID */
    id;
    /** Current provider */
    provider;
    /** Gas used on the transaction */
    gasUsed = bn(0);
    /** Number of attempts made to fetch the transaction */
    fetchAttempts = 0;
    /** Number of attempts made to retrieve a processed transaction. */
    resultAttempts = 0;
    /** The graphql Transaction with receipts object. */
    gqlTransaction;
    /**
     * Constructor for `TransactionResponse`.
     *
     * @param id - The transaction ID.
     * @param provider - The provider.
     */
    constructor(id, provider) {
      this.id = id;
      this.provider = provider;
    }
    /**
     * Async constructor for `TransactionResponse`. This method can be used to create
     * an instance of `TransactionResponse` and wait for the transaction to be fetched
     * from the chain, ensuring that the `gqlTransaction` property is set.
     *
     * @param id - The transaction ID.
     * @param provider - The provider.
     */
    static async create(id, provider) {
      const response = new TransactionResponse2(id, provider);
      await response.fetch();
      return response;
    }
    /**
     * Fetch the transaction with receipts from the provider.
     *
     * @returns Transaction with receipts query result.
     */
    async fetch() {
      const response = await this.provider.operations.getTransactionWithReceipts({
        transactionId: this.id
      });
      if (!response.transaction) {
        await this.sleepBasedOnAttempts(++this.fetchAttempts);
        return this.fetch();
      }
      this.gqlTransaction = response.transaction;
      return response.transaction;
    }
    /**
     * Decode the raw payload of the transaction.
     *
     * @param transactionWithReceipts - The transaction with receipts object.
     * @returns The decoded transaction.
     */
    decodeTransaction(transactionWithReceipts) {
      return new TransactionCoder().decode(
        getBytesCopy(transactionWithReceipts.rawPayload),
        0
      )?.[0];
    }
    /**
     * Retrieves the TransactionSummary. If the `gqlTransaction` is not set, it will
     * fetch it from the provider
     *
     * @param contractsAbiMap - The contracts ABI map.
     * @returns
     */
    async getTransactionSummary(contractsAbiMap) {
      let transaction = this.gqlTransaction;
      if (!transaction) {
        transaction = await this.fetch();
      }
      const decodedTransaction = this.decodeTransaction(
        transaction
      );
      const receipts = transaction.receipts?.map(processGqlReceipt) || [];
      const { gasPerByte, gasPriceFactor } = this.provider.getGasConfig();
      const maxInputs = this.provider.getChain().consensusParameters.maxInputs;
      const transactionSummary = assembleTransactionSummary({
        id: this.id,
        receipts,
        transaction: decodedTransaction,
        transactionBytes: getBytesCopy(transaction.rawPayload),
        gqlTransactionStatus: transaction.status,
        gasPerByte,
        gasPriceFactor,
        abiMap: contractsAbiMap,
        maxInputs
      });
      return transactionSummary;
    }
    /**
     * Waits for transaction to complete and returns the result.
     *
     * @returns The completed transaction result
     */
    async waitForResult(contractsAbiMap) {
      await this.fetch();
      if (this.gqlTransaction?.status?.type === "SubmittedStatus") {
        await this.sleepBasedOnAttempts(++this.resultAttempts);
        return this.waitForResult(contractsAbiMap);
      }
      const transactionSummary = await this.getTransactionSummary(contractsAbiMap);
      const transactionResult = {
        gqlTransaction: this.gqlTransaction,
        ...transactionSummary
      };
      return transactionResult;
    }
    /**
     * Waits for transaction to complete and returns the result.
     *
     * @param contractsAbiMap - The contracts ABI map.
     */
    async wait(contractsAbiMap) {
      const result = await this.waitForResult(contractsAbiMap);
      if (result.isStatusFailure) {
        throw new FuelError(
          ErrorCode.TRANSACTION_FAILED,
          `Transaction failed: ${result.gqlTransaction.status.reason}`
        );
      }
      return result;
    }
    /**
     * Introduces a delay based on the number of previous attempts made.
     *
     * @param attempts - The number of attempts.
     */
    async sleepBasedOnAttempts(attempts) {
      await sleep(
        Math.min(STATUS_POLLING_INTERVAL_MIN_MS * attempts, STATUS_POLLING_INTERVAL_MAX_MS)
      );
    }
  };
  function getDecodedLogs(receipts, abiInterface) {
    return receipts.reduce((logs, r) => {
      if (r.type === ReceiptType.LogData) {
        logs.push(abiInterface.decodeLog(r.data, r.val1.toNumber(), r.id)[0]);
      }
      if (r.type === ReceiptType.Log) {
        logs.push(abiInterface.decodeLog(new U64Coder().encode(r.val0), r.val1.toNumber(), r.id)[0]);
      }
      return logs;
    }, []);
  }
  var mergeQuantities = (arr1, arr2) => {
    const resultMap = {};
    function addToMap({ amount, assetId }) {
      if (resultMap[assetId]) {
        resultMap[assetId] = resultMap[assetId].add(amount);
      } else {
        resultMap[assetId] = amount;
      }
    }
    arr1.forEach(addToMap);
    arr2.forEach(addToMap);
    return Object.entries(resultMap).map(([assetId, amount]) => ({ assetId, amount }));
  };
  var MAX_RETRIES = 10;
  var processGqlChain = (chain) => {
    const { name, baseChainHeight, peerCount, consensusParameters, latestBlock } = chain;
    return {
      name,
      baseChainHeight: bn(baseChainHeight),
      peerCount,
      consensusParameters: {
        contractMaxSize: bn(consensusParameters.contractMaxSize),
        maxInputs: bn(consensusParameters.maxInputs),
        maxOutputs: bn(consensusParameters.maxOutputs),
        maxWitnesses: bn(consensusParameters.maxWitnesses),
        maxGasPerTx: bn(consensusParameters.maxGasPerTx),
        maxScriptLength: bn(consensusParameters.maxScriptLength),
        maxScriptDataLength: bn(consensusParameters.maxScriptDataLength),
        maxStorageSlots: bn(consensusParameters.maxStorageSlots),
        maxPredicateLength: bn(consensusParameters.maxPredicateLength),
        maxPredicateDataLength: bn(consensusParameters.maxPredicateDataLength),
        maxGasPerPredicate: bn(consensusParameters.maxGasPerPredicate),
        gasPriceFactor: bn(consensusParameters.gasPriceFactor),
        gasPerByte: bn(consensusParameters.gasPerByte),
        maxMessageDataLength: bn(consensusParameters.maxMessageDataLength),
        chainId: bn(consensusParameters.chainId)
      },
      latestBlock: {
        id: latestBlock.id,
        height: bn(latestBlock.header.height),
        time: latestBlock.header.time,
        transactions: latestBlock.transactions.map((i) => ({
          id: i.id
        }))
      }
    };
  };
  var _cacheInputs;
  var cacheInputs_fn;
  var _Provider = class {
    /**
     * Constructor to initialize a Provider.
     *
     * @param url - GraphQL endpoint of the Fuel node
     * @param chainInfo - Chain info of the Fuel node
     * @param options - Additional options for the provider
     * @hidden
     */
    constructor(url, options = {}) {
      this.url = url;
      this.options = options;
      __privateAdd3(this, _cacheInputs);
      __publicField6(this, "operations");
      __publicField6(this, "cache");
      this.operations = this.createOperations(url, options);
      this.cache = options.cacheUtxo ? new MemoryCache(options.cacheUtxo) : void 0;
    }
    static clearChainAndNodeCaches() {
      _Provider.nodeInfoCache = {};
      _Provider.chainInfoCache = {};
    }
    /**
     * Creates a new instance of the Provider class. This is the recommended way to initialize a Provider.
     * @param url - GraphQL endpoint of the Fuel node
     * @param options - Additional options for the provider
     */
    static async create(url, options = {}) {
      const provider = new _Provider(url, options);
      await provider.fetchChainAndNodeInfo();
      return provider;
    }
    /**
     * Returns the cached chainInfo for the current URL.
     */
    getChain() {
      const chain = _Provider.chainInfoCache[this.url];
      if (!chain) {
        throw new FuelError(
          ErrorCode.CHAIN_INFO_CACHE_EMPTY,
          "Chain info cache is empty. Make sure you have called `Provider.create` to initialize the provider."
        );
      }
      return chain;
    }
    /**
     * Returns the cached nodeInfo for the current URL.
     */
    getNode() {
      const node = _Provider.nodeInfoCache[this.url];
      if (!node) {
        throw new FuelError(
          ErrorCode.NODE_INFO_CACHE_EMPTY,
          "Node info cache is empty. Make sure you have called `Provider.create` to initialize the provider."
        );
      }
      return node;
    }
    /**
     * Returns some helpful parameters related to gas fees.
     */
    getGasConfig() {
      const { minGasPrice } = this.getNode();
      const { maxGasPerTx, maxGasPerPredicate, gasPriceFactor, gasPerByte } = this.getChain().consensusParameters;
      return {
        minGasPrice,
        maxGasPerTx,
        maxGasPerPredicate,
        gasPriceFactor,
        gasPerByte
      };
    }
    /**
     * Updates the URL for the provider and fetches the consensus parameters for the new URL, if needed.
     */
    async connect(url, options) {
      this.url = url;
      this.operations = this.createOperations(url, options ?? this.options);
      await this.fetchChainAndNodeInfo();
    }
    /**
     * Fetches both the chain and node information, saves it to the cache, and return it.
     *
     * @returns NodeInfo and Chain
     */
    async fetchChainAndNodeInfo() {
      const chain = await this.fetchChain();
      const nodeInfo = await this.fetchNode();
      _Provider.ensureClientVersionIsSupported(nodeInfo);
      return {
        chain,
        nodeInfo
      };
    }
    static ensureClientVersionIsSupported(nodeInfo) {
      const { isMajorSupported, isMinorSupported, supportedVersion } = checkFuelCoreVersionCompatibility(nodeInfo.nodeVersion);
      if (!isMajorSupported || !isMinorSupported) {
        throw new FuelError(
          FuelError.CODES.UNSUPPORTED_FUEL_CLIENT_VERSION,
          `Fuel client version: ${nodeInfo.nodeVersion}, Supported version: ${supportedVersion}`
        );
      }
    }
    /**
     * Create GraphQL client and set operations.
     *
     * @param url - The URL of the Fuel node
     * @param options - Additional options for the provider
     * @returns The operation SDK object
     */
    createOperations(url, options = {}) {
      this.url = url;
      const gqlClient = new import_graphql_request.GraphQLClient(url, options.fetch ? { fetch: options.fetch } : void 0);
      return getSdk(gqlClient);
    }
    /**
     * Returns the version of the connected node.
     *
     * @returns A promise that resolves to the version string.
     */
    async getVersion() {
      const {
        nodeInfo: { nodeVersion }
      } = await this.operations.getVersion();
      return nodeVersion;
    }
    /**
     * @hidden
     *
     * Returns the network configuration of the connected Fuel node.
     *
     * @returns A promise that resolves to the network configuration object
     */
    async getNetwork() {
      const {
        name,
        consensusParameters: { chainId }
      } = await this.getChain();
      const network = new Network(name, chainId.toNumber());
      return Promise.resolve(network);
    }
    /**
     * Returns the block number.
     *
     * @returns A promise that resolves to the block number
     */
    async getBlockNumber() {
      const { chain } = await this.operations.getChain();
      return bn(chain.latestBlock.header.height, 10);
    }
    /**
     * Returns the chain information.
     * @param url - The URL of the Fuel node
     * @returns NodeInfo object
     */
    async fetchNode() {
      const { nodeInfo } = await this.operations.getNodeInfo();
      const processedNodeInfo = {
        maxDepth: bn(nodeInfo.maxDepth),
        maxTx: bn(nodeInfo.maxTx),
        minGasPrice: bn(nodeInfo.minGasPrice),
        nodeVersion: nodeInfo.nodeVersion,
        utxoValidation: nodeInfo.utxoValidation,
        vmBacktrace: nodeInfo.vmBacktrace
      };
      _Provider.nodeInfoCache[this.url] = processedNodeInfo;
      return processedNodeInfo;
    }
    /**
     * Fetches the `chainInfo` for the given node URL.
     * @param url - The URL of the Fuel node
     * @returns ChainInfo object
     */
    async fetchChain() {
      const { chain } = await this.operations.getChain();
      const processedChain = processGqlChain(chain);
      _Provider.chainInfoCache[this.url] = processedChain;
      return processedChain;
    }
    /**
     * Returns the chain ID
     * @returns A promise that resolves to the chain ID number
     */
    getChainId() {
      const {
        consensusParameters: { chainId }
      } = this.getChain();
      return chainId.toNumber();
    }
    /**
     * Submits a transaction to the chain to be executed.
     *
     * If the transaction is missing any dependencies,
     * the transaction will be mutated and those dependencies will be added.
     *
     * @param transactionRequestLike - The transaction request object.
     * @returns A promise that resolves to the transaction response object.
     */
    // #region Provider-sendTransaction
    async sendTransaction(transactionRequestLike) {
      const transactionRequest = transactionRequestify(transactionRequestLike);
      __privateMethod3(this, _cacheInputs, cacheInputs_fn).call(this, transactionRequest.inputs);
      await this.estimateTxDependencies(transactionRequest);
      const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());
      const { gasUsed, minGasPrice } = await this.getTransactionCost(transactionRequest);
      if (bn(gasUsed).gt(bn(transactionRequest.gasLimit))) {
        throw new FuelError(
          ErrorCode.GAS_LIMIT_TOO_LOW,
          `Gas limit '${transactionRequest.gasLimit}' is lower than the required: '${gasUsed}'.`
        );
      } else if (bn(minGasPrice).gt(bn(transactionRequest.gasPrice))) {
        throw new FuelError(
          ErrorCode.GAS_PRICE_TOO_LOW,
          `Gas price '${transactionRequest.gasPrice}' is lower than the required: '${minGasPrice}'.`
        );
      }
      const {
        submit: { id: transactionId }
      } = await this.operations.submit({ encodedTransaction });
      const response = new TransactionResponse2(transactionId, this);
      return response;
    }
    /**
     * Executes a transaction without actually submitting it to the chain.
     *
     * If the transaction is missing any dependencies,
     * the transaction will be mutated and those dependencies will be added.
     *
     * @param transactionRequestLike - The transaction request object.
     * @param utxoValidation - Additional provider call parameters.
     * @returns A promise that resolves to the call result object.
     */
    async call(transactionRequestLike, { utxoValidation } = {}) {
      const transactionRequest = transactionRequestify(transactionRequestLike);
      await this.estimateTxDependencies(transactionRequest);
      const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());
      const { dryRun: gqlReceipts } = await this.operations.dryRun({
        encodedTransaction,
        utxoValidation: utxoValidation || false
      });
      const receipts = gqlReceipts.map(processGqlReceipt);
      return {
        receipts
      };
    }
    /**
     * Verifies whether enough gas is available to complete transaction.
     *
     * @param transactionRequest - The transaction request object.
     * @returns A promise that resolves to the estimated transaction request object.
     */
    async estimatePredicates(transactionRequest) {
      const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());
      const response = await this.operations.estimatePredicates({
        encodedTransaction
      });
      const estimatedTransaction = transactionRequest;
      const [decodedTransaction] = new TransactionCoder().decode(
        getBytesCopy(response.estimatePredicates.rawPayload),
        0
      );
      if (decodedTransaction.inputs) {
        decodedTransaction.inputs.forEach((input, index) => {
          if ("predicate" in input && input.predicateGasUsed.gt(0)) {
            estimatedTransaction.inputs[index].predicateGasUsed = input.predicateGasUsed;
          }
        });
      }
      return estimatedTransaction;
    }
    /**
     * Will dryRun a transaction and check for missing dependencies.
     *
     * If there are missing variable outputs,
     * `addVariableOutputs` is called on the transaction.
     *
     * @privateRemarks
     * TODO: Investigate support for missing contract IDs
     * TODO: Add support for missing output messages
     *
     * @param transactionRequest - The transaction request object.
     * @returns A promise.
     */
    async estimateTxDependencies(transactionRequest) {
      let missingOutputVariableCount = 0;
      let missingOutputContractIdsCount = 0;
      let tries = 0;
      if (transactionRequest.type === TransactionType.Create) {
        return;
      }
      const encodedTransaction = transactionRequest.hasPredicateInput() ? hexlify((await this.estimatePredicates(transactionRequest)).toTransactionBytes()) : hexlify(transactionRequest.toTransactionBytes());
      do {
        const { dryRun: gqlReceipts } = await this.operations.dryRun({
          encodedTransaction,
          utxoValidation: false
        });
        const receipts = gqlReceipts.map(processGqlReceipt);
        const { missingOutputVariables, missingOutputContractIds } = getReceiptsWithMissingData(receipts);
        missingOutputVariableCount = missingOutputVariables.length;
        missingOutputContractIdsCount = missingOutputContractIds.length;
        if (missingOutputVariableCount === 0 && missingOutputContractIdsCount === 0) {
          return;
        }
        if (transactionRequest instanceof ScriptTransactionRequest) {
          transactionRequest.addVariableOutputs(missingOutputVariableCount);
          missingOutputContractIds.forEach(
            ({ contractId }) => transactionRequest.addContractInputAndOutput(Address.fromString(contractId))
          );
        }
        tries += 1;
      } while (tries < MAX_RETRIES);
    }
    /**
     * Executes a signed transaction without applying the states changes
     * on the chain.
     *
     * If the transaction is missing any dependencies,
     * the transaction will be mutated and those dependencies will be added
     *
     * @param transactionRequestLike - The transaction request object.
     * @returns A promise that resolves to the call result object.
     */
    async simulate(transactionRequestLike) {
      const transactionRequest = transactionRequestify(transactionRequestLike);
      await this.estimateTxDependencies(transactionRequest);
      const encodedTransaction = hexlify(transactionRequest.toTransactionBytes());
      const { dryRun: gqlReceipts } = await this.operations.dryRun({
        encodedTransaction,
        utxoValidation: true
      });
      const receipts = gqlReceipts.map(processGqlReceipt);
      return {
        receipts
      };
    }
    /**
     * Returns a transaction cost to enable user
     * to set gasLimit and also reserve balance amounts
     * on the the transaction.
     *
     * @privateRemarks
     * The tolerance is add on top of the gasUsed calculated
     * from the node, this create a safe margin costs like
     * change states on transfer that don't occur on the dryRun
     * transaction. The default value is 0.2 or 20%
     *
     * @param transactionRequestLike - The transaction request object.
     * @param tolerance - The tolerance to add on top of the gasUsed.
     * @returns A promise that resolves to the transaction cost object.
     */
    async getTransactionCost(transactionRequestLike, forwardingQuantities = []) {
      const clonedTransactionRequest = transactionRequestify(clone_default(transactionRequestLike));
      const { gasLimit } = clonedTransactionRequest;
      let { gasPrice } = clonedTransactionRequest;
      const { minGasPrice, gasPerByte, gasPriceFactor, maxGasPerTx } = this.getGasConfig();
      gasPrice = max(gasPrice, minGasPrice);
      const coinOutputsQuantitites = clonedTransactionRequest.getCoinOutputsQuantities();
      const allQuantities = mergeQuantities(coinOutputsQuantitites, forwardingQuantities);
      clonedTransactionRequest.fundWithFakeUtxos(allQuantities);
      const transactionBytes = clonedTransactionRequest.toTransactionBytes();
      const chargeableBytes = calculateTxChargeableBytes({
        transactionBytes,
        transactionWitnesses: new TransactionCoder().decode(transactionBytes, 0)[0].witnesses
      });
      let gasUsed = bn(0);
      let receipts = [];
      const isTransactionCreate = clonedTransactionRequest.type === TransactionType.Create;
      if (!isTransactionCreate) {
        clonedTransactionRequest.gasPrice = bn(0);
        clonedTransactionRequest.gasLimit = maxGasPerTx;
        const result = await this.call(clonedTransactionRequest);
        receipts = result.receipts;
        gasUsed = getGasUsedFromReceipts(receipts);
      }
      const { minFee, maxFee } = calculateTransactionFee({
        gasPrice,
        gasPerByte,
        gasPriceFactor,
        chargeableBytes,
        gasLimit,
        gasUsed
      });
      return {
        requiredQuantities: allQuantities,
        minGasPrice,
        receipts,
        gasPrice,
        gasUsed,
        minFee,
        maxFee
      };
    }
    /**
     * Returns coins for the given owner.
     */
    async getCoins(owner, assetId, paginationArgs) {
      const result = await this.operations.getCoins({
        first: 10,
        ...paginationArgs,
        filter: { owner: owner.toB256(), assetId: assetId && hexlify(assetId) }
      });
      const coins = result.coins.edges.map((edge) => edge.node);
      return coins.map((coin) => ({
        id: coin.utxoId,
        assetId: coin.assetId,
        amount: bn(coin.amount),
        owner: Address.fromAddressOrString(coin.owner),
        maturity: bn(coin.maturity).toNumber(),
        blockCreated: bn(coin.blockCreated),
        txCreatedIdx: bn(coin.txCreatedIdx)
      }));
    }
    /**
     * Returns resources for the given owner satisfying the spend query.
     *
     * @param owner - The address to get resources for.
     * @param quantities - The quantities to get.
     * @param excludedIds - IDs of excluded resources from the selection.
     * @returns A promise that resolves to the resources.
     */
    async getResourcesToSpend(owner, quantities, excludedIds) {
      const excludeInput = {
        messages: excludedIds?.messages?.map((id) => hexlify(id)) || [],
        utxos: excludedIds?.utxos?.map((id) => hexlify(id)) || []
      };
      if (this.cache) {
        const uniqueUtxos = new Set(
          excludeInput.utxos.concat(this.cache?.getActiveData().map((id) => hexlify(id)))
        );
        excludeInput.utxos = Array.from(uniqueUtxos);
      }
      const coinsQuery = {
        owner: owner.toB256(),
        queryPerAsset: quantities.map(coinQuantityfy).map(({ assetId, amount, max: maxPerAsset }) => ({
          assetId: hexlify(assetId),
          amount: amount.toString(10),
          max: maxPerAsset ? maxPerAsset.toString(10) : void 0
        })),
        excludedIds: excludeInput
      };
      const result = await this.operations.getCoinsToSpend(coinsQuery);
      const coins = result.coinsToSpend.flat().map((coin) => {
        switch (coin.__typename) {
          case "MessageCoin":
            return {
              amount: bn(coin.amount),
              assetId: coin.assetId,
              daHeight: bn(coin.daHeight),
              sender: Address.fromAddressOrString(coin.sender),
              recipient: Address.fromAddressOrString(coin.recipient),
              nonce: coin.nonce
            };
          case "Coin":
            return {
              id: coin.utxoId,
              amount: bn(coin.amount),
              assetId: coin.assetId,
              owner: Address.fromAddressOrString(coin.owner),
              maturity: bn(coin.maturity).toNumber(),
              blockCreated: bn(coin.blockCreated),
              txCreatedIdx: bn(coin.txCreatedIdx)
            };
          default:
            return null;
        }
      }).filter((v) => !!v);
      return coins;
    }
    /**
     * Returns block matching the given ID or height.
     *
     * @param idOrHeight - ID or height of the block.
     * @returns A promise that resolves to the block.
     */
    async getBlock(idOrHeight) {
      let variables;
      if (typeof idOrHeight === "number") {
        variables = { blockHeight: bn(idOrHeight).toString(10) };
      } else if (idOrHeight === "latest") {
        variables = { blockHeight: (await this.getBlockNumber()).toString(10) };
      } else if (idOrHeight.length === 66) {
        variables = { blockId: idOrHeight };
      } else {
        variables = { blockId: bn(idOrHeight).toString(10) };
      }
      const { block } = await this.operations.getBlock(variables);
      if (!block) {
        return null;
      }
      return {
        id: block.id,
        height: bn(block.header.height),
        time: block.header.time,
        transactionIds: block.transactions.map((tx) => tx.id)
      };
    }
    /**
     * Returns all the blocks matching the given parameters.
     *
     * @param params - The parameters to query blocks.
     * @returns A promise that resolves to the blocks.
     */
    async getBlocks(params) {
      const { blocks: fetchedData } = await this.operations.getBlocks(params);
      const blocks = fetchedData.edges.map(({ node: block }) => ({
        id: block.id,
        height: bn(block.header.height),
        time: block.header.time,
        transactionIds: block.transactions.map((tx) => tx.id)
      }));
      return blocks;
    }
    /**
     * Returns block matching the given ID or type, including transaction data.
     *
     * @param idOrHeight - ID or height of the block.
     * @returns A promise that resolves to the block.
     */
    async getBlockWithTransactions(idOrHeight) {
      let variables;
      if (typeof idOrHeight === "number") {
        variables = { blockHeight: bn(idOrHeight).toString(10) };
      } else if (idOrHeight === "latest") {
        variables = { blockHeight: (await this.getBlockNumber()).toString() };
      } else {
        variables = { blockId: idOrHeight };
      }
      const { block } = await this.operations.getBlockWithTransactions(variables);
      if (!block) {
        return null;
      }
      return {
        id: block.id,
        height: bn(block.header.height, 10),
        time: block.header.time,
        transactionIds: block.transactions.map((tx) => tx.id),
        transactions: block.transactions.map(
          (tx) => new TransactionCoder().decode(getBytesCopy(tx.rawPayload), 0)?.[0]
        )
      };
    }
    /**
     * Get transaction with the given ID.
     *
     * @param transactionId - ID of the transaction.
     * @returns A promise that resolves to the transaction.
     */
    async getTransaction(transactionId) {
      const { transaction } = await this.operations.getTransaction({ transactionId });
      if (!transaction) {
        return null;
      }
      return new TransactionCoder().decode(
        getBytesCopy(transaction.rawPayload),
        0
      )?.[0];
    }
    /**
     * Get deployed contract with the given ID.
     *
     * @param contractId - ID of the contract.
     * @returns A promise that resolves to the contract.
     */
    async getContract(contractId) {
      const { contract } = await this.operations.getContract({ contractId });
      if (!contract) {
        return null;
      }
      return contract;
    }
    /**
     * Returns the balance for the given contract for the given asset ID.
     *
     * @param contractId - The contract ID to get the balance for.
     * @param assetId - The asset ID of coins to get.
     * @returns A promise that resolves to the balance.
     */
    async getContractBalance(contractId, assetId) {
      const { contractBalance } = await this.operations.getContractBalance({
        contract: contractId.toB256(),
        asset: hexlify(assetId)
      });
      return bn(contractBalance.amount, 10);
    }
    /**
     * Returns the balance for the given owner for the given asset ID.
     *
     * @param owner - The address to get coins for.
     * @param assetId - The asset ID of coins to get.
     * @returns A promise that resolves to the balance.
     */
    async getBalance(owner, assetId) {
      const { balance } = await this.operations.getBalance({
        owner: owner.toB256(),
        assetId: hexlify(assetId)
      });
      return bn(balance.amount, 10);
    }
    /**
     * Returns balances for the given owner.
     *
     * @param owner - The address to get coins for.
     * @param paginationArgs - Pagination arguments.
     * @returns A promise that resolves to the balances.
     */
    async getBalances(owner, paginationArgs) {
      const result = await this.operations.getBalances({
        first: 10,
        ...paginationArgs,
        filter: { owner: owner.toB256() }
      });
      const balances = result.balances.edges.map((edge) => edge.node);
      return balances.map((balance) => ({
        assetId: balance.assetId,
        amount: bn(balance.amount)
      }));
    }
    /**
     * Returns message for the given address.
     *
     * @param address - The address to get message from.
     * @param paginationArgs - Pagination arguments.
     * @returns A promise that resolves to the messages.
     */
    async getMessages(address, paginationArgs) {
      const result = await this.operations.getMessages({
        first: 10,
        ...paginationArgs,
        owner: address.toB256()
      });
      const messages = result.messages.edges.map((edge) => edge.node);
      return messages.map((message) => ({
        messageId: InputMessageCoder.getMessageId({
          sender: message.sender,
          recipient: message.recipient,
          nonce: message.nonce,
          amount: bn(message.amount),
          data: message.data
        }),
        sender: Address.fromAddressOrString(message.sender),
        recipient: Address.fromAddressOrString(message.recipient),
        nonce: message.nonce,
        amount: bn(message.amount),
        data: InputMessageCoder.decodeData(message.data),
        daHeight: bn(message.daHeight)
      }));
    }
    /**
     * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
     *
     * @param transactionId - The transaction to get message from.
     * @param messageId - The message id from MessageOut receipt.
     * @param commitBlockId - The commit block id.
     * @param commitBlockHeight - The commit block height.
     * @returns A promise that resolves to the message proof.
     */
    async getMessageProof(transactionId, messageId, commitBlockId, commitBlockHeight) {
      let inputObject = {
        transactionId,
        messageId
      };
      if (commitBlockId && commitBlockHeight) {
        throw new FuelError(
          ErrorCode.INVALID_INPUT_PARAMETERS,
          "commitBlockId and commitBlockHeight cannot be used together"
        );
      }
      if (commitBlockId) {
        inputObject = {
          ...inputObject,
          commitBlockId
        };
      }
      if (commitBlockHeight) {
        inputObject = {
          ...inputObject,
          // Conver BN into a number string required on the query
          // This should problably be fixed on the fuel client side
          commitBlockHeight: commitBlockHeight.toNumber().toString()
        };
      }
      const result = await this.operations.getMessageProof(inputObject);
      if (!result.messageProof) {
        return null;
      }
      const {
        messageProof,
        messageBlockHeader,
        commitBlockHeader,
        blockProof,
        nonce,
        sender,
        recipient,
        amount,
        data
      } = result.messageProof;
      return {
        messageProof: {
          proofIndex: bn(messageProof.proofIndex),
          proofSet: messageProof.proofSet
        },
        blockProof: {
          proofIndex: bn(blockProof.proofIndex),
          proofSet: blockProof.proofSet
        },
        messageBlockHeader: {
          id: messageBlockHeader.id,
          daHeight: bn(messageBlockHeader.daHeight),
          transactionsCount: bn(messageBlockHeader.transactionsCount),
          transactionsRoot: messageBlockHeader.transactionsRoot,
          height: bn(messageBlockHeader.height),
          prevRoot: messageBlockHeader.prevRoot,
          time: messageBlockHeader.time,
          applicationHash: messageBlockHeader.applicationHash,
          messageReceiptRoot: messageBlockHeader.messageReceiptRoot,
          messageReceiptCount: bn(messageBlockHeader.messageReceiptCount)
        },
        commitBlockHeader: {
          id: commitBlockHeader.id,
          daHeight: bn(commitBlockHeader.daHeight),
          transactionsCount: bn(commitBlockHeader.transactionsCount),
          transactionsRoot: commitBlockHeader.transactionsRoot,
          height: bn(commitBlockHeader.height),
          prevRoot: commitBlockHeader.prevRoot,
          time: commitBlockHeader.time,
          applicationHash: commitBlockHeader.applicationHash,
          messageReceiptRoot: commitBlockHeader.messageReceiptRoot,
          messageReceiptCount: bn(commitBlockHeader.messageReceiptCount)
        },
        sender: Address.fromAddressOrString(sender),
        recipient: Address.fromAddressOrString(recipient),
        nonce,
        amount: bn(amount),
        data
      };
    }
    /**
     * Returns Message Proof for given transaction id and the message id from MessageOut receipt.
     *
     * @param nonce - The nonce of the message to get status from.
     * @returns A promise that resolves to the message status
     */
    async getMessageStatus(nonce) {
      const result = await this.operations.getMessageStatus({ nonce });
      return result.messageStatus;
    }
    /**
     * Lets you produce blocks with custom timestamps and the block number of the last block produced.
     *
     * @param amount - The amount of blocks to produce
     * @param startTime - The UNIX timestamp to set for the first produced block
     * @returns A promise that resolves to the block number of the last produced block.
     */
    async produceBlocks(amount, startTime) {
      const { produceBlocks: latestBlockHeight } = await this.operations.produceBlocks({
        blocksToProduce: bn(amount).toString(10),
        startTimestamp: startTime ? fromUnixToTai64(startTime) : void 0
      });
      return bn(latestBlockHeight);
    }
  };
  var Provider = _Provider;
  _cacheInputs = /* @__PURE__ */ new WeakSet();
  cacheInputs_fn = function(inputs) {
    if (!this.cache) {
      return;
    }
    inputs.forEach((input) => {
      if (input.type === InputType.Coin) {
        this.cache?.set(input.id);
      }
    });
  };
  __publicField6(Provider, "chainInfoCache", {});
  __publicField6(Provider, "nodeInfoCache", {});

  // ../hasher/dist/index.mjs
  function hashMessage(msg) {
    return sha256(bufferFromString2(msg, "utf-8"));
  }
  function uint64ToBytesBE(value) {
    const bigIntValue = BigInt(value);
    const buffer = new ArrayBuffer(8);
    const dataView = new DataView(buffer);
    dataView.setBigUint64(0, bigIntValue, false);
    return new Uint8Array(dataView.buffer);
  }
  function hashTransaction(transactionRequestLike, chainId) {
    const transactionRequest = transactionRequestify(transactionRequestLike);
    const transaction = transactionRequest.toTransaction();
    if (transaction.type === TransactionType.Script) {
      transaction.receiptsRoot = ZeroBytes32;
    }
    transaction.inputs = transaction.inputs.map((input) => {
      const inputClone = clone_default(input);
      switch (inputClone.type) {
        case InputType.Coin: {
          inputClone.txPointer = {
            blockHeight: 0,
            txIndex: 0
          };
          inputClone.predicateGasUsed = bn(0);
          return inputClone;
        }
        case InputType.Message: {
          inputClone.predicateGasUsed = bn(0);
          return inputClone;
        }
        case InputType.Contract: {
          inputClone.txPointer = {
            blockHeight: 0,
            txIndex: 0
          };
          inputClone.utxoID = {
            transactionId: ZeroBytes32,
            outputIndex: 0
          };
          inputClone.balanceRoot = ZeroBytes32;
          inputClone.stateRoot = ZeroBytes32;
          return inputClone;
        }
        default:
          return inputClone;
      }
    });
    transaction.outputs = transaction.outputs.map((output3) => {
      const outputClone = clone_default(output3);
      switch (outputClone.type) {
        case OutputType.Contract: {
          outputClone.balanceRoot = ZeroBytes32;
          outputClone.stateRoot = ZeroBytes32;
          return outputClone;
        }
        case OutputType.Change: {
          outputClone.amount = bn(0);
          return outputClone;
        }
        case OutputType.Variable: {
          outputClone.to = ZeroBytes32;
          outputClone.amount = bn(0);
          outputClone.assetId = ZeroBytes32;
          return outputClone;
        }
        default:
          return outputClone;
      }
    });
    transaction.witnessesCount = 0;
    transaction.witnesses = [];
    const chainIdBytes = uint64ToBytesBE(chainId);
    const concatenatedData = concat([chainIdBytes, new TransactionCoder().encode(transaction)]);
    return sha256(concatenatedData);
  }
  function hash3(data) {
    return sha256(data);
  }

  // ../signer/dist/index.mjs
  var elliptic = __toESM(require_elliptic(), 1);
  var { ec: EC } = elliptic;
  function getCurve() {
    return new EC("secp256k1");
  }
  var Signer = class {
    address;
    publicKey;
    compressedPublicKey;
    privateKey;
    /**
     * Create a Signer instance from a given private key
     *
     * @param privateKey - The private key to use for signing
     * @returns A new Signer instance
     */
    constructor(privateKey) {
      if (typeof privateKey === "string") {
        if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
          privateKey = `0x${privateKey}`;
        }
      }
      const privateKeyBytes = getBytesCopy(privateKey);
      const keyPair = getCurve().keyFromPrivate(privateKeyBytes, "hex");
      this.compressedPublicKey = hexlify(Uint8Array.from(keyPair.getPublic(true, "array")));
      this.publicKey = hexlify(Uint8Array.from(keyPair.getPublic(false, "array").slice(1)));
      this.privateKey = hexlify(privateKeyBytes);
      this.address = Address.fromPublicKey(this.publicKey);
    }
    /**
     * Sign data using the Signer instance
     *
     * Signature is a 64 byte array of the concatenated r and s values with the compressed recoveryParam byte. [Read more](FuelLabs/fuel-specs/specs/protocol/cryptographic_primitives.md#public-key-cryptography)
     *
     * @param data - The data to be sign
     * @returns hashed signature
     */
    sign(data) {
      const keyPair = getCurve().keyFromPrivate(getBytesCopy(this.privateKey), "hex");
      const signature = keyPair.sign(getBytesCopy(data), {
        canonical: true
      });
      const r = toBytes2(signature.r, 32);
      const s = toBytes2(signature.s, 32);
      s[0] |= (signature.recoveryParam || 0) << 7;
      return concat([r, s]);
    }
    /**
     * Add point on the current elliptic curve
     *
     * @param point - Point to add on the curve
     * @returns compressed point on the curve
     */
    addPoint(point) {
      const p0 = getCurve().keyFromPublic(getBytesCopy(this.compressedPublicKey));
      const p1 = getCurve().keyFromPublic(getBytesCopy(point));
      const result = p0.getPublic().add(p1.getPublic());
      return hexlify(Uint8Array.from(result.encode("array", true)));
    }
    /**
     * Recover the public key from a signature performed with [`sign`](#sign).
     *
     * @param data - Data
     * @param signature - hashed signature
     * @returns public key from signature from the
     */
    static recoverPublicKey(data, signature) {
      const signedMessageBytes = getBytesCopy(signature);
      const r = signedMessageBytes.slice(0, 32);
      const s = signedMessageBytes.slice(32, 64);
      const recoveryParam = (s[0] & 128) >> 7;
      s[0] &= 127;
      const publicKey = getCurve().recoverPubKey(getBytesCopy(data), { r, s }, recoveryParam).encode("array", false).slice(1);
      return hexlify(Uint8Array.from(publicKey));
    }
    /**
     * Recover the address from a signature performed with [`sign`](#sign).
     *
     * @param data - Data
     * @param signature - Signature
     * @returns Address from signature
     */
    static recoverAddress(data, signature) {
      return Address.fromPublicKey(Signer.recoverPublicKey(data, signature));
    }
    /**
     * Generate a random privateKey
     *
     * @param entropy - Adds extra entropy to generate the privateKey
     * @returns random 32-byte hashed
     */
    static generatePrivateKey(entropy) {
      return entropy ? hash3(concat([randomBytes22(32), getBytesCopy(entropy)])) : randomBytes22(32);
    }
    /**
     * Extended publicKey from a compact publicKey
     *
     * @param publicKey - Compact publicKey
     * @returns extended publicKey
     */
    static extendPublicKey(publicKey) {
      const keyPair = getCurve().keyFromPublic(getBytesCopy(publicKey));
      return hexlify(Uint8Array.from(keyPair.getPublic(false, "array").slice(1)));
    }
  };
  var signer_default = Signer;

  // ../wallet/dist/index.mjs
  var asm = __toESM(require_node(), 1);

  // ../../node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-node/rng.js
  var import_crypto16 = __toESM(__require2("crypto"));
  var rnds8Pool = new Uint8Array(256);
  var poolPtr = rnds8Pool.length;
  function rng() {
    if (poolPtr > rnds8Pool.length - 16) {
      import_crypto16.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  }

  // ../../node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-node/stringify.js
  var byteToHex = [];
  for (let i = 0; i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset = 0) {
    return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
  }

  // ../../node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-node/native.js
  var import_crypto17 = __toESM(__require2("crypto"));
  var native_default = {
    randomUUID: import_crypto17.default.randomUUID
  };

  // ../../node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-node/v4.js
  function v4(options, buf, offset) {
    if (native_default.randomUUID && !buf && !options) {
      return native_default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return unsafeStringify(rnds);
  }
  var v4_default = v4;

  // ../wordlists/dist/index.mjs
  var english = [
    "abandon",
    "ability",
    "able",
    "about",
    "above",
    "absent",
    "absorb",
    "abstract",
    "absurd",
    "abuse",
    "access",
    "accident",
    "account",
    "accuse",
    "achieve",
    "acid",
    "acoustic",
    "acquire",
    "across",
    "act",
    "action",
    "actor",
    "actress",
    "actual",
    "adapt",
    "add",
    "addict",
    "address",
    "adjust",
    "admit",
    "adult",
    "advance",
    "advice",
    "aerobic",
    "affair",
    "afford",
    "afraid",
    "again",
    "age",
    "agent",
    "agree",
    "ahead",
    "aim",
    "air",
    "airport",
    "aisle",
    "alarm",
    "album",
    "alcohol",
    "alert",
    "alien",
    "all",
    "alley",
    "allow",
    "almost",
    "alone",
    "alpha",
    "already",
    "also",
    "alter",
    "always",
    "amateur",
    "amazing",
    "among",
    "amount",
    "amused",
    "analyst",
    "anchor",
    "ancient",
    "anger",
    "angle",
    "angry",
    "animal",
    "ankle",
    "announce",
    "annual",
    "another",
    "answer",
    "antenna",
    "antique",
    "anxiety",
    "any",
    "apart",
    "apology",
    "appear",
    "apple",
    "approve",
    "april",
    "arch",
    "arctic",
    "area",
    "arena",
    "argue",
    "arm",
    "armed",
    "armor",
    "army",
    "around",
    "arrange",
    "arrest",
    "arrive",
    "arrow",
    "art",
    "artefact",
    "artist",
    "artwork",
    "ask",
    "aspect",
    "assault",
    "asset",
    "assist",
    "assume",
    "asthma",
    "athlete",
    "atom",
    "attack",
    "attend",
    "attitude",
    "attract",
    "auction",
    "audit",
    "august",
    "aunt",
    "author",
    "auto",
    "autumn",
    "average",
    "avocado",
    "avoid",
    "awake",
    "aware",
    "away",
    "awesome",
    "awful",
    "awkward",
    "axis",
    "baby",
    "bachelor",
    "bacon",
    "badge",
    "bag",
    "balance",
    "balcony",
    "ball",
    "bamboo",
    "banana",
    "banner",
    "bar",
    "barely",
    "bargain",
    "barrel",
    "base",
    "basic",
    "basket",
    "battle",
    "beach",
    "bean",
    "beauty",
    "because",
    "become",
    "beef",
    "before",
    "begin",
    "behave",
    "behind",
    "believe",
    "below",
    "belt",
    "bench",
    "benefit",
    "best",
    "betray",
    "better",
    "between",
    "beyond",
    "bicycle",
    "bid",
    "bike",
    "bind",
    "biology",
    "bird",
    "birth",
    "bitter",
    "black",
    "blade",
    "blame",
    "blanket",
    "blast",
    "bleak",
    "bless",
    "blind",
    "blood",
    "blossom",
    "blouse",
    "blue",
    "blur",
    "blush",
    "board",
    "boat",
    "body",
    "boil",
    "bomb",
    "bone",
    "bonus",
    "book",
    "boost",
    "border",
    "boring",
    "borrow",
    "boss",
    "bottom",
    "bounce",
    "box",
    "boy",
    "bracket",
    "brain",
    "brand",
    "brass",
    "brave",
    "bread",
    "breeze",
    "brick",
    "bridge",
    "brief",
    "bright",
    "bring",
    "brisk",
    "broccoli",
    "broken",
    "bronze",
    "broom",
    "brother",
    "brown",
    "brush",
    "bubble",
    "buddy",
    "budget",
    "buffalo",
    "build",
    "bulb",
    "bulk",
    "bullet",
    "bundle",
    "bunker",
    "burden",
    "burger",
    "burst",
    "bus",
    "business",
    "busy",
    "butter",
    "buyer",
    "buzz",
    "cabbage",
    "cabin",
    "cable",
    "cactus",
    "cage",
    "cake",
    "call",
    "calm",
    "camera",
    "camp",
    "can",
    "canal",
    "cancel",
    "candy",
    "cannon",
    "canoe",
    "canvas",
    "canyon",
    "capable",
    "capital",
    "captain",
    "car",
    "carbon",
    "card",
    "cargo",
    "carpet",
    "carry",
    "cart",
    "case",
    "cash",
    "casino",
    "castle",
    "casual",
    "cat",
    "catalog",
    "catch",
    "category",
    "cattle",
    "caught",
    "cause",
    "caution",
    "cave",
    "ceiling",
    "celery",
    "cement",
    "census",
    "century",
    "cereal",
    "certain",
    "chair",
    "chalk",
    "champion",
    "change",
    "chaos",
    "chapter",
    "charge",
    "chase",
    "chat",
    "cheap",
    "check",
    "cheese",
    "chef",
    "cherry",
    "chest",
    "chicken",
    "chief",
    "child",
    "chimney",
    "choice",
    "choose",
    "chronic",
    "chuckle",
    "chunk",
    "churn",
    "cigar",
    "cinnamon",
    "circle",
    "citizen",
    "city",
    "civil",
    "claim",
    "clap",
    "clarify",
    "claw",
    "clay",
    "clean",
    "clerk",
    "clever",
    "click",
    "client",
    "cliff",
    "climb",
    "clinic",
    "clip",
    "clock",
    "clog",
    "close",
    "cloth",
    "cloud",
    "clown",
    "club",
    "clump",
    "cluster",
    "clutch",
    "coach",
    "coast",
    "coconut",
    "code",
    "coffee",
    "coil",
    "coin",
    "collect",
    "color",
    "column",
    "combine",
    "come",
    "comfort",
    "comic",
    "common",
    "company",
    "concert",
    "conduct",
    "confirm",
    "congress",
    "connect",
    "consider",
    "control",
    "convince",
    "cook",
    "cool",
    "copper",
    "copy",
    "coral",
    "core",
    "corn",
    "correct",
    "cost",
    "cotton",
    "couch",
    "country",
    "couple",
    "course",
    "cousin",
    "cover",
    "coyote",
    "crack",
    "cradle",
    "craft",
    "cram",
    "crane",
    "crash",
    "crater",
    "crawl",
    "crazy",
    "cream",
    "credit",
    "creek",
    "crew",
    "cricket",
    "crime",
    "crisp",
    "critic",
    "crop",
    "cross",
    "crouch",
    "crowd",
    "crucial",
    "cruel",
    "cruise",
    "crumble",
    "crunch",
    "crush",
    "cry",
    "crystal",
    "cube",
    "culture",
    "cup",
    "cupboard",
    "curious",
    "current",
    "curtain",
    "curve",
    "cushion",
    "custom",
    "cute",
    "cycle",
    "dad",
    "damage",
    "damp",
    "dance",
    "danger",
    "daring",
    "dash",
    "daughter",
    "dawn",
    "day",
    "deal",
    "debate",
    "debris",
    "decade",
    "december",
    "decide",
    "decline",
    "decorate",
    "decrease",
    "deer",
    "defense",
    "define",
    "defy",
    "degree",
    "delay",
    "deliver",
    "demand",
    "demise",
    "denial",
    "dentist",
    "deny",
    "depart",
    "depend",
    "deposit",
    "depth",
    "deputy",
    "derive",
    "describe",
    "desert",
    "design",
    "desk",
    "despair",
    "destroy",
    "detail",
    "detect",
    "develop",
    "device",
    "devote",
    "diagram",
    "dial",
    "diamond",
    "diary",
    "dice",
    "diesel",
    "diet",
    "differ",
    "digital",
    "dignity",
    "dilemma",
    "dinner",
    "dinosaur",
    "direct",
    "dirt",
    "disagree",
    "discover",
    "disease",
    "dish",
    "dismiss",
    "disorder",
    "display",
    "distance",
    "divert",
    "divide",
    "divorce",
    "dizzy",
    "doctor",
    "document",
    "dog",
    "doll",
    "dolphin",
    "domain",
    "donate",
    "donkey",
    "donor",
    "door",
    "dose",
    "double",
    "dove",
    "draft",
    "dragon",
    "drama",
    "drastic",
    "draw",
    "dream",
    "dress",
    "drift",
    "drill",
    "drink",
    "drip",
    "drive",
    "drop",
    "drum",
    "dry",
    "duck",
    "dumb",
    "dune",
    "during",
    "dust",
    "dutch",
    "duty",
    "dwarf",
    "dynamic",
    "eager",
    "eagle",
    "early",
    "earn",
    "earth",
    "easily",
    "east",
    "easy",
    "echo",
    "ecology",
    "economy",
    "edge",
    "edit",
    "educate",
    "effort",
    "egg",
    "eight",
    "either",
    "elbow",
    "elder",
    "electric",
    "elegant",
    "element",
    "elephant",
    "elevator",
    "elite",
    "else",
    "embark",
    "embody",
    "embrace",
    "emerge",
    "emotion",
    "employ",
    "empower",
    "empty",
    "enable",
    "enact",
    "end",
    "endless",
    "endorse",
    "enemy",
    "energy",
    "enforce",
    "engage",
    "engine",
    "enhance",
    "enjoy",
    "enlist",
    "enough",
    "enrich",
    "enroll",
    "ensure",
    "enter",
    "entire",
    "entry",
    "envelope",
    "episode",
    "equal",
    "equip",
    "era",
    "erase",
    "erode",
    "erosion",
    "error",
    "erupt",
    "escape",
    "essay",
    "essence",
    "estate",
    "eternal",
    "ethics",
    "evidence",
    "evil",
    "evoke",
    "evolve",
    "exact",
    "example",
    "excess",
    "exchange",
    "excite",
    "exclude",
    "excuse",
    "execute",
    "exercise",
    "exhaust",
    "exhibit",
    "exile",
    "exist",
    "exit",
    "exotic",
    "expand",
    "expect",
    "expire",
    "explain",
    "expose",
    "express",
    "extend",
    "extra",
    "eye",
    "eyebrow",
    "fabric",
    "face",
    "faculty",
    "fade",
    "faint",
    "faith",
    "fall",
    "false",
    "fame",
    "family",
    "famous",
    "fan",
    "fancy",
    "fantasy",
    "farm",
    "fashion",
    "fat",
    "fatal",
    "father",
    "fatigue",
    "fault",
    "favorite",
    "feature",
    "february",
    "federal",
    "fee",
    "feed",
    "feel",
    "female",
    "fence",
    "festival",
    "fetch",
    "fever",
    "few",
    "fiber",
    "fiction",
    "field",
    "figure",
    "file",
    "film",
    "filter",
    "final",
    "find",
    "fine",
    "finger",
    "finish",
    "fire",
    "firm",
    "first",
    "fiscal",
    "fish",
    "fit",
    "fitness",
    "fix",
    "flag",
    "flame",
    "flash",
    "flat",
    "flavor",
    "flee",
    "flight",
    "flip",
    "float",
    "flock",
    "floor",
    "flower",
    "fluid",
    "flush",
    "fly",
    "foam",
    "focus",
    "fog",
    "foil",
    "fold",
    "follow",
    "food",
    "foot",
    "force",
    "forest",
    "forget",
    "fork",
    "fortune",
    "forum",
    "forward",
    "fossil",
    "foster",
    "found",
    "fox",
    "fragile",
    "frame",
    "frequent",
    "fresh",
    "friend",
    "fringe",
    "frog",
    "front",
    "frost",
    "frown",
    "frozen",
    "fruit",
    "fuel",
    "fun",
    "funny",
    "furnace",
    "fury",
    "future",
    "gadget",
    "gain",
    "galaxy",
    "gallery",
    "game",
    "gap",
    "garage",
    "garbage",
    "garden",
    "garlic",
    "garment",
    "gas",
    "gasp",
    "gate",
    "gather",
    "gauge",
    "gaze",
    "general",
    "genius",
    "genre",
    "gentle",
    "genuine",
    "gesture",
    "ghost",
    "giant",
    "gift",
    "giggle",
    "ginger",
    "giraffe",
    "girl",
    "give",
    "glad",
    "glance",
    "glare",
    "glass",
    "glide",
    "glimpse",
    "globe",
    "gloom",
    "glory",
    "glove",
    "glow",
    "glue",
    "goat",
    "goddess",
    "gold",
    "good",
    "goose",
    "gorilla",
    "gospel",
    "gossip",
    "govern",
    "gown",
    "grab",
    "grace",
    "grain",
    "grant",
    "grape",
    "grass",
    "gravity",
    "great",
    "green",
    "grid",
    "grief",
    "grit",
    "grocery",
    "group",
    "grow",
    "grunt",
    "guard",
    "guess",
    "guide",
    "guilt",
    "guitar",
    "gun",
    "gym",
    "habit",
    "hair",
    "half",
    "hammer",
    "hamster",
    "hand",
    "happy",
    "harbor",
    "hard",
    "harsh",
    "harvest",
    "hat",
    "have",
    "hawk",
    "hazard",
    "head",
    "health",
    "heart",
    "heavy",
    "hedgehog",
    "height",
    "hello",
    "helmet",
    "help",
    "hen",
    "hero",
    "hidden",
    "high",
    "hill",
    "hint",
    "hip",
    "hire",
    "history",
    "hobby",
    "hockey",
    "hold",
    "hole",
    "holiday",
    "hollow",
    "home",
    "honey",
    "hood",
    "hope",
    "horn",
    "horror",
    "horse",
    "hospital",
    "host",
    "hotel",
    "hour",
    "hover",
    "hub",
    "huge",
    "human",
    "humble",
    "humor",
    "hundred",
    "hungry",
    "hunt",
    "hurdle",
    "hurry",
    "hurt",
    "husband",
    "hybrid",
    "ice",
    "icon",
    "idea",
    "identify",
    "idle",
    "ignore",
    "ill",
    "illegal",
    "illness",
    "image",
    "imitate",
    "immense",
    "immune",
    "impact",
    "impose",
    "improve",
    "impulse",
    "inch",
    "include",
    "income",
    "increase",
    "index",
    "indicate",
    "indoor",
    "industry",
    "infant",
    "inflict",
    "inform",
    "inhale",
    "inherit",
    "initial",
    "inject",
    "injury",
    "inmate",
    "inner",
    "innocent",
    "input",
    "inquiry",
    "insane",
    "insect",
    "inside",
    "inspire",
    "install",
    "intact",
    "interest",
    "into",
    "invest",
    "invite",
    "involve",
    "iron",
    "island",
    "isolate",
    "issue",
    "item",
    "ivory",
    "jacket",
    "jaguar",
    "jar",
    "jazz",
    "jealous",
    "jeans",
    "jelly",
    "jewel",
    "job",
    "join",
    "joke",
    "journey",
    "joy",
    "judge",
    "juice",
    "jump",
    "jungle",
    "junior",
    "junk",
    "just",
    "kangaroo",
    "keen",
    "keep",
    "ketchup",
    "key",
    "kick",
    "kid",
    "kidney",
    "kind",
    "kingdom",
    "kiss",
    "kit",
    "kitchen",
    "kite",
    "kitten",
    "kiwi",
    "knee",
    "knife",
    "knock",
    "know",
    "lab",
    "label",
    "labor",
    "ladder",
    "lady",
    "lake",
    "lamp",
    "language",
    "laptop",
    "large",
    "later",
    "latin",
    "laugh",
    "laundry",
    "lava",
    "law",
    "lawn",
    "lawsuit",
    "layer",
    "lazy",
    "leader",
    "leaf",
    "learn",
    "leave",
    "lecture",
    "left",
    "leg",
    "legal",
    "legend",
    "leisure",
    "lemon",
    "lend",
    "length",
    "lens",
    "leopard",
    "lesson",
    "letter",
    "level",
    "liar",
    "liberty",
    "library",
    "license",
    "life",
    "lift",
    "light",
    "like",
    "limb",
    "limit",
    "link",
    "lion",
    "liquid",
    "list",
    "little",
    "live",
    "lizard",
    "load",
    "loan",
    "lobster",
    "local",
    "lock",
    "logic",
    "lonely",
    "long",
    "loop",
    "lottery",
    "loud",
    "lounge",
    "love",
    "loyal",
    "lucky",
    "luggage",
    "lumber",
    "lunar",
    "lunch",
    "luxury",
    "lyrics",
    "machine",
    "mad",
    "magic",
    "magnet",
    "maid",
    "mail",
    "main",
    "major",
    "make",
    "mammal",
    "man",
    "manage",
    "mandate",
    "mango",
    "mansion",
    "manual",
    "maple",
    "marble",
    "march",
    "margin",
    "marine",
    "market",
    "marriage",
    "mask",
    "mass",
    "master",
    "match",
    "material",
    "math",
    "matrix",
    "matter",
    "maximum",
    "maze",
    "meadow",
    "mean",
    "measure",
    "meat",
    "mechanic",
    "medal",
    "media",
    "melody",
    "melt",
    "member",
    "memory",
    "mention",
    "menu",
    "mercy",
    "merge",
    "merit",
    "merry",
    "mesh",
    "message",
    "metal",
    "method",
    "middle",
    "midnight",
    "milk",
    "million",
    "mimic",
    "mind",
    "minimum",
    "minor",
    "minute",
    "miracle",
    "mirror",
    "misery",
    "miss",
    "mistake",
    "mix",
    "mixed",
    "mixture",
    "mobile",
    "model",
    "modify",
    "mom",
    "moment",
    "monitor",
    "monkey",
    "monster",
    "month",
    "moon",
    "moral",
    "more",
    "morning",
    "mosquito",
    "mother",
    "motion",
    "motor",
    "mountain",
    "mouse",
    "move",
    "movie",
    "much",
    "muffin",
    "mule",
    "multiply",
    "muscle",
    "museum",
    "mushroom",
    "music",
    "must",
    "mutual",
    "myself",
    "mystery",
    "myth",
    "naive",
    "name",
    "napkin",
    "narrow",
    "nasty",
    "nation",
    "nature",
    "near",
    "neck",
    "need",
    "negative",
    "neglect",
    "neither",
    "nephew",
    "nerve",
    "nest",
    "net",
    "network",
    "neutral",
    "never",
    "news",
    "next",
    "nice",
    "night",
    "noble",
    "noise",
    "nominee",
    "noodle",
    "normal",
    "north",
    "nose",
    "notable",
    "note",
    "nothing",
    "notice",
    "novel",
    "now",
    "nuclear",
    "number",
    "nurse",
    "nut",
    "oak",
    "obey",
    "object",
    "oblige",
    "obscure",
    "observe",
    "obtain",
    "obvious",
    "occur",
    "ocean",
    "october",
    "odor",
    "off",
    "offer",
    "office",
    "often",
    "oil",
    "okay",
    "old",
    "olive",
    "olympic",
    "omit",
    "once",
    "one",
    "onion",
    "online",
    "only",
    "open",
    "opera",
    "opinion",
    "oppose",
    "option",
    "orange",
    "orbit",
    "orchard",
    "order",
    "ordinary",
    "organ",
    "orient",
    "original",
    "orphan",
    "ostrich",
    "other",
    "outdoor",
    "outer",
    "output",
    "outside",
    "oval",
    "oven",
    "over",
    "own",
    "owner",
    "oxygen",
    "oyster",
    "ozone",
    "pact",
    "paddle",
    "page",
    "pair",
    "palace",
    "palm",
    "panda",
    "panel",
    "panic",
    "panther",
    "paper",
    "parade",
    "parent",
    "park",
    "parrot",
    "party",
    "pass",
    "patch",
    "path",
    "patient",
    "patrol",
    "pattern",
    "pause",
    "pave",
    "payment",
    "peace",
    "peanut",
    "pear",
    "peasant",
    "pelican",
    "pen",
    "penalty",
    "pencil",
    "people",
    "pepper",
    "perfect",
    "permit",
    "person",
    "pet",
    "phone",
    "photo",
    "phrase",
    "physical",
    "piano",
    "picnic",
    "picture",
    "piece",
    "pig",
    "pigeon",
    "pill",
    "pilot",
    "pink",
    "pioneer",
    "pipe",
    "pistol",
    "pitch",
    "pizza",
    "place",
    "planet",
    "plastic",
    "plate",
    "play",
    "please",
    "pledge",
    "pluck",
    "plug",
    "plunge",
    "poem",
    "poet",
    "point",
    "polar",
    "pole",
    "police",
    "pond",
    "pony",
    "pool",
    "popular",
    "portion",
    "position",
    "possible",
    "post",
    "potato",
    "pottery",
    "poverty",
    "powder",
    "power",
    "practice",
    "praise",
    "predict",
    "prefer",
    "prepare",
    "present",
    "pretty",
    "prevent",
    "price",
    "pride",
    "primary",
    "print",
    "priority",
    "prison",
    "private",
    "prize",
    "problem",
    "process",
    "produce",
    "profit",
    "program",
    "project",
    "promote",
    "proof",
    "property",
    "prosper",
    "protect",
    "proud",
    "provide",
    "public",
    "pudding",
    "pull",
    "pulp",
    "pulse",
    "pumpkin",
    "punch",
    "pupil",
    "puppy",
    "purchase",
    "purity",
    "purpose",
    "purse",
    "push",
    "put",
    "puzzle",
    "pyramid",
    "quality",
    "quantum",
    "quarter",
    "question",
    "quick",
    "quit",
    "quiz",
    "quote",
    "rabbit",
    "raccoon",
    "race",
    "rack",
    "radar",
    "radio",
    "rail",
    "rain",
    "raise",
    "rally",
    "ramp",
    "ranch",
    "random",
    "range",
    "rapid",
    "rare",
    "rate",
    "rather",
    "raven",
    "raw",
    "razor",
    "ready",
    "real",
    "reason",
    "rebel",
    "rebuild",
    "recall",
    "receive",
    "recipe",
    "record",
    "recycle",
    "reduce",
    "reflect",
    "reform",
    "refuse",
    "region",
    "regret",
    "regular",
    "reject",
    "relax",
    "release",
    "relief",
    "rely",
    "remain",
    "remember",
    "remind",
    "remove",
    "render",
    "renew",
    "rent",
    "reopen",
    "repair",
    "repeat",
    "replace",
    "report",
    "require",
    "rescue",
    "resemble",
    "resist",
    "resource",
    "response",
    "result",
    "retire",
    "retreat",
    "return",
    "reunion",
    "reveal",
    "review",
    "reward",
    "rhythm",
    "rib",
    "ribbon",
    "rice",
    "rich",
    "ride",
    "ridge",
    "rifle",
    "right",
    "rigid",
    "ring",
    "riot",
    "ripple",
    "risk",
    "ritual",
    "rival",
    "river",
    "road",
    "roast",
    "robot",
    "robust",
    "rocket",
    "romance",
    "roof",
    "rookie",
    "room",
    "rose",
    "rotate",
    "rough",
    "round",
    "route",
    "royal",
    "rubber",
    "rude",
    "rug",
    "rule",
    "run",
    "runway",
    "rural",
    "sad",
    "saddle",
    "sadness",
    "safe",
    "sail",
    "salad",
    "salmon",
    "salon",
    "salt",
    "salute",
    "same",
    "sample",
    "sand",
    "satisfy",
    "satoshi",
    "sauce",
    "sausage",
    "save",
    "say",
    "scale",
    "scan",
    "scare",
    "scatter",
    "scene",
    "scheme",
    "school",
    "science",
    "scissors",
    "scorpion",
    "scout",
    "scrap",
    "screen",
    "script",
    "scrub",
    "sea",
    "search",
    "season",
    "seat",
    "second",
    "secret",
    "section",
    "security",
    "seed",
    "seek",
    "segment",
    "select",
    "sell",
    "seminar",
    "senior",
    "sense",
    "sentence",
    "series",
    "service",
    "session",
    "settle",
    "setup",
    "seven",
    "shadow",
    "shaft",
    "shallow",
    "share",
    "shed",
    "shell",
    "sheriff",
    "shield",
    "shift",
    "shine",
    "ship",
    "shiver",
    "shock",
    "shoe",
    "shoot",
    "shop",
    "short",
    "shoulder",
    "shove",
    "shrimp",
    "shrug",
    "shuffle",
    "shy",
    "sibling",
    "sick",
    "side",
    "siege",
    "sight",
    "sign",
    "silent",
    "silk",
    "silly",
    "silver",
    "similar",
    "simple",
    "since",
    "sing",
    "siren",
    "sister",
    "situate",
    "six",
    "size",
    "skate",
    "sketch",
    "ski",
    "skill",
    "skin",
    "skirt",
    "skull",
    "slab",
    "slam",
    "sleep",
    "slender",
    "slice",
    "slide",
    "slight",
    "slim",
    "slogan",
    "slot",
    "slow",
    "slush",
    "small",
    "smart",
    "smile",
    "smoke",
    "smooth",
    "snack",
    "snake",
    "snap",
    "sniff",
    "snow",
    "soap",
    "soccer",
    "social",
    "sock",
    "soda",
    "soft",
    "solar",
    "soldier",
    "solid",
    "solution",
    "solve",
    "someone",
    "song",
    "soon",
    "sorry",
    "sort",
    "soul",
    "sound",
    "soup",
    "source",
    "south",
    "space",
    "spare",
    "spatial",
    "spawn",
    "speak",
    "special",
    "speed",
    "spell",
    "spend",
    "sphere",
    "spice",
    "spider",
    "spike",
    "spin",
    "spirit",
    "split",
    "spoil",
    "sponsor",
    "spoon",
    "sport",
    "spot",
    "spray",
    "spread",
    "spring",
    "spy",
    "square",
    "squeeze",
    "squirrel",
    "stable",
    "stadium",
    "staff",
    "stage",
    "stairs",
    "stamp",
    "stand",
    "start",
    "state",
    "stay",
    "steak",
    "steel",
    "stem",
    "step",
    "stereo",
    "stick",
    "still",
    "sting",
    "stock",
    "stomach",
    "stone",
    "stool",
    "story",
    "stove",
    "strategy",
    "street",
    "strike",
    "strong",
    "struggle",
    "student",
    "stuff",
    "stumble",
    "style",
    "subject",
    "submit",
    "subway",
    "success",
    "such",
    "sudden",
    "suffer",
    "sugar",
    "suggest",
    "suit",
    "summer",
    "sun",
    "sunny",
    "sunset",
    "super",
    "supply",
    "supreme",
    "sure",
    "surface",
    "surge",
    "surprise",
    "surround",
    "survey",
    "suspect",
    "sustain",
    "swallow",
    "swamp",
    "swap",
    "swarm",
    "swear",
    "sweet",
    "swift",
    "swim",
    "swing",
    "switch",
    "sword",
    "symbol",
    "symptom",
    "syrup",
    "system",
    "table",
    "tackle",
    "tag",
    "tail",
    "talent",
    "talk",
    "tank",
    "tape",
    "target",
    "task",
    "taste",
    "tattoo",
    "taxi",
    "teach",
    "team",
    "tell",
    "ten",
    "tenant",
    "tennis",
    "tent",
    "term",
    "test",
    "text",
    "thank",
    "that",
    "theme",
    "then",
    "theory",
    "there",
    "they",
    "thing",
    "this",
    "thought",
    "three",
    "thrive",
    "throw",
    "thumb",
    "thunder",
    "ticket",
    "tide",
    "tiger",
    "tilt",
    "timber",
    "time",
    "tiny",
    "tip",
    "tired",
    "tissue",
    "title",
    "toast",
    "tobacco",
    "today",
    "toddler",
    "toe",
    "together",
    "toilet",
    "token",
    "tomato",
    "tomorrow",
    "tone",
    "tongue",
    "tonight",
    "tool",
    "tooth",
    "top",
    "topic",
    "topple",
    "torch",
    "tornado",
    "tortoise",
    "toss",
    "total",
    "tourist",
    "toward",
    "tower",
    "town",
    "toy",
    "track",
    "trade",
    "traffic",
    "tragic",
    "train",
    "transfer",
    "trap",
    "trash",
    "travel",
    "tray",
    "treat",
    "tree",
    "trend",
    "trial",
    "tribe",
    "trick",
    "trigger",
    "trim",
    "trip",
    "trophy",
    "trouble",
    "truck",
    "true",
    "truly",
    "trumpet",
    "trust",
    "truth",
    "try",
    "tube",
    "tuition",
    "tumble",
    "tuna",
    "tunnel",
    "turkey",
    "turn",
    "turtle",
    "twelve",
    "twenty",
    "twice",
    "twin",
    "twist",
    "two",
    "type",
    "typical",
    "ugly",
    "umbrella",
    "unable",
    "unaware",
    "uncle",
    "uncover",
    "under",
    "undo",
    "unfair",
    "unfold",
    "unhappy",
    "uniform",
    "unique",
    "unit",
    "universe",
    "unknown",
    "unlock",
    "until",
    "unusual",
    "unveil",
    "update",
    "upgrade",
    "uphold",
    "upon",
    "upper",
    "upset",
    "urban",
    "urge",
    "usage",
    "use",
    "used",
    "useful",
    "useless",
    "usual",
    "utility",
    "vacant",
    "vacuum",
    "vague",
    "valid",
    "valley",
    "valve",
    "van",
    "vanish",
    "vapor",
    "various",
    "vast",
    "vault",
    "vehicle",
    "velvet",
    "vendor",
    "venture",
    "venue",
    "verb",
    "verify",
    "version",
    "very",
    "vessel",
    "veteran",
    "viable",
    "vibrant",
    "vicious",
    "victory",
    "video",
    "view",
    "village",
    "vintage",
    "violin",
    "virtual",
    "virus",
    "visa",
    "visit",
    "visual",
    "vital",
    "vivid",
    "vocal",
    "voice",
    "void",
    "volcano",
    "volume",
    "vote",
    "voyage",
    "wage",
    "wagon",
    "wait",
    "walk",
    "wall",
    "walnut",
    "want",
    "warfare",
    "warm",
    "warrior",
    "wash",
    "wasp",
    "waste",
    "water",
    "wave",
    "way",
    "wealth",
    "weapon",
    "wear",
    "weasel",
    "weather",
    "web",
    "wedding",
    "weekend",
    "weird",
    "welcome",
    "west",
    "wet",
    "whale",
    "what",
    "wheat",
    "wheel",
    "when",
    "where",
    "whip",
    "whisper",
    "wide",
    "width",
    "wife",
    "wild",
    "will",
    "win",
    "window",
    "wine",
    "wing",
    "wink",
    "winner",
    "winter",
    "wire",
    "wisdom",
    "wise",
    "wish",
    "witness",
    "wolf",
    "woman",
    "wonder",
    "wood",
    "wool",
    "word",
    "work",
    "world",
    "worry",
    "worth",
    "wrap",
    "wreck",
    "wrestle",
    "wrist",
    "write",
    "wrong",
    "yard",
    "year",
    "yellow",
    "you",
    "young",
    "youth",
    "zebra",
    "zero",
    "zone",
    "zoo"
  ];

  // ../mnemonic/dist/index.mjs
  function toUtf8Bytes2(stri) {
    const str = stri.normalize("NFKD");
    const result = [];
    for (let i = 0; i < str.length; i += 1) {
      const c = str.charCodeAt(i);
      if (c < 128) {
        result.push(c);
      } else if (c < 2048) {
        result.push(c >> 6 | 192);
        result.push(c & 63 | 128);
      } else if ((c & 64512) === 55296) {
        i += 1;
        const c2 = str.charCodeAt(i);
        if (i >= str.length || (c2 & 64512) !== 56320) {
          throw new FuelError(
            ErrorCode.INVALID_INPUT_PARAMETERS,
            "Invalid UTF-8 in the input string."
          );
        }
        const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
        result.push(pair >> 18 | 240);
        result.push(pair >> 12 & 63 | 128);
        result.push(pair >> 6 & 63 | 128);
        result.push(pair & 63 | 128);
      } else {
        result.push(c >> 12 | 224);
        result.push(c >> 6 & 63 | 128);
        result.push(c & 63 | 128);
      }
    }
    return Uint8Array.from(result);
  }
  function getLowerMask(bits) {
    return (1 << bits) - 1;
  }
  function getUpperMask(bits) {
    return (1 << bits) - 1 << 8 - bits;
  }
  function getWords(mnemonic) {
    if (!Array.isArray(mnemonic)) {
      return mnemonic.split(/\s+/);
    }
    return mnemonic;
  }
  function getPhrase(mnemonic) {
    if (Array.isArray(mnemonic)) {
      return mnemonic.join(" ");
    }
    return mnemonic;
  }
  function entropyToMnemonicIndices(entropy) {
    const indices = [0];
    let remainingBits = 11;
    for (let i = 0; i < entropy.length; i += 1) {
      if (remainingBits > 8) {
        indices[indices.length - 1] <<= 8;
        indices[indices.length - 1] |= entropy[i];
        remainingBits -= 8;
      } else {
        indices[indices.length - 1] <<= remainingBits;
        indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
        indices.push(entropy[i] & getLowerMask(8 - remainingBits));
        remainingBits += 3;
      }
    }
    const checksumBits = entropy.length / 4;
    const checksum = getBytesCopy(sha256(entropy))[0] & getUpperMask(checksumBits);
    indices[indices.length - 1] <<= checksumBits;
    indices[indices.length - 1] |= checksum >> 8 - checksumBits;
    return indices;
  }
  function mnemonicWordsToEntropy(words, wordlist) {
    const size = Math.ceil(11 * words.length / 8);
    const entropy = getBytesCopy(new Uint8Array(size));
    let offset = 0;
    for (let i = 0; i < words.length; i += 1) {
      const index = wordlist.indexOf(words[i].normalize("NFKD"));
      if (index === -1) {
        throw new FuelError(
          ErrorCode.INVALID_MNEMONIC,
          `Invalid mnemonic: the word '${words[i]}' is not found in the provided wordlist.`
        );
      }
      for (let bit = 0; bit < 11; bit += 1) {
        if (index & 1 << 10 - bit) {
          entropy[offset >> 3] |= 1 << 7 - offset % 8;
        }
        offset += 1;
      }
    }
    const entropyBits = 32 * words.length / 3;
    const checksumBits = words.length / 3;
    const checksumMask = getUpperMask(checksumBits);
    const checksum = getBytesCopy(sha256(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
      throw new FuelError(
        ErrorCode.INVALID_CHECKSUM,
        "Checksum validation failed for the provided mnemonic."
      );
    }
    return entropy.slice(0, entropyBits / 8);
  }
  var MasterSecret = toUtf8Bytes2("Bitcoin seed");
  var MainnetPRV = "0x0488ade4";
  var TestnetPRV = "0x04358394";
  var MNEMONIC_SIZES = [12, 15, 18, 21, 24];
  function assertWordList(wordlist) {
    if (wordlist.length !== 2048) {
      throw new FuelError(
        ErrorCode.INVALID_WORD_LIST,
        `Expected word list length of 2048, but got ${wordlist.length}.`
      );
    }
  }
  function assertEntropy(entropy) {
    if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
      throw new FuelError(
        ErrorCode.INVALID_ENTROPY,
        `Entropy should be between 16 and 32 bytes and a multiple of 4, but got ${entropy.length} bytes.`
      );
    }
  }
  function assertMnemonic(words) {
    if (!MNEMONIC_SIZES.includes(words.length)) {
      const errorMsg = `Invalid mnemonic size. Expected one of [${MNEMONIC_SIZES.join(
        ", "
      )}] words, but got ${words.length}.`;
      throw new FuelError(ErrorCode.INVALID_MNEMONIC, errorMsg);
    }
  }
  var Mnemonic = class {
    wordlist;
    /**
     *
     * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.
     * @returns Mnemonic instance
     */
    constructor(wordlist = english) {
      this.wordlist = wordlist;
      assertWordList(this.wordlist);
    }
    /**
     *
     * @param phrase - Mnemonic phrase composed by words from the provided wordlist
     * @returns Entropy hash
     */
    mnemonicToEntropy(phrase) {
      return Mnemonic.mnemonicToEntropy(phrase, this.wordlist);
    }
    /**
     *
     * @param entropy - Entropy source to the mnemonic phrase.
     * @returns Mnemonic phrase
     */
    entropyToMnemonic(entropy) {
      return Mnemonic.entropyToMnemonic(entropy, this.wordlist);
    }
    /**
     *
     * @param phrase - Mnemonic phrase composed by words from the provided wordlist
     * @param wordlist - Provide a wordlist with the list of words used to generate the mnemonic phrase. The default value is the English list.
     * @returns Mnemonic phrase
     */
    static mnemonicToEntropy(phrase, wordlist = english) {
      const words = getWords(phrase);
      assertMnemonic(words);
      return hexlify(mnemonicWordsToEntropy(words, wordlist));
    }
    /**
     * @param entropy - Entropy source to the mnemonic phrase.
     * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
     * @returns 64-byte array contains privateKey and chainCode as described on BIP39
     */
    static entropyToMnemonic(entropy, wordlist = english) {
      const entropyBytes = getBytesCopy(entropy);
      assertWordList(wordlist);
      assertEntropy(entropyBytes);
      return entropyToMnemonicIndices(entropyBytes).map((i) => wordlist[i]).join(" ");
    }
    /**
     * @param phrase - Mnemonic phrase composed by words from the provided wordlist
     * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`
     * @returns 64-byte array contains privateKey and chainCode as described on BIP39
     */
    static mnemonicToSeed(phrase, passphrase = "") {
      assertMnemonic(getWords(phrase));
      const phraseBytes = toUtf8Bytes2(getPhrase(phrase));
      const salt = toUtf8Bytes2(`mnemonic${passphrase}`);
      return pbkdf2(phraseBytes, salt, 2048, 64, "sha512");
    }
    /**
     * @param phrase - Mnemonic phrase composed by words from the provided wordlist
     * @param passphrase - Add additional security to protect the generated seed with a memorized passphrase. `Note: if the owner forgot the passphrase, all wallets and accounts derive from the phrase will be lost.`
     * @returns 64-byte array contains privateKey and chainCode as described on BIP39
     */
    static mnemonicToMasterKeys(phrase, passphrase = "") {
      const seed = Mnemonic.mnemonicToSeed(phrase, passphrase);
      return Mnemonic.masterKeysFromSeed(seed);
    }
    /**
     * Validates if given mnemonic is  valid
     * @param phrase - Mnemonic phrase composed by words from the provided wordlist
     * @returns true if phrase is a valid mnemonic
     */
    static isMnemonicValid(phrase) {
      const words = getWords(phrase);
      let i = 0;
      try {
        assertMnemonic(words);
      } catch {
        return false;
      }
      while (i < words.length) {
        if (Mnemonic.binarySearch(words[i]) === false) {
          return false;
        }
        i += 1;
      }
      return true;
    }
    static binarySearch(target) {
      const words = english;
      let left = 0;
      let right = words.length - 1;
      while (left <= right) {
        const mid = Math.floor((left + right) / 2);
        if (words[mid] === target) {
          return true;
        }
        if (target < words[mid]) {
          right = mid - 1;
        } else {
          left = mid + 1;
        }
      }
      return false;
    }
    /**
     * @param seed - BIP39 seed
     * @param testnet - Inform if should use testnet or mainnet prefix, the default value is true (`mainnet`).
     * @returns 64-byte array contains privateKey and chainCode as described on BIP39
     */
    static masterKeysFromSeed(seed) {
      const seedArray = getBytesCopy(seed);
      if (seedArray.length < 16 || seedArray.length > 64) {
        throw new FuelError(
          ErrorCode.INVALID_SEED,
          `Seed length should be between 16 and 64 bytes, but received ${seedArray.length} bytes.`
        );
      }
      return getBytesCopy(computeHmac("sha512", MasterSecret, seedArray));
    }
    /**
     * Get the extendKey as defined on BIP-32 from the provided seed
     *
     * @param seed - BIP39 seed
     * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
     * @returns BIP-32 extended private key
     */
    static seedToExtendedKey(seed, testnet = false) {
      const masterKey = Mnemonic.masterKeysFromSeed(seed);
      const prefix = getBytesCopy(testnet ? TestnetPRV : MainnetPRV);
      const depth = "0x00";
      const fingerprint = "0x00000000";
      const index = "0x00000000";
      const chainCode = masterKey.slice(32);
      const privateKey = masterKey.slice(0, 32);
      const extendedKey = concat([
        prefix,
        depth,
        fingerprint,
        index,
        chainCode,
        concat(["0x00", privateKey])
      ]);
      const checksum = dataSlice(sha256(sha256(extendedKey)), 0, 4);
      return encodeBase58(concat([extendedKey, checksum]));
    }
    /**
     *  Create a new mnemonic using a randomly generated number as entropy.
     *  As defined in BIP39, the entropy must be a multiple of 32 bits, and its size must be between 128 and 256 bits.
     *  Therefore, the possible values for `strength` are 128, 160, 192, 224, and 256.
     *  If not provided, the default entropy length will be set to 256 bits.
     *  The return is a list of words that encodes the generated entropy.
     *
     *
     * @param size - Number of bytes used as an entropy
     * @param extraEntropy - Optional extra entropy to increase randomness
     * @returns A randomly generated mnemonic
     */
    static generate(size = 32, extraEntropy = "") {
      const entropy = extraEntropy ? sha256(concat([randomBytes22(size), getBytesCopy(extraEntropy)])) : randomBytes22(size);
      return Mnemonic.entropyToMnemonic(entropy);
    }
  };
  var mnemonic_default = Mnemonic;

  // ../hdwallet/dist/index.mjs
  var HARDENED_INDEX = 2147483648;
  var MainnetPRV2 = hexlify("0x0488ade4");
  var MainnetPUB = hexlify("0x0488b21e");
  var TestnetPRV2 = hexlify("0x04358394");
  var TestnetPUB = hexlify("0x043587cf");
  function base58check(data) {
    return encodeBase58(concat([data, dataSlice(sha256(sha256(data)), 0, 4)]));
  }
  function getExtendedKeyPrefix(isPublic = false, testnet = false) {
    if (isPublic) {
      return testnet ? TestnetPUB : MainnetPUB;
    }
    return testnet ? TestnetPRV2 : MainnetPRV2;
  }
  function isPublicExtendedKey(extendedKey) {
    return [MainnetPUB, TestnetPUB].includes(hexlify(extendedKey.slice(0, 4)));
  }
  function isValidExtendedKey(extendedKey) {
    return [MainnetPRV2, TestnetPRV2, MainnetPUB, TestnetPUB].includes(
      hexlify(extendedKey.slice(0, 4))
    );
  }
  function parsePath(path4, depth = 0) {
    const components = path4.split("/");
    if (components.length === 0 || components[0] === "m" && depth !== 0) {
      throw new FuelError(ErrorCode.HD_WALLET_ERROR, `invalid path - ${path4}`);
    }
    if (components[0] === "m") {
      components.shift();
    }
    return components.map(
      (p) => ~p.indexOf(`'`) ? parseInt(p, 10) + HARDENED_INDEX : parseInt(p, 10)
    );
  }
  var HDWallet = class {
    depth = 0;
    index = 0;
    fingerprint = hexlify("0x00000000");
    parentFingerprint = hexlify("0x00000000");
    privateKey;
    publicKey;
    chainCode;
    /**
     * HDWallet is a implementation of the BIP-0044 and BIP-0032, Multi-Account Hierarchy for Deterministic Wallets
     *
     * @param config - Wallet configurations
     */
    constructor(config) {
      if (config.privateKey) {
        const signer = new signer_default(config.privateKey);
        this.publicKey = hexlify(signer.compressedPublicKey);
        this.privateKey = hexlify(config.privateKey);
      } else {
        if (!config.publicKey) {
          throw new FuelError(
            ErrorCode.HD_WALLET_ERROR,
            "Both public and private Key cannot be missing. At least one should be provided."
          );
        }
        this.publicKey = hexlify(config.publicKey);
      }
      this.parentFingerprint = config.parentFingerprint || this.parentFingerprint;
      this.fingerprint = dataSlice(ripemd1602(sha256(this.publicKey)), 0, 4);
      this.depth = config.depth || this.depth;
      this.index = config.index || this.index;
      this.chainCode = config.chainCode;
    }
    get extendedKey() {
      return this.toExtendedKey();
    }
    /**
     * Derive the current HDWallet instance navigating only on the index.
     * `Ex.: m/44'/0 -> Ex.: m/44'/1 -> m/44'/2`. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
     *
     * @param index - Index of the child HDWallet.
     * @returns A new instance of HDWallet on the derived index
     */
    deriveIndex(index) {
      const privateKey = this.privateKey && getBytesCopy(this.privateKey);
      const publicKey = getBytesCopy(this.publicKey);
      const chainCode = getBytesCopy(this.chainCode);
      const data = new Uint8Array(37);
      if (index & HARDENED_INDEX) {
        if (!privateKey) {
          throw new FuelError(
            ErrorCode.HD_WALLET_ERROR,
            "Cannot derive a hardened index without a private Key."
          );
        }
        data.set(privateKey, 1);
      } else {
        data.set(getBytesCopy(this.publicKey));
      }
      data.set(toBytes2(index, 4), 33);
      const bytes3 = getBytesCopy(computeHmac("sha512", chainCode, data));
      const IL = bytes3.slice(0, 32);
      const IR = bytes3.slice(32);
      if (privateKey) {
        const N = "0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141";
        const ki = bn(IL).add(privateKey).mod(N).toBytes(32);
        return new HDWallet({
          privateKey: ki,
          chainCode: IR,
          index,
          depth: this.depth + 1,
          parentFingerprint: this.fingerprint
        });
      }
      const signer = new signer_default(hexlify(IL));
      const Ki = signer.addPoint(publicKey);
      return new HDWallet({
        publicKey: Ki,
        chainCode: IR,
        index,
        depth: this.depth + 1,
        parentFingerprint: this.fingerprint
      });
    }
    /**
     * Derive the current HDWallet instance to the path. [Learn more](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki)
     *
     * @param path - The string representation of the child HDWallet. `Ex.: m/44'/0'/0'/0/0`
     * @returns A new instance of HDWallet on the derived path
     */
    derivePath(path4) {
      const paths = parsePath(path4, this.depth);
      return paths.reduce((hdwallet, index) => hdwallet.deriveIndex(index), this);
    }
    /**
     * Get the extendKey as defined on BIP-32 from the provided seed
     *
     * @param isPublic - enable to export public extendedKey, it not required when HDWallet didn't have the privateKey.
     * @param testnet - Inform if should use testnet or mainnet prefix, default value is true (`mainnet`).
     * @returns BIP-32 extended private key
     */
    toExtendedKey(isPublic = false, testnet = false) {
      if (this.depth >= 256) {
        throw new FuelError(
          ErrorCode.HD_WALLET_ERROR,
          `Exceeded max depth of 255. Current depth: ${this.depth}.`
        );
      }
      const prefix = getExtendedKeyPrefix(this.privateKey == null || isPublic, testnet);
      const depth = hexlify(Uint8Array.from([this.depth]));
      const parentFingerprint = this.parentFingerprint;
      const index = toHex(this.index, 4);
      const chainCode = this.chainCode;
      const key = this.privateKey != null && !isPublic ? concat(["0x00", this.privateKey]) : this.publicKey;
      const extendedKey = getBytesCopy(
        concat([prefix, depth, parentFingerprint, index, chainCode, key])
      );
      return base58check(extendedKey);
    }
    /**
     * Create HDWallet instance from seed
     *
     * @param seed - Seed
     * @returns A new instance of HDWallet
     */
    static fromSeed(seed) {
      const masterKey = mnemonic_default.masterKeysFromSeed(seed);
      return new HDWallet({
        chainCode: getBytesCopy(masterKey.slice(32)),
        privateKey: getBytesCopy(masterKey.slice(0, 32))
      });
    }
    static fromExtendedKey(extendedKey) {
      const decoded = toBeHex(decodeBase58(extendedKey));
      const bytes3 = getBytesCopy(decoded);
      const validChecksum = base58check(bytes3.slice(0, 78)) === extendedKey;
      if (bytes3.length !== 82 || !isValidExtendedKey(bytes3)) {
        throw new FuelError(ErrorCode.HD_WALLET_ERROR, "Provided key is not a valid extended key.");
      }
      if (!validChecksum) {
        throw new FuelError(ErrorCode.HD_WALLET_ERROR, "Provided key has an invalid checksum.");
      }
      const depth = bytes3[4];
      const parentFingerprint = hexlify(bytes3.slice(5, 9));
      const index = parseInt(hexlify(bytes3.slice(9, 13)).substring(2), 16);
      const chainCode = hexlify(bytes3.slice(13, 45));
      const key = bytes3.slice(45, 78);
      if (depth === 0 && parentFingerprint !== "0x00000000" || depth === 0 && index !== 0) {
        throw new FuelError(
          ErrorCode.HD_WALLET_ERROR,
          "Inconsistency detected: Depth is zero but fingerprint/index is non-zero."
        );
      }
      if (isPublicExtendedKey(bytes3)) {
        if (key[0] !== 3) {
          throw new FuelError(ErrorCode.HD_WALLET_ERROR, "Invalid public extended key.");
        }
        return new HDWallet({
          publicKey: key,
          chainCode,
          index,
          depth,
          parentFingerprint
        });
      }
      if (key[0] !== 0) {
        throw new FuelError(ErrorCode.HD_WALLET_ERROR, "Invalid private extended key.");
      }
      return new HDWallet({
        privateKey: key.slice(1),
        chainCode,
        index,
        depth,
        parentFingerprint
      });
    }
  };
  var hdwallet_default = HDWallet;

  // ../wallet/dist/index.mjs
  var __defProp7 = Object.defineProperty;
  var __defNormalProp7 = (obj, key, value) => key in obj ? __defProp7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField7 = (obj, key, value) => {
    __defNormalProp7(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var composeScriptForTransferringToContract = async () => {
    await asm.initWasm();
    const gtf2 = asm.gtf(16, 0, asm.GTFArgs.ScriptData);
    const addi2 = asm.addi(17, 16, 32);
    const lw22 = asm.lw(18, 17, 0);
    const addi22 = asm.addi(19, 17, 8);
    const tr2 = asm.tr(16, 18, 19);
    const ret22 = asm.ret(1);
    const script = Uint8Array.from([
      ...gtf2.to_bytes(),
      ...addi2.to_bytes(),
      ...lw22.to_bytes(),
      ...addi22.to_bytes(),
      ...tr2.to_bytes(),
      ...ret22.to_bytes()
    ]);
    return script;
  };
  var formatScriptDataForTransferringToContract = (hexelifiedContractId, amountToTransfer, assetId) => {
    const numberCoder = new U64Coder();
    const encoded = numberCoder.encode(new BN(amountToTransfer).toNumber());
    const scriptData = Uint8Array.from([
      ...getBytesCopy(hexelifiedContractId),
      ...encoded,
      ...getBytesCopy(assetId)
    ]);
    return scriptData;
  };
  var Account = class extends AbstractAccount {
    /**
     * The address associated with the account.
     */
    address;
    /**
     * The provider used to interact with the network.
     */
    provider;
    /**
     * Creates a new Account instance.
     *
     * @param address - The address of the account.
     * @param provider - A Provider instance.
     */
    constructor(address, provider) {
      super();
      this.provider = provider;
      this.address = Address.fromDynamicInput(address);
    }
    /**
     * Changes the provider connection for the account.
     *
     * @param provider - A Provider instance.
     * @returns The updated Provider instance.
     */
    connect(provider) {
      this.provider = provider;
      return this.provider;
    }
    /**
     * Retrieves resources satisfying the spend query for the account.
     *
     * @param quantities - IDs of coins to exclude.
     * @param excludedIds - IDs of resources to be excluded from the query.
     * @returns A promise that resolves to an array of Resources.
     */
    async getResourcesToSpend(quantities, excludedIds) {
      return this.provider.getResourcesToSpend(this.address, quantities, excludedIds);
    }
    /**
     * Retrieves coins owned by the account.
     *
     * @param assetId - The asset ID of the coins to retrieve.
     * @returns A promise that resolves to an array of Coins.
     */
    async getCoins(assetId) {
      const coins = [];
      const pageSize = 9999;
      let cursor;
      for (; ; ) {
        const pageCoins = await this.provider.getCoins(this.address, assetId, {
          first: pageSize,
          after: cursor
        });
        coins.push(...pageCoins);
        const hasNextPage = pageCoins.length >= pageSize;
        if (!hasNextPage) {
          break;
        }
        throw new FuelError(
          ErrorCode.NOT_SUPPORTED,
          `Wallets containing more than ${pageSize} coins exceed the current supported limit.`
        );
      }
      return coins;
    }
    /**
     * Retrieves messages owned by the account.
     *
     * @returns A promise that resolves to an array of Messages.
     */
    async getMessages() {
      const messages = [];
      const pageSize = 9999;
      let cursor;
      for (; ; ) {
        const pageMessages = await this.provider.getMessages(this.address, {
          first: pageSize,
          after: cursor
        });
        messages.push(...pageMessages);
        const hasNextPage = pageMessages.length >= pageSize;
        if (!hasNextPage) {
          break;
        }
        throw new FuelError(
          ErrorCode.NOT_SUPPORTED,
          `Wallets containing more than ${pageSize} messages exceed the current supported limit.`
        );
      }
      return messages;
    }
    /**
     * Retrieves the balance of the account for the given asset.
     *
     * @param assetId - The asset ID to check the balance for.
     * @returns A promise that resolves to the balance amount.
     */
    async getBalance(assetId = BaseAssetId) {
      const amount = await this.provider.getBalance(this.address, assetId);
      return amount;
    }
    /**
     * Retrieves all the balances for the account.
     *
     * @returns A promise that resolves to an array of Coins and their quantities.
     */
    async getBalances() {
      const balances = [];
      const pageSize = 9999;
      let cursor;
      for (; ; ) {
        const pageBalances = await this.provider.getBalances(this.address, {
          first: pageSize,
          after: cursor
        });
        balances.push(...pageBalances);
        const hasNextPage = pageBalances.length >= pageSize;
        if (!hasNextPage) {
          break;
        }
        throw new FuelError(
          ErrorCode.NOT_SUPPORTED,
          `Wallets containing more than ${pageSize} balances exceed the current supported limit.`
        );
      }
      return balances;
    }
    /**
     * Adds resources to the transaction enough to fund it.
     *
     * @param request - The transaction request.
     * @returns A promise that resolves when the resources are added to the transaction.
     */
    async fund(request, quantities, fee) {
      addAmountToAsset({
        amount: fee,
        assetId: BaseAssetId,
        coinQuantities: quantities
      });
      const resources = await this.getResourcesToSpend(quantities);
      request.addResources(resources);
    }
    /**
     * Transfers coins to a destination address.
     *
     * @param destination - The address of the destination.
     * @param amount - The amount of coins to transfer.
     * @param assetId - The asset ID of the coins to transfer.
     * @param txParams - The transaction parameters (gasLimit, gasPrice, maturity).
     * @returns A promise that resolves to the transaction response.
     */
    async transfer(destination, amount, assetId = BaseAssetId, txParams = {}) {
      const request = await this.prepareTransferTxRequest(destination, amount, assetId, txParams);
      return this.sendTransaction(request);
    }
    /**
     * A helper that prepares a transaction request for calculating the transaction ID.
     *
     * @param destination - The address of the destination.
     * @param amount - The amount of coins to transfer.
     * @param assetId - The asset ID of the coins to transfer.
     * @param txParams - The transaction parameters (gasLimit, gasPrice, maturity).
     * @returns A promise that resolves to the prepared transaction request.
     */
    async prepareTransferTxRequest(destination, amount, assetId = BaseAssetId, txParams = {}) {
      const { maxGasPerTx } = this.provider.getGasConfig();
      const params = { gasLimit: maxGasPerTx, ...txParams };
      const request = new ScriptTransactionRequest(params);
      request.addCoinOutput(destination, amount, assetId);
      const { maxFee, requiredQuantities } = await this.provider.getTransactionCost(request);
      await this.fund(request, requiredQuantities, maxFee);
      return request;
    }
    /**
     * Transfers coins to a contract address.
     *
     * @param contractId - The address of the contract.
     * @param amount - The amount of coins to transfer.
     * @param assetId - The asset ID of the coins to transfer.
     * @param txParams - The optional transaction parameters.
     * @returns A promise that resolves to the transaction response.
     */
    async transferToContract(contractId, amount, assetId = BaseAssetId, txParams = {}) {
      const script = await composeScriptForTransferringToContract();
      const scriptData = formatScriptDataForTransferringToContract(
        contractId.toB256(),
        amount,
        assetId
      );
      const { maxGasPerTx } = this.provider.getGasConfig();
      const request = new ScriptTransactionRequest({
        gasLimit: maxGasPerTx,
        ...txParams,
        script,
        scriptData
      });
      request.addContractInputAndOutput(contractId);
      const { maxFee, requiredQuantities } = await this.provider.getTransactionCost(request, [
        { amount: bn(amount), assetId: String(assetId) }
      ]);
      await this.fund(request, requiredQuantities, maxFee);
      return this.sendTransaction(request);
    }
    /**
     * Withdraws an amount of the base asset to the base chain.
     *
     * @param recipient - Address of the recipient on the base chain.
     * @param amount - Amount of base asset.
     * @param txParams - The optional transaction parameters.
     * @returns A promise that resolves to the transaction response.
     */
    async withdrawToBaseLayer(recipient, amount, txParams = {}) {
      const recipientDataArray = getBytesCopy(
        "0x".concat(recipient.toHexString().substring(2).padStart(64, "0"))
      );
      const amountDataArray = getBytesCopy(
        "0x".concat(bn(amount).toHex().substring(2).padStart(16, "0"))
      );
      const script = new Uint8Array([
        ...getBytesCopy(withdrawScript.bytes),
        ...recipientDataArray,
        ...amountDataArray
      ]);
      const { maxGasPerTx } = this.provider.getGasConfig();
      const params = { script, gasLimit: maxGasPerTx, ...txParams };
      const request = new ScriptTransactionRequest(params);
      const { gasPriceFactor } = this.provider.getGasConfig();
      const fee = request.calculateFee(gasPriceFactor);
      let quantities = [];
      fee.amount = fee.amount.add(amount);
      quantities = [fee];
      const resources = await this.getResourcesToSpend(quantities);
      request.addResources(resources);
      return this.sendTransaction(request);
    }
    /**
     * Sends a transaction to the network.
     *
     * @param transactionRequestLike - The transaction request to be sent.
     * @returns A promise that resolves to the transaction response.
     */
    async sendTransaction(transactionRequestLike) {
      const transactionRequest = transactionRequestify(transactionRequestLike);
      await this.provider.estimateTxDependencies(transactionRequest);
      return this.provider.sendTransaction(transactionRequest);
    }
    /**
     * Simulates a transaction.
     *
     * @param transactionRequestLike - The transaction request to be simulated.
     * @returns A promise that resolves to the call result.
     */
    async simulateTransaction(transactionRequestLike) {
      const transactionRequest = transactionRequestify(transactionRequestLike);
      await this.provider.estimateTxDependencies(transactionRequest);
      return this.provider.simulate(transactionRequest);
    }
  };
  var DEFAULT_KDF_PARAMS_LOG_N = 13;
  var DEFAULT_KDF_PARAMS_R = 8;
  var DEFAULT_KDF_PARAMS_P = 1;
  var DEFAULT_KEY_SIZE = 32;
  var DEFAULT_IV_SIZE = 16;
  var removeHexPrefix = (hexString) => {
    if (/^0x/.test(hexString)) {
      return hexString.slice(2);
    }
    return hexString;
  };
  async function encryptKeystoreWallet(privateKey, address, password) {
    const privateKeyBuffer = bufferFromString2(removeHexPrefix(privateKey), "hex");
    const salt = randomBytes22(DEFAULT_KEY_SIZE);
    const key = scrypt22({
      password: bufferFromString2(password),
      salt,
      dklen: DEFAULT_KEY_SIZE,
      n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,
      r: DEFAULT_KDF_PARAMS_R,
      p: DEFAULT_KDF_PARAMS_P
    });
    const iv = randomBytes22(DEFAULT_IV_SIZE);
    const ciphertext = await encryptJsonWalletData2(privateKeyBuffer, key, iv);
    const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertext]);
    const macHashUint8Array = keccak25622(data);
    const mac = stringFromBuffer2(macHashUint8Array, "hex");
    const keystore = {
      id: v4_default(),
      version: 3,
      address: removeHexPrefix(address.toHexString()),
      crypto: {
        cipher: "aes-128-ctr",
        mac,
        cipherparams: { iv: stringFromBuffer2(iv, "hex") },
        ciphertext: stringFromBuffer2(ciphertext, "hex"),
        kdf: "scrypt",
        kdfparams: {
          dklen: DEFAULT_KEY_SIZE,
          n: 2 ** DEFAULT_KDF_PARAMS_LOG_N,
          p: DEFAULT_KDF_PARAMS_P,
          r: DEFAULT_KDF_PARAMS_R,
          salt: stringFromBuffer2(salt, "hex")
        }
      }
    };
    return JSON.stringify(keystore);
  }
  async function decryptKeystoreWallet(jsonWallet, password) {
    const keystoreWallet = JSON.parse(jsonWallet);
    const {
      crypto: {
        mac,
        ciphertext,
        cipherparams: { iv },
        kdfparams: { dklen, n, r, p, salt }
      }
    } = keystoreWallet;
    const ciphertextBuffer = bufferFromString2(ciphertext, "hex");
    const ivBuffer = bufferFromString2(iv, "hex");
    const saltBuffer = bufferFromString2(salt, "hex");
    const passwordBuffer = bufferFromString2(password);
    const key = scrypt22({
      password: passwordBuffer,
      salt: saltBuffer,
      n,
      p,
      r,
      dklen
    });
    const data = Uint8Array.from([...key.subarray(16, 32), ...ciphertextBuffer]);
    const macHashUint8Array = keccak25622(data);
    const macHash = stringFromBuffer2(macHashUint8Array, "hex");
    if (mac !== macHash) {
      throw new FuelError(
        ErrorCode.INVALID_PASSWORD,
        "Failed to decrypt the keystore wallet, the provided password is incorrect."
      );
    }
    const buffer = await decryptJsonWalletData2(ciphertextBuffer, key, ivBuffer);
    const privateKey = hexlify(buffer);
    return privateKey;
  }
  var BaseWalletUnlocked = class extends Account {
    /**
     * The provider used to interact with the Fuel network.
     */
    provider;
    /**
     * A function that returns the wallet's signer.
     */
    signer;
    /**
     * Creates a new BaseWalletUnlocked instance.
     *
     * @param privateKey - The private key of the wallet.
     * @param provider - A Provider instance.
     */
    constructor(privateKey, provider) {
      const signer = new signer_default(privateKey);
      super(signer.address, provider);
      this.signer = () => signer;
      this.provider = provider;
    }
    /**
     * Gets the private key of the wallet.
     *
     * @returns The private key of the wallet.
     */
    get privateKey() {
      return this.signer().privateKey;
    }
    /**
     * Gets the public key of the wallet.
     *
     * @returns
     */
    get publicKey() {
      return this.signer().publicKey;
    }
    /**
     * Signs a message with the wallet's private key.
     *
     * @param message - The message to sign.
     * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
     */
    async signMessage(message) {
      const signedMessage = await this.signer().sign(hashMessage(message));
      return signedMessage;
    }
    /**
     * Signs a transaction with the wallet's private key.
     *
     * @param transactionRequestLike - The transaction request to sign.
     * @returns A promise that resolves to the signature as a ECDSA 64 bytes string.
     */
    async signTransaction(transactionRequestLike) {
      const transactionRequest = transactionRequestify(transactionRequestLike);
      const chainId = (await this.provider.getChain()).consensusParameters.chainId.toNumber();
      const hashedTransaction = hashTransaction(transactionRequest, chainId);
      const signature = await this.signer().sign(hashedTransaction);
      return signature;
    }
    /**
     * Populates a transaction with the witnesses signature.
     *
     * @param transactionRequestLike - The transaction request to populate.
     * @returns The populated transaction request.
     */
    async populateTransactionWitnessesSignature(transactionRequestLike) {
      const transactionRequest = transactionRequestify(transactionRequestLike);
      const signedTransaction = await this.signTransaction(transactionRequest);
      transactionRequest.updateWitnessByOwner(this.address, signedTransaction);
      return transactionRequest;
    }
    /**
     * Populates the witness signature for a transaction and sends it to the network using `provider.sendTransaction`.
     *
     * @param transactionRequestLike - The transaction request to send.
     * @returns A promise that resolves to the TransactionResponse object.
     */
    async sendTransaction(transactionRequestLike) {
      const transactionRequest = transactionRequestify(transactionRequestLike);
      await this.provider.estimateTxDependencies(transactionRequest);
      return this.provider.sendTransaction(
        await this.populateTransactionWitnessesSignature(transactionRequest)
      );
    }
    /**
     * Populates the witness signature for a transaction and sends a call to the network using `provider.call`.
     *
     * @param transactionRequestLike - The transaction request to simulate.
     * @returns A promise that resolves to the CallResult object.
     */
    async simulateTransaction(transactionRequestLike) {
      const transactionRequest = transactionRequestify(transactionRequestLike);
      await this.provider.estimateTxDependencies(transactionRequest);
      return this.provider.call(
        await this.populateTransactionWitnessesSignature(transactionRequest),
        {
          utxoValidation: true
        }
      );
    }
    async encrypt(password) {
      return encryptKeystoreWallet(this.privateKey, this.address, password);
    }
  };
  __publicField7(BaseWalletUnlocked, "defaultPath", "m/44'/1179993420'/0'/0/0");
  var WalletLocked = class extends Account {
    /**
     * Unlocks the wallet using the provided private key and returns an instance of WalletUnlocked.
     *
     * @param privateKey - The private key used to unlock the wallet.
     * @returns An instance of WalletUnlocked.
     */
    unlock(privateKey) {
      return new WalletUnlocked(privateKey, this.provider);
    }
  };
  var WalletUnlocked = class extends BaseWalletUnlocked {
    /**
     * Locks the wallet and returns an instance of WalletLocked.
     *
     * @returns An instance of WalletLocked.
     */
    lock() {
      this.signer = () => new signer_default("0x00");
      return new WalletLocked(this.address, this.provider);
    }
    /**
     * Generate a new Wallet Unlocked with a random key pair.
     *
     * @param generateOptions - Options to customize the generation process (optional).
     * @returns An instance of WalletUnlocked.
     */
    static generate(generateOptions) {
      const privateKey = signer_default.generatePrivateKey(generateOptions?.entropy);
      return new WalletUnlocked(privateKey, generateOptions?.provider);
    }
    /**
     * Create a Wallet Unlocked from a seed.
     *
     * @param seed - The seed phrase.
     * @param provider - A Provider instance.
     * @param path - The derivation path (optional).
     * @returns An instance of WalletUnlocked.
     */
    static fromSeed(seed, provider, path4) {
      const hdWallet = hdwallet_default.fromSeed(seed);
      const childWallet = hdWallet.derivePath(path4 || WalletUnlocked.defaultPath);
      return new WalletUnlocked(childWallet.privateKey, provider);
    }
    /**
     * Create a Wallet Unlocked from a mnemonic phrase.
     *
     * @param mnemonic - The mnemonic phrase.
     * @param provider - A Provider instance.
     * @param path - The derivation path (optional).
     * @param passphrase - The passphrase for the mnemonic (optional).
     * @returns An instance of WalletUnlocked.
     */
    static fromMnemonic(mnemonic, provider, path4, passphrase) {
      const seed = mnemonic_default.mnemonicToSeed(mnemonic, passphrase);
      const hdWallet = hdwallet_default.fromSeed(seed);
      const childWallet = hdWallet.derivePath(path4 || WalletUnlocked.defaultPath);
      return new WalletUnlocked(childWallet.privateKey, provider);
    }
    /**
     * Create a Wallet Unlocked from an extended key.
     *
     * @param extendedKey - The extended key.
     * @param provider - A Provider instance.
     * @returns An instance of WalletUnlocked.
     */
    static fromExtendedKey(extendedKey, provider) {
      const hdWallet = hdwallet_default.fromExtendedKey(extendedKey);
      return new WalletUnlocked(hdWallet.privateKey, provider);
    }
    static async fromEncryptedJson(jsonWallet, password, provider) {
      const privateKey = await decryptKeystoreWallet(jsonWallet, password);
      return new WalletUnlocked(privateKey, provider);
    }
  };
  var Wallet = class {
    /**
     * Creates a locked wallet instance from an address and a provider.
     *
     * @param address - The address of the wallet.
     * @param provider - A Provider instance.
     * @returns A locked wallet instance.
     */
    static fromAddress(address, provider) {
      return new WalletLocked(address, provider);
    }
    /**
     * Creates an unlocked wallet instance from a private key and a provider.
     *
     * @param privateKey - The private key of the wallet.
     * @param provider - A Provider instance.
     * @returns An unlocked wallet instance.
     */
    static fromPrivateKey(privateKey, provider) {
      return new WalletUnlocked(privateKey, provider);
    }
  };
  __publicField7(Wallet, "generate", WalletUnlocked.generate);
  __publicField7(Wallet, "fromSeed", WalletUnlocked.fromSeed);
  __publicField7(Wallet, "fromMnemonic", WalletUnlocked.fromMnemonic);
  __publicField7(Wallet, "fromExtendedKey", WalletUnlocked.fromExtendedKey);
  __publicField7(Wallet, "fromEncryptedJson", WalletUnlocked.fromEncryptedJson);

  // src/cli/commands/deploy/createWallet.ts
  async function createWallet(providerUrl, privateKey) {
    let pvtKey;
    if (privateKey) {
      pvtKey = privateKey;
    } else if (process.env.PRIVATE_KEY) {
      pvtKey = process.env.PRIVATE_KEY;
    } else {
      throw new Error("You must provide a privateKey via config.privateKey or env PRIVATE_KEY");
    }
    const provider = await Provider.create(providerUrl);
    return Wallet.fromPrivateKey(pvtKey, provider);
  }

  // ../program/dist/index.mjs
  var asm2 = __toESM(require_node(), 1);
  var asm3 = __toESM(require_node(), 1);
  var PANIC_REASONS = [
    "Success",
    "Revert",
    "OutOfGas",
    "TransactionValidity",
    "MemoryOverflow",
    "ArithmeticOverflow",
    "ContractNotFound",
    "MemoryOwnership",
    "NotEnoughBalance",
    "ExpectedInternalContext",
    "AssetIdNotFound",
    "InputNotFound",
    "OutputNotFound",
    "WitnessNotFound",
    "TransactionMaturity",
    "InvalidMetadataIdentifier",
    "MalformedCallStructure",
    "ReservedRegisterNotWritable",
    "ErrorFlag",
    "InvalidImmediateValue",
    "ExpectedCoinInput",
    "MaxMemoryAccess",
    "MemoryWriteOverlap",
    "ContractNotInInputs",
    "InternalBalanceOverflow",
    "ContractMaxSize",
    "ExpectedUnallocatedStack",
    "MaxStaticContractsReached",
    "TransferAmountCannotBeZero",
    "ExpectedOutputVariable",
    "ExpectedParentInternalContext",
    "IllegalJump",
    "NonZeroMessageOutputRecipient",
    "ZeroedMessageOutputRecipient"
  ];
  var PANIC_DOC_URL = "https://docs.rs/fuel-asm/latest/fuel_asm/enum.PanicReason.html";
  var getFailureReason = (reason) => {
    if (PANIC_REASONS.includes(reason)) {
      return reason;
    }
    return reason === "Revert(123)" ? "MismatchedSelector" : "unknown";
  };
  var getDocs = (status) => {
    if (status?.type === "FailureStatus") {
      const reason = getFailureReason(status.reason);
      return {
        doc: reason !== "unknown" ? `${PANIC_DOC_URL}#variant.${reason}` : PANIC_DOC_URL,
        reason
      };
    }
    return { doc: PANIC_DOC_URL, reason: "unknown" };
  };
  function assert4(condition, message) {
    if (!condition) {
      throw new FuelError(ErrorCode.TRANSACTION_ERROR, message);
    }
  }
  var REVERT_MAP = {
    [FAILED_REQUIRE_SIGNAL]: "RequireFailed",
    [FAILED_TRANSFER_TO_ADDRESS_SIGNAL]: "TransferToAddressFailed",
    [FAILED_SEND_MESSAGE_SIGNAL]: "SendMessageFailed",
    [FAILED_ASSERT_EQ_SIGNAL]: "AssertEqFailed",
    [FAILED_ASSERT_SIGNAL]: "AssertFailed",
    [FAILED_UNKNOWN_SIGNAL]: "Unknown"
  };
  var decodeRevertErrorCode = (receipt) => {
    const signalHex = receipt.val.toHex();
    return REVERT_MAP[signalHex] ? REVERT_MAP[signalHex] : void 0;
  };
  var RevertError = class extends Error {
    /**
     * The receipt associated with the revert error.
     */
    receipt;
    /**
     * Creates a new instance of RevertError.
     *
     * @param receipt - The transaction revert receipt.
     * @param reason - The revert reason.
     */
    constructor(receipt, reason) {
      super(`The script reverted with reason ${reason}`);
      this.name = "RevertError";
      this.receipt = receipt;
    }
    /**
     * Returns a string representation of the RevertError.
     *
     * @returns The string representation of the error.
     */
    toString() {
      const { id, ...r } = this.receipt;
      return `${this.name}: ${this.message}
    ${id}: ${JSON.stringify(r)}`;
    }
  };
  var RequireRevertError = class extends RevertError {
    /**
     * Creates a new instance of RequireRevertError.
     *
     * @param receipt - The transaction revert receipt.
     * @param reason - The revert reason.
     */
    constructor(receipt, reason) {
      super(receipt, reason);
      this.name = "RequireRevertError";
    }
  };
  var TransferToAddressRevertError = class extends RevertError {
    /**
     * Creates a new instance of TransferToAddressRevertError.
     *
     * @param receipt - The transaction revert receipt.
     * @param reason - The revert reason.
     */
    constructor(receipt, reason) {
      super(receipt, reason);
      this.name = "TransferToAddressRevertError";
    }
  };
  var SendMessageRevertError = class extends RevertError {
    /**
     * Creates a new instance of SendMessageRevertError.
     *
     * @param receipt - The transaction revert receipt.
     * @param reason - The revert reason.
     */
    constructor(receipt, reason) {
      super(receipt, reason);
      this.name = "SendMessageRevertError";
    }
  };
  var AssertFailedRevertError = class extends RevertError {
    /**
     * Creates a new instance of AssertFailedRevertError.
     *
     * @param receipt - The transaction revert receipt.
     * @param reason - The revert reason.
     */
    constructor(receipt, reason) {
      super(receipt, reason);
      this.name = "AssertFailedRevertError";
    }
  };
  var revertErrorFactory = (receipt) => {
    const reason = decodeRevertErrorCode(receipt);
    if (!reason) {
      return void 0;
    }
    switch (reason) {
      case "RequireFailed":
        return new RequireRevertError(receipt, reason);
      case "TransferToAddressFailed":
        return new TransferToAddressRevertError(receipt, reason);
      case "SendMessageFailed":
        return new SendMessageRevertError(receipt, reason);
      case "AssertFailed":
        return new AssertFailedRevertError(receipt, reason);
      default:
        return new RevertError(receipt, reason);
    }
  };
  var { warn } = console;
  var getRevertReceipts = (receipts) => receipts.filter((r) => r.type === ReceiptType.Revert);
  var RevertErrorCodes = class {
    revertReceipts;
    constructor(receipts) {
      this.revertReceipts = getRevertReceipts(receipts);
    }
    assert(detailedError) {
      const revertError = this.getError();
      if (revertError) {
        revertError.cause = detailedError;
        throw revertError;
      }
    }
    getError() {
      if (!this.revertReceipts.length) {
        return void 0;
      }
      if (this.revertReceipts.length !== 1) {
        warn(
          "Multiple revert receipts found, expected one. Receipts:",
          JSON.stringify(this.revertReceipts)
        );
      }
      return revertErrorFactory(this.revertReceipts[0]);
    }
  };
  var bigintReplacer = (key, value) => typeof value === "bigint" ? value.toString() : value;
  var ScriptResultDecoderError = class extends Error {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    logs;
    constructor(result, message, logs) {
      let docLink = "";
      if (result?.gqlTransaction?.status) {
        docLink = `${JSON.stringify(getDocs(result.gqlTransaction.status), null, 2)}

`;
      }
      const logsText = logs.length ? `Logs:
${JSON.stringify(logs, null, 2)}

` : "";
      const receiptsText = `Receipts:
${JSON.stringify(
        result.receipts.map(({ type: type3, ...r }) => ({ type: ReceiptType[type3], ...r })),
        bigintReplacer,
        2
      )}`;
      super(`${message}

${docLink}${logsText}${receiptsText}`);
      this.logs = logs;
      new RevertErrorCodes(result.receipts).assert(this);
    }
  };
  var InstructionSet = class {
    #operations;
    constructor(...args) {
      this.#operations = args || [];
    }
    entries() {
      return this.#operations;
    }
    push(...args) {
      this.#operations.push(...args);
    }
    concat(ops) {
      return this.#operations.concat(ops);
    }
    extend(ops) {
      this.#operations.push(...ops);
    }
    toBytes() {
      return concat2(
        this.#operations.reduce((instructions, line) => {
          instructions.push(line.to_bytes());
          return instructions;
        }, [])
      );
    }
    toHex() {
      return hexlify(this.toBytes());
    }
    toString() {
      return `Program:
${JSON.stringify(this.#operations, null, 2)}`;
    }
    byteLength() {
      return this.toBytes().byteLength;
    }
  };
  var calculateScriptDataBaseOffset = (maxInputs) => SCRIPT_FIXED_SIZE + calculateVmTxMemory({ maxInputs });
  var POINTER_DATA_OFFSET = WORD_SIZE + ASSET_ID_LEN + CONTRACT_ID_LEN + WORD_SIZE + WORD_SIZE;
  function callResultToScriptResult(callResult) {
    const receipts = [...callResult.receipts];
    let scriptResultReceipt;
    let returnReceipt;
    receipts.forEach((receipt) => {
      if (receipt.type === ReceiptType.ScriptResult) {
        scriptResultReceipt = receipt;
      } else if (receipt.type === ReceiptType.Return || receipt.type === ReceiptType.ReturnData || receipt.type === ReceiptType.Revert) {
        returnReceipt = receipt;
      }
    });
    if (!scriptResultReceipt) {
      throw new FuelError(
        ErrorCode.TRANSACTION_ERROR,
        `The script call result does not contain a 'scriptResultReceipt'.`
      );
    }
    if (!returnReceipt) {
      throw new FuelError(
        ErrorCode.TRANSACTION_ERROR,
        `The script call result does not contain a 'returnReceipt'.`
      );
    }
    const scriptResult = {
      code: scriptResultReceipt.result,
      gasUsed: scriptResultReceipt.gasUsed,
      receipts,
      scriptResultReceipt,
      returnReceipt,
      callResult
    };
    return scriptResult;
  }
  function decodeCallResult(callResult, decoder, logs = []) {
    try {
      const scriptResult = callResultToScriptResult(callResult);
      return decoder(scriptResult);
    } catch (error2) {
      throw new ScriptResultDecoderError(
        callResult,
        error2.message,
        logs
      );
    }
  }
  function callResultToInvocationResult(callResult, call2, logs) {
    return decodeCallResult(
      callResult,
      (scriptResult) => {
        if (scriptResult.returnReceipt.type === ReceiptType.Revert) {
          throw new FuelError(
            ErrorCode.SCRIPT_REVERTED,
            `Script Reverted. Logs: ${JSON.stringify(logs)}`
          );
        }
        if (scriptResult.returnReceipt.type !== ReceiptType.Return && scriptResult.returnReceipt.type !== ReceiptType.ReturnData) {
          const { type: type3 } = scriptResult.returnReceipt;
          throw new FuelError(
            ErrorCode.SCRIPT_REVERTED,
            `Script Return Type [${type3}] Invalid. Logs: ${JSON.stringify({
              logs,
              receipt: scriptResult.returnReceipt
            })}`
          );
        }
        let value;
        if (scriptResult.returnReceipt.type === ReceiptType.Return) {
          value = scriptResult.returnReceipt.val;
        }
        if (scriptResult.returnReceipt.type === ReceiptType.ReturnData) {
          const decoded = call2.func.decodeOutput(scriptResult.returnReceipt.data);
          value = decoded[0];
        }
        return value;
      },
      logs
    );
  }
  var ScriptRequest = class {
    /**
     * The bytes of the script.
     */
    bytes;
    /**
     * A function to encode the script data.
     */
    scriptDataEncoder;
    /**
     * A function to decode the script result.
     */
    scriptResultDecoder;
    /**
     * Creates an instance of the ScriptRequest class.
     *
     * @param bytes - The bytes of the script.
     * @param scriptDataEncoder - The script data encoder function.
     * @param scriptResultDecoder - The script result decoder function.
     */
    constructor(bytes3, scriptDataEncoder, scriptResultDecoder2) {
      this.bytes = getBytesCopy(bytes3);
      this.scriptDataEncoder = scriptDataEncoder;
      this.scriptResultDecoder = scriptResultDecoder2;
    }
    /**
     * Gets the script data offset for the given bytes.
     *
     * @param byteLength - The byte length of the script.
     * @param maxInputs - The maxInputs value from the chain's consensus params.
     * @returns The script data offset.
     */
    static getScriptDataOffsetWithScriptBytes(byteLength, maxInputs) {
      const scriptDataBaseOffset = calculateVmTxMemory({ maxInputs }) + SCRIPT_FIXED_SIZE;
      return scriptDataBaseOffset + byteLength;
    }
    /**
     * Gets the script data offset.
     *
     * @param maxInputs - The maxInputs value from the chain's consensus params.
     * @returns The script data offset.
     */
    getScriptDataOffset(maxInputs) {
      return ScriptRequest.getScriptDataOffsetWithScriptBytes(this.bytes.length, maxInputs);
    }
    /**
     * Encodes the data for a script call.
     *
     * @param data - The script data.
     * @returns The encoded data.
     */
    encodeScriptData(data) {
      const callScript = this.scriptDataEncoder(data);
      if (ArrayBuffer.isView(callScript)) {
        return callScript;
      }
      this.bytes = getBytesCopy(callScript.script);
      return callScript.data;
    }
    /**
     * Decodes the result of a script call.
     *
     * @param callResult - The CallResult from the script call.
     * @param logs - Optional logs associated with the decoding.
     * @returns The decoded result.
     */
    decodeCallResult(callResult, logs = []) {
      return decodeCallResult(callResult, this.scriptResultDecoder, logs);
    }
  };
  var DEFAULT_OPCODE_PARAMS = {
    assetIdOffset: 0,
    amountOffset: 0,
    gasForwardedOffset: 0,
    callDataOffset: 0
  };
  var SCRIPT_WRAPPER_CONTRACT_ID = ZeroBytes32;
  var getSingleCallInstructions = ({ callDataOffset, gasForwardedOffset, amountOffset, assetIdOffset }, outputInfo) => {
    const inst = new InstructionSet(
      asm3.movi(16, callDataOffset),
      asm3.movi(17, amountOffset),
      asm3.lw(17, 17, 0),
      asm3.movi(18, assetIdOffset)
    );
    if (gasForwardedOffset) {
      inst.push(
        asm3.movi(19, gasForwardedOffset),
        asm3.lw(19, 19, 0),
        asm3.call(16, 17, 18, 19)
      );
    } else {
      inst.push(asm3.call(16, 17, 18, asm3.RegId.cgas().to_u8()));
    }
    if (outputInfo.isHeap) {
      inst.extend([
        // The RET register contains the pointer address of the `CALL` return (a stack
        // address).
        // The RETL register contains the length of the `CALL` return (=24 because the Vec/Bytes
        // struct takes 3 WORDs). We don't actually need it unless the Vec/Bytes struct encoding
        // changes in the compiler.
        // Load the word located at the address contained in RET, it's a word that
        // translates to a heap address. 0x15 is a free register.
        asm3.lw(21, asm3.RegId.ret().to_u8(), 0),
        // We know a Vec/Bytes struct has its third WORD contain the length of the underlying
        // vector, so use a 2 offset to store the length in 0x16, which is a free register.
        asm3.lw(22, asm3.RegId.ret().to_u8(), 2),
        // The in-memory size of the type is (in-memory size of the inner type) * length
        asm3.muli(22, 22, outputInfo.encodedLength),
        asm3.retd(21, 22)
      ]);
    }
    return inst;
  };
  function getInstructions(offsets, outputs) {
    if (!offsets.length) {
      return new Uint8Array();
    }
    const multiCallInstructions = new InstructionSet();
    for (let i = 0; i < offsets.length; i += 1) {
      multiCallInstructions.extend(getSingleCallInstructions(offsets[i], outputs[i]).entries());
    }
    multiCallInstructions.push(asm3.ret(1));
    return multiCallInstructions.toBytes();
  }
  var isReturnType = (type3) => type3 === ReceiptType.Return || type3 === ReceiptType.ReturnData;
  var getMainCallReceipt = (receipts, contractId) => receipts.find(
    ({ type: type3, from, to }) => type3 === ReceiptType.Call && from === SCRIPT_WRAPPER_CONTRACT_ID && to === contractId
  );
  var scriptResultDecoder = (contractId, isOutputDataHeap) => (result) => {
    if (toNumber2(result.code) !== 0) {
      throw new FuelError(
        ErrorCode.TRANSACTION_ERROR,
        `Execution of the script associated with contract ${contractId} resulted in a non-zero exit code: ${result.code}.`
      );
    }
    const mainCallResult = getMainCallReceipt(
      result.receipts,
      contractId.toB256()
    );
    const mainCallInstructionStart = bn(mainCallResult?.is);
    const receipts = result.receipts;
    return receipts.filter(({ type: type3 }) => isReturnType(type3)).flatMap((receipt, index, filtered) => {
      if (!mainCallInstructionStart.eq(bn(receipt.is))) {
        return [];
      }
      if (receipt.type === ReceiptType.Return) {
        return [new U64Coder().encode(receipt.val)];
      }
      if (receipt.type === ReceiptType.ReturnData) {
        const encodedScriptReturn = getBytesCopy(receipt.data);
        if (isOutputDataHeap && isReturnType(filtered[index + 1]?.type)) {
          const nextReturnData = filtered[index + 1];
          return concat2([encodedScriptReturn, getBytesCopy(nextReturnData.data)]);
        }
        return [encodedScriptReturn];
      }
      return [new Uint8Array()];
    });
  };
  var decodeContractCallScriptResult = (callResult, contractId, isOutputDataHeap, logs = []) => decodeCallResult(callResult, scriptResultDecoder(contractId, isOutputDataHeap), logs);
  var getCallInstructionsLength = (contractCalls) => contractCalls.reduce(
    (sum, call2) => {
      const offset = { ...DEFAULT_OPCODE_PARAMS };
      if (call2.gas) {
        offset.gasForwardedOffset = 1;
      }
      const output3 = {
        isHeap: call2.isOutputDataHeap,
        encodedLength: call2.outputEncodedLength
      };
      return sum + getSingleCallInstructions(offset, output3).byteLength();
    },
    asm3.Instruction.size()
    // placeholder for single RET instruction which is added later
  );
  var getFunctionOutputInfos = (functionScopes) => functionScopes.map((funcScope) => {
    const { func } = funcScope.getCallConfig();
    return {
      isHeap: func.outputMetadata.isHeapType,
      encodedLength: func.outputMetadata.encodedLength
    };
  });
  var getContractCallScript = (functionScopes, maxInputs) => new ScriptRequest(
    // Script to call the contract, start with stub size matching length of calls
    getInstructions(
      new Array(functionScopes.length).fill(DEFAULT_OPCODE_PARAMS),
      getFunctionOutputInfos(functionScopes)
    ),
    (contractCalls) => {
      const TOTAL_CALLS = contractCalls.length;
      if (TOTAL_CALLS === 0) {
        return { data: new Uint8Array(), script: new Uint8Array() };
      }
      const callInstructionsLength = getCallInstructionsLength(contractCalls);
      const paddingLength = (8 - callInstructionsLength % 8) % 8;
      const paddedInstructionsLength = callInstructionsLength + paddingLength;
      const dataOffset = calculateScriptDataBaseOffset(maxInputs.toNumber()) + paddedInstructionsLength;
      const paramOffsets = [];
      let segmentOffset = dataOffset;
      const outputInfos = [];
      const scriptData = [];
      for (let i = 0; i < TOTAL_CALLS; i += 1) {
        const call2 = contractCalls[i];
        outputInfos.push({
          isHeap: call2.isOutputDataHeap,
          encodedLength: call2.outputEncodedLength
        });
        paramOffsets.push({
          gasForwardedOffset: call2.gas ? segmentOffset + WORD_SIZE + ASSET_ID_LEN + CONTRACT_ID_LEN + WORD_SIZE : 0,
          amountOffset: segmentOffset,
          assetIdOffset: segmentOffset + WORD_SIZE,
          callDataOffset: segmentOffset + WORD_SIZE + ASSET_ID_LEN
        });
        scriptData.push(new U64Coder().encode(call2.amount || 0));
        scriptData.push(new B256Coder().encode(call2.assetId?.toString() || BaseAssetId));
        scriptData.push(call2.contractId.toBytes());
        scriptData.push(new U64Coder().encode(call2.fnSelector));
        let gasForwardedSize = 0;
        if (call2.gas) {
          scriptData.push(new U64Coder().encode(call2.gas));
          gasForwardedSize = WORD_SIZE;
        }
        if (call2.isInputDataPointer) {
          const pointerInputOffset = segmentOffset + POINTER_DATA_OFFSET + gasForwardedSize;
          scriptData.push(new U64Coder().encode(pointerInputOffset));
        }
        const args = getBytesCopy(call2.data);
        scriptData.push(args);
        segmentOffset = dataOffset + concat2(scriptData).byteLength;
      }
      const script = getInstructions(paramOffsets, outputInfos);
      const finalScriptData = concat2(scriptData);
      return { data: finalScriptData, script };
    },
    () => [new Uint8Array()]
  );
  function getGasUsage(callResult) {
    const scriptResult = callResult.receipts.find((r) => r.type === ReceiptType.ScriptResult);
    return scriptResult?.gasUsed || bn(0);
  }
  var InvocationResult = class {
    functionScopes;
    isMultiCall;
    gasUsed;
    value;
    /**
     * Constructs an instance of InvocationResult.
     *
     * @param funcScopes - The function scopes.
     * @param callResult - The call result.
     * @param isMultiCall - Whether it's a multi-call.
     */
    constructor(funcScopes, callResult, isMultiCall) {
      this.functionScopes = Array.isArray(funcScopes) ? funcScopes : [funcScopes];
      this.isMultiCall = isMultiCall;
      this.value = this.getDecodedValue(callResult);
      this.gasUsed = getGasUsage(callResult);
    }
    /**
     * Gets the first call config.
     *
     * @returns The first call config.
     */
    getFirstCallConfig() {
      if (!this.functionScopes[0]) {
        return void 0;
      }
      return this.functionScopes[0].getCallConfig();
    }
    /**
     * Decodes the value from the call result.
     *
     * @param callResult - The call result.
     * @returns The decoded value.
     */
    getDecodedValue(callResult) {
      const logs = this.getDecodedLogs(callResult.receipts);
      const callConfig = this.getFirstCallConfig();
      if (this.functionScopes.length === 1 && callConfig && "bytes" in callConfig.program) {
        return callResultToInvocationResult(callResult, callConfig, logs);
      }
      const encodedResults = decodeContractCallScriptResult(
        callResult,
        (callConfig?.program).id,
        callConfig?.func.outputMetadata.isHeapType || false,
        logs
      );
      const returnValues = encodedResults.map((encodedResult, i) => {
        const { func } = this.functionScopes[i].getCallConfig();
        return func.decodeOutput(encodedResult)?.[0];
      });
      return this.isMultiCall ? returnValues : returnValues?.[0];
    }
    /**
     * Decodes the logs from the receipts.
     *
     * @param receipts - The transaction result receipts.
     * @returns The decoded logs.
     */
    getDecodedLogs(receipts) {
      const callConfig = this.getFirstCallConfig();
      if (!callConfig) {
        return [];
      }
      const { program: program2 } = callConfig;
      return getDecodedLogs(receipts, program2.interface);
    }
  };
  var FunctionInvocationResult = class extends InvocationResult {
    transactionId;
    transactionResponse;
    transactionResult;
    program;
    logs;
    /**
     * Constructs an instance of FunctionInvocationResult.
     *
     * @param funcScopes - The function scopes.
     * @param transactionResponse - The transaction response.
     * @param transactionResult - The transaction result.
     * @param program - The program.
     * @param isMultiCall - Whether it's a multi-call.
     */
    constructor(funcScopes, transactionResponse, transactionResult, program2, isMultiCall) {
      super(funcScopes, transactionResult, isMultiCall);
      this.transactionResponse = transactionResponse;
      this.transactionResult = transactionResult;
      this.transactionId = this.transactionResponse.id;
      this.program = program2;
      this.logs = this.getDecodedLogs(transactionResult.receipts);
    }
    /**
     * Builds an instance of FunctionInvocationResult.
     *
     * @param funcScope - The function scope.
     * @param transactionResponse - The transaction response.
     * @param isMultiCall - Whether it's a multi-call.
     * @param program - The program.
     * @returns The function invocation result.
     */
    static async build(funcScope, transactionResponse, isMultiCall, program2) {
      const txResult = await transactionResponse.waitForResult();
      const fnResult = new FunctionInvocationResult(
        funcScope,
        transactionResponse,
        txResult,
        program2,
        isMultiCall
      );
      return fnResult;
    }
  };
  var InvocationCallResult = class extends InvocationResult {
    callResult;
    /**
     * Constructs an instance of InvocationCallResult.
     *
     * @param funcScopes - The function scopes.
     * @param callResult - The call result.
     * @param isMultiCall - Whether it's a multi-call.
     */
    constructor(funcScopes, callResult, isMultiCall) {
      super(funcScopes, callResult, isMultiCall);
      this.callResult = callResult;
    }
    /**
     * Builds an instance of InvocationCallResult.
     *
     * @param funcScopes - The function scopes.
     * @param callResult - The call result.
     * @param isMultiCall - Whether it's a multi-call.
     * @returns The invocation call result.
     */
    static async build(funcScopes, callResult, isMultiCall) {
      const fnResult = await new InvocationCallResult(funcScopes, callResult, isMultiCall);
      return fnResult;
    }
  };
  function createContractCall(funcScope, offset) {
    const { program: program2, args, forward, func, callParameters } = funcScope.getCallConfig();
    const DATA_POINTER_OFFSET = funcScope.getCallConfig().func.isInputDataPointer ? POINTER_DATA_OFFSET : 0;
    const data = func.encodeArguments(args, offset + DATA_POINTER_OFFSET);
    return {
      contractId: program2.id,
      fnSelector: func.selector,
      data,
      isInputDataPointer: func.isInputDataPointer,
      isOutputDataHeap: func.outputMetadata.isHeapType,
      outputEncodedLength: func.outputMetadata.encodedLength,
      assetId: forward?.assetId,
      amount: forward?.amount,
      gas: callParameters?.gasLimit
    };
  }
  var BaseInvocationScope = class {
    transactionRequest;
    program;
    functionInvocationScopes = [];
    txParameters;
    requiredCoins = [];
    isMultiCall = false;
    /**
     * Constructs an instance of BaseInvocationScope.
     *
     * @param program - The abstract program to be invoked.
     * @param isMultiCall - A flag indicating whether the invocation is a multi-call.
     */
    constructor(program2, isMultiCall) {
      this.program = program2;
      this.isMultiCall = isMultiCall;
      const provider = program2.provider;
      const { maxGasPerTx } = provider.getGasConfig();
      this.transactionRequest = new ScriptTransactionRequest({
        gasLimit: maxGasPerTx
      });
    }
    /**
     * Getter for the contract calls.
     *
     * @returns An array of contract calls.
     */
    get calls() {
      const provider = this.getProvider();
      const consensusParams = provider.getChain().consensusParameters;
      if (!consensusParams) {
        throw new FuelError(
          FuelError.CODES.CHAIN_INFO_CACHE_EMPTY,
          "Provider chain info cache is empty. Please make sure to initialize the `Provider` properly by running `await Provider.create()``"
        );
      }
      const maxInputs = consensusParams.maxInputs;
      const script = getContractCallScript(this.functionInvocationScopes, maxInputs);
      return this.functionInvocationScopes.map(
        (funcScope) => createContractCall(funcScope, script.getScriptDataOffset(maxInputs.toNumber()))
      );
    }
    /**
     * Updates the script request with the current contract calls.
     */
    updateScriptRequest() {
      const maxInputs = this.program.provider.getChain().consensusParameters.maxInputs;
      const contractCallScript = getContractCallScript(this.functionInvocationScopes, maxInputs);
      this.transactionRequest.setScript(contractCallScript, this.calls);
    }
    /**
     * Updates the transaction request with the current input/output.
     */
    updateContractInputAndOutput() {
      const calls = this.calls;
      calls.forEach((c) => {
        if (c.contractId) {
          this.transactionRequest.addContractInputAndOutput(c.contractId);
        }
      });
    }
    /**
     * Gets the required coins for the transaction.
     *
     * @returns An array of required coin quantities.
     */
    getRequiredCoins() {
      const forwardingAssets = this.calls.map((call2) => ({
        assetId: String(call2.assetId),
        amount: bn(call2.amount || 0)
      })).filter(({ assetId, amount }) => assetId && !bn(amount).isZero());
      return forwardingAssets;
    }
    /**
     * Updates the required coins for the transaction.
     */
    updateRequiredCoins() {
      const assets = this.getRequiredCoins();
      const reduceForwardCoins = (requiredCoins, { assetId, amount }) => {
        const currentAmount = requiredCoins.get(assetId)?.amount || bn(0);
        return requiredCoins.set(assetId, {
          assetId: String(assetId),
          amount: currentAmount.add(amount)
        });
      };
      this.requiredCoins = Array.from(
        assets.reduce(reduceForwardCoins, /* @__PURE__ */ new Map()).values()
      );
    }
    /**
     * Adds a single call to the invocation scope.
     *
     * @param funcScope - The function scope to add.
     * @returns The current instance of the class.
     */
    addCall(funcScope) {
      this.addCalls([funcScope]);
      return this;
    }
    /**
     * Adds multiple calls to the invocation scope.
     *
     * @param funcScopes - An array of function scopes to add.
     * @returns The current instance of the class.
     */
    addCalls(funcScopes) {
      this.functionInvocationScopes.push(...funcScopes);
      this.updateContractInputAndOutput();
      this.updateRequiredCoins();
      return this;
    }
    /**
     * Prepares the transaction by updating the script request, required coins, and checking the gas limit.
     */
    async prepareTransaction() {
      await asm2.initWasm();
      this.updateScriptRequest();
      this.updateRequiredCoins();
      this.checkGasLimitTotal();
    }
    /**
     * Checks if the total gas limit is within the acceptable range.
     */
    checkGasLimitTotal() {
      const gasLimitOnCalls = this.calls.reduce((total, call2) => total.add(call2.gas || 0), bn(0));
      if (gasLimitOnCalls.gt(this.transactionRequest.gasLimit)) {
        throw new FuelError(
          ErrorCode.TRANSACTION_ERROR,
          "Transaction's gasLimit must be equal to or greater than the combined forwarded gas of all calls."
        );
      }
    }
    /**
     * Gets the transaction cost ny dry running the transaction.
     *
     * @param options - Optional transaction cost options.
     * @returns The transaction cost details.
     */
    async getTransactionCost(options) {
      const provider = this.getProvider();
      const request = await this.getTransactionRequest();
      request.gasPrice = bn(toNumber2(request.gasPrice) || toNumber2(options?.gasPrice || 0));
      const txCost = await provider.getTransactionCost(request, this.getRequiredCoins());
      return txCost;
    }
    /**
     * Funds the transaction with the required coins.
     *
     * @returns The current instance of the class.
     */
    async fundWithRequiredCoins(fee) {
      this.transactionRequest.inputs = this.transactionRequest.inputs.filter(
        (i) => i.type !== InputType.Coin
      );
      await this.program.account?.fund(this.transactionRequest, this.requiredCoins, fee);
      return this;
    }
    /**
     * Sets the transaction parameters.
     *
     * @param txParams - The transaction parameters to set.
     * @returns The current instance of the class.
     */
    txParams(txParams) {
      this.txParameters = txParams;
      const request = this.transactionRequest;
      request.gasLimit = bn(txParams.gasLimit || request.gasLimit);
      request.gasPrice = bn(txParams.gasPrice || request.gasPrice);
      request.addVariableOutputs(this.txParameters?.variableOutputs || 0);
      return this;
    }
    /**
     * Adds contracts to the invocation scope.
     *
     * @param contracts - An array of contracts to add.
     * @returns The current instance of the class.
     */
    addContracts(contracts) {
      contracts.forEach((contract) => {
        this.transactionRequest.addContractInputAndOutput(contract.id);
        this.program.interface.updateExternalLoggedTypes(contract.id.toB256(), contract.interface);
      });
      return this;
    }
    /**
     * Prepares and returns the transaction request object.
     *
     * @returns The prepared transaction request.
     */
    async getTransactionRequest() {
      await this.prepareTransaction();
      return this.transactionRequest;
    }
    /**
     * Submits a transaction.
     *
     * @returns The result of the function invocation.
     */
    async call() {
      assert4(this.program.account, "Wallet is required!");
      const transactionRequest = await this.getTransactionRequest();
      const { maxFee, gasUsed } = await this.getTransactionCost();
      if (gasUsed.gt(bn(transactionRequest.gasLimit))) {
        throw new FuelError(
          ErrorCode.GAS_LIMIT_TOO_LOW,
          `Gas limit '${transactionRequest.gasLimit}' is lower than the required: '${gasUsed}'.`
        );
      }
      await this.fundWithRequiredCoins(maxFee);
      const response = await this.program.account.sendTransaction(transactionRequest);
      return FunctionInvocationResult.build(
        this.functionInvocationScopes,
        response,
        this.isMultiCall,
        this.program
      );
    }
    /**
     * Simulates a transaction.
     *
     * @returns The result of the invocation call.
     */
    async simulate() {
      assert4(this.program.account, "Wallet is required!");
      const isUnlockedWallet = this.program.account.populateTransactionWitnessesSignature;
      if (!isUnlockedWallet) {
        return this.dryRun();
      }
      const transactionRequest = await this.getTransactionRequest();
      const { maxFee } = await this.getTransactionCost();
      await this.fundWithRequiredCoins(maxFee);
      const result = await this.program.account.simulateTransaction(transactionRequest);
      return InvocationCallResult.build(this.functionInvocationScopes, result, this.isMultiCall);
    }
    /**
     * Executes a transaction in dry run mode.
     *
     * @returns The result of the invocation call.
     */
    async dryRun() {
      assert4(this.program.account, "Wallet is required!");
      const provider = this.getProvider();
      const { maxFee } = await this.getTransactionCost();
      await this.fundWithRequiredCoins(maxFee);
      const transactionRequest = await this.getTransactionRequest();
      const response = await provider.call(transactionRequest, {
        utxoValidation: false
      });
      const result = await InvocationCallResult.build(
        this.functionInvocationScopes,
        response,
        this.isMultiCall
      );
      return result;
    }
    getProvider() {
      const provider = this.program.provider;
      return provider;
    }
    /**
     * Obtains the ID of a transaction.
     *
     * @param chainId - the chainId to use to hash the transaction with
     * @returns the ID of the transaction.
     */
    async getTransactionId(chainId) {
      const chainIdToHash = chainId ?? await this.getProvider().getChainId();
      const transactionRequest = await this.getTransactionRequest();
      return hashTransaction(transactionRequest, chainIdToHash);
    }
  };
  var FunctionInvocationScope = class extends BaseInvocationScope {
    func;
    callParameters;
    forward;
    args;
    /**
     * Constructs an instance of FunctionInvocationScope.
     *
     * @param program - The program.
     * @param func - The function fragment.
     * @param args - The arguments.
     */
    constructor(program2, func, args) {
      super(program2, false);
      this.func = func;
      this.args = args || [];
      this.setArguments(...args);
      super.addCall(this);
    }
    /**
     * Gets the call configuration.
     *
     * @returns The call configuration.
     */
    getCallConfig() {
      return {
        func: this.func,
        program: this.program,
        callParameters: this.callParameters,
        txParameters: this.txParameters,
        forward: this.forward,
        args: this.args
      };
    }
    /**
     * Sets the arguments for the function invocation.
     *
     * @param args - The arguments.
     * @returns The instance of FunctionInvocationScope.
     */
    setArguments(...args) {
      this.args = args || [];
      return this;
    }
    /**
     * Sets the call parameters for the function invocation.
     *
     * @param callParams - The call parameters.
     * @returns The instance of FunctionInvocationScope.
     * @throws If the function is not payable and forward is set.
     */
    callParams(callParams) {
      this.callParameters = callParams;
      if (callParams?.forward) {
        if (!this.func.attributes.find((attr) => attr.name === "payable")) {
          throw new FuelError(
            ErrorCode.TRANSACTION_ERROR,
            `The target function ${this.func.name} cannot accept forwarded funds as it's not marked as 'payable'.`
          );
        }
        this.forward = coinQuantityfy(callParams.forward);
      }
      this.setArguments(...this.args);
      this.updateRequiredCoins();
      return this;
    }
  };
  var MultiCallInvocationScope = class extends BaseInvocationScope {
    /**
     * Constructs an instance of MultiCallInvocationScope.
     *
     * @param contract - The contract.
     * @param funcScopes - An array of function invocation scopes.
     */
    constructor(contract, funcScopes) {
      super(contract, true);
      this.addCalls(funcScopes);
      this.validateHeapTypeReturnCalls();
    }
    /**
     * Adds a single function invocation scope to the multi-call invocation scope.
     *
     * @param funcScope - The function invocation scope.
     * @returns The instance of MultiCallInvocationScope.
     */
    addCall(funcScope) {
      return super.addCalls([funcScope]);
    }
    /**
     * Adds multiple function invocation scopes to the multi-call invocation scope.
     *
     * @param funcScopes - An array of function invocation scopes.
     * @returns The instance of MultiCallInvocationScope.
     */
    addCalls(funcScopes) {
      return super.addCalls(funcScopes);
    }
    validateHeapTypeReturnCalls() {
      let heapOutputIndex = -1;
      let numberOfHeaps = 0;
      this.calls.forEach((call2, callIndex) => {
        const { isOutputDataHeap } = call2;
        if (isOutputDataHeap) {
          heapOutputIndex = callIndex;
          if (++numberOfHeaps > 1) {
            throw new FuelError(
              ErrorCode.INVALID_MULTICALL,
              "A multicall can have only one call that returns a heap type."
            );
          }
        }
      });
      const hasHeapTypeReturn = heapOutputIndex !== -1;
      const isOnLastCall = heapOutputIndex === this.calls.length - 1;
      if (hasHeapTypeReturn && !isOnLastCall) {
        throw new FuelError(
          ErrorCode.INVALID_MULTICALL,
          "In a multicall, the contract call returning a heap type must be the last call."
        );
      }
    }
  };
  var Contract = class {
    /**
     * The unique contract identifier.
     */
    id;
    /**
     * The provider for interacting with the contract.
     */
    provider;
    /**
     * The contract's ABI interface.
     */
    interface;
    /**
     * The account associated with the contract, if available.
     */
    account;
    /**
     * A collection of functions available on the contract.
     */
    functions = {};
    /**
     * Creates an instance of the Contract class.
     *
     * @param id - The contract's address.
     * @param abi - The contract's ABI (JSON ABI or Interface instance).
     * @param accountOrProvider - The account or provider for interaction.
     */
    constructor(id, abi, accountOrProvider) {
      this.interface = abi instanceof Interface ? abi : new Interface(abi);
      this.id = Address.fromAddressOrString(id);
      if (accountOrProvider && "provider" in accountOrProvider) {
        this.provider = accountOrProvider.provider;
        this.account = accountOrProvider;
      } else {
        this.provider = accountOrProvider;
        this.account = null;
      }
      Object.keys(this.interface.functions).forEach((name) => {
        const fragment = this.interface.getFunction(name);
        Object.defineProperty(this.functions, fragment.name, {
          value: this.buildFunction(fragment),
          writable: false
        });
      });
    }
    /**
     * Build a function invocation scope for the provided function fragment.
     *
     * @param func - The function fragment to build a scope for.
     * @returns A function that creates a FunctionInvocationScope.
     */
    buildFunction(func) {
      return (...args) => new FunctionInvocationScope(this, func, args);
    }
    /**
     * Create a multi-call invocation scope for the provided function invocation scopes.
     *
     * @param calls - An array of FunctionInvocationScopes to execute in a batch.
     * @returns A MultiCallInvocationScope instance.
     */
    multiCall(calls) {
      return new MultiCallInvocationScope(this, calls);
    }
    /**
     * Get the balance for a given asset ID for this contract.
     *
     * @param assetId - The specified asset ID.
     * @returns The balance of the contract for the specified asset.
     */
    // #region contract-balance-1
    getBalance(assetId) {
      return this.provider.getContractBalance(this.id, assetId);
    }
    // #endregion contract-balance-1
  };

  // ../merkle/dist/index.mjs
  var EMPTY = "0xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
  function hash4(data) {
    return sha256(data);
  }
  var Node = class {
    left;
    right;
    parent;
    hash;
    data;
    index;
    constructor(left, right, parent, hash22, data, index = 0) {
      this.left = left;
      this.right = right;
      this.parent = parent;
      this.hash = hash22;
      this.data = data;
      this.index = index;
    }
  };
  var node_default2 = Node;
  function hashLeaf(data) {
    return hash4("0x00".concat(data.slice(2)));
  }
  function hashNode(left, right) {
    return hash4("0x01".concat(left.slice(2)).concat(right.slice(2)));
  }
  function calcRoot(data) {
    if (!data.length) {
      return EMPTY;
    }
    const nodes = [];
    for (let i = 0; i < data.length; i += 1) {
      const hashed = hashLeaf(data[i]);
      nodes.push(new node_default2(-1, -1, -1, hashed, data[i]));
    }
    let pNodes = nodes;
    let size = nodes.length + 1 >> 1;
    let odd = nodes.length & 1;
    while (true) {
      let i = 0;
      for (; i < size - odd; i += 1) {
        const j = i << 1;
        const hashed = hashNode(pNodes[j].hash, pNodes[j + 1].hash);
        nodes[i] = new node_default2(pNodes[j].index, pNodes[j + 1].index, -1, hashed, "");
      }
      if (odd === 1) {
        nodes[i] = pNodes[i << 1];
      }
      if (size === 1) {
        break;
      }
      odd = size & 1;
      size = size + 1 >> 1;
      pNodes = nodes;
    }
    return nodes[0].hash;
  }
  var leafPrefix = "0x00";
  var nodePrefix = "0x01";
  function hashLeaf2(key, data) {
    const value = "0x00".concat(key.slice(2)).concat(hash4(data).slice(2));
    return [hash4(value), value];
  }
  function hashNode2(left, right) {
    const value = "0x01".concat(left.slice(2)).concat(right.slice(2));
    return [hash4(value), value];
  }
  function parseLeaf(data) {
    const len = nodePrefix.length;
    return ["0x".concat(data.slice(len, len + 64)), "0x".concat(data.slice(len + 64))];
  }
  function parseNode(data) {
    const len = nodePrefix.length;
    return ["0x".concat(data.slice(len, len + 64)), "0x".concat(data.slice(len + 64))];
  }
  function isLeaf(data) {
    return data.slice(0, 4) === leafPrefix;
  }
  var SparseCompactMerkleProof = class {
    SideNodes;
    NonMembershipLeafData;
    BitMask;
    NumSideNodes;
    SiblingData;
    constructor(SideNodes, NonMembershipLeafData, Bitmask, NumSideNodes, SiblingData) {
      this.SideNodes = SideNodes;
      this.NonMembershipLeafData = NonMembershipLeafData;
      this.BitMask = Bitmask;
      this.NumSideNodes = NumSideNodes;
      this.SiblingData = SiblingData;
    }
  };
  var sparseCompactMerkleProof_default = SparseCompactMerkleProof;
  var SparseMerkleProof = class {
    SideNodes;
    NonMembershipLeafData;
    SiblingData;
    constructor(sideNodes, NonMembershipLeafData, SiblingData) {
      this.SideNodes = sideNodes;
      this.NonMembershipLeafData = NonMembershipLeafData;
      this.SiblingData = SiblingData;
    }
  };
  var sparseMerkleProof_default = SparseMerkleProof;
  var ZERO = "0x0000000000000000000000000000000000000000000000000000000000000000";
  var MAX_HEIGHT = 256;
  function getBitAtFromMSB(data, position) {
    const slicedData = data.slice(2);
    const byte = "0x".concat(
      slicedData.slice(Math.floor(position / 8) * 2, Math.floor(position / 8) * 2 + 2)
    );
    const bits = Number(byte) & 1 << 8 - 1 - position % 8;
    if (bits > 0) {
      return 1;
    }
    return 0;
  }
  function reverseSideNodes(sideNodes) {
    let left = 0;
    let right = sideNodes.length - 1;
    const reversedSideNodes = sideNodes;
    while (left < right) {
      [reversedSideNodes[left], reversedSideNodes[right]] = [
        reversedSideNodes[right],
        reversedSideNodes[left]
      ];
      left += 1;
      right -= 1;
    }
    return reversedSideNodes;
  }
  function countCommonPrefix(data1, data2) {
    let count = 0;
    for (let i = 0; i < MAX_HEIGHT; i += 1) {
      if (getBitAtFromMSB(data1, i) === getBitAtFromMSB(data2, i)) {
        count += 1;
      } else {
        break;
      }
    }
    return count;
  }
  function compactProof(proof) {
    const bitMask = [];
    const compactedSideNodes = [];
    let node;
    for (let i = 0; i < proof.SideNodes.length; i += 1) {
      node = proof.SideNodes[i];
      if (node === ZERO) {
        bitMask.push(0);
      } else {
        compactedSideNodes.push(node);
        bitMask.push(1);
      }
    }
    const compactedProof = new sparseCompactMerkleProof_default(
      compactedSideNodes,
      proof.NonMembershipLeafData,
      bitMask,
      proof.SideNodes.length,
      proof.SiblingData
    );
    return compactedProof;
  }
  var SparseMerkleTree = class {
    ms;
    root;
    constructor() {
      const ms = {};
      this.ms = ms;
      this.root = ZERO;
      this.ms[this.root] = ZERO;
    }
    get(key) {
      return this.ms[key];
    }
    set(key, value) {
      this.ms[key] = value;
    }
    setRoot(root) {
      this.root = root;
    }
    sideNodesForRoot(key, root) {
      const sideNodes = [];
      if (root === ZERO) {
        return [sideNodes, ZERO, "", ""];
      }
      let currentData = this.get(root);
      if (isLeaf(currentData)) {
        return [sideNodes, root, currentData, ""];
      }
      let leftNode;
      let rightNode;
      let nodeHash = "";
      let sideNode = "";
      for (let i = 0; i < MAX_HEIGHT; i += 1) {
        [leftNode, rightNode] = parseNode(currentData);
        if (getBitAtFromMSB(key, i) === 1) {
          sideNode = leftNode;
          nodeHash = rightNode;
        } else {
          sideNode = rightNode;
          nodeHash = leftNode;
        }
        sideNodes.push(sideNode);
        if (nodeHash === ZERO) {
          currentData = "";
          break;
        }
        currentData = this.get(nodeHash);
        if (isLeaf(currentData)) {
          break;
        }
      }
      const siblingData = this.get(sideNode);
      return [reverseSideNodes(sideNodes), nodeHash, currentData, siblingData];
    }
    deleteWithSideNodes(key, sideNodes, oldLeafHash, oldLeafData) {
      if (oldLeafHash === ZERO) {
        return this.root;
      }
      const [actualPath] = parseLeaf(oldLeafData);
      if (actualPath !== key) {
        return this.root;
      }
      let currentHash = "";
      let currentData = "";
      let sideNode = "";
      let sideNodeValue = "";
      let nonPlaceholderReached = false;
      for (let i = 0; i < sideNodes.length; i += 1) {
        if (sideNodes[i] === "") {
          continue;
        }
        sideNode = sideNodes[i];
        if (currentData === "") {
          sideNodeValue = this.get(sideNode);
          if (isLeaf(sideNodeValue)) {
            currentHash = sideNode;
            currentData = sideNode;
            continue;
          } else {
            currentData = ZERO;
            nonPlaceholderReached = true;
          }
        }
        if (!nonPlaceholderReached && sideNode === ZERO) {
          continue;
        } else if (!nonPlaceholderReached) {
          nonPlaceholderReached = true;
        }
        if (getBitAtFromMSB(key, sideNodes.length - 1 - i) === 1) {
          [currentHash, currentData] = hashNode2(sideNode, currentData);
        } else {
          [currentHash, currentData] = hashNode2(currentData, sideNode);
        }
        this.set(currentHash, currentData);
        currentData = currentHash;
      }
      if (currentHash === "") {
        currentHash = ZERO;
      }
      return currentHash;
    }
    updateWithSideNodes(key, value, sideNodes, oldLeafHash, oldLeafData) {
      let currentHash;
      let currentData;
      this.set(hash4(value), value);
      [currentHash, currentData] = hashLeaf2(key, value);
      this.set(currentHash, currentData);
      currentData = currentHash;
      let commonPrefixCount;
      if (oldLeafHash === ZERO) {
        commonPrefixCount = MAX_HEIGHT;
      } else {
        const [actualPath] = parseLeaf(oldLeafData);
        commonPrefixCount = countCommonPrefix(key, actualPath);
      }
      if (commonPrefixCount !== MAX_HEIGHT) {
        if (getBitAtFromMSB(key, commonPrefixCount) === 1) {
          [currentHash, currentData] = hashNode2(oldLeafHash, currentData);
        } else {
          [currentHash, currentData] = hashNode2(currentData, oldLeafHash);
        }
        this.set(currentHash, currentData);
        currentData = currentHash;
      }
      for (let i = 0; i < MAX_HEIGHT; i += 1) {
        let sideNode;
        const offsetOfSideNodes = MAX_HEIGHT - sideNodes.length;
        if (i - offsetOfSideNodes < 0 || sideNodes[i - offsetOfSideNodes] === "") {
          if (commonPrefixCount !== MAX_HEIGHT && commonPrefixCount > MAX_HEIGHT - 1 - i) {
            sideNode = ZERO;
          } else {
            continue;
          }
        } else {
          sideNode = sideNodes[i - offsetOfSideNodes];
        }
        if (getBitAtFromMSB(key, MAX_HEIGHT - 1 - i) === 1) {
          [currentHash, currentData] = hashNode2(sideNode, currentData);
        } else {
          [currentHash, currentData] = hashNode2(currentData, sideNode);
        }
        this.set(currentHash, currentData);
        currentData = currentHash;
      }
      return currentHash;
    }
    update(key, value) {
      const [sideNodes, oldLeafHash, oldLeafData] = this.sideNodesForRoot(key, this.root);
      const newRoot = this.updateWithSideNodes(key, value, sideNodes, oldLeafHash, oldLeafData);
      this.setRoot(newRoot);
    }
    delete(key) {
      const [sideNodes, oldLeafHash, oldLeafData] = this.sideNodesForRoot(key, this.root);
      const newRoot = this.deleteWithSideNodes(key, sideNodes, oldLeafHash, oldLeafData);
      this.setRoot(newRoot);
    }
    prove(key) {
      const [sideNodes, leafHash, leafData, siblingData] = this.sideNodesForRoot(key, this.root);
      const nonEmptySideNodes = [];
      for (let i = 0; i < sideNodes.length; i += 1) {
        if (sideNodes[i] !== "") {
          nonEmptySideNodes.push(sideNodes[i]);
        }
      }
      let nonMembershipLeafData = "";
      if (leafHash !== ZERO) {
        const [actualPath] = parseLeaf(leafData);
        if (actualPath !== key) {
          nonMembershipLeafData = leafData;
        }
      }
      const proof = new sparseMerkleProof_default(nonEmptySideNodes, nonMembershipLeafData, siblingData);
      return proof;
    }
    proveCompacted(key) {
      const proof = this.prove(key);
      const compactedProof = compactProof(proof);
      return compactedProof;
    }
  };

  // ../contract/dist/index.mjs
  var __defProp8 = Object.defineProperty;
  var __export2 = (target, all) => {
    for (var name in all)
      __defProp8(target, name, { get: all[name], enumerable: true });
  };
  var util_exports = {};
  __export2(util_exports, {
    getContractId: () => getContractId,
    getContractRoot: () => getContractRoot,
    getContractStorageRoot: () => getContractStorageRoot,
    hexlifyWithPrefix: () => hexlifyWithPrefix
  });
  var getContractRoot = (bytecode) => {
    const chunkSize = 16 * 1024;
    const bytes3 = getBytesCopy(bytecode);
    const chunks = chunkAndPadBytes(bytes3, chunkSize);
    return calcRoot(chunks.map((c) => hexlify(c)));
  };
  var getContractStorageRoot = (storageSlots) => {
    const tree = new SparseMerkleTree();
    storageSlots.forEach(({ key, value }) => tree.update(sha256(key), value));
    return tree.root;
  };
  var getContractId = (bytecode, salt, stateRoot) => {
    const root = getContractRoot(getBytesCopy(bytecode));
    const contractId = sha256(concat(["0x4655454C", salt, root, stateRoot]));
    return contractId;
  };
  var hexlifyWithPrefix = (value, isKnownHex = false) => {
    if (value.startsWith("0x")) {
      return hexlify(value);
    }
    if (isKnownHex) {
      return hexlify(`0x${value}`);
    }
    throw new FuelError(FuelError.CODES.UNEXPECTED_HEX_VALUE, `Value should be hex string ${value}.`);
  };
  var ContractFactory = class {
    bytecode;
    interface;
    provider;
    account;
    /**
     * Create a ContractFactory instance.
     *
     * @param bytecode - The bytecode of the contract.
     * @param abi - The contract's ABI (Application Binary Interface).
     * @param accountOrProvider - An account or provider to be associated with the factory.
     */
    constructor(bytecode, abi, accountOrProvider = null) {
      this.bytecode = getBytesCopy(bytecode);
      if (abi instanceof Interface) {
        this.interface = abi;
      } else {
        this.interface = new Interface(abi);
      }
      if (accountOrProvider && "provider" in accountOrProvider) {
        this.provider = accountOrProvider.provider;
        this.account = accountOrProvider;
      } else {
        this.provider = accountOrProvider;
        this.account = null;
      }
    }
    /**
     * Connect the factory to a provider.
     *
     * @param provider - The provider to be associated with the factory.
     * @returns A new ContractFactory instance.
     */
    connect(provider) {
      return new ContractFactory(this.bytecode, this.interface, provider);
    }
    /**
     * Create a transaction request to deploy a contract with the specified options.
     *
     * @param deployContractOptions - Options for deploying the contract.
     * @returns The CreateTransactionRequest object for deploying the contract.
     */
    createTransactionRequest(deployContractOptions) {
      const storageSlots = deployContractOptions?.storageSlots?.map(({ key, value }) => ({
        key: hexlifyWithPrefix(key, true),
        value: hexlifyWithPrefix(value, true)
      })).sort(({ key: keyA }, { key: keyB }) => keyA.localeCompare(keyB));
      const options = {
        salt: randomBytes22(32),
        ...deployContractOptions,
        storageSlots: storageSlots || []
      };
      if (!this.provider) {
        throw new FuelError(
          ErrorCode.MISSING_PROVIDER,
          "Cannot create transaction request without provider"
        );
      }
      const stateRoot = options.stateRoot || getContractStorageRoot(options.storageSlots);
      const contractId = getContractId(this.bytecode, options.salt, stateRoot);
      const transactionRequest = new CreateTransactionRequest({
        gasPrice: 0,
        gasLimit: 0,
        bytecodeWitnessIndex: 0,
        witnesses: [this.bytecode],
        ...options
      });
      transactionRequest.addContractCreatedOutput(contractId, stateRoot);
      return {
        contractId,
        transactionRequest
      };
    }
    /**
     * Deploy a contract with the specified options.
     *
     * @param deployContractOptions - Options for deploying the contract.
     * @returns A promise that resolves to the deployed contract instance.
     */
    async deployContract(deployContractOptions = {}) {
      if (!this.account) {
        throw new FuelError(ErrorCode.ACCOUNT_REQUIRED, "Cannot deploy Contract without account.");
      }
      const { configurableConstants } = deployContractOptions;
      if (configurableConstants) {
        this.setConfigurableConstants(configurableConstants);
      }
      const { contractId, transactionRequest } = this.createTransactionRequest(deployContractOptions);
      const { requiredQuantities, maxFee, gasUsed } = await this.account.provider.getTransactionCost(transactionRequest);
      transactionRequest.gasLimit = gasUsed;
      await this.account.fund(transactionRequest, requiredQuantities, maxFee);
      const response = await this.account.sendTransaction(transactionRequest);
      await response.wait();
      return new Contract(contractId, this.interface, this.account);
    }
    /**
     * Set configurable constants of the contract with the specified values.
     *
     * @param configurableConstants - An object containing configurable names and their values.
     */
    setConfigurableConstants(configurableConstants) {
      try {
        const hasConfigurable = Object.keys(this.interface.configurables).length;
        if (!hasConfigurable) {
          throw new Error("Contract does not have configurables to be set");
        }
        Object.entries(configurableConstants).forEach(([key, value]) => {
          if (!this.interface.configurables[key]) {
            throw new Error(`Contract does not have a configurable named: '${key}'`);
          }
          const { offset } = this.interface.configurables[key];
          const encoded = this.interface.encodeConfigurable(key, value);
          const bytes3 = getBytesCopy(this.bytecode);
          bytes3.set(encoded, offset);
          this.bytecode = bytes3;
        });
      } catch (err) {
        throw new FuelError(
          ErrorCode.INVALID_CONFIGURABLE_CONSTANTS,
          `Error setting configurable constants on contract: ${err.message}.`
        );
      }
    }
  };

  // src/cli/commands/deploy/deployContract.ts
  var import_fs6 = __require2("fs");
  async function deployContract(wallet, binaryPath, abiPath, storageSlotsPath, deployConfig) {
    debug(`Deploying contract for ABI: ${abiPath}`);
    const bytecode = (0, import_fs6.readFileSync)(binaryPath);
    if ((0, import_fs6.existsSync)(storageSlotsPath)) {
      const storageSlots = JSON.parse((0, import_fs6.readFileSync)(storageSlotsPath, "utf-8"));
      deployConfig.storageSlots = storageSlots;
    }
    const { minGasPrice: gasPrice } = wallet.provider.getGasConfig();
    const abi = JSON.parse((0, import_fs6.readFileSync)(abiPath, "utf-8"));
    const contractFactory = new ContractFactory(bytecode, abi, wallet);
    deployConfig.gasPrice = deployConfig.gasPrice ?? gasPrice;
    const contract = await contractFactory.deployContract(deployConfig);
    return contract.id.toB256();
  }

  // src/cli/commands/deploy/getDeployConfig.ts
  async function getDeployConfig(deployConfig, options) {
    let config;
    if (typeof deployConfig === "function") {
      config = await deployConfig(options);
    } else {
      config = deployConfig;
    }
    return config;
  }

  // src/cli/commands/deploy/saveContractIds.ts
  var import_promises2 = __require2("fs/promises");
  var import_path13 = __require2("path");
  async function saveContractIds(contracts, output3) {
    const contractsMap = contracts.reduce(
      (cConfig, { name, contractId }) => ({
        ...cConfig,
        [name]: contractId
      }),
      {}
    );
    const filePath = (0, import_path13.resolve)(output3, "contract-ids.json");
    await (0, import_promises2.mkdir)(output3, { recursive: true });
    await (0, import_promises2.writeFile)(filePath, JSON.stringify(contractsMap, null, 2));
    log(`Contract IDs saved at: ${filePath}`);
  }

  // src/cli/commands/deploy/index.ts
  async function deploy(config) {
    const contracts = [];
    const wallet = await createWallet(config.providerUrl, config.privateKey);
    log(`Deploying contracts to: ${wallet.provider.url}`);
    const contractsLen = config.contracts.length;
    for (let i = 0; i < contractsLen; i++) {
      const contractPath = config.contracts[i];
      const binaryPath = getBinaryPath(contractPath);
      const abiPath = getABIPath(contractPath);
      const storageSlotsPath = getStorageSlotsPath(contractPath);
      const projectName = getContractName(contractPath);
      const contractName = getContractCamelCase(contractPath);
      const deployConfig = await getDeployConfig(config.deployConfig, {
        contracts: Array.from(contracts),
        contractName,
        contractPath
      });
      const contractId = await deployContract(
        wallet,
        binaryPath,
        abiPath,
        storageSlotsPath,
        deployConfig
      );
      debug(`Contract deployed: ${projectName} - ${contractId}`);
      contracts.push({
        name: contractName,
        contractId
      });
    }
    await saveContractIds(contracts, config.output);
    return contracts;
  }

  // src/cli/commands/dev/startFuelCore.ts
  var import_child_process2 = __require2("child_process");
  var import_fs8 = __require2("fs");
  var import_path15 = __require2("path");
  var import_portfinder = __toESM(require_portfinder());
  var import_tree_kill = __toESM(require_tree_kill());

  // src/cli/utils/findBinPath.ts
  var import_fs7 = __require2("fs");
  var import_path14 = __require2("path");
  var npmWhich = require_npm_which()(__dirname);
  function findBinPath(binCommandName) {
    let binPath = npmWhich.sync(binCommandName);
    if (!(0, import_fs7.existsSync)(binPath)) {
      binPath = (0, import_path14.join)("node_modules", ".bin", binCommandName);
    }
    return binPath;
  }

  // src/cli/utils/getBinarySource.ts
  var import_chalk5 = __toESM(require_source());
  var getBinarySource = (useBuiltIn) => ({
    true: import_chalk5.default.cyan("built-in"),
    false: import_chalk5.default.green("source")
  })[`${useBuiltIn}`];

  // src/cli/commands/dev/defaultChainConfig.ts
  var defaultConsensusKey = "0xa449b1ffee0e2205fa924c6740cc48b3b473aa28587df6dab12abc245d1f5298";
  var defaultChainConfig = {
    chain_name: "local_testnet",
    block_gas_limit: 5e9,
    initial_state: {
      coins: [
        {
          owner: "0x94ffcc53b892684acefaebc8a3d4a595e528a8cf664eeb3ef36f1020b0809d0d",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          owner: "0x09c0b2d1a486c439a87bcba6b46a7a1a23f3897cc83a94521a96da5c23bc58db",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          owner: "0x5d99ee966b42cd8fc7bdd1364b389153a9e78b42b7d4a691470674e817888d4e",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          owner: "0xbdaad6a89e073e177895b3e5a9ccd15806749eda134a6438dae32fc5b6601f3f",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          owner: "0x95a7aa6cc32743f8706c40ef49a7423b47da763bb4bbc055b1f07254dc729036",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          owner: "0xcee104acd38b940c8f1c62c6d7ea00a0ad2241d6dee0509a4bf27297508870d3",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          owner: "0x7e3626e306588eba79cafab73f0709e55ab8f4bdfe8c8b75034a430fc56ece89",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          owner: "0x1c31df52b6df56407dd95f83082e8beb9cfc9532ac111d5bd8491651d95ba775",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          owner: "0x09dd7a49174d6fcc9f4c6f7942c18060a935ddd03ee69b594189b8c3581276ea",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
        },
        {
          owner: "0x86604282dc604481b809845be49667607c470644f6822fc01eb0d22f167e08cf",
          amount: "0xFFFFFFFFFFFFFFFF",
          asset_id: "0x0000000000000000000000000000000000000000000000000000000000000000"
        }
      ],
      messages: [
        {
          sender: "0xc43454aa38dd91f88109a4b7aef5efb96ce34e3f24992fe0f81d233ca686f80f",
          recipient: "0x69a2b736b60159b43bb8a4f98c0589f6da5fa3a3d101e8e269c499eb942753ba",
          nonce: "0101010101010101010101010101010101010101010101010101010101010101",
          amount: "0x000000000000FFFF",
          data: "",
          da_height: "0x00"
        },
        {
          sender: "0x69a2b736b60159b43bb8a4f98c0589f6da5fa3a3d101e8e269c499eb942753ba",
          recipient: "0xc43454aa38dd91f88109a4b7aef5efb96ce34e3f24992fe0f81d233ca686f80f",
          nonce: "0e1ef2963832068b0e1ef2963832068b0e1ef2963832068b0e1ef2963832068b",
          amount: "0xb04f3c08f59b309e",
          data: "",
          da_height: "0x00"
        }
      ]
    },
    transaction_parameters: {
      contract_max_size: 16777216,
      max_inputs: 255,
      max_outputs: 255,
      max_witnesses: 255,
      max_gas_per_tx: 5e8,
      max_script_length: 1048576,
      max_script_data_length: 1048576,
      max_static_contracts: 255,
      max_storage_slots: 255,
      max_predicate_length: 1048576,
      max_predicate_data_length: 1048576,
      max_gas_per_predicate: 1e8,
      gas_price_factor: 1e9,
      gas_per_byte: 4,
      max_message_data_length: 1048576
    },
    gas_costs: {
      add: 1,
      addi: 1,
      aloc: 1,
      and: 1,
      andi: 1,
      bal: 21,
      bhei: 1,
      bhsh: 1,
      burn: 35,
      cb: 2,
      cfei: 1,
      cfsi: 1,
      croo: 28,
      div: 1,
      divi: 1,
      ecr: 1703,
      eq: 1,
      exp: 1,
      expi: 1,
      flag: 1,
      gm: 1,
      gt: 1,
      gtf: 1,
      ji: 1,
      jmp: 1,
      jne: 1,
      jnei: 1,
      jnzi: 1,
      k256: 19,
      lb: 1,
      log: 40,
      lt: 1,
      lw: 1,
      mcpi: 3,
      mint: 35,
      mlog: 1,
      mod: 1,
      modi: 1,
      move: 1,
      movi: 1,
      mroo: 2,
      mul: 1,
      muli: 1,
      noop: 1,
      not: 1,
      or: 1,
      ori: 1,
      ret_contract: 61,
      rvrt_contract: 61,
      s256: 5,
      sb: 1,
      scwq: 11,
      sll: 1,
      slli: 1,
      srl: 1,
      srli: 1,
      srw: 23,
      sub: 1,
      subi: 1,
      sw: 1,
      sww: 79,
      swwq: 72,
      time: 1,
      tr: 120,
      tro: 99,
      xor: 1,
      xori: 1,
      call: {
        base: 116,
        dep_per_unit: 14
      },
      ccp: {
        base: 24,
        dep_per_unit: 13
      },
      csiz: {
        base: 17,
        dep_per_unit: 15
      },
      ldc: {
        base: 23,
        dep_per_unit: 14
      },
      logd: {
        base: 46,
        dep_per_unit: 19
      },
      mcl: {
        base: 1,
        dep_per_unit: 2359
      },
      mcli: {
        base: 1,
        dep_per_unit: 2322
      },
      mcp: {
        base: 1,
        dep_per_unit: 1235
      },
      meq: {
        base: 1,
        dep_per_unit: 2343
      },
      retd_contract: {
        base: 65,
        dep_per_unit: 19
      },
      smo: {
        base: 84,
        dep_per_unit: 13
      },
      srwq: {
        base: 54,
        dep_per_unit: 2
      }
    },
    consensus: {
      PoA: {
        signing_key: "0x94ffcc53b892684acefaebc8a3d4a595e528a8cf664eeb3ef36f1020b0809d0d"
      }
    }
  };

  // src/cli/commands/dev/startFuelCore.ts
  var killNode = (params) => () => {
    const { core, state, killFn } = params;
    if (core.pid && !state.isDead) {
      state.isDead = true;
      killFn(Number(core.pid));
    }
  };
  var createTempChainConfig = (coreDir) => {
    const chainConfigPath = (0, import_path15.join)(coreDir, "chainConfig.json");
    const chainConfigJson = JSON.stringify(defaultChainConfig, null, 2);
    (0, import_fs8.mkdirSync)((0, import_path15.dirname)(chainConfigPath), { recursive: true });
    (0, import_fs8.writeFileSync)(chainConfigPath, chainConfigJson);
    return chainConfigPath;
  };
  var startFuelCore = async (config) => {
    log(`Starting ${getBinarySource(config.useBuiltinFuelCore)} 'fuel-core' node..`);
    const coreDir = (0, import_path15.join)(config.basePath, ".fuels");
    const bindIp = "0.0.0.0";
    const accessIp = "127.0.0.1";
    const chainConfig = config.chainConfig ?? createTempChainConfig(coreDir);
    const port = config.fuelCorePort ?? await (0, import_portfinder.getPortPromise)({ port: 4e3 });
    const providerUrl = `http://${accessIp}:${port}/graphql`;
    const flags = [
      "run",
      ["--ip", bindIp],
      ["--port", port.toString()],
      ["--db-path", coreDir],
      ["--min-gas-price", "0"],
      ["--poa-instant", "true"],
      ["--consensus-key", defaultConsensusKey],
      ["--chain", chainConfig],
      "--vm-backtrace",
      "--utxo-validation",
      "--manual_blocks_enabled"
    ].flat();
    return new Promise((resolve4, reject) => {
      const builtInFuelsCorePath = findBinPath("fuels-core");
      const command = config.useBuiltinFuelCore ? builtInFuelsCorePath : "fuel-core";
      const core = (0, import_child_process2.spawn)(command, flags, { stdio: "pipe" });
      if (loggingConfig.isLoggingEnabled) {
        core.stderr.pipe(process.stderr);
      }
      if (loggingConfig.isDebugEnabled) {
        core.stdout.pipe(process.stdout);
      }
      const state = { isDead: false };
      const killChildProcess = killNode({ core, state, killFn: import_tree_kill.default });
      process.on("beforeExit", killChildProcess);
      process.on("uncaughtException", killChildProcess);
      core.stderr?.on("data", (data) => {
        if (/Binding GraphQL provider to/.test(data)) {
          resolve4({
            bindIp,
            accessIp,
            port,
            providerUrl,
            killChildProcess,
            chainConfig
          });
        }
        if (/error/i.test(data)) {
          error(
            `Some error occurred. Please, check to see if you have another instance running locally.`
          );
          reject(data.toString());
        }
      });
      core.on("error", reject);
    });
  };
  var autoStartFuelCore = async (config) => {
    let fuelCore;
    if (config.autoStartFuelCore) {
      fuelCore = await startFuelCore(config);
      config.providerUrl = fuelCore.providerUrl;
      config.privateKey = defaultConsensusKey;
    }
    return fuelCore;
  };

  // src/cli/commands/build/buildSwayPrograms.ts
  var import_child_process3 = __require2("child_process");
  var onForcExit = (onResultFn, onErrorFn) => (code) => {
    if (code) {
      onErrorFn(code);
    } else {
      onResultFn();
    }
  };
  var onForcError = (onError) => (err) => {
    error(err);
    onError(err);
  };
  var buildSwayProgram = async (config, path4) => {
    debug("Building Sway program", path4);
    return new Promise((resolve4, reject) => {
      const builtInForcPath = findBinPath("fuels-forc");
      const command = config.useBuiltinForc ? builtInForcPath : "forc";
      const forc = (0, import_child_process3.spawn)(command, ["build", "-p", path4], { stdio: "pipe" });
      if (loggingConfig.isLoggingEnabled) {
        forc.stderr?.pipe(process.stderr);
      }
      if (loggingConfig.isDebugEnabled) {
        forc.stdout?.pipe(process.stdout);
      }
      const onExit = onForcExit(resolve4, reject);
      const onError = onForcError(reject);
      forc.on("exit", onExit);
      forc.on("error", onError);
    });
  };
  async function buildSwayPrograms(config) {
    log(`Building Sway programs using ${getBinarySource(config.useBuiltinFuelCore)} 'forc' binary`);
    const paths = config.workspace ? [config.workspace] : [config.contracts, config.predicates, config.scripts].flat();
    await Promise.all(paths.map((path4) => buildSwayProgram(config, path4)));
  }

  // ../abi-typegen/dist/index.mjs
  var import_handlebars2 = __toESM(require_lib(), 1);
  var __defProp9 = Object.defineProperty;
  var __defNormalProp8 = (obj, key, value) => key in obj ? __defProp9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField8 = (obj, key, value) => {
    __defNormalProp8(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  function findType2(params) {
    const { types: types2, typeId } = params;
    const foundType = types2.find(({ rawAbiType: { typeId: tid } }) => tid === typeId);
    if (!foundType) {
      throw new FuelError(ErrorCode.TYPE_ID_NOT_FOUND, `Type ID not found: ${typeId}.`);
    }
    foundType.parseComponentsAttributes({ types: types2 });
    return foundType;
  }
  function parseTypeArguments2(params) {
    const { types: types2, typeArguments, parentTypeId, target } = params;
    const attributeKey = `${target}Label`;
    const buffer = [];
    let parentType;
    let parentLabel;
    if (parentTypeId !== void 0) {
      parentType = findType2({ types: types2, typeId: parentTypeId });
      parentLabel = parentType.attributes[attributeKey];
    }
    typeArguments.forEach((typeArgument) => {
      let currentLabel;
      const currentTypeId = typeArgument.type;
      try {
        const currentType = findType2({ types: types2, typeId: currentTypeId });
        currentLabel = currentType.attributes[attributeKey];
      } catch (_err) {
        currentLabel = "void";
      }
      if (typeArgument.typeArguments) {
        const nestedParsed = parseTypeArguments2({
          types: types2,
          target,
          parentTypeId: typeArgument.type,
          typeArguments: typeArgument.typeArguments
        });
        buffer.push(nestedParsed);
      } else {
        buffer.push(`${currentLabel}`);
      }
    });
    let output3 = buffer.join(", ");
    if (parentLabel) {
      output3 = `${parentLabel}<${output3}>`;
    }
    return output3;
  }
  var AType2 = class {
    rawAbiType;
    attributes;
    requiredFuelsMembersImports;
    constructor(params) {
      this.rawAbiType = params.rawAbiType;
      this.attributes = {
        inputLabel: "unknown",
        outputLabel: "unknown"
      };
      this.requiredFuelsMembersImports = [];
    }
  };
  var _ArrayType2 = class extends AType2 {
    name = "array";
    static isSuitableFor(params) {
      return _ArrayType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(params) {
      const { types: types2 } = params;
      const { type: type3 } = this.rawAbiType;
      const arrayLen = Number(type3.match(_ArrayType2.MATCH_REGEX)?.[1]);
      const inputs = [];
      const outputs = [];
      this.rawAbiType.components?.forEach((component) => {
        const { type: typeId, typeArguments } = component;
        if (!typeArguments) {
          const { attributes } = findType2({ types: types2, typeId });
          inputs.push(attributes.inputLabel);
          outputs.push(attributes.outputLabel);
        } else {
          const inputLabel = parseTypeArguments2({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "input"
            /* INPUT */
          });
          const outputLabel = parseTypeArguments2({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "output"
            /* OUTPUT */
          });
          inputs.push(inputLabel);
          outputs.push(outputLabel);
        }
      });
      const inputTypes = Array(arrayLen).fill(inputs[0]).join(", ");
      const outputTypes = Array(arrayLen).fill(outputs[0]).join(", ");
      this.attributes = {
        inputLabel: `[${inputTypes}]`,
        outputLabel: `[${outputTypes}]`
      };
      return this.attributes;
    }
  };
  var ArrayType2 = _ArrayType2;
  __publicField8(ArrayType2, "swayType", "[_; 2]");
  __publicField8(ArrayType2, "MATCH_REGEX", /^\[_; ([0-9]+)\]$/m);
  var _StrType2 = class extends AType2 {
    name = "str";
    static isSuitableFor(params) {
      return _StrType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: "string",
        outputLabel: "string"
      };
      return this.attributes;
    }
  };
  var StrType2 = _StrType2;
  __publicField8(StrType2, "swayType", "str[3]");
  __publicField8(StrType2, "MATCH_REGEX", /^str\[(.+)\]$/m);
  var _B256Type2 = class extends StrType2 {
    name = "b256";
    static isSuitableFor(params) {
      return _B256Type2.MATCH_REGEX.test(params.type);
    }
  };
  var B256Type2 = _B256Type2;
  __publicField8(B256Type2, "swayType", "b256");
  __publicField8(B256Type2, "MATCH_REGEX", /^b256$/m);
  var _B512Type2 = class extends B256Type2 {
    name = "b512";
    static isSuitableFor(params) {
      return _B512Type2.MATCH_REGEX.test(params.type);
    }
  };
  var B512Type2 = _B512Type2;
  __publicField8(B512Type2, "swayType", "struct B512");
  __publicField8(B512Type2, "MATCH_REGEX", /^struct B512$/m);
  var _BoolType2 = class extends AType2 {
    name = "bool";
    static isSuitableFor(params) {
      return _BoolType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: "boolean",
        outputLabel: "boolean"
      };
      return this.attributes;
    }
  };
  var BoolType2 = _BoolType2;
  __publicField8(BoolType2, "swayType", "bool");
  __publicField8(BoolType2, "MATCH_REGEX", /^bool$/m);
  var _BytesType2 = class extends ArrayType2 {
    name = "bytes";
    static isSuitableFor(params) {
      return _BytesType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "Bytes";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var BytesType2 = _BytesType2;
  __publicField8(BytesType2, "swayType", "struct Bytes");
  __publicField8(BytesType2, "MATCH_REGEX", /^struct Bytes/m);
  function extractStructName2(params) {
    const { rawAbiType, regex } = params;
    const match3 = rawAbiType.type.match(params.regex)?.[1];
    if (!match3) {
      let errorMessage = `Couldn't extract struct name with: '${regex}'.

`;
      errorMessage += `Check your JSON ABI.

[source]
`;
      errorMessage += `${JSON.stringify(rawAbiType, null, 2)}`;
      throw new FuelError(ErrorCode.JSON_ABI_ERROR, errorMessage);
    }
    return match3;
  }
  var _EnumType2 = class extends AType2 {
    name = "enum";
    static isSuitableFor(params) {
      const isAMatch = _EnumType2.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _EnumType2.IGNORE_REGEX.test(params.type);
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      const structName = this.getStructName();
      this.attributes = {
        structName,
        inputLabel: `${structName}Input`,
        outputLabel: `${structName}Output`
      };
      return this.attributes;
    }
    getStructName() {
      const name = extractStructName2({
        rawAbiType: this.rawAbiType,
        regex: _EnumType2.MATCH_REGEX
      });
      return name;
    }
    getNativeEnum(params) {
      const { types: types2 } = params;
      const typeHash = types2.reduce(
        (hash5, row) => ({
          ...hash5,
          [row.rawAbiType.typeId]: row
        }),
        {}
      );
      const { components } = this.rawAbiType;
      const enumComponents = components;
      if (!enumComponents.every(({ type: type3 }) => !typeHash[type3])) {
        return void 0;
      }
      return enumComponents.map(({ name }) => `${name} = '${name}'`).join(", ");
    }
    getStructContents(params) {
      const { types: types2, target } = params;
      const { components } = this.rawAbiType;
      const enumComponents = components;
      const attributeKey = `${target}Label`;
      const contents = enumComponents.map((component) => {
        const { name, type: typeId } = component;
        if (typeId === 0) {
          return `${name}: []`;
        }
        const { attributes } = findType2({ types: types2, typeId });
        return `${name}: ${attributes[attributeKey]}`;
      });
      return contents.join(", ");
    }
  };
  var EnumType2 = _EnumType2;
  __publicField8(EnumType2, "swayType", "enum MyEnumName");
  __publicField8(EnumType2, "MATCH_REGEX", /^enum (.+)$/m);
  __publicField8(EnumType2, "IGNORE_REGEX", /^enum Option$/m);
  var _EvmAddressType2 = class extends AType2 {
    name = "evmAddress";
    static isSuitableFor(params) {
      return _EvmAddressType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "EvmAddress";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var EvmAddressType2 = _EvmAddressType2;
  __publicField8(EvmAddressType2, "swayType", "struct EvmAddress");
  __publicField8(EvmAddressType2, "MATCH_REGEX", /^struct EvmAddress$/m);
  var _GenericType2 = class extends AType2 {
    name = "generic";
    static isSuitableFor(params) {
      return _GenericType2.MATCH_REGEX.test(params.type);
    }
    getStructName() {
      const name = extractStructName2({
        rawAbiType: this.rawAbiType,
        regex: _GenericType2.MATCH_REGEX
      });
      return name;
    }
    parseComponentsAttributes(_params) {
      const label = this.getStructName();
      this.attributes = {
        inputLabel: label,
        outputLabel: label
      };
      return this.attributes;
    }
  };
  var GenericType2 = _GenericType2;
  __publicField8(GenericType2, "swayType", "generic T");
  __publicField8(GenericType2, "MATCH_REGEX", /^generic ([^\s]+)$/m);
  var _OptionType2 = class extends AType2 {
    name = "option";
    static isSuitableFor(params) {
      return _OptionType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `Option`,
        outputLabel: `Option`
      };
      return this.attributes;
    }
  };
  var OptionType2 = _OptionType2;
  __publicField8(OptionType2, "swayType", "enum Option");
  __publicField8(OptionType2, "MATCH_REGEX", /^enum Option$/m);
  var _U8Type2 = class extends AType2 {
    name = "u8";
    constructor(params) {
      super(params);
      this.attributes = {
        inputLabel: `BigNumberish`,
        outputLabel: `number`
      };
      this.requiredFuelsMembersImports = [this.attributes.inputLabel];
    }
    static isSuitableFor(params) {
      return _U8Type2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      return this.attributes;
    }
  };
  var U8Type2 = _U8Type2;
  __publicField8(U8Type2, "swayType", "u8");
  __publicField8(U8Type2, "MATCH_REGEX", /^u8$/m);
  var _U64Type2 = class extends U8Type2 {
    name = "u64";
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `BigNumberish`,
        outputLabel: `BN`
      };
      this.requiredFuelsMembersImports = Object.values(this.attributes);
      return this.attributes;
    }
    static isSuitableFor(params) {
      return _U64Type2.MATCH_REGEX.test(params.type);
    }
  };
  var U64Type2 = _U64Type2;
  __publicField8(U64Type2, "swayType", "u64");
  __publicField8(U64Type2, "MATCH_REGEX", /^u64$/m);
  var _RawUntypedPtr2 = class extends U64Type2 {
    name = "rawUntypedPtr";
    static isSuitableFor(params) {
      return _RawUntypedPtr2.MATCH_REGEX.test(params.type);
    }
  };
  var RawUntypedPtr2 = _RawUntypedPtr2;
  __publicField8(RawUntypedPtr2, "swayType", "raw untyped ptr");
  __publicField8(RawUntypedPtr2, "MATCH_REGEX", /^raw untyped ptr$/m);
  var _RawUntypedSlice2 = class extends ArrayType2 {
    name = "rawUntypedSlice";
    static isSuitableFor(params) {
      return _RawUntypedSlice2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "RawSlice";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var RawUntypedSlice2 = _RawUntypedSlice2;
  __publicField8(RawUntypedSlice2, "swayType", "raw untyped slice");
  __publicField8(RawUntypedSlice2, "MATCH_REGEX", /^raw untyped slice$/m);
  var _StdStringType2 = class extends AType2 {
    name = "stdString";
    static isSuitableFor(params) {
      return _StdStringType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "StdString";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var StdStringType2 = _StdStringType2;
  __publicField8(StdStringType2, "swayType", "struct String");
  __publicField8(StdStringType2, "MATCH_REGEX", /^struct String/m);
  var _StrSliceType2 = class extends AType2 {
    name = "strSlice";
    static isSuitableFor(params) {
      return _StrSliceType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: "StrSlice",
        outputLabel: "StrSlice"
      };
      return this.attributes;
    }
  };
  var StrSliceType2 = _StrSliceType2;
  __publicField8(StrSliceType2, "swayType", "str");
  __publicField8(StrSliceType2, "MATCH_REGEX", /^str$/m);
  var _StructType2 = class extends AType2 {
    name = "struct";
    static isSuitableFor(params) {
      const isAMatch = _StructType2.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _StructType2.IGNORE_REGEX.test(params.type);
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      const structName = this.getStructName();
      this.attributes = {
        structName,
        inputLabel: `${structName}Input`,
        outputLabel: `${structName}Output`
      };
      return this.attributes;
    }
    getStructName() {
      const name = extractStructName2({
        rawAbiType: this.rawAbiType,
        regex: _StructType2.MATCH_REGEX
      });
      return name;
    }
    getStructContents(params) {
      const { types: types2, target } = params;
      const { components } = this.rawAbiType;
      const structComponents = components;
      const members = structComponents.map((component) => {
        const { name, type: typeId, typeArguments } = component;
        const type3 = findType2({ types: types2, typeId });
        let typeDecl;
        if (typeArguments) {
          typeDecl = parseTypeArguments2({
            types: types2,
            target,
            parentTypeId: typeId,
            typeArguments
          });
        } else {
          const attributeKey = `${target}Label`;
          typeDecl = type3.attributes[attributeKey];
        }
        return `${name}: ${typeDecl}`;
      });
      return members.join(", ");
    }
    getStructDeclaration(params) {
      const { types: types2 } = params;
      const { typeParameters } = this.rawAbiType;
      if (typeParameters) {
        const structs = typeParameters.map((typeId) => findType2({ types: types2, typeId }));
        const labels = structs.map(({ attributes: { inputLabel } }) => inputLabel);
        return `<${labels.join(", ")}>`;
      }
      return "";
    }
  };
  var StructType2 = _StructType2;
  __publicField8(StructType2, "swayType", "struct MyStruct");
  __publicField8(StructType2, "MATCH_REGEX", /^struct (.+)$/m);
  __publicField8(StructType2, "IGNORE_REGEX", /^struct (Vec|RawVec|EvmAddress|Bytes|String)$/m);
  var _TupleType2 = class extends AType2 {
    name = "tupple";
    static isSuitableFor(params) {
      return _TupleType2.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(params) {
      const { types: types2 } = params;
      const inputs = [];
      const outputs = [];
      this.rawAbiType.components?.forEach((component) => {
        const { type: typeId, typeArguments } = component;
        if (!typeArguments) {
          const { attributes } = findType2({ types: types2, typeId });
          inputs.push(attributes.inputLabel);
          outputs.push(attributes.outputLabel);
        } else {
          const inputLabel = parseTypeArguments2({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "input"
            /* INPUT */
          });
          const outputLabel = parseTypeArguments2({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "output"
            /* OUTPUT */
          });
          inputs.push(inputLabel);
          outputs.push(outputLabel);
        }
      });
      this.attributes = {
        inputLabel: `[${inputs.join(", ")}]`,
        outputLabel: `[${outputs.join(", ")}]`
      };
      return this.attributes;
    }
  };
  var TupleType2 = _TupleType2;
  __publicField8(TupleType2, "swayType", "(_, _, _)");
  __publicField8(TupleType2, "MATCH_REGEX", /^\([_,\s]+\)$/m);
  var _U16Type2 = class extends U8Type2 {
    name = "u16";
    static isSuitableFor(params) {
      return _U16Type2.MATCH_REGEX.test(params.type);
    }
  };
  var U16Type2 = _U16Type2;
  __publicField8(U16Type2, "swayType", "u16");
  __publicField8(U16Type2, "MATCH_REGEX", /^u16$/m);
  var _U32Type2 = class extends U8Type2 {
    name = "u32";
    static isSuitableFor(params) {
      return _U32Type2.MATCH_REGEX.test(params.type);
    }
  };
  var U32Type2 = _U32Type2;
  __publicField8(U32Type2, "swayType", "u32");
  __publicField8(U32Type2, "MATCH_REGEX", /^u32$/m);
  var _VectorType2 = class extends ArrayType2 {
    name = "vector";
    static isSuitableFor(params) {
      const isAMatch = _VectorType2.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _VectorType2.IGNORE_REGEX.test(params.type);
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `Vec`,
        outputLabel: `Vec`
      };
      return this.attributes;
    }
  };
  var VectorType2 = _VectorType2;
  __publicField8(VectorType2, "swayType", "struct Vec");
  __publicField8(VectorType2, "MATCH_REGEX", /^struct Vec/m);
  __publicField8(VectorType2, "IGNORE_REGEX", /^struct RawVec$/m);
  var ProgramTypeEnum2 = /* @__PURE__ */ ((ProgramTypeEnum22) => {
    ProgramTypeEnum22["CONTRACT"] = "contract";
    ProgramTypeEnum22["SCRIPT"] = "script";
    ProgramTypeEnum22["PREDICATE"] = "predicate";
    return ProgramTypeEnum22;
  })(ProgramTypeEnum2 || {});

  // ../abi-typegen/dist/runTypegen.mjs
  var import_fs9 = __require2("fs");
  var import_mkdirp2 = __toESM(require_mkdirp(), 1);
  var import_path16 = __require2("path");
  var import_rimraf2 = __toESM(require_rimraf(), 1);
  var import_path17 = __require2("path");
  var import_handlebars3 = __toESM(require_lib(), 1);
  var import_path18 = __require2("path");
  var import_path19 = __require2("path");
  var import_fs10 = __require2("fs");
  var import_fs11 = __require2("fs");
  var __defProp10 = Object.defineProperty;
  var __defNormalProp9 = (obj, key, value) => key in obj ? __defProp10(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField9 = (obj, key, value) => {
    __defNormalProp9(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  function findType3(params) {
    const { types: types2, typeId } = params;
    const foundType = types2.find(({ rawAbiType: { typeId: tid } }) => tid === typeId);
    if (!foundType) {
      throw new FuelError(ErrorCode.TYPE_ID_NOT_FOUND, `Type ID not found: ${typeId}.`);
    }
    foundType.parseComponentsAttributes({ types: types2 });
    return foundType;
  }
  var Configurable2 = class {
    name;
    type;
    rawAbiConfigurable;
    constructor(params) {
      const { types: types2, rawAbiConfigurable } = params;
      this.name = rawAbiConfigurable.name;
      this.rawAbiConfigurable = rawAbiConfigurable;
      this.type = findType3({ types: types2, typeId: rawAbiConfigurable.configurableType.type });
    }
  };
  function makeConfigurable2(params) {
    const { types: types2, rawAbiConfigurable } = params;
    return new Configurable2({ types: types2, rawAbiConfigurable });
  }
  function parseConfigurables2(params) {
    const { types: types2, rawAbiConfigurables } = params;
    const configurables = rawAbiConfigurables.map(
      (rawAbiConfigurable) => makeConfigurable2({ types: types2, rawAbiConfigurable })
    );
    return configurables;
  }
  function parseTypeArguments3(params) {
    const { types: types2, typeArguments, parentTypeId, target } = params;
    const attributeKey = `${target}Label`;
    const buffer = [];
    let parentType;
    let parentLabel;
    if (parentTypeId !== void 0) {
      parentType = findType3({ types: types2, typeId: parentTypeId });
      parentLabel = parentType.attributes[attributeKey];
    }
    typeArguments.forEach((typeArgument) => {
      let currentLabel;
      const currentTypeId = typeArgument.type;
      try {
        const currentType = findType3({ types: types2, typeId: currentTypeId });
        currentLabel = currentType.attributes[attributeKey];
      } catch (_err) {
        currentLabel = "void";
      }
      if (typeArgument.typeArguments) {
        const nestedParsed = parseTypeArguments3({
          types: types2,
          target,
          parentTypeId: typeArgument.type,
          typeArguments: typeArgument.typeArguments
        });
        buffer.push(nestedParsed);
      } else {
        buffer.push(`${currentLabel}`);
      }
    });
    let output3 = buffer.join(", ");
    if (parentLabel) {
      output3 = `${parentLabel}<${output3}>`;
    }
    return output3;
  }
  var Function3 = class {
    name;
    types;
    rawAbiFunction;
    attributes;
    constructor(params) {
      this.rawAbiFunction = params.rawAbiFunction;
      this.types = params.types;
      this.name = params.rawAbiFunction.name;
      this.attributes = {
        inputs: this.bundleInputTypes(),
        output: this.bundleOutputTypes(),
        prefixedInputs: this.bundleInputTypes(true)
      };
    }
    bundleInputTypes(shouldPrefixParams = false) {
      const { types: types2 } = this;
      const inputs = this.rawAbiFunction.inputs.map((input) => {
        const { name, type: typeId, typeArguments } = input;
        const type3 = findType3({ types: types2, typeId });
        let typeDecl;
        if (typeArguments) {
          typeDecl = parseTypeArguments3({
            types: types2,
            target: "input",
            parentTypeId: typeId,
            typeArguments
          });
        } else {
          typeDecl = type3.attributes.inputLabel;
        }
        if (shouldPrefixParams) {
          return `${name}: ${typeDecl}`;
        }
        return typeDecl;
      });
      return inputs.join(", ");
    }
    bundleOutputTypes() {
      return parseTypeArguments3({
        types: this.types,
        target: "output",
        typeArguments: [this.rawAbiFunction.output]
      });
    }
    getDeclaration() {
      const { name } = this;
      const { prefixedInputs, output: output3 } = this.attributes;
      const decl = `${name}: InvokeFunction<[${prefixedInputs}], ${output3}>`;
      return decl;
    }
  };
  function makeFunction2(params) {
    const { types: types2, rawAbiFunction } = params;
    return new Function3({ types: types2, rawAbiFunction });
  }
  function parseFunctions2(params) {
    const { types: types2, rawAbiFunctions } = params;
    const functions = rawAbiFunctions.map(
      (rawAbiFunction) => makeFunction2({ types: types2, rawAbiFunction })
    );
    return functions;
  }
  var AType3 = class {
    rawAbiType;
    attributes;
    requiredFuelsMembersImports;
    constructor(params) {
      this.rawAbiType = params.rawAbiType;
      this.attributes = {
        inputLabel: "unknown",
        outputLabel: "unknown"
      };
      this.requiredFuelsMembersImports = [];
    }
  };
  var _ArrayType3 = class extends AType3 {
    name = "array";
    static isSuitableFor(params) {
      return _ArrayType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(params) {
      const { types: types2 } = params;
      const { type: type3 } = this.rawAbiType;
      const arrayLen = Number(type3.match(_ArrayType3.MATCH_REGEX)?.[1]);
      const inputs = [];
      const outputs = [];
      this.rawAbiType.components?.forEach((component) => {
        const { type: typeId, typeArguments } = component;
        if (!typeArguments) {
          const { attributes } = findType3({ types: types2, typeId });
          inputs.push(attributes.inputLabel);
          outputs.push(attributes.outputLabel);
        } else {
          const inputLabel = parseTypeArguments3({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "input"
            /* INPUT */
          });
          const outputLabel = parseTypeArguments3({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "output"
            /* OUTPUT */
          });
          inputs.push(inputLabel);
          outputs.push(outputLabel);
        }
      });
      const inputTypes = Array(arrayLen).fill(inputs[0]).join(", ");
      const outputTypes = Array(arrayLen).fill(outputs[0]).join(", ");
      this.attributes = {
        inputLabel: `[${inputTypes}]`,
        outputLabel: `[${outputTypes}]`
      };
      return this.attributes;
    }
  };
  var ArrayType3 = _ArrayType3;
  __publicField9(ArrayType3, "swayType", "[_; 2]");
  __publicField9(ArrayType3, "MATCH_REGEX", /^\[_; ([0-9]+)\]$/m);
  var _StrType3 = class extends AType3 {
    name = "str";
    static isSuitableFor(params) {
      return _StrType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: "string",
        outputLabel: "string"
      };
      return this.attributes;
    }
  };
  var StrType3 = _StrType3;
  __publicField9(StrType3, "swayType", "str[3]");
  __publicField9(StrType3, "MATCH_REGEX", /^str\[(.+)\]$/m);
  var _B256Type3 = class extends StrType3 {
    name = "b256";
    static isSuitableFor(params) {
      return _B256Type3.MATCH_REGEX.test(params.type);
    }
  };
  var B256Type3 = _B256Type3;
  __publicField9(B256Type3, "swayType", "b256");
  __publicField9(B256Type3, "MATCH_REGEX", /^b256$/m);
  var _B512Type3 = class extends B256Type3 {
    name = "b512";
    static isSuitableFor(params) {
      return _B512Type3.MATCH_REGEX.test(params.type);
    }
  };
  var B512Type3 = _B512Type3;
  __publicField9(B512Type3, "swayType", "struct B512");
  __publicField9(B512Type3, "MATCH_REGEX", /^struct B512$/m);
  var _BoolType3 = class extends AType3 {
    name = "bool";
    static isSuitableFor(params) {
      return _BoolType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: "boolean",
        outputLabel: "boolean"
      };
      return this.attributes;
    }
  };
  var BoolType3 = _BoolType3;
  __publicField9(BoolType3, "swayType", "bool");
  __publicField9(BoolType3, "MATCH_REGEX", /^bool$/m);
  var _BytesType3 = class extends ArrayType3 {
    name = "bytes";
    static isSuitableFor(params) {
      return _BytesType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "Bytes";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var BytesType3 = _BytesType3;
  __publicField9(BytesType3, "swayType", "struct Bytes");
  __publicField9(BytesType3, "MATCH_REGEX", /^struct Bytes/m);
  function extractStructName3(params) {
    const { rawAbiType, regex } = params;
    const match3 = rawAbiType.type.match(params.regex)?.[1];
    if (!match3) {
      let errorMessage = `Couldn't extract struct name with: '${regex}'.

`;
      errorMessage += `Check your JSON ABI.

[source]
`;
      errorMessage += `${JSON.stringify(rawAbiType, null, 2)}`;
      throw new FuelError(ErrorCode.JSON_ABI_ERROR, errorMessage);
    }
    return match3;
  }
  var _EnumType3 = class extends AType3 {
    name = "enum";
    static isSuitableFor(params) {
      const isAMatch = _EnumType3.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _EnumType3.IGNORE_REGEX.test(params.type);
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      const structName = this.getStructName();
      this.attributes = {
        structName,
        inputLabel: `${structName}Input`,
        outputLabel: `${structName}Output`
      };
      return this.attributes;
    }
    getStructName() {
      const name = extractStructName3({
        rawAbiType: this.rawAbiType,
        regex: _EnumType3.MATCH_REGEX
      });
      return name;
    }
    getNativeEnum(params) {
      const { types: types2 } = params;
      const typeHash = types2.reduce(
        (hash5, row) => ({
          ...hash5,
          [row.rawAbiType.typeId]: row
        }),
        {}
      );
      const { components } = this.rawAbiType;
      const enumComponents = components;
      if (!enumComponents.every(({ type: type3 }) => !typeHash[type3])) {
        return void 0;
      }
      return enumComponents.map(({ name }) => `${name} = '${name}'`).join(", ");
    }
    getStructContents(params) {
      const { types: types2, target } = params;
      const { components } = this.rawAbiType;
      const enumComponents = components;
      const attributeKey = `${target}Label`;
      const contents = enumComponents.map((component) => {
        const { name, type: typeId } = component;
        if (typeId === 0) {
          return `${name}: []`;
        }
        const { attributes } = findType3({ types: types2, typeId });
        return `${name}: ${attributes[attributeKey]}`;
      });
      return contents.join(", ");
    }
  };
  var EnumType3 = _EnumType3;
  __publicField9(EnumType3, "swayType", "enum MyEnumName");
  __publicField9(EnumType3, "MATCH_REGEX", /^enum (.+)$/m);
  __publicField9(EnumType3, "IGNORE_REGEX", /^enum Option$/m);
  var _EvmAddressType3 = class extends AType3 {
    name = "evmAddress";
    static isSuitableFor(params) {
      return _EvmAddressType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "EvmAddress";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var EvmAddressType3 = _EvmAddressType3;
  __publicField9(EvmAddressType3, "swayType", "struct EvmAddress");
  __publicField9(EvmAddressType3, "MATCH_REGEX", /^struct EvmAddress$/m);
  var _GenericType3 = class extends AType3 {
    name = "generic";
    static isSuitableFor(params) {
      return _GenericType3.MATCH_REGEX.test(params.type);
    }
    getStructName() {
      const name = extractStructName3({
        rawAbiType: this.rawAbiType,
        regex: _GenericType3.MATCH_REGEX
      });
      return name;
    }
    parseComponentsAttributes(_params) {
      const label = this.getStructName();
      this.attributes = {
        inputLabel: label,
        outputLabel: label
      };
      return this.attributes;
    }
  };
  var GenericType3 = _GenericType3;
  __publicField9(GenericType3, "swayType", "generic T");
  __publicField9(GenericType3, "MATCH_REGEX", /^generic ([^\s]+)$/m);
  var _OptionType3 = class extends AType3 {
    name = "option";
    static isSuitableFor(params) {
      return _OptionType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `Option`,
        outputLabel: `Option`
      };
      return this.attributes;
    }
  };
  var OptionType3 = _OptionType3;
  __publicField9(OptionType3, "swayType", "enum Option");
  __publicField9(OptionType3, "MATCH_REGEX", /^enum Option$/m);
  var _U8Type3 = class extends AType3 {
    name = "u8";
    constructor(params) {
      super(params);
      this.attributes = {
        inputLabel: `BigNumberish`,
        outputLabel: `number`
      };
      this.requiredFuelsMembersImports = [this.attributes.inputLabel];
    }
    static isSuitableFor(params) {
      return _U8Type3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      return this.attributes;
    }
  };
  var U8Type3 = _U8Type3;
  __publicField9(U8Type3, "swayType", "u8");
  __publicField9(U8Type3, "MATCH_REGEX", /^u8$/m);
  var _U64Type3 = class extends U8Type3 {
    name = "u64";
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `BigNumberish`,
        outputLabel: `BN`
      };
      this.requiredFuelsMembersImports = Object.values(this.attributes);
      return this.attributes;
    }
    static isSuitableFor(params) {
      return _U64Type3.MATCH_REGEX.test(params.type);
    }
  };
  var U64Type3 = _U64Type3;
  __publicField9(U64Type3, "swayType", "u64");
  __publicField9(U64Type3, "MATCH_REGEX", /^u64$/m);
  var _RawUntypedPtr3 = class extends U64Type3 {
    name = "rawUntypedPtr";
    static isSuitableFor(params) {
      return _RawUntypedPtr3.MATCH_REGEX.test(params.type);
    }
  };
  var RawUntypedPtr3 = _RawUntypedPtr3;
  __publicField9(RawUntypedPtr3, "swayType", "raw untyped ptr");
  __publicField9(RawUntypedPtr3, "MATCH_REGEX", /^raw untyped ptr$/m);
  var _RawUntypedSlice3 = class extends ArrayType3 {
    name = "rawUntypedSlice";
    static isSuitableFor(params) {
      return _RawUntypedSlice3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "RawSlice";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var RawUntypedSlice3 = _RawUntypedSlice3;
  __publicField9(RawUntypedSlice3, "swayType", "raw untyped slice");
  __publicField9(RawUntypedSlice3, "MATCH_REGEX", /^raw untyped slice$/m);
  var _StdStringType3 = class extends AType3 {
    name = "stdString";
    static isSuitableFor(params) {
      return _StdStringType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      const capitalizedName = "StdString";
      this.attributes = {
        inputLabel: capitalizedName,
        outputLabel: capitalizedName
      };
      this.requiredFuelsMembersImports = [capitalizedName];
      return this.attributes;
    }
  };
  var StdStringType3 = _StdStringType3;
  __publicField9(StdStringType3, "swayType", "struct String");
  __publicField9(StdStringType3, "MATCH_REGEX", /^struct String/m);
  var _StrSliceType3 = class extends AType3 {
    name = "strSlice";
    static isSuitableFor(params) {
      return _StrSliceType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: "StrSlice",
        outputLabel: "StrSlice"
      };
      return this.attributes;
    }
  };
  var StrSliceType3 = _StrSliceType3;
  __publicField9(StrSliceType3, "swayType", "str");
  __publicField9(StrSliceType3, "MATCH_REGEX", /^str$/m);
  var _StructType3 = class extends AType3 {
    name = "struct";
    static isSuitableFor(params) {
      const isAMatch = _StructType3.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _StructType3.IGNORE_REGEX.test(params.type);
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      const structName = this.getStructName();
      this.attributes = {
        structName,
        inputLabel: `${structName}Input`,
        outputLabel: `${structName}Output`
      };
      return this.attributes;
    }
    getStructName() {
      const name = extractStructName3({
        rawAbiType: this.rawAbiType,
        regex: _StructType3.MATCH_REGEX
      });
      return name;
    }
    getStructContents(params) {
      const { types: types2, target } = params;
      const { components } = this.rawAbiType;
      const structComponents = components;
      const members = structComponents.map((component) => {
        const { name, type: typeId, typeArguments } = component;
        const type3 = findType3({ types: types2, typeId });
        let typeDecl;
        if (typeArguments) {
          typeDecl = parseTypeArguments3({
            types: types2,
            target,
            parentTypeId: typeId,
            typeArguments
          });
        } else {
          const attributeKey = `${target}Label`;
          typeDecl = type3.attributes[attributeKey];
        }
        return `${name}: ${typeDecl}`;
      });
      return members.join(", ");
    }
    getStructDeclaration(params) {
      const { types: types2 } = params;
      const { typeParameters } = this.rawAbiType;
      if (typeParameters) {
        const structs = typeParameters.map((typeId) => findType3({ types: types2, typeId }));
        const labels = structs.map(({ attributes: { inputLabel } }) => inputLabel);
        return `<${labels.join(", ")}>`;
      }
      return "";
    }
  };
  var StructType3 = _StructType3;
  __publicField9(StructType3, "swayType", "struct MyStruct");
  __publicField9(StructType3, "MATCH_REGEX", /^struct (.+)$/m);
  __publicField9(StructType3, "IGNORE_REGEX", /^struct (Vec|RawVec|EvmAddress|Bytes|String)$/m);
  var _TupleType3 = class extends AType3 {
    name = "tupple";
    static isSuitableFor(params) {
      return _TupleType3.MATCH_REGEX.test(params.type);
    }
    parseComponentsAttributes(params) {
      const { types: types2 } = params;
      const inputs = [];
      const outputs = [];
      this.rawAbiType.components?.forEach((component) => {
        const { type: typeId, typeArguments } = component;
        if (!typeArguments) {
          const { attributes } = findType3({ types: types2, typeId });
          inputs.push(attributes.inputLabel);
          outputs.push(attributes.outputLabel);
        } else {
          const inputLabel = parseTypeArguments3({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "input"
            /* INPUT */
          });
          const outputLabel = parseTypeArguments3({
            types: types2,
            typeArguments,
            parentTypeId: typeId,
            target: "output"
            /* OUTPUT */
          });
          inputs.push(inputLabel);
          outputs.push(outputLabel);
        }
      });
      this.attributes = {
        inputLabel: `[${inputs.join(", ")}]`,
        outputLabel: `[${outputs.join(", ")}]`
      };
      return this.attributes;
    }
  };
  var TupleType3 = _TupleType3;
  __publicField9(TupleType3, "swayType", "(_, _, _)");
  __publicField9(TupleType3, "MATCH_REGEX", /^\([_,\s]+\)$/m);
  var _U16Type3 = class extends U8Type3 {
    name = "u16";
    static isSuitableFor(params) {
      return _U16Type3.MATCH_REGEX.test(params.type);
    }
  };
  var U16Type3 = _U16Type3;
  __publicField9(U16Type3, "swayType", "u16");
  __publicField9(U16Type3, "MATCH_REGEX", /^u16$/m);
  var _U32Type3 = class extends U8Type3 {
    name = "u32";
    static isSuitableFor(params) {
      return _U32Type3.MATCH_REGEX.test(params.type);
    }
  };
  var U32Type3 = _U32Type3;
  __publicField9(U32Type3, "swayType", "u32");
  __publicField9(U32Type3, "MATCH_REGEX", /^u32$/m);
  var _VectorType3 = class extends ArrayType3 {
    name = "vector";
    static isSuitableFor(params) {
      const isAMatch = _VectorType3.MATCH_REGEX.test(params.type);
      const shouldBeIgnored = _VectorType3.IGNORE_REGEX.test(params.type);
      return isAMatch && !shouldBeIgnored;
    }
    parseComponentsAttributes(_params) {
      this.attributes = {
        inputLabel: `Vec`,
        outputLabel: `Vec`
      };
      return this.attributes;
    }
  };
  var VectorType3 = _VectorType3;
  __publicField9(VectorType3, "swayType", "struct Vec");
  __publicField9(VectorType3, "MATCH_REGEX", /^struct Vec/m);
  __publicField9(VectorType3, "IGNORE_REGEX", /^struct RawVec$/m);
  var supportedTypes2 = [
    ArrayType3,
    B256Type3,
    B512Type3,
    BoolType3,
    BytesType3,
    EnumType3,
    GenericType3,
    OptionType3,
    RawUntypedPtr3,
    RawUntypedSlice3,
    StdStringType3,
    StrType3,
    StrSliceType3,
    StructType3,
    TupleType3,
    U16Type3,
    U32Type3,
    U64Type3,
    U8Type3,
    VectorType3,
    EvmAddressType3
  ];
  function makeType2(params) {
    const { rawAbiType } = params;
    const { type: type3 } = rawAbiType;
    const TypeClass = supportedTypes2.find((tc) => tc.isSuitableFor({ type: type3 }));
    if (!TypeClass) {
      throw new FuelError(ErrorCode.TYPE_NOT_SUPPORTED, `Type not supported: ${type3}`);
    }
    return new TypeClass(params);
  }
  function shouldSkipAbiType2(params) {
    const ignoreList = ["()", "struct RawVec"];
    const shouldSkip = ignoreList.indexOf(params.type) >= 0;
    return shouldSkip;
  }
  function parseTypes2(params) {
    const types2 = [];
    params.rawAbiTypes.forEach((rawAbiType) => {
      const { type: type3 } = rawAbiType;
      const skip = shouldSkipAbiType2({ type: type3 });
      if (!skip) {
        const parsedType = makeType2({ rawAbiType });
        types2.push(parsedType);
      }
    });
    types2.forEach((type3) => {
      type3.parseComponentsAttributes({ types: types2 });
    });
    return types2;
  }
  var Abi2 = class {
    name;
    programType;
    filepath;
    outputDir;
    commonTypesInUse = [];
    rawContents;
    hexlifiedBinContents;
    storageSlotsContents;
    types;
    functions;
    configurables;
    constructor(params) {
      const {
        filepath,
        outputDir,
        rawContents,
        hexlifiedBinContents,
        programType,
        storageSlotsContents
      } = params;
      const abiNameRegex = /([^/]+)-abi\.json$/m;
      const abiName = filepath.match(abiNameRegex);
      const couldNotParseName = !abiName || abiName.length === 0;
      if (couldNotParseName) {
        throw new FuelError(
          ErrorCode.PARSE_FAILED,
          `Could not parse name from ABI file: ${filepath}.`
        );
      }
      const name = `${normalizeString(abiName[1])}Abi`;
      this.name = name;
      this.programType = programType;
      this.filepath = filepath;
      this.rawContents = rawContents;
      this.hexlifiedBinContents = hexlifiedBinContents;
      this.storageSlotsContents = storageSlotsContents;
      this.outputDir = outputDir;
      const { types: types2, functions, configurables } = this.parse();
      this.types = types2;
      this.functions = functions;
      this.configurables = configurables;
      this.computeCommonTypesInUse();
    }
    parse() {
      const {
        types: rawAbiTypes,
        functions: rawAbiFunctions,
        configurables: rawAbiConfigurables
      } = this.rawContents;
      const types2 = parseTypes2({ rawAbiTypes });
      const functions = parseFunctions2({ rawAbiFunctions, types: types2 });
      const configurables = parseConfigurables2({ rawAbiConfigurables, types: types2 });
      return {
        types: types2,
        functions,
        configurables
      };
    }
    computeCommonTypesInUse() {
      const customTypesTable = {
        option: "Option",
        enum: "Enum",
        vector: "Vec"
      };
      this.commonTypesInUse = [];
      Object.keys(customTypesTable).forEach((typeName) => {
        const isInUse = !!this.types.find((t) => t.name === typeName);
        if (isInUse) {
          const commonTypeLabel = customTypesTable[typeName];
          this.commonTypesInUse.push(commonTypeLabel);
        }
      });
    }
  };
  var ProgramTypeEnum3 = /* @__PURE__ */ ((ProgramTypeEnum22) => {
    ProgramTypeEnum22["CONTRACT"] = "contract";
    ProgramTypeEnum22["SCRIPT"] = "script";
    ProgramTypeEnum22["PREDICATE"] = "predicate";
    return ProgramTypeEnum22;
  })(ProgramTypeEnum3 || {});
  var header_default2 = "/* Autogenerated file. Do not edit manually. */\n\n/* tslint:disable */\n/* eslint-disable */\n\n/*\n  Fuels version: {{FUELS}}\n  Forc version: {{FORC}}\n  Fuel-Core version: {{FUEL_CORE}}\n*/\n";
  function renderHbsTemplate2(params) {
    const { data, template } = params;
    const options = {
      strict: true,
      noEscape: true
    };
    const renderTemplate = (0, import_handlebars3.compile)(template, options);
    const renderHeaderTemplate = (0, import_handlebars3.compile)(header_default2, options);
    const text = renderTemplate({
      ...data,
      header: renderHeaderTemplate(versions)
    });
    return text.replace(/[\n]{3,}/gm, "\n\n");
  }
  var common_default3 = "{{header}}\n\n/*\n  Mimics Sway Enum, requires at least one Key-Value but\n  does not raise error on multiple pairs.\n  This is done in the abi-coder\n*/\nexport type Enum<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &\n  U[keyof U];\n\n/*\n  Mimics Sway Option and Vectors.\n  Vectors are treated like arrays in Typescript.\n*/\nexport type Option<T> = T | undefined;\n\nexport type Vec<T> = T[];\n";
  function renderCommonTemplate2() {
    const text = renderHbsTemplate2({ template: common_default3 });
    return text;
  }
  var common_default22 = "{{header}}\n\n{{#if isGeneratingContracts}}\n{{#each abis}}\nexport type { {{name}} } from './{{name}}';\n{{/each}}\n{{/if}}\n\n{{#each abis}}\nexport { {{name}}__factory } from './factories/{{name}}__factory';\n{{/each}}\n";
  function renderIndexTemplate2(params) {
    const { abis } = params;
    const isGeneratingContracts = abis[0].programType === "contract";
    const text = renderHbsTemplate2({
      template: common_default22,
      data: { abis, isGeneratingContracts }
    });
    return text;
  }
  var bytecode_default2 = "{{header}}\n\nexport default '{{hexlifiedBytecode}}'";
  function renderBytecodeTemplate2(params) {
    const text = renderHbsTemplate2({
      template: bytecode_default2,
      data: {
        hexlifiedBytecode: params.hexlifiedBytecode
      }
    });
    return text;
  }
  function formatConfigurables2(params) {
    const { configurables } = params;
    const formattedConfigurables = configurables.map((c) => {
      const {
        name,
        type: {
          attributes: { inputLabel }
        }
      } = c;
      return {
        configurableName: name,
        configurableType: inputLabel
      };
    });
    return { formattedConfigurables };
  }
  function formatEnums2(params) {
    const { types: types2 } = params;
    const enums = types2.filter((t) => t.name === "enum").map((t) => {
      const et = t;
      const structName = et.getStructName();
      const inputValues = et.getStructContents({
        types: types2,
        target: "input"
        /* INPUT */
      });
      const outputValues = et.getStructContents({
        types: types2,
        target: "output"
        /* OUTPUT */
      });
      const inputNativeValues = et.getNativeEnum({ types: types2 });
      const outputNativeValues = et.getNativeEnum({ types: types2 });
      return {
        structName,
        inputValues,
        outputValues,
        recycleRef: inputValues === outputValues,
        // reduces duplication
        inputNativeValues,
        outputNativeValues
      };
    });
    return { enums };
  }
  var caseInsensitiveSort2 = (a, b) => a.toLowerCase().localeCompare(b.toLowerCase());
  function formatImports2(params) {
    const { types: types2, baseMembers = [] } = params;
    const members = types2.flatMap((t) => t.requiredFuelsMembersImports);
    const imports = uniq_default(baseMembers.concat(members).sort(caseInsensitiveSort2));
    return {
      imports: imports.length ? imports : void 0
    };
  }
  function formatStructs2(params) {
    const { types: types2 } = params;
    const structs = types2.filter((t) => t.name === "struct").map((t) => {
      const st = t;
      const structName = st.getStructName();
      const inputValues = st.getStructContents({
        types: types2,
        target: "input"
        /* INPUT */
      });
      const outputValues = st.getStructContents({
        types: types2,
        target: "output"
        /* OUTPUT */
      });
      const typeAnnotations = st.getStructDeclaration({ types: types2 });
      return {
        structName,
        typeAnnotations,
        inputValues,
        outputValues,
        recycleRef: inputValues === outputValues
        // reduces duplication
      };
    });
    return { structs };
  }
  var dts_default2 = `{{header}}

{{#if imports}}
import type {
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
{{#if inputNativeValues}}
export enum {{structName}}Input { {{inputNativeValues}} };
{{else}}
export type {{structName}}Input = Enum<{ {{inputValues}} }>;
{{/if}}
{{#if outputNativeValues}}
export enum {{structName}}Output { {{outputNativeValues}} };
{{else}}
  {{#if recycleRef}}
export type {{structName}}Output = {{structName}}Input;
  {{else}}
export type {{structName}}Output = Enum<{ {{outputValues}} }>;
  {{/if}}
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

{{#if formattedConfigurables}}
export type {{capitalizedName}}Configurables = {
{{#each formattedConfigurables}}
  {{configurableName}}: {{configurableType}};
{{/each}}
};
{{/if}}

interface {{capitalizedName}}Interface extends Interface {
  functions: {
    {{#each functionsFragments}}
    {{this}}: FunctionFragment;
    {{/each}}
  };

  {{#each encoders}}
  encodeFunctionData(functionFragment: '{{functionName}}', values: [{{input}}]): Uint8Array;
  {{/each}}

  {{#each decoders}}
  decodeFunctionData(functionFragment: '{{functionName}}', data: BytesLike): DecodedValue;
  {{/each}}
}


export class {{capitalizedName}} extends Contract {
  interface: {{capitalizedName}}Interface;
  functions: {
    {{#each functionsTypedefs}}
    {{this}};
    {{/each}}
  };
}
`;
  function renderDtsTemplate2(params) {
    const { name: capitalizedName, types: types2, functions, commonTypesInUse, configurables } = params.abi;
    const functionsTypedefs = functions.map((f2) => f2.getDeclaration());
    const functionsFragments = functions.map((f2) => f2.name);
    const encoders = functions.map((f2) => ({
      functionName: f2.name,
      input: f2.attributes.inputs
    }));
    const decoders = functions.map((f2) => ({
      functionName: f2.name
    }));
    const { enums } = formatEnums2({ types: types2 });
    const { structs } = formatStructs2({ types: types2 });
    const { imports } = formatImports2({
      types: types2,
      baseMembers: [
        "Interface",
        "FunctionFragment",
        "DecodedValue",
        "Contract",
        "BytesLike",
        "InvokeFunction"
      ]
    });
    const { formattedConfigurables } = formatConfigurables2({ configurables });
    const text = renderHbsTemplate2({
      template: dts_default2,
      data: {
        capitalizedName,
        commonTypesInUse: commonTypesInUse.join(", "),
        functionsTypedefs,
        functionsFragments,
        encoders,
        decoders,
        structs,
        enums,
        imports,
        formattedConfigurables
      }
    });
    return text;
  }
  var factory_default4 = '{{header}}\n\nimport { Interface, Contract, ContractFactory } from "fuels";\nimport type { Provider, Account, AbstractAddress, BytesLike, DeployContractOptions, StorageSlot } from "fuels";\nimport type { {{capitalizedName}}, {{capitalizedName}}Interface } from "../{{capitalizedName}}";\n\nconst _abi = {{abiJsonString}};\n\nconst _storageSlots: StorageSlot[] = {{storageSlotsJsonString}};\n\nexport class {{capitalizedName}}__factory {\n  static readonly abi = _abi;\n\n  static readonly storageSlots = _storageSlots;\n\n  static createInterface(): {{capitalizedName}}Interface {\n    return new Interface(_abi) as unknown as {{capitalizedName}}Interface\n  }\n\n  static connect(\n    id: string | AbstractAddress,\n    accountOrProvider: Account | Provider\n  ): {{capitalizedName}} {\n    return new Contract(id, _abi, accountOrProvider) as unknown as {{capitalizedName}}\n  }\n\n  static async deployContract(\n    bytecode: BytesLike,\n    wallet: Account,\n    options: DeployContractOptions = {}\n  ): Promise<{{capitalizedName}}> {\n    const factory = new ContractFactory(bytecode, _abi, wallet);\n\n    const { storageSlots } = {{capitalizedName}}__factory;\n\n    const contract = await factory.deployContract({\n      storageSlots,\n      ...options,\n    });\n\n    return contract as unknown as {{capitalizedName}};\n  }\n}\n';
  function renderFactoryTemplate4(params) {
    const { name: capitalizedName, rawContents, storageSlotsContents } = params.abi;
    const abiJsonString = JSON.stringify(rawContents, null, 2);
    const storageSlotsJsonString = storageSlotsContents ?? "[]";
    const text = renderHbsTemplate2({
      template: factory_default4,
      data: { capitalizedName, abiJsonString, storageSlotsJsonString }
    });
    return text;
  }
  function assembleContracts2(params) {
    const { abis, outputDir } = params;
    const files = [];
    const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);
    abis.forEach((abi) => {
      const { name } = abi;
      const dtsFilepath = `${outputDir}/${name}.d.ts`;
      const factoryFilepath = `${outputDir}/factories/${name}__factory.ts`;
      const hexBinFilePath = `${outputDir}/${name}.hex.ts`;
      const dts = {
        path: dtsFilepath,
        contents: renderDtsTemplate2({ abi })
      };
      const factory = {
        path: factoryFilepath,
        contents: renderFactoryTemplate4({ abi })
      };
      const hexBinFile = {
        path: hexBinFilePath,
        contents: renderBytecodeTemplate2({
          hexlifiedBytecode: abi.hexlifiedBinContents
        })
      };
      files.push(dts);
      files.push(factory);
      files.push(hexBinFile);
    });
    const indexFile = {
      path: `${outputDir}/index.ts`,
      contents: renderIndexTemplate2({ abis })
    };
    files.push(indexFile);
    if (usesCommonTypes) {
      const commonsFilepath = (0, import_path17.join)(outputDir, "common.d.ts");
      const file = {
        path: commonsFilepath,
        contents: renderCommonTemplate2()
      };
      files.push(file);
    }
    return files;
  }
  var factory_default22 = `{{header}}

{{#if imports}}
import {
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
{{#if inputNativeValues}}
export enum {{structName}}Input { {{inputNativeValues}} };
{{else}}
export type {{structName}}Input = Enum<{ {{inputValues}} }>;
{{/if}}
{{#if outputNativeValues}}
export enum {{structName}}Output { {{outputNativeValues}} };
{{else}}
  {{#if recycleRef}}
export type {{structName}}Output = {{structName}}Input;
  {{else}}
export type {{structName}}Output = Enum<{ {{outputValues}} }>;
  {{/if}}
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

export type {{capitalizedName}}Configurables = {
{{#each formattedConfigurables}}
  {{configurableName}}: {{configurableType}};
{{/each}}
};

type {{capitalizedName}}Inputs = [{{inputs}}];

const _abi = {{abiJsonString}}

const _bin = '{{hexlifiedBinString}}'

export class {{capitalizedName}}__factory {

  static readonly abi = _abi
  static readonly bin = _bin;

  static createInstance(provider: Provider, configurables?: {{capitalizedName}}Configurables) {

    const { abi, bin } = {{capitalizedName}}__factory

    const predicate = new Predicate(bin, provider, abi, configurables);

    return predicate;

  }

}
`;
  function renderFactoryTemplate22(params) {
    const { abi } = params;
    const { types: types2, configurables } = abi;
    const {
      rawContents,
      name: capitalizedName,
      hexlifiedBinContents: hexlifiedBinString
    } = params.abi;
    const abiJsonString = JSON.stringify(rawContents, null, 2);
    const func = abi.functions.find((f2) => f2.name === "main");
    if (!func) {
      throw new FuelError(ErrorCode.ABI_MAIN_METHOD_MISSING, `ABI doesn't have a 'main()' method.`);
    }
    const { enums } = formatEnums2({ types: types2 });
    const { structs } = formatStructs2({ types: types2 });
    const { imports } = formatImports2({ types: types2, baseMembers: ["Predicate", "Provider"] });
    const { formattedConfigurables } = formatConfigurables2({ configurables });
    const { prefixedInputs: inputs, output: output3 } = func.attributes;
    const text = renderHbsTemplate2({
      template: factory_default22,
      data: {
        inputs,
        output: output3,
        structs,
        enums,
        abiJsonString,
        hexlifiedBinString,
        capitalizedName,
        imports,
        formattedConfigurables
      }
    });
    return text;
  }
  function assemblePredicates2(params) {
    const { abis, outputDir } = params;
    const files = [];
    const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);
    abis.forEach((abi) => {
      const { name } = abi;
      const factoryFilepath = `${outputDir}/factories/${name}__factory.ts`;
      const factory = {
        path: factoryFilepath,
        contents: renderFactoryTemplate22({ abi })
      };
      files.push(factory);
    });
    const indexFile = {
      path: `${outputDir}/index.ts`,
      contents: renderIndexTemplate2({ abis })
    };
    files.push(indexFile);
    if (usesCommonTypes) {
      const commonsFilepath = (0, import_path18.join)(outputDir, "common.d.ts");
      const file = {
        path: commonsFilepath,
        contents: renderCommonTemplate2()
      };
      files.push(file);
    }
    return files;
  }
  var factory_default32 = `{{header}}

{{#if imports}}
import {
{{#each imports}}
  {{this}},
{{/each}}
} from 'fuels';
{{/if}}

{{#if commonTypesInUse}}
import type { {{commonTypesInUse}} } from "./common";
{{/if}}


{{#each enums}}
{{#if inputNativeValues}}
export enum {{structName}}Input { {{inputNativeValues}} };
{{else}}
export type {{structName}}Input = Enum<{ {{inputValues}} }>;
{{/if}}
{{#if outputNativeValues}}
export enum {{structName}}Output { {{outputNativeValues}} };
{{else}}
  {{#if recycleRef}}
export type {{structName}}Output = {{structName}}Input;
  {{else}}
export type {{structName}}Output = Enum<{ {{outputValues}} }>;
  {{/if}}
{{/if}}
{{/each}}


{{#each structs}}
export type {{structName}}Input{{typeAnnotations}} = { {{inputValues}} };
{{#if recycleRef}}
export type {{structName}}Output{{typeAnnotations}} = {{structName}}Input{{typeAnnotations}};
{{else}}
export type {{structName}}Output{{typeAnnotations}} = { {{outputValues}} };
{{/if}}
{{/each}}

type {{capitalizedName}}Inputs = [{{inputs}}];
type {{capitalizedName}}Output = {{output}};

{{#if formattedConfigurables}}
export type {{capitalizedName}}Configurables = {
{{#each formattedConfigurables}}
  {{configurableName}}: {{configurableType}};
{{/each}}
};
{{/if}}

const _abi = {{abiJsonString}}

const _bin = '{{hexlifiedBinString}}'

export class {{capitalizedName}}__factory {

  static readonly abi = _abi
  static readonly bin = _bin

  static createInstance(wallet: Account) {

    const { abi, bin } = {{capitalizedName}}__factory

    const script = new Script<
      {{capitalizedName}}Inputs,
      {{capitalizedName}}Output
    >(bin, abi, wallet);

    return script;

  }

}
`;
  function renderFactoryTemplate32(params) {
    const { abi } = params;
    const { types: types2, configurables } = abi;
    const {
      rawContents,
      name: capitalizedName,
      hexlifiedBinContents: hexlifiedBinString
    } = params.abi;
    const abiJsonString = JSON.stringify(rawContents, null, 2);
    const func = abi.functions.find((f2) => f2.name === "main");
    if (!func) {
      throw new FuelError(ErrorCode.ABI_MAIN_METHOD_MISSING, `ABI doesn't have a 'main()' method.`);
    }
    const { enums } = formatEnums2({ types: types2 });
    const { structs } = formatStructs2({ types: types2 });
    const { imports } = formatImports2({ types: types2, baseMembers: ["Script", "Account"] });
    const { formattedConfigurables } = formatConfigurables2({ configurables });
    const { prefixedInputs: inputs, output: output3 } = func.attributes;
    const text = renderHbsTemplate2({
      template: factory_default32,
      data: {
        inputs,
        output: output3,
        structs,
        enums,
        abiJsonString,
        hexlifiedBinString,
        capitalizedName,
        imports,
        formattedConfigurables
      }
    });
    return text;
  }
  function assembleScripts2(params) {
    const { abis, outputDir } = params;
    const files = [];
    const usesCommonTypes = abis.find((a) => a.commonTypesInUse.length > 0);
    abis.forEach((abi) => {
      const { name } = abi;
      const factoryFilepath = `${outputDir}/factories/${name}__factory.ts`;
      const factory = {
        path: factoryFilepath,
        contents: renderFactoryTemplate32({ abi })
      };
      files.push(factory);
    });
    const indexFile = {
      path: `${outputDir}/index.ts`,
      contents: renderIndexTemplate2({ abis })
    };
    files.push(indexFile);
    if (usesCommonTypes) {
      const commonsFilepath = (0, import_path19.join)(outputDir, "common.d.ts");
      const file = {
        path: commonsFilepath,
        contents: renderCommonTemplate2()
      };
      files.push(file);
    }
    return files;
  }
  var upperFirst2 = (s) => s[0].toUpperCase() + s.slice(1);
  function validateBinFile2(params) {
    const { abiFilepath, binFilepath, binExists, programType } = params;
    const isScript = programType === "script";
    if (!binExists && isScript) {
      throw new FuelError(
        ErrorCode.BIN_FILE_NOT_FOUND,
        [
          `Could not find BIN file for counterpart ${upperFirst2(programType)} ABI.`,
          `  - ABI: ${abiFilepath}`,
          `  - BIN: ${binFilepath}`,
          programType
        ].join("\n")
      );
    }
  }
  var AbiTypeGen2 = class {
    abis;
    abiFiles;
    binFiles;
    storageSlotsFiles;
    outputDir;
    files;
    constructor(params) {
      const { abiFiles, binFiles, outputDir, programType, storageSlotsFiles } = params;
      this.outputDir = outputDir;
      this.abiFiles = abiFiles;
      this.binFiles = binFiles;
      this.storageSlotsFiles = storageSlotsFiles;
      this.abis = this.abiFiles.map((abiFile) => {
        const binFilepath = abiFile.path.replace("-abi.json", ".bin");
        const relatedBinFile = this.binFiles.find(({ path: path4 }) => path4 === binFilepath);
        const storageSlotFilepath = abiFile.path.replace("-abi.json", "-storage_slots.json");
        const relatedStorageSlotsFile = this.storageSlotsFiles.find(
          ({ path: path4 }) => path4 === storageSlotFilepath
        );
        if (!relatedBinFile) {
          validateBinFile2({
            abiFilepath: abiFile.path,
            binExists: !!relatedBinFile,
            binFilepath,
            programType
          });
        }
        const abi = new Abi2({
          filepath: abiFile.path,
          rawContents: JSON.parse(abiFile.contents),
          hexlifiedBinContents: relatedBinFile?.contents,
          storageSlotsContents: relatedStorageSlotsFile?.contents,
          outputDir,
          programType
        });
        return abi;
      });
      this.files = this.getAssembledFiles({ programType });
    }
    getAssembledFiles(params) {
      const { abis, outputDir } = this;
      const { programType } = params;
      switch (programType) {
        case "contract":
          return assembleContracts2({ abis, outputDir });
        case "script":
          return assembleScripts2({ abis, outputDir });
        case "predicate":
          return assemblePredicates2({ abis, outputDir });
        default:
          throw new FuelError(
            ErrorCode.INVALID_INPUT_PARAMETERS,
            `Invalid Typegen programType: ${programType}. Must be one of ${Object.values(
              ProgramTypeEnum3
            )}`
          );
      }
    }
  };
  var collectBinFilepaths2 = (params) => {
    const { filepaths, programType } = params;
    const binFiles = filepaths.map((abiFilepath) => {
      const binFilepath = abiFilepath.replace("-abi.json", ".bin");
      const binExists = (0, import_fs10.existsSync)(binFilepath);
      validateBinFile2({ abiFilepath, binFilepath, binExists, programType });
      const bin = {
        path: binFilepath,
        contents: hexlify((0, import_fs10.readFileSync)(binFilepath))
      };
      return bin;
    });
    return binFiles;
  };
  var collectStorageSlotsFilepaths2 = (params) => {
    const { filepaths, programType } = params;
    const storageSlotsFiles = [];
    if (programType !== "contract") {
      return storageSlotsFiles;
    }
    filepaths.forEach((abiFilepath) => {
      const storageSlotsFilepath = abiFilepath.replace("-abi.json", "-storage_slots.json");
      const storageSlotsExists = (0, import_fs11.existsSync)(storageSlotsFilepath);
      if (storageSlotsExists) {
        const storageSlots = {
          path: storageSlotsFilepath,
          contents: (0, import_fs11.readFileSync)(storageSlotsFilepath, "utf-8")
        };
        storageSlotsFiles.push(storageSlots);
      }
    });
    return storageSlotsFiles;
  };
  function runTypegen2(params) {
    const { cwd, inputs, output: output3, silent, programType, filepaths: inputFilepaths } = params;
    const cwdBasename = (0, import_path16.basename)(cwd);
    function log2(...args) {
      if (!silent) {
        process.stdout.write(`${args.join(" ")}
`);
      }
    }
    let filepaths = [];
    if (!inputFilepaths?.length && inputs?.length) {
      filepaths = inputs.flatMap((i) => globSync(i, { cwd }));
    } else if (inputFilepaths?.length) {
      filepaths = inputFilepaths;
    } else {
      throw new FuelError(
        ErrorCode.MISSING_REQUIRED_PARAMETER,
        `At least one parameter should be supplied: 'input' or 'filepaths'.`
      );
    }
    const abiFiles = filepaths.map((filepath) => {
      const abi = {
        path: filepath,
        contents: (0, import_fs9.readFileSync)(filepath, "utf-8")
      };
      return abi;
    });
    if (!abiFiles.length) {
      throw new FuelError(ErrorCode.NO_ABIS_FOUND, `no ABI found at '${inputs}'`);
    }
    const binFiles = collectBinFilepaths2({ filepaths, programType });
    const storageSlotsFiles = collectStorageSlotsFilepaths2({ filepaths, programType });
    const abiTypeGen = new AbiTypeGen2({
      outputDir: output3,
      abiFiles,
      binFiles,
      storageSlotsFiles,
      programType
    });
    log2("Generating files..\n");
    import_mkdirp2.default.sync(`${output3}/factories`);
    abiTypeGen.files.forEach((file) => {
      import_rimraf2.default.sync(file.path);
      (0, import_fs9.writeFileSync)(file.path, file.contents);
      const trimPathRegex = new RegExp(`^.+${cwdBasename}/`, "m");
      log2(` - ${file.path.replace(trimPathRegex, "")}`);
    });
    log2("\nDone.\u26A1");
  }

  // src/cli/commands/build/generateTypes.ts
  var import_fs12 = __require2("fs");
  var import_path20 = __require2("path");

  // src/cli/templates/index.ts
  var import_handlebars4 = __toESM(require_lib());

  // src/cli/templates/index.hbs
  var templates_default = "{{#each paths}}\nexport * from './{{this}}';\n{{/each}}\n";

  // src/cli/templates/index.ts
  function renderIndexTemplate3(paths) {
    const renderTemplate = (0, import_handlebars4.compile)(templates_default, {
      strict: true,
      noEscape: true
    });
    return renderTemplate({
      paths
    });
  }

  // src/cli/commands/build/generateTypes.ts
  async function generateTypesForProgramType(config, paths, programType) {
    debug("Generating types..");
    const filepaths = await getABIPaths(paths);
    const pluralizedDirName = `${String(programType).toLocaleLowerCase()}s`;
    runTypegen2({
      programType,
      cwd: config.basePath,
      filepaths,
      output: (0, import_path20.join)(config.output, pluralizedDirName),
      silent: !loggingConfig.isDebugEnabled
    });
    return pluralizedDirName;
  }
  async function generateTypes(config) {
    log("Generating types..");
    const { contracts, scripts, predicates, output: output3 } = config;
    (0, import_fs12.mkdirSync)(output3, { recursive: true });
    const members = [
      { type: ProgramTypeEnum2.CONTRACT, programs: contracts },
      { type: ProgramTypeEnum2.SCRIPT, programs: scripts },
      { type: ProgramTypeEnum2.PREDICATE, programs: predicates }
    ];
    const pluralizedDirNames = await Promise.all(
      members.filter(({ programs }) => !!programs.length).map(({ programs, type: type3 }) => generateTypesForProgramType(config, programs, type3))
    );
    const indexFile = await renderIndexTemplate3(pluralizedDirNames);
    (0, import_fs12.writeFileSync)((0, import_path20.join)(config.output, "index.ts"), indexFile);
  }

  // src/cli/commands/build/index.ts
  async function build(config, program2) {
    log("Building..");
    await buildSwayPrograms(config);
    await generateTypes(config);
    const options = program2?.opts();
    if (options?.deploy) {
      const fuelCore = await autoStartFuelCore(config);
      await deploy(config);
      fuelCore?.killChildProcess();
    }
  }

  // src/cli/commands/dev/index.ts
  var import_chokidar = __toESM(require_chokidar());

  // ../wallet/dist/configs.mjs
  var FUEL_NETWORK_URL = typeof process !== "undefined" ? process?.env?.FUEL_NETWORK_URL || "http://127.0.0.1:4000/graphql" : "http://127.0.0.1:4000/graphql";

  // ../../node_modules/.pnpm/bundle-require@4.0.1_esbuild@0.19.3/node_modules/bundle-require/dist/index.js
  var import_fs14 = __toESM(__require2("fs"), 1);
  var import_path22 = __toESM(__require2("path"), 1);
  var import_url4 = __require2("url");
  var import_esbuild = __toESM(require_main(), 1);

  // ../../node_modules/.pnpm/load-tsconfig@0.2.5/node_modules/load-tsconfig/dist/index.js
  var import_path21 = __toESM(__require2("path"), 1);
  var import_fs13 = __toESM(__require2("fs"), 1);
  var import_module = __require2("module");
  var import_meta = {};
  var singleComment = Symbol("singleComment");
  var multiComment = Symbol("multiComment");
  var stripWithoutWhitespace = () => "";
  var stripWithWhitespace = (string2, start, end) => string2.slice(start, end).replace(/\S/g, " ");
  var isEscaped = (jsonString, quotePosition) => {
    let index = quotePosition - 1;
    let backslashCount = 0;
    while (jsonString[index] === "\\") {
      index -= 1;
      backslashCount += 1;
    }
    return Boolean(backslashCount % 2);
  };
  function stripJsonComments(jsonString, { whitespace = true, trailingCommas = false } = {}) {
    if (typeof jsonString !== "string") {
      throw new TypeError(`Expected argument \`jsonString\` to be a \`string\`, got \`${typeof jsonString}\``);
    }
    const strip = whitespace ? stripWithWhitespace : stripWithoutWhitespace;
    let isInsideString = false;
    let isInsideComment = false;
    let offset = 0;
    let buffer = "";
    let result = "";
    let commaIndex = -1;
    for (let index = 0; index < jsonString.length; index++) {
      const currentCharacter = jsonString[index];
      const nextCharacter = jsonString[index + 1];
      if (!isInsideComment && currentCharacter === '"') {
        const escaped = isEscaped(jsonString, index);
        if (!escaped) {
          isInsideString = !isInsideString;
        }
      }
      if (isInsideString) {
        continue;
      }
      if (!isInsideComment && currentCharacter + nextCharacter === "//") {
        buffer += jsonString.slice(offset, index);
        offset = index;
        isInsideComment = singleComment;
        index++;
      } else if (isInsideComment === singleComment && currentCharacter + nextCharacter === "\r\n") {
        index++;
        isInsideComment = false;
        buffer += strip(jsonString, offset, index);
        offset = index;
        continue;
      } else if (isInsideComment === singleComment && currentCharacter === "\n") {
        isInsideComment = false;
        buffer += strip(jsonString, offset, index);
        offset = index;
      } else if (!isInsideComment && currentCharacter + nextCharacter === "/*") {
        buffer += jsonString.slice(offset, index);
        offset = index;
        isInsideComment = multiComment;
        index++;
        continue;
      } else if (isInsideComment === multiComment && currentCharacter + nextCharacter === "*/") {
        index++;
        isInsideComment = false;
        buffer += strip(jsonString, offset, index + 1);
        offset = index + 1;
        continue;
      } else if (trailingCommas && !isInsideComment) {
        if (commaIndex !== -1) {
          if (currentCharacter === "}" || currentCharacter === "]") {
            buffer += jsonString.slice(offset, index);
            result += strip(buffer, 0, 1) + buffer.slice(1);
            buffer = "";
            offset = index;
            commaIndex = -1;
          } else if (currentCharacter !== " " && currentCharacter !== "	" && currentCharacter !== "\r" && currentCharacter !== "\n") {
            buffer += jsonString.slice(offset, index);
            offset = index;
            commaIndex = -1;
          }
        } else if (currentCharacter === ",") {
          result += buffer + jsonString.slice(offset, index);
          buffer = "";
          offset = index;
          commaIndex = index;
        }
      }
    }
    return result + buffer + (isInsideComment ? strip(jsonString.slice(offset)) : jsonString.slice(offset));
  }
  function jsoncParse(data) {
    try {
      return new Function("return " + stripJsonComments(data).trim())();
    } catch (_) {
      return {};
    }
  }
  var req = true ? (0, import_module.createRequire)(import_meta.url) : __require;
  var findUp = (name, startDir, stopDir = import_path21.default.parse(startDir).root) => {
    let dir = startDir;
    while (dir !== stopDir) {
      const file = import_path21.default.join(dir, name);
      if (import_fs13.default.existsSync(file))
        return file;
      if (!file.endsWith(".json")) {
        const fileWithExt = file + ".json";
        if (import_fs13.default.existsSync(fileWithExt))
          return fileWithExt;
      }
      dir = import_path21.default.dirname(dir);
    }
    return null;
  };
  var resolveTsConfigFromFile = (cwd, filename) => {
    if (import_path21.default.isAbsolute(filename))
      return import_fs13.default.existsSync(filename) ? filename : null;
    return findUp(filename, cwd);
  };
  var resolveTsConfigFromExtends = (cwd, name) => {
    if (import_path21.default.isAbsolute(name))
      return import_fs13.default.existsSync(name) ? name : null;
    if (name.startsWith("."))
      return findUp(name, cwd);
    const id = req.resolve(name, { paths: [cwd] });
    return id;
  };
  var loadTsConfigInternal = (dir = process.cwd(), name = "tsconfig.json", isExtends = false) => {
    var _a, _b;
    dir = import_path21.default.resolve(dir);
    const id = isExtends ? resolveTsConfigFromExtends(dir, name) : resolveTsConfigFromFile(dir, name);
    if (!id)
      return null;
    const data = jsoncParse(import_fs13.default.readFileSync(id, "utf-8"));
    const configDir = import_path21.default.dirname(id);
    if ((_a = data.compilerOptions) == null ? void 0 : _a.baseUrl) {
      data.compilerOptions.baseUrl = import_path21.default.join(
        configDir,
        data.compilerOptions.baseUrl
      );
    }
    let extendsFiles = [];
    if (data.extends) {
      const extendsList = Array.isArray(data.extends) ? data.extends : [data.extends];
      const extendsData = {};
      for (const name2 of extendsList) {
        const parentConfig = loadTsConfigInternal(configDir, name2, true);
        if (parentConfig) {
          Object.assign(extendsData, {
            ...parentConfig == null ? void 0 : parentConfig.data,
            compilerOptions: {
              ...extendsData.compilerOptions,
              ...(_b = parentConfig == null ? void 0 : parentConfig.data) == null ? void 0 : _b.compilerOptions
            }
          });
          extendsFiles.push(...parentConfig.files);
        }
      }
      Object.assign(data, {
        ...extendsData,
        ...data,
        compilerOptions: {
          ...extendsData.compilerOptions,
          ...data.compilerOptions
        }
      });
    }
    delete data.extends;
    return { path: id, data, files: [...extendsFiles, id] };
  };
  var loadTsConfig = (dir, name) => loadTsConfigInternal(dir, name);

  // ../../node_modules/.pnpm/bundle-require@4.0.1_esbuild@0.19.3/node_modules/bundle-require/dist/index.js
  var import_fs15 = __toESM(__require2("fs"), 1);
  var import_path23 = __toESM(__require2("path"), 1);
  var import_module2 = __require2("module");
  var import_meta2 = {};
  var getPkgType = () => {
    try {
      const pkg = JSON.parse(
        import_fs15.default.readFileSync(import_path23.default.resolve("package.json"), "utf-8")
      );
      return pkg.type;
    } catch (error2) {
    }
  };
  function guessFormat(inputFile) {
    if (!usingDynamicImport)
      return "cjs";
    const ext2 = import_path23.default.extname(inputFile);
    const type3 = getPkgType();
    if (ext2 === ".js") {
      return type3 === "module" ? "esm" : "cjs";
    } else if (ext2 === ".ts") {
      return "esm";
    } else if (ext2 === ".mjs") {
      return "esm";
    }
    return "cjs";
  }
  var usingDynamicImport = typeof jest === "undefined";
  var dynamicImport = async (id, { format }) => {
    const fn = format === "esm" ? (file) => import(file) : true ? (0, import_module2.createRequire)(import_meta2.url) : __require;
    return fn(id);
  };
  var getRandomId = () => {
    return Math.random().toString(36).substring(2, 15);
  };
  var DIRNAME_VAR_NAME = "__injected_dirname__";
  var FILENAME_VAR_NAME = "__injected_filename__";
  var IMPORT_META_URL_VAR_NAME = "__injected_import_meta_url__";
  var JS_EXT_RE = /\.(mjs|cjs|ts|js|tsx|jsx)$/;
  function inferLoader(ext2) {
    if (ext2 === ".mjs" || ext2 === ".cjs")
      return "js";
    return ext2.slice(1);
  }
  var defaultGetOutputFile = (filepath, format) => filepath.replace(
    JS_EXT_RE,
    `.bundled_${getRandomId()}.${format === "esm" ? "mjs" : "cjs"}`
  );
  var tsconfigPathsToRegExp = (paths) => {
    return Object.keys(paths || {}).map((key) => {
      return new RegExp(`^${key.replace(/\*/, ".*")}$`);
    });
  };
  var match2 = (id, patterns) => {
    if (!patterns)
      return false;
    return patterns.some((p) => {
      if (p instanceof RegExp) {
        return p.test(id);
      }
      return id === p || id.startsWith(p + "/");
    });
  };
  var externalPlugin = ({
    external,
    notExternal
  } = {}) => {
    return {
      name: "bundle-require:external",
      setup(ctx) {
        ctx.onResolve({ filter: /.*/ }, async (args) => {
          if (args.path[0] === "." || import_path22.default.isAbsolute(args.path)) {
            return;
          }
          if (match2(args.path, external)) {
            return {
              external: true
            };
          }
          if (match2(args.path, notExternal)) {
            return;
          }
          return {
            external: true
          };
        });
      }
    };
  };
  var injectFileScopePlugin = () => {
    return {
      name: "bundle-require:inject-file-scope",
      setup(ctx) {
        ctx.initialOptions.define = {
          ...ctx.initialOptions.define,
          __dirname: DIRNAME_VAR_NAME,
          __filename: FILENAME_VAR_NAME,
          "import.meta.url": IMPORT_META_URL_VAR_NAME
        };
        ctx.onLoad({ filter: JS_EXT_RE }, async (args) => {
          const contents = await import_fs14.default.promises.readFile(args.path, "utf-8");
          const injectLines = [
            `const ${FILENAME_VAR_NAME} = ${JSON.stringify(args.path)};`,
            `const ${DIRNAME_VAR_NAME} = ${JSON.stringify(
              import_path22.default.dirname(args.path)
            )};`,
            `const ${IMPORT_META_URL_VAR_NAME} = ${JSON.stringify(
              (0, import_url4.pathToFileURL)(args.path).href
            )};`
          ];
          return {
            contents: injectLines.join("") + contents,
            loader: inferLoader(import_path22.default.extname(args.path))
          };
        });
      }
    };
  };
  function bundleRequire(options) {
    return new Promise((resolve4, reject) => {
      var _a, _b, _c, _d;
      if (!JS_EXT_RE.test(options.filepath)) {
        throw new Error(`${options.filepath} is not a valid JS file`);
      }
      const preserveTemporaryFile = (_a = options.preserveTemporaryFile) != null ? _a : !!process.env.BUNDLE_REQUIRE_PRESERVE;
      const cwd = options.cwd || process.cwd();
      const format = (_b = options.format) != null ? _b : guessFormat(options.filepath);
      const tsconfig = loadTsConfig(cwd, options.tsconfig);
      const resolvePaths = tsconfigPathsToRegExp(
        ((_c = tsconfig == null ? void 0 : tsconfig.data.compilerOptions) == null ? void 0 : _c.paths) || {}
      );
      const extractResult = async (result) => {
        if (!result.outputFiles) {
          throw new Error(`[bundle-require] no output files`);
        }
        const { text } = result.outputFiles[0];
        const getOutputFile = options.getOutputFile || defaultGetOutputFile;
        const outfile = getOutputFile(options.filepath, format);
        await import_fs14.default.promises.writeFile(outfile, text, "utf8");
        let mod;
        const req2 = options.require || dynamicImport;
        try {
          mod = await req2(
            format === "esm" ? (0, import_url4.pathToFileURL)(outfile).href : outfile,
            { format }
          );
        } finally {
          if (!preserveTemporaryFile) {
            await import_fs14.default.promises.unlink(outfile);
          }
        }
        return {
          mod,
          dependencies: result.metafile ? Object.keys(result.metafile.inputs) : []
        };
      };
      const { watch: watchMode, ...restEsbuildOptions } = options.esbuildOptions || {};
      const esbuildOptions = {
        ...restEsbuildOptions,
        entryPoints: [options.filepath],
        absWorkingDir: cwd,
        outfile: "out.js",
        format,
        platform: "node",
        sourcemap: "inline",
        bundle: true,
        metafile: true,
        write: false,
        plugins: [
          ...((_d = options.esbuildOptions) == null ? void 0 : _d.plugins) || [],
          externalPlugin({
            external: options.external,
            notExternal: resolvePaths
          }),
          injectFileScopePlugin()
        ]
      };
      const run2 = async () => {
        if (!(watchMode || options.onRebuild)) {
          const result = await (0, import_esbuild.build)(esbuildOptions);
          resolve4(await extractResult(result));
        } else {
          const rebuildCallback = typeof watchMode === "object" && typeof watchMode.onRebuild === "function" ? watchMode.onRebuild : async (error2, result) => {
            var _a2, _b2;
            if (error2) {
              (_a2 = options.onRebuild) == null ? void 0 : _a2.call(options, { err: error2 });
            }
            if (result) {
              (_b2 = options.onRebuild) == null ? void 0 : _b2.call(options, await extractResult(result));
            }
          };
          const onRebuildPlugin = () => {
            return {
              name: "bundle-require:on-rebuild",
              setup(ctx2) {
                let count = 0;
                ctx2.onEnd(async (result) => {
                  if (count++ === 0) {
                    if (result.errors.length === 0)
                      resolve4(await extractResult(result));
                  } else {
                    if (result.errors.length > 0) {
                      return rebuildCallback(
                        { errors: result.errors, warnings: result.warnings },
                        null
                      );
                    }
                    if (result) {
                      rebuildCallback(null, result);
                    }
                  }
                });
              }
            };
          };
          esbuildOptions.plugins.push(onRebuildPlugin());
          const ctx = await (0, import_esbuild.context)(esbuildOptions);
          await ctx.watch();
        }
      };
      run2().catch(reject);
    });
  }

  // src/cli/config/loadConfig.ts
  var import_joycon = __toESM(require_lib5());
  var import_path24 = __require2("path");

  // src/cli/commands/init/shouldUseBuiltinForc.ts
  var shouldUseBuiltinForc = () => {
    const { systemForcVersion } = getSystemForc();
    if (systemForcVersion !== null) {
      return false;
    }
    return true;
  };

  // src/cli/commands/init/shouldUseBuiltinFuelCore.ts
  var shouldUseBuiltinFuelCore = () => {
    const { systemFuelCoreVersion } = getSystemFuelCore();
    if (systemFuelCoreVersion !== null) {
      return false;
    }
    return true;
  };

  // ../../node_modules/.pnpm/nanoclone@0.2.1/node_modules/nanoclone/src/index.js
  var map;
  try {
    map = Map;
  } catch (_) {
  }
  var set;
  try {
    set = Set;
  } catch (_) {
  }
  function baseClone(src, circulars, clones) {
    if (!src || typeof src !== "object" || typeof src === "function") {
      return src;
    }
    if (src.nodeType && "cloneNode" in src) {
      return src.cloneNode(true);
    }
    if (src instanceof Date) {
      return new Date(src.getTime());
    }
    if (src instanceof RegExp) {
      return new RegExp(src);
    }
    if (Array.isArray(src)) {
      return src.map(clone4);
    }
    if (map && src instanceof map) {
      return new Map(Array.from(src.entries()));
    }
    if (set && src instanceof set) {
      return new Set(Array.from(src.values()));
    }
    if (src instanceof Object) {
      circulars.push(src);
      var obj = Object.create(src);
      clones.push(obj);
      for (var key in src) {
        var idx = circulars.findIndex(function(i) {
          return i === src[key];
        });
        obj[key] = idx > -1 ? clones[idx] : baseClone(src[key], circulars, clones);
      }
      return obj;
    }
    return src;
  }
  function clone4(src) {
    return baseClone(src, [], []);
  }

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/util/printValue.js
  var toString2 = Object.prototype.toString;
  var errorToString = Error.prototype.toString;
  var regExpToString = RegExp.prototype.toString;
  var symbolToString = typeof Symbol !== "undefined" ? Symbol.prototype.toString : () => "";
  var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
  function printNumber(val) {
    if (val != +val)
      return "NaN";
    const isNegativeZero = val === 0 && 1 / val < 0;
    return isNegativeZero ? "-0" : "" + val;
  }
  function printSimpleValue(val, quoteStrings = false) {
    if (val == null || val === true || val === false)
      return "" + val;
    const typeOf = typeof val;
    if (typeOf === "number")
      return printNumber(val);
    if (typeOf === "string")
      return quoteStrings ? `"${val}"` : val;
    if (typeOf === "function")
      return "[Function " + (val.name || "anonymous") + "]";
    if (typeOf === "symbol")
      return symbolToString.call(val).replace(SYMBOL_REGEXP, "Symbol($1)");
    const tag = toString2.call(val).slice(8, -1);
    if (tag === "Date")
      return isNaN(val.getTime()) ? "" + val : val.toISOString(val);
    if (tag === "Error" || val instanceof Error)
      return "[" + errorToString.call(val) + "]";
    if (tag === "RegExp")
      return regExpToString.call(val);
    return null;
  }
  function printValue(value, quoteStrings) {
    let result = printSimpleValue(value, quoteStrings);
    if (result !== null)
      return result;
    return JSON.stringify(value, function(key, value2) {
      let result2 = printSimpleValue(this[key], quoteStrings);
      if (result2 !== null)
        return result2;
      return value2;
    }, 2);
  }

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/locale.js
  var mixed = {
    default: "${path} is invalid",
    required: "${path} is a required field",
    oneOf: "${path} must be one of the following values: ${values}",
    notOneOf: "${path} must not be one of the following values: ${values}",
    notType: ({
      path: path4,
      type: type3,
      value,
      originalValue
    }) => {
      let isCast = originalValue != null && originalValue !== value;
      let msg = `${path4} must be a \`${type3}\` type, but the final value was: \`${printValue(value, true)}\`` + (isCast ? ` (cast from the value \`${printValue(originalValue, true)}\`).` : ".");
      if (value === null) {
        msg += `
 If "null" is intended as an empty value be sure to mark the schema as \`.nullable()\``;
      }
      return msg;
    },
    defined: "${path} must be defined"
  };
  var string = {
    length: "${path} must be exactly ${length} characters",
    min: "${path} must be at least ${min} characters",
    max: "${path} must be at most ${max} characters",
    matches: '${path} must match the following: "${regex}"',
    email: "${path} must be a valid email",
    url: "${path} must be a valid URL",
    uuid: "${path} must be a valid UUID",
    trim: "${path} must be a trimmed string",
    lowercase: "${path} must be a lowercase string",
    uppercase: "${path} must be a upper case string"
  };
  var number3 = {
    min: "${path} must be greater than or equal to ${min}",
    max: "${path} must be less than or equal to ${max}",
    lessThan: "${path} must be less than ${less}",
    moreThan: "${path} must be greater than ${more}",
    positive: "${path} must be a positive number",
    negative: "${path} must be a negative number",
    integer: "${path} must be an integer"
  };
  var date = {
    min: "${path} field must be later than ${min}",
    max: "${path} field must be at earlier than ${max}"
  };
  var boolean = {
    isValue: "${path} field must be ${value}"
  };
  var object = {
    noUnknown: "${path} field has unspecified keys: ${unknown}"
  };
  var array = {
    min: "${path} field must have at least ${min} items",
    max: "${path} field must have less than or equal to ${max} items",
    length: "${path} must have ${length} items"
  };
  var locale_default = Object.assign(/* @__PURE__ */ Object.create(null), {
    mixed,
    string,
    number: number3,
    date,
    object,
    array,
    boolean
  });

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/Condition.js
  var import_has17 = __toESM(require_has());

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/util/isSchema.js
  var isSchema = (obj) => obj && obj.__isYupSchema__;
  var isSchema_default = isSchema;

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/Condition.js
  var Condition = class {
    constructor(refs, options) {
      this.fn = void 0;
      this.refs = refs;
      this.refs = refs;
      if (typeof options === "function") {
        this.fn = options;
        return;
      }
      if (!(0, import_has17.default)(options, "is"))
        throw new TypeError("`is:` is required for `when()` conditions");
      if (!options.then && !options.otherwise)
        throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
      let {
        is,
        then,
        otherwise
      } = options;
      let check = typeof is === "function" ? is : (...values) => values.every((value) => value === is);
      this.fn = function(...args) {
        let options2 = args.pop();
        let schema2 = args.pop();
        let branch = check(...args) ? then : otherwise;
        if (!branch)
          return void 0;
        if (typeof branch === "function")
          return branch(schema2);
        return schema2.concat(branch.resolve(options2));
      };
    }
    resolve(base, options) {
      let values = this.refs.map((ref) => ref.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context));
      let schema2 = this.fn.apply(base, values.concat(base, options));
      if (schema2 === void 0 || schema2 === base)
        return base;
      if (!isSchema_default(schema2))
        throw new TypeError("conditions must return a schema object");
      return schema2.resolve(options);
    }
  };
  var Condition_default = Condition;

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/util/toArray.js
  function toArray(value) {
    return value == null ? [] : [].concat(value);
  }

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/ValidationError.js
  function _extends() {
    _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  var strReg = /\$\{\s*(\w+)\s*\}/g;
  var ValidationError = class extends Error {
    static formatError(message, params) {
      const path4 = params.label || params.path || "this";
      if (path4 !== params.path)
        params = _extends({}, params, {
          path: path4
        });
      if (typeof message === "string")
        return message.replace(strReg, (_, key) => printValue(params[key]));
      if (typeof message === "function")
        return message(params);
      return message;
    }
    static isError(err) {
      return err && err.name === "ValidationError";
    }
    constructor(errorOrErrors, value, field, type3) {
      super();
      this.value = void 0;
      this.path = void 0;
      this.type = void 0;
      this.errors = void 0;
      this.params = void 0;
      this.inner = void 0;
      this.name = "ValidationError";
      this.value = value;
      this.path = field;
      this.type = type3;
      this.errors = [];
      this.inner = [];
      toArray(errorOrErrors).forEach((err) => {
        if (ValidationError.isError(err)) {
          this.errors.push(...err.errors);
          this.inner = this.inner.concat(err.inner.length ? err.inner : err);
        } else {
          this.errors.push(err);
        }
      });
      this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, ValidationError);
    }
  };

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/util/runTests.js
  var once = (cb) => {
    let fired = false;
    return (...args) => {
      if (fired)
        return;
      fired = true;
      cb(...args);
    };
  };
  function runTests(options, cb) {
    let {
      endEarly,
      tests,
      args,
      value,
      errors,
      sort,
      path: path4
    } = options;
    let callback = once(cb);
    let count = tests.length;
    const nestedErrors = [];
    errors = errors ? errors : [];
    if (!count)
      return errors.length ? callback(new ValidationError(errors, value, path4)) : callback(null, value);
    for (let i = 0; i < tests.length; i++) {
      const test = tests[i];
      test(args, function finishTestRun(err) {
        if (err) {
          if (!ValidationError.isError(err)) {
            return callback(err, value);
          }
          if (endEarly) {
            err.value = value;
            return callback(err, value);
          }
          nestedErrors.push(err);
        }
        if (--count <= 0) {
          if (nestedErrors.length) {
            if (sort)
              nestedErrors.sort(sort);
            if (errors.length)
              nestedErrors.push(...errors);
            errors = nestedErrors;
          }
          if (errors.length) {
            callback(new ValidationError(errors, value, path4), value);
            return;
          }
          callback(null, value);
        }
      });
    }
  }

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/util/createValidation.js
  var import_mapValues = __toESM(require_mapValues());

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/Reference.js
  var import_property_expr = __toESM(require_property_expr());
  var prefixes = {
    context: "$",
    value: "."
  };
  var Reference = class {
    constructor(key, options = {}) {
      this.key = void 0;
      this.isContext = void 0;
      this.isValue = void 0;
      this.isSibling = void 0;
      this.path = void 0;
      this.getter = void 0;
      this.map = void 0;
      if (typeof key !== "string")
        throw new TypeError("ref must be a string, got: " + key);
      this.key = key.trim();
      if (key === "")
        throw new TypeError("ref must be a non-empty string");
      this.isContext = this.key[0] === prefixes.context;
      this.isValue = this.key[0] === prefixes.value;
      this.isSibling = !this.isContext && !this.isValue;
      let prefix = this.isContext ? prefixes.context : this.isValue ? prefixes.value : "";
      this.path = this.key.slice(prefix.length);
      this.getter = this.path && (0, import_property_expr.getter)(this.path, true);
      this.map = options.map;
    }
    getValue(value, parent, context2) {
      let result = this.isContext ? context2 : this.isValue ? value : parent;
      if (this.getter)
        result = this.getter(result || {});
      if (this.map)
        result = this.map(result);
      return result;
    }
    /**
     *
     * @param {*} value
     * @param {Object} options
     * @param {Object=} options.context
     * @param {Object=} options.parent
     */
    cast(value, options) {
      return this.getValue(value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);
    }
    resolve() {
      return this;
    }
    describe() {
      return {
        type: "ref",
        key: this.key
      };
    }
    toString() {
      return `Ref(${this.key})`;
    }
    static isRef(value) {
      return value && value.__isYupRef;
    }
  };
  Reference.prototype.__isYupRef = true;

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/util/createValidation.js
  function _extends2() {
    _extends2 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends2.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function createValidation(config) {
    function validate(_ref, cb) {
      let {
        value,
        path: path4 = "",
        label,
        options,
        originalValue,
        sync: sync2
      } = _ref, rest = _objectWithoutPropertiesLoose(_ref, ["value", "path", "label", "options", "originalValue", "sync"]);
      const {
        name,
        test,
        params,
        message
      } = config;
      let {
        parent,
        context: context2
      } = options;
      function resolve4(item) {
        return Reference.isRef(item) ? item.getValue(value, parent, context2) : item;
      }
      function createError(overrides = {}) {
        const nextParams = (0, import_mapValues.default)(_extends2({
          value,
          originalValue,
          label,
          path: overrides.path || path4
        }, params, overrides.params), resolve4);
        const error2 = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value, nextParams.path, overrides.type || name);
        error2.params = nextParams;
        return error2;
      }
      let ctx = _extends2({
        path: path4,
        parent,
        type: name,
        createError,
        resolve: resolve4,
        options,
        originalValue
      }, rest);
      if (!sync2) {
        try {
          Promise.resolve(test.call(ctx, value, ctx)).then((validOrError) => {
            if (ValidationError.isError(validOrError))
              cb(validOrError);
            else if (!validOrError)
              cb(createError());
            else
              cb(null, validOrError);
          }).catch(cb);
        } catch (err) {
          cb(err);
        }
        return;
      }
      let result;
      try {
        var _ref2;
        result = test.call(ctx, value, ctx);
        if (typeof ((_ref2 = result) == null ? void 0 : _ref2.then) === "function") {
          throw new Error(`Validation test of type: "${ctx.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);
        }
      } catch (err) {
        cb(err);
        return;
      }
      if (ValidationError.isError(result))
        cb(result);
      else if (!result)
        cb(createError());
      else
        cb(null, result);
    }
    validate.OPTIONS = config;
    return validate;
  }

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/util/reach.js
  var import_property_expr2 = __toESM(require_property_expr());
  var trim = (part) => part.substr(0, part.length - 1).substr(1);
  function getIn(schema2, path4, value, context2 = value) {
    let parent, lastPart, lastPartDebug;
    if (!path4)
      return {
        parent,
        parentPath: path4,
        schema: schema2
      };
    (0, import_property_expr2.forEach)(path4, (_part, isBracket, isArray) => {
      let part = isBracket ? trim(_part) : _part;
      schema2 = schema2.resolve({
        context: context2,
        parent,
        value
      });
      if (schema2.innerType) {
        let idx = isArray ? parseInt(part, 10) : 0;
        if (value && idx >= value.length) {
          throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path4}. because there is no value at that index. `);
        }
        parent = value;
        value = value && value[idx];
        schema2 = schema2.innerType;
      }
      if (!isArray) {
        if (!schema2.fields || !schema2.fields[part])
          throw new Error(`The schema does not contain the path: ${path4}. (failed at: ${lastPartDebug} which is a type: "${schema2._type}")`);
        parent = value;
        value = value && value[part];
        schema2 = schema2.fields[part];
      }
      lastPart = part;
      lastPartDebug = isBracket ? "[" + _part + "]" : "." + _part;
    });
    return {
      schema: schema2,
      parent,
      parentPath: lastPart
    };
  }

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/util/ReferenceSet.js
  var ReferenceSet = class {
    constructor() {
      this.list = void 0;
      this.refs = void 0;
      this.list = /* @__PURE__ */ new Set();
      this.refs = /* @__PURE__ */ new Map();
    }
    get size() {
      return this.list.size + this.refs.size;
    }
    describe() {
      const description = [];
      for (const item of this.list)
        description.push(item);
      for (const [, ref] of this.refs)
        description.push(ref.describe());
      return description;
    }
    toArray() {
      return Array.from(this.list).concat(Array.from(this.refs.values()));
    }
    resolveAll(resolve4) {
      return this.toArray().reduce((acc, e) => acc.concat(Reference.isRef(e) ? resolve4(e) : e), []);
    }
    add(value) {
      Reference.isRef(value) ? this.refs.set(value.key, value) : this.list.add(value);
    }
    delete(value) {
      Reference.isRef(value) ? this.refs.delete(value.key) : this.list.delete(value);
    }
    clone() {
      const next = new ReferenceSet();
      next.list = new Set(this.list);
      next.refs = new Map(this.refs);
      return next;
    }
    merge(newItems, removeItems) {
      const next = this.clone();
      newItems.list.forEach((value) => next.add(value));
      newItems.refs.forEach((value) => next.add(value));
      removeItems.list.forEach((value) => next.delete(value));
      removeItems.refs.forEach((value) => next.delete(value));
      return next;
    }
  };

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/schema.js
  function _extends3() {
    _extends3 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends3.apply(this, arguments);
  }
  var BaseSchema = class {
    constructor(options) {
      this.deps = [];
      this.tests = void 0;
      this.transforms = void 0;
      this.conditions = [];
      this._mutate = void 0;
      this._typeError = void 0;
      this._whitelist = new ReferenceSet();
      this._blacklist = new ReferenceSet();
      this.exclusiveTests = /* @__PURE__ */ Object.create(null);
      this.spec = void 0;
      this.tests = [];
      this.transforms = [];
      this.withMutation(() => {
        this.typeError(mixed.notType);
      });
      this.type = (options == null ? void 0 : options.type) || "mixed";
      this.spec = _extends3({
        strip: false,
        strict: false,
        abortEarly: true,
        recursive: true,
        nullable: false,
        presence: "optional"
      }, options == null ? void 0 : options.spec);
    }
    // TODO: remove
    get _type() {
      return this.type;
    }
    _typeCheck(_value) {
      return true;
    }
    clone(spec) {
      if (this._mutate) {
        if (spec)
          Object.assign(this.spec, spec);
        return this;
      }
      const next = Object.create(Object.getPrototypeOf(this));
      next.type = this.type;
      next._typeError = this._typeError;
      next._whitelistError = this._whitelistError;
      next._blacklistError = this._blacklistError;
      next._whitelist = this._whitelist.clone();
      next._blacklist = this._blacklist.clone();
      next.exclusiveTests = _extends3({}, this.exclusiveTests);
      next.deps = [...this.deps];
      next.conditions = [...this.conditions];
      next.tests = [...this.tests];
      next.transforms = [...this.transforms];
      next.spec = clone4(_extends3({}, this.spec, spec));
      return next;
    }
    label(label) {
      let next = this.clone();
      next.spec.label = label;
      return next;
    }
    meta(...args) {
      if (args.length === 0)
        return this.spec.meta;
      let next = this.clone();
      next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);
      return next;
    }
    // withContext<TContext extends AnyObject>(): BaseSchema<
    //   TCast,
    //   TContext,
    //   TOutput
    // > {
    //   return this as any;
    // }
    withMutation(fn) {
      let before = this._mutate;
      this._mutate = true;
      let result = fn(this);
      this._mutate = before;
      return result;
    }
    concat(schema2) {
      if (!schema2 || schema2 === this)
        return this;
      if (schema2.type !== this.type && this.type !== "mixed")
        throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${schema2.type}`);
      let base = this;
      let combined = schema2.clone();
      const mergedSpec = _extends3({}, base.spec, combined.spec);
      combined.spec = mergedSpec;
      combined._typeError || (combined._typeError = base._typeError);
      combined._whitelistError || (combined._whitelistError = base._whitelistError);
      combined._blacklistError || (combined._blacklistError = base._blacklistError);
      combined._whitelist = base._whitelist.merge(schema2._whitelist, schema2._blacklist);
      combined._blacklist = base._blacklist.merge(schema2._blacklist, schema2._whitelist);
      combined.tests = base.tests;
      combined.exclusiveTests = base.exclusiveTests;
      combined.withMutation((next) => {
        schema2.tests.forEach((fn) => {
          next.test(fn.OPTIONS);
        });
      });
      combined.transforms = [...base.transforms, ...combined.transforms];
      return combined;
    }
    isType(v) {
      if (this.spec.nullable && v === null)
        return true;
      return this._typeCheck(v);
    }
    resolve(options) {
      let schema2 = this;
      if (schema2.conditions.length) {
        let conditions = schema2.conditions;
        schema2 = schema2.clone();
        schema2.conditions = [];
        schema2 = conditions.reduce((schema3, condition) => condition.resolve(schema3, options), schema2);
        schema2 = schema2.resolve(options);
      }
      return schema2;
    }
    /**
     *
     * @param {*} value
     * @param {Object} options
     * @param {*=} options.parent
     * @param {*=} options.context
     */
    cast(value, options = {}) {
      let resolvedSchema = this.resolve(_extends3({
        value
      }, options));
      let result = resolvedSchema._cast(value, options);
      if (value !== void 0 && options.assert !== false && resolvedSchema.isType(result) !== true) {
        let formattedValue = printValue(value);
        let formattedResult = printValue(result);
        throw new TypeError(`The value of ${options.path || "field"} could not be cast to a value that satisfies the schema type: "${resolvedSchema._type}". 

attempted value: ${formattedValue} 
` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : ""));
      }
      return result;
    }
    _cast(rawValue, _options2) {
      let value = rawValue === void 0 ? rawValue : this.transforms.reduce((value2, fn) => fn.call(this, value2, rawValue, this), rawValue);
      if (value === void 0) {
        value = this.getDefault();
      }
      return value;
    }
    _validate(_value, options = {}, cb) {
      let {
        sync: sync2,
        path: path4,
        from = [],
        originalValue = _value,
        strict = this.spec.strict,
        abortEarly = this.spec.abortEarly
      } = options;
      let value = _value;
      if (!strict) {
        value = this._cast(value, _extends3({
          assert: false
        }, options));
      }
      let args = {
        value,
        path: path4,
        options,
        originalValue,
        schema: this,
        label: this.spec.label,
        sync: sync2,
        from
      };
      let initialTests = [];
      if (this._typeError)
        initialTests.push(this._typeError);
      let finalTests = [];
      if (this._whitelistError)
        finalTests.push(this._whitelistError);
      if (this._blacklistError)
        finalTests.push(this._blacklistError);
      runTests({
        args,
        value,
        path: path4,
        sync: sync2,
        tests: initialTests,
        endEarly: abortEarly
      }, (err) => {
        if (err)
          return void cb(err, value);
        runTests({
          tests: this.tests.concat(finalTests),
          args,
          path: path4,
          sync: sync2,
          value,
          endEarly: abortEarly
        }, cb);
      });
    }
    validate(value, options, maybeCb) {
      let schema2 = this.resolve(_extends3({}, options, {
        value
      }));
      return typeof maybeCb === "function" ? schema2._validate(value, options, maybeCb) : new Promise((resolve4, reject) => schema2._validate(value, options, (err, value2) => {
        if (err)
          reject(err);
        else
          resolve4(value2);
      }));
    }
    validateSync(value, options) {
      let schema2 = this.resolve(_extends3({}, options, {
        value
      }));
      let result;
      schema2._validate(value, _extends3({}, options, {
        sync: true
      }), (err, value2) => {
        if (err)
          throw err;
        result = value2;
      });
      return result;
    }
    isValid(value, options) {
      return this.validate(value, options).then(() => true, (err) => {
        if (ValidationError.isError(err))
          return false;
        throw err;
      });
    }
    isValidSync(value, options) {
      try {
        this.validateSync(value, options);
        return true;
      } catch (err) {
        if (ValidationError.isError(err))
          return false;
        throw err;
      }
    }
    _getDefault() {
      let defaultValue = this.spec.default;
      if (defaultValue == null) {
        return defaultValue;
      }
      return typeof defaultValue === "function" ? defaultValue.call(this) : clone4(defaultValue);
    }
    getDefault(options) {
      let schema2 = this.resolve(options || {});
      return schema2._getDefault();
    }
    default(def) {
      if (arguments.length === 0) {
        return this._getDefault();
      }
      let next = this.clone({
        default: def
      });
      return next;
    }
    strict(isStrict = true) {
      let next = this.clone();
      next.spec.strict = isStrict;
      return next;
    }
    _isPresent(value) {
      return value != null;
    }
    defined(message = mixed.defined) {
      return this.test({
        message,
        name: "defined",
        exclusive: true,
        test(value) {
          return value !== void 0;
        }
      });
    }
    required(message = mixed.required) {
      return this.clone({
        presence: "required"
      }).withMutation((s) => s.test({
        message,
        name: "required",
        exclusive: true,
        test(value) {
          return this.schema._isPresent(value);
        }
      }));
    }
    notRequired() {
      let next = this.clone({
        presence: "optional"
      });
      next.tests = next.tests.filter((test) => test.OPTIONS.name !== "required");
      return next;
    }
    nullable(isNullable = true) {
      let next = this.clone({
        nullable: isNullable !== false
      });
      return next;
    }
    transform(fn) {
      let next = this.clone();
      next.transforms.push(fn);
      return next;
    }
    /**
     * Adds a test function to the schema's queue of tests.
     * tests can be exclusive or non-exclusive.
     *
     * - exclusive tests, will replace any existing tests of the same name.
     * - non-exclusive: can be stacked
     *
     * If a non-exclusive test is added to a schema with an exclusive test of the same name
     * the exclusive test is removed and further tests of the same name will be stacked.
     *
     * If an exclusive test is added to a schema with non-exclusive tests of the same name
     * the previous tests are removed and further tests of the same name will replace each other.
     */
    test(...args) {
      let opts;
      if (args.length === 1) {
        if (typeof args[0] === "function") {
          opts = {
            test: args[0]
          };
        } else {
          opts = args[0];
        }
      } else if (args.length === 2) {
        opts = {
          name: args[0],
          test: args[1]
        };
      } else {
        opts = {
          name: args[0],
          message: args[1],
          test: args[2]
        };
      }
      if (opts.message === void 0)
        opts.message = mixed.default;
      if (typeof opts.test !== "function")
        throw new TypeError("`test` is a required parameters");
      let next = this.clone();
      let validate = createValidation(opts);
      let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;
      if (opts.exclusive) {
        if (!opts.name)
          throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");
      }
      if (opts.name)
        next.exclusiveTests[opts.name] = !!opts.exclusive;
      next.tests = next.tests.filter((fn) => {
        if (fn.OPTIONS.name === opts.name) {
          if (isExclusive)
            return false;
          if (fn.OPTIONS.test === validate.OPTIONS.test)
            return false;
        }
        return true;
      });
      next.tests.push(validate);
      return next;
    }
    when(keys4, options) {
      if (!Array.isArray(keys4) && typeof keys4 !== "string") {
        options = keys4;
        keys4 = ".";
      }
      let next = this.clone();
      let deps = toArray(keys4).map((key) => new Reference(key));
      deps.forEach((dep) => {
        if (dep.isSibling)
          next.deps.push(dep.key);
      });
      next.conditions.push(new Condition_default(deps, options));
      return next;
    }
    typeError(message) {
      let next = this.clone();
      next._typeError = createValidation({
        message,
        name: "typeError",
        test(value) {
          if (value !== void 0 && !this.schema.isType(value))
            return this.createError({
              params: {
                type: this.schema._type
              }
            });
          return true;
        }
      });
      return next;
    }
    oneOf(enums, message = mixed.oneOf) {
      let next = this.clone();
      enums.forEach((val) => {
        next._whitelist.add(val);
        next._blacklist.delete(val);
      });
      next._whitelistError = createValidation({
        message,
        name: "oneOf",
        test(value) {
          if (value === void 0)
            return true;
          let valids = this.schema._whitelist;
          let resolved = valids.resolveAll(this.resolve);
          return resolved.includes(value) ? true : this.createError({
            params: {
              values: valids.toArray().join(", "),
              resolved
            }
          });
        }
      });
      return next;
    }
    notOneOf(enums, message = mixed.notOneOf) {
      let next = this.clone();
      enums.forEach((val) => {
        next._blacklist.add(val);
        next._whitelist.delete(val);
      });
      next._blacklistError = createValidation({
        message,
        name: "notOneOf",
        test(value) {
          let invalids = this.schema._blacklist;
          let resolved = invalids.resolveAll(this.resolve);
          if (resolved.includes(value))
            return this.createError({
              params: {
                values: invalids.toArray().join(", "),
                resolved
              }
            });
          return true;
        }
      });
      return next;
    }
    strip(strip = true) {
      let next = this.clone();
      next.spec.strip = strip;
      return next;
    }
    describe() {
      const next = this.clone();
      const {
        label,
        meta
      } = next.spec;
      const description = {
        meta,
        label,
        type: next.type,
        oneOf: next._whitelist.describe(),
        notOneOf: next._blacklist.describe(),
        tests: next.tests.map((fn) => ({
          name: fn.OPTIONS.name,
          params: fn.OPTIONS.params
        })).filter((n, idx, list) => list.findIndex((c) => c.name === n.name) === idx)
      };
      return description;
    }
  };
  BaseSchema.prototype.__isYupSchema__ = true;
  for (const method of ["validate", "validateSync"])
    BaseSchema.prototype[`${method}At`] = function(path4, value, options = {}) {
      const {
        parent,
        parentPath,
        schema: schema2
      } = getIn(this, path4, value, options.context);
      return schema2[method](parent && parent[parentPath], _extends3({}, options, {
        parent,
        path: path4
      }));
    };
  for (const alias of ["equals", "is"])
    BaseSchema.prototype[alias] = BaseSchema.prototype.oneOf;
  for (const alias of ["not", "nope"])
    BaseSchema.prototype[alias] = BaseSchema.prototype.notOneOf;
  BaseSchema.prototype.optional = BaseSchema.prototype.notRequired;

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/mixed.js
  var Mixed = BaseSchema;
  function create() {
    return new Mixed();
  }
  create.prototype = Mixed.prototype;

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/util/isAbsent.js
  var isAbsent = (value) => value == null;
  var isAbsent_default = isAbsent;

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/boolean.js
  function create2() {
    return new BooleanSchema();
  }
  var BooleanSchema = class extends BaseSchema {
    constructor() {
      super({
        type: "boolean"
      });
      this.withMutation(() => {
        this.transform(function(value) {
          if (!this.isType(value)) {
            if (/^(true|1)$/i.test(String(value)))
              return true;
            if (/^(false|0)$/i.test(String(value)))
              return false;
          }
          return value;
        });
      });
    }
    _typeCheck(v) {
      if (v instanceof Boolean)
        v = v.valueOf();
      return typeof v === "boolean";
    }
    isTrue(message = boolean.isValue) {
      return this.test({
        message,
        name: "is-value",
        exclusive: true,
        params: {
          value: "true"
        },
        test(value) {
          return isAbsent_default(value) || value === true;
        }
      });
    }
    isFalse(message = boolean.isValue) {
      return this.test({
        message,
        name: "is-value",
        exclusive: true,
        params: {
          value: "false"
        },
        test(value) {
          return isAbsent_default(value) || value === false;
        }
      });
    }
  };
  create2.prototype = BooleanSchema.prototype;

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/string.js
  var rEmail = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
  var rUrl = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;
  var rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  var isTrimmed = (value) => isAbsent_default(value) || value === value.trim();
  var objStringTag = {}.toString();
  function create3() {
    return new StringSchema();
  }
  var StringSchema = class extends BaseSchema {
    constructor() {
      super({
        type: "string"
      });
      this.withMutation(() => {
        this.transform(function(value) {
          if (this.isType(value))
            return value;
          if (Array.isArray(value))
            return value;
          const strValue = value != null && value.toString ? value.toString() : value;
          if (strValue === objStringTag)
            return value;
          return strValue;
        });
      });
    }
    _typeCheck(value) {
      if (value instanceof String)
        value = value.valueOf();
      return typeof value === "string";
    }
    _isPresent(value) {
      return super._isPresent(value) && !!value.length;
    }
    length(length, message = string.length) {
      return this.test({
        message,
        name: "length",
        exclusive: true,
        params: {
          length
        },
        test(value) {
          return isAbsent_default(value) || value.length === this.resolve(length);
        }
      });
    }
    min(min, message = string.min) {
      return this.test({
        message,
        name: "min",
        exclusive: true,
        params: {
          min
        },
        test(value) {
          return isAbsent_default(value) || value.length >= this.resolve(min);
        }
      });
    }
    max(max2, message = string.max) {
      return this.test({
        name: "max",
        exclusive: true,
        message,
        params: {
          max: max2
        },
        test(value) {
          return isAbsent_default(value) || value.length <= this.resolve(max2);
        }
      });
    }
    matches(regex, options) {
      let excludeEmptyString = false;
      let message;
      let name;
      if (options) {
        if (typeof options === "object") {
          ({
            excludeEmptyString = false,
            message,
            name
          } = options);
        } else {
          message = options;
        }
      }
      return this.test({
        name: name || "matches",
        message: message || string.matches,
        params: {
          regex
        },
        test: (value) => isAbsent_default(value) || value === "" && excludeEmptyString || value.search(regex) !== -1
      });
    }
    email(message = string.email) {
      return this.matches(rEmail, {
        name: "email",
        message,
        excludeEmptyString: true
      });
    }
    url(message = string.url) {
      return this.matches(rUrl, {
        name: "url",
        message,
        excludeEmptyString: true
      });
    }
    uuid(message = string.uuid) {
      return this.matches(rUUID, {
        name: "uuid",
        message,
        excludeEmptyString: false
      });
    }
    //-- transforms --
    ensure() {
      return this.default("").transform((val) => val === null ? "" : val);
    }
    trim(message = string.trim) {
      return this.transform((val) => val != null ? val.trim() : val).test({
        message,
        name: "trim",
        test: isTrimmed
      });
    }
    lowercase(message = string.lowercase) {
      return this.transform((value) => !isAbsent_default(value) ? value.toLowerCase() : value).test({
        message,
        name: "string_case",
        exclusive: true,
        test: (value) => isAbsent_default(value) || value === value.toLowerCase()
      });
    }
    uppercase(message = string.uppercase) {
      return this.transform((value) => !isAbsent_default(value) ? value.toUpperCase() : value).test({
        message,
        name: "string_case",
        exclusive: true,
        test: (value) => isAbsent_default(value) || value === value.toUpperCase()
      });
    }
  };
  create3.prototype = StringSchema.prototype;

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/number.js
  var isNaN2 = (value) => value != +value;
  function create4() {
    return new NumberSchema();
  }
  var NumberSchema = class extends BaseSchema {
    constructor() {
      super({
        type: "number"
      });
      this.withMutation(() => {
        this.transform(function(value) {
          let parsed = value;
          if (typeof parsed === "string") {
            parsed = parsed.replace(/\s/g, "");
            if (parsed === "")
              return NaN;
            parsed = +parsed;
          }
          if (this.isType(parsed))
            return parsed;
          return parseFloat(parsed);
        });
      });
    }
    _typeCheck(value) {
      if (value instanceof Number)
        value = value.valueOf();
      return typeof value === "number" && !isNaN2(value);
    }
    min(min, message = number3.min) {
      return this.test({
        message,
        name: "min",
        exclusive: true,
        params: {
          min
        },
        test(value) {
          return isAbsent_default(value) || value >= this.resolve(min);
        }
      });
    }
    max(max2, message = number3.max) {
      return this.test({
        message,
        name: "max",
        exclusive: true,
        params: {
          max: max2
        },
        test(value) {
          return isAbsent_default(value) || value <= this.resolve(max2);
        }
      });
    }
    lessThan(less, message = number3.lessThan) {
      return this.test({
        message,
        name: "max",
        exclusive: true,
        params: {
          less
        },
        test(value) {
          return isAbsent_default(value) || value < this.resolve(less);
        }
      });
    }
    moreThan(more, message = number3.moreThan) {
      return this.test({
        message,
        name: "min",
        exclusive: true,
        params: {
          more
        },
        test(value) {
          return isAbsent_default(value) || value > this.resolve(more);
        }
      });
    }
    positive(msg = number3.positive) {
      return this.moreThan(0, msg);
    }
    negative(msg = number3.negative) {
      return this.lessThan(0, msg);
    }
    integer(message = number3.integer) {
      return this.test({
        name: "integer",
        message,
        test: (val) => isAbsent_default(val) || Number.isInteger(val)
      });
    }
    truncate() {
      return this.transform((value) => !isAbsent_default(value) ? value | 0 : value);
    }
    round(method) {
      var _method;
      let avail = ["ceil", "floor", "round", "trunc"];
      method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || "round";
      if (method === "trunc")
        return this.truncate();
      if (avail.indexOf(method.toLowerCase()) === -1)
        throw new TypeError("Only valid options for round() are: " + avail.join(", "));
      return this.transform((value) => !isAbsent_default(value) ? Math[method](value) : value);
    }
  };
  create4.prototype = NumberSchema.prototype;

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/util/isodate.js
  var isoReg = /^(\d{4}|[+\-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,\.](\d{1,}))?)?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?)?)?$/;
  function parseIsoDate(date2) {
    var numericKeys = [1, 4, 5, 6, 7, 10, 11], minutesOffset = 0, timestamp, struct;
    if (struct = isoReg.exec(date2)) {
      for (var i = 0, k; k = numericKeys[i]; ++i)
        struct[k] = +struct[k] || 0;
      struct[2] = (+struct[2] || 1) - 1;
      struct[3] = +struct[3] || 1;
      struct[7] = struct[7] ? String(struct[7]).substr(0, 3) : 0;
      if ((struct[8] === void 0 || struct[8] === "") && (struct[9] === void 0 || struct[9] === ""))
        timestamp = +new Date(struct[1], struct[2], struct[3], struct[4], struct[5], struct[6], struct[7]);
      else {
        if (struct[8] !== "Z" && struct[9] !== void 0) {
          minutesOffset = struct[10] * 60 + struct[11];
          if (struct[9] === "+")
            minutesOffset = 0 - minutesOffset;
        }
        timestamp = Date.UTC(struct[1], struct[2], struct[3], struct[4], struct[5] + minutesOffset, struct[6], struct[7]);
      }
    } else
      timestamp = Date.parse ? Date.parse(date2) : NaN;
    return timestamp;
  }

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/date.js
  var invalidDate = /* @__PURE__ */ new Date("");
  var isDate = (obj) => Object.prototype.toString.call(obj) === "[object Date]";
  function create5() {
    return new DateSchema();
  }
  var DateSchema = class extends BaseSchema {
    constructor() {
      super({
        type: "date"
      });
      this.withMutation(() => {
        this.transform(function(value) {
          if (this.isType(value))
            return value;
          value = parseIsoDate(value);
          return !isNaN(value) ? new Date(value) : invalidDate;
        });
      });
    }
    _typeCheck(v) {
      return isDate(v) && !isNaN(v.getTime());
    }
    prepareParam(ref, name) {
      let param;
      if (!Reference.isRef(ref)) {
        let cast = this.cast(ref);
        if (!this._typeCheck(cast))
          throw new TypeError(`\`${name}\` must be a Date or a value that can be \`cast()\` to a Date`);
        param = cast;
      } else {
        param = ref;
      }
      return param;
    }
    min(min, message = date.min) {
      let limit = this.prepareParam(min, "min");
      return this.test({
        message,
        name: "min",
        exclusive: true,
        params: {
          min
        },
        test(value) {
          return isAbsent_default(value) || value >= this.resolve(limit);
        }
      });
    }
    max(max2, message = date.max) {
      let limit = this.prepareParam(max2, "max");
      return this.test({
        message,
        name: "max",
        exclusive: true,
        params: {
          max: max2
        },
        test(value) {
          return isAbsent_default(value) || value <= this.resolve(limit);
        }
      });
    }
  };
  DateSchema.INVALID_DATE = invalidDate;
  create5.prototype = DateSchema.prototype;
  create5.INVALID_DATE = invalidDate;

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/object.js
  var import_has19 = __toESM(require_has());
  var import_snakeCase = __toESM(require_snakeCase());
  var import_camelCase = __toESM(require_camelCase());
  var import_mapKeys = __toESM(require_mapKeys());
  var import_mapValues2 = __toESM(require_mapValues());
  var import_property_expr4 = __toESM(require_property_expr());

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/util/sortFields.js
  var import_has18 = __toESM(require_has());
  var import_toposort = __toESM(require_toposort());
  var import_property_expr3 = __toESM(require_property_expr());
  function sortFields(fields, excludedEdges = []) {
    let edges = [];
    let nodes = /* @__PURE__ */ new Set();
    let excludes = new Set(excludedEdges.map(([a, b]) => `${a}-${b}`));
    function addNode(depPath, key) {
      let node = (0, import_property_expr3.split)(depPath)[0];
      nodes.add(node);
      if (!excludes.has(`${key}-${node}`))
        edges.push([key, node]);
    }
    for (const key in fields)
      if ((0, import_has18.default)(fields, key)) {
        let value = fields[key];
        nodes.add(key);
        if (Reference.isRef(value) && value.isSibling)
          addNode(value.path, key);
        else if (isSchema_default(value) && "deps" in value)
          value.deps.forEach((path4) => addNode(path4, key));
      }
    return import_toposort.default.array(Array.from(nodes), edges).reverse();
  }

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/util/sortByKeyOrder.js
  function findIndex(arr, err) {
    let idx = Infinity;
    arr.some((key, ii) => {
      var _err$path;
      if (((_err$path = err.path) == null ? void 0 : _err$path.indexOf(key)) !== -1) {
        idx = ii;
        return true;
      }
    });
    return idx;
  }
  function sortByKeyOrder(keys4) {
    return (a, b) => {
      return findIndex(keys4, a) - findIndex(keys4, b);
    };
  }

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/object.js
  function _extends4() {
    _extends4 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends4.apply(this, arguments);
  }
  var isObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]";
  function unknown(ctx, value) {
    let known = Object.keys(ctx.fields);
    return Object.keys(value).filter((key) => known.indexOf(key) === -1);
  }
  var defaultSort = sortByKeyOrder([]);
  var ObjectSchema = class extends BaseSchema {
    constructor(spec) {
      super({
        type: "object"
      });
      this.fields = /* @__PURE__ */ Object.create(null);
      this._sortErrors = defaultSort;
      this._nodes = [];
      this._excludedEdges = [];
      this.withMutation(() => {
        this.transform(function coerce(value) {
          if (typeof value === "string") {
            try {
              value = JSON.parse(value);
            } catch (err) {
              value = null;
            }
          }
          if (this.isType(value))
            return value;
          return null;
        });
        if (spec) {
          this.shape(spec);
        }
      });
    }
    _typeCheck(value) {
      return isObject(value) || typeof value === "function";
    }
    _cast(_value, options = {}) {
      var _options$stripUnknown;
      let value = super._cast(_value, options);
      if (value === void 0)
        return this.getDefault();
      if (!this._typeCheck(value))
        return value;
      let fields = this.fields;
      let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;
      let props = this._nodes.concat(Object.keys(value).filter((v) => this._nodes.indexOf(v) === -1));
      let intermediateValue = {};
      let innerOptions = _extends4({}, options, {
        parent: intermediateValue,
        __validating: options.__validating || false
      });
      let isChanged = false;
      for (const prop of props) {
        let field = fields[prop];
        let exists3 = (0, import_has19.default)(value, prop);
        if (field) {
          let fieldValue;
          let inputValue = value[prop];
          innerOptions.path = (options.path ? `${options.path}.` : "") + prop;
          field = field.resolve({
            value: inputValue,
            context: options.context,
            parent: intermediateValue
          });
          let fieldSpec = "spec" in field ? field.spec : void 0;
          let strict = fieldSpec == null ? void 0 : fieldSpec.strict;
          if (fieldSpec == null ? void 0 : fieldSpec.strip) {
            isChanged = isChanged || prop in value;
            continue;
          }
          fieldValue = !options.__validating || !strict ? (
            // TODO: use _cast, this is double resolving
            field.cast(value[prop], innerOptions)
          ) : value[prop];
          if (fieldValue !== void 0) {
            intermediateValue[prop] = fieldValue;
          }
        } else if (exists3 && !strip) {
          intermediateValue[prop] = value[prop];
        }
        if (intermediateValue[prop] !== value[prop]) {
          isChanged = true;
        }
      }
      return isChanged ? intermediateValue : value;
    }
    _validate(_value, opts = {}, callback) {
      let errors = [];
      let {
        sync: sync2,
        from = [],
        originalValue = _value,
        abortEarly = this.spec.abortEarly,
        recursive = this.spec.recursive
      } = opts;
      from = [{
        schema: this,
        value: originalValue
      }, ...from];
      opts.__validating = true;
      opts.originalValue = originalValue;
      opts.from = from;
      super._validate(_value, opts, (err, value) => {
        if (err) {
          if (!ValidationError.isError(err) || abortEarly) {
            return void callback(err, value);
          }
          errors.push(err);
        }
        if (!recursive || !isObject(value)) {
          callback(errors[0] || null, value);
          return;
        }
        originalValue = originalValue || value;
        let tests = this._nodes.map((key) => (_, cb) => {
          let path4 = key.indexOf(".") === -1 ? (opts.path ? `${opts.path}.` : "") + key : `${opts.path || ""}["${key}"]`;
          let field = this.fields[key];
          if (field && "validate" in field) {
            field.validate(value[key], _extends4({}, opts, {
              // @ts-ignore
              path: path4,
              from,
              // inner fields are always strict:
              // 1. this isn't strict so the casting will also have cast inner values
              // 2. this is strict in which case the nested values weren't cast either
              strict: true,
              parent: value,
              originalValue: originalValue[key]
            }), cb);
            return;
          }
          cb(null);
        });
        runTests({
          sync: sync2,
          tests,
          value,
          errors,
          endEarly: abortEarly,
          sort: this._sortErrors,
          path: opts.path
        }, callback);
      });
    }
    clone(spec) {
      const next = super.clone(spec);
      next.fields = _extends4({}, this.fields);
      next._nodes = this._nodes;
      next._excludedEdges = this._excludedEdges;
      next._sortErrors = this._sortErrors;
      return next;
    }
    concat(schema2) {
      let next = super.concat(schema2);
      let nextFields = next.fields;
      for (let [field, schemaOrRef] of Object.entries(this.fields)) {
        const target = nextFields[field];
        if (target === void 0) {
          nextFields[field] = schemaOrRef;
        } else if (target instanceof BaseSchema && schemaOrRef instanceof BaseSchema) {
          nextFields[field] = schemaOrRef.concat(target);
        }
      }
      return next.withMutation(() => next.shape(nextFields, this._excludedEdges));
    }
    getDefaultFromShape() {
      let dft = {};
      this._nodes.forEach((key) => {
        const field = this.fields[key];
        dft[key] = "default" in field ? field.getDefault() : void 0;
      });
      return dft;
    }
    _getDefault() {
      if ("default" in this.spec) {
        return super._getDefault();
      }
      if (!this._nodes.length) {
        return void 0;
      }
      return this.getDefaultFromShape();
    }
    shape(additions, excludes = []) {
      let next = this.clone();
      let fields = Object.assign(next.fields, additions);
      next.fields = fields;
      next._sortErrors = sortByKeyOrder(Object.keys(fields));
      if (excludes.length) {
        if (!Array.isArray(excludes[0]))
          excludes = [excludes];
        next._excludedEdges = [...next._excludedEdges, ...excludes];
      }
      next._nodes = sortFields(fields, next._excludedEdges);
      return next;
    }
    pick(keys4) {
      const picked = {};
      for (const key of keys4) {
        if (this.fields[key])
          picked[key] = this.fields[key];
      }
      return this.clone().withMutation((next) => {
        next.fields = {};
        return next.shape(picked);
      });
    }
    omit(keys4) {
      const next = this.clone();
      const fields = next.fields;
      next.fields = {};
      for (const key of keys4) {
        delete fields[key];
      }
      return next.withMutation(() => next.shape(fields));
    }
    from(from, to, alias) {
      let fromGetter = (0, import_property_expr4.getter)(from, true);
      return this.transform((obj) => {
        if (obj == null)
          return obj;
        let newObj = obj;
        if ((0, import_has19.default)(obj, from)) {
          newObj = _extends4({}, obj);
          if (!alias)
            delete newObj[from];
          newObj[to] = fromGetter(obj);
        }
        return newObj;
      });
    }
    noUnknown(noAllow = true, message = object.noUnknown) {
      if (typeof noAllow === "string") {
        message = noAllow;
        noAllow = true;
      }
      let next = this.test({
        name: "noUnknown",
        exclusive: true,
        message,
        test(value) {
          if (value == null)
            return true;
          const unknownKeys = unknown(this.schema, value);
          return !noAllow || unknownKeys.length === 0 || this.createError({
            params: {
              unknown: unknownKeys.join(", ")
            }
          });
        }
      });
      next.spec.noUnknown = noAllow;
      return next;
    }
    unknown(allow = true, message = object.noUnknown) {
      return this.noUnknown(!allow, message);
    }
    transformKeys(fn) {
      return this.transform((obj) => obj && (0, import_mapKeys.default)(obj, (_, key) => fn(key)));
    }
    camelCase() {
      return this.transformKeys(import_camelCase.default);
    }
    snakeCase() {
      return this.transformKeys(import_snakeCase.default);
    }
    constantCase() {
      return this.transformKeys((key) => (0, import_snakeCase.default)(key).toUpperCase());
    }
    describe() {
      let base = super.describe();
      base.fields = (0, import_mapValues2.default)(this.fields, (value) => value.describe());
      return base;
    }
  };
  function create6(spec) {
    return new ObjectSchema(spec);
  }
  create6.prototype = ObjectSchema.prototype;

  // ../../node_modules/.pnpm/yup@0.32.11/node_modules/yup/es/array.js
  function _extends5() {
    _extends5 = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends5.apply(this, arguments);
  }
  function create7(type3) {
    return new ArraySchema(type3);
  }
  var ArraySchema = class extends BaseSchema {
    constructor(type3) {
      super({
        type: "array"
      });
      this.innerType = void 0;
      this.innerType = type3;
      this.withMutation(() => {
        this.transform(function(values) {
          if (typeof values === "string")
            try {
              values = JSON.parse(values);
            } catch (err) {
              values = null;
            }
          return this.isType(values) ? values : null;
        });
      });
    }
    _typeCheck(v) {
      return Array.isArray(v);
    }
    get _subType() {
      return this.innerType;
    }
    _cast(_value, _opts) {
      const value = super._cast(_value, _opts);
      if (!this._typeCheck(value) || !this.innerType)
        return value;
      let isChanged = false;
      const castArray = value.map((v, idx) => {
        const castElement = this.innerType.cast(v, _extends5({}, _opts, {
          path: `${_opts.path || ""}[${idx}]`
        }));
        if (castElement !== v) {
          isChanged = true;
        }
        return castElement;
      });
      return isChanged ? castArray : value;
    }
    _validate(_value, options = {}, callback) {
      var _options$abortEarly, _options$recursive;
      let errors = [];
      let sync2 = options.sync;
      let path4 = options.path;
      let innerType = this.innerType;
      let endEarly = (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly;
      let recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;
      let originalValue = options.originalValue != null ? options.originalValue : _value;
      super._validate(_value, options, (err, value) => {
        if (err) {
          if (!ValidationError.isError(err) || endEarly) {
            return void callback(err, value);
          }
          errors.push(err);
        }
        if (!recursive || !innerType || !this._typeCheck(value)) {
          callback(errors[0] || null, value);
          return;
        }
        originalValue = originalValue || value;
        let tests = new Array(value.length);
        for (let idx = 0; idx < value.length; idx++) {
          let item = value[idx];
          let path5 = `${options.path || ""}[${idx}]`;
          let innerOptions = _extends5({}, options, {
            path: path5,
            strict: true,
            parent: value,
            index: idx,
            originalValue: originalValue[idx]
          });
          tests[idx] = (_, cb) => innerType.validate(item, innerOptions, cb);
        }
        runTests({
          sync: sync2,
          path: path4,
          value,
          errors,
          endEarly,
          tests
        }, callback);
      });
    }
    clone(spec) {
      const next = super.clone(spec);
      next.innerType = this.innerType;
      return next;
    }
    concat(schema2) {
      let next = super.concat(schema2);
      next.innerType = this.innerType;
      if (schema2.innerType)
        next.innerType = next.innerType ? (
          // @ts-expect-error Lazy doesn't have concat()
          next.innerType.concat(schema2.innerType)
        ) : schema2.innerType;
      return next;
    }
    of(schema2) {
      let next = this.clone();
      if (!isSchema_default(schema2))
        throw new TypeError("`array.of()` sub-schema must be a valid yup schema not: " + printValue(schema2));
      next.innerType = schema2;
      return next;
    }
    length(length, message = array.length) {
      return this.test({
        message,
        name: "length",
        exclusive: true,
        params: {
          length
        },
        test(value) {
          return isAbsent_default(value) || value.length === this.resolve(length);
        }
      });
    }
    min(min, message) {
      message = message || array.min;
      return this.test({
        message,
        name: "min",
        exclusive: true,
        params: {
          min
        },
        // FIXME(ts): Array<typeof T>
        test(value) {
          return isAbsent_default(value) || value.length >= this.resolve(min);
        }
      });
    }
    max(max2, message) {
      message = message || array.max;
      return this.test({
        message,
        name: "max",
        exclusive: true,
        params: {
          max: max2
        },
        test(value) {
          return isAbsent_default(value) || value.length <= this.resolve(max2);
        }
      });
    }
    ensure() {
      return this.default(() => []).transform((val, original) => {
        if (this._typeCheck(val))
          return val;
        return original == null ? [] : [].concat(original);
      });
    }
    compact(rejector) {
      let reject = !rejector ? (v) => !!v : (v, i, a) => !rejector(v, i, a);
      return this.transform((values) => values != null ? values.filter(reject) : values);
    }
    describe() {
      let base = super.describe();
      if (this.innerType)
        base.innerType = this.innerType.describe();
      return base;
    }
    nullable(isNullable = true) {
      return super.nullable(isNullable);
    }
    defined() {
      return super.defined();
    }
    required(msg) {
      return super.required(msg);
    }
  };
  create7.prototype = ArraySchema.prototype;

  // src/cli/config/validateConfig.ts
  var schema = create6({
    workspace: create3(),
    contracts: create7(create3()),
    scripts: create7(create3()),
    predicates: create7(create3()),
    output: create3().required("config.output should be a valid string")
  }).required();
  async function validateConfig(config) {
    return schema.validate(config);
  }

  // src/cli/config/loadConfig.ts
  async function loadConfig(cwd) {
    const configJoycon = new import_joycon.default();
    const configPath = await configJoycon.resolve({
      files: ["ts", "js", "cjs", "mjs"].map((e) => `fuels.config.${e}`),
      cwd,
      stopDir: (0, import_path24.parse)(cwd).root
    });
    if (!configPath) {
      throw new Error("Config file not found!");
    }
    const esbuildOptions = {
      target: "ES2021",
      platform: "node",
      format: "esm"
    };
    const result = await bundleRequire({
      filepath: configPath,
      esbuildOptions,
      cwd
    });
    const userConfig = result.mod.default;
    await validateConfig(userConfig);
    const useBuiltinForc = userConfig.useBuiltinForc ?? shouldUseBuiltinForc();
    const useBuiltinFuelCore = userConfig.useBuiltinFuelCore ?? shouldUseBuiltinFuelCore();
    const config = {
      contracts: [],
      scripts: [],
      predicates: [],
      deployConfig: {},
      autoStartFuelCore: true,
      fuelCorePort: 4e3,
      providerUrl: FUEL_NETWORK_URL,
      privateKey: defaultConsensusKey,
      ...userConfig,
      basePath: cwd,
      useBuiltinForc,
      useBuiltinFuelCore,
      configPath
    };
    config.output = (0, import_path24.resolve)(cwd, config.output);
    config.autoStartFuelCore = userConfig.autoStartFuelCore ?? true;
    if (!userConfig.workspace) {
      const { contracts, predicates, scripts } = userConfig;
      config.contracts = (contracts || []).map((c) => (0, import_path24.resolve)(cwd, c));
      config.scripts = (scripts || []).map((s) => (0, import_path24.resolve)(cwd, s));
      config.predicates = (predicates || []).map((p) => (0, import_path24.resolve)(cwd, p));
    } else {
      const workspace = (0, import_path24.resolve)(cwd, userConfig.workspace);
      const forcToml = readForcToml(workspace);
      if (!forcToml.workspace) {
        const workspaceMsg = `Forc workspace not detected in:
  ${workspace}/Forc.toml`;
        const swayProgramType = readSwayType(workspace);
        const exampleMsg = `Try using '${swayProgramType}s' instead of 'workspace' in:
  ${configPath}`;
        throw new Error([workspaceMsg, exampleMsg].join("\n\n"));
      }
      const swayMembers = forcToml.workspace.members.map((member) => (0, import_path24.resolve)(workspace, member));
      swayMembers.forEach((path4) => {
        const type3 = readSwayType(path4);
        config[`${type3}s`].push(path4);
      });
      config.workspace = workspace;
    }
    return config;
  }

  // src/cli/commands/withConfig.ts
  var withConfigErrorHandler = async (err, config) => {
    error(err);
    if (config) {
      await config.onFailure?.(err, config);
    }
  };
  function withConfig(program2, command, fn) {
    return async () => {
      const options = program2.opts();
      let config;
      try {
        config = await loadConfig(options.path);
      } catch (err) {
        await withConfigErrorHandler(err);
        return;
      }
      try {
        const eventData = await fn(config, program2);
        config.onSuccess?.(
          {
            type: command,
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            data: eventData
          },
          config
        );
        log(`\u{1F389}  ${capitalizeString(command)} completed successfully!`);
      } catch (err) {
        await withConfigErrorHandler(err, config);
      }
    };
  }

  // src/cli/commands/dev/index.ts
  var closeAllFileHandlers = (handlers) => {
    handlers.forEach((h) => h.close());
  };
  var buildAndDeploy = async (config) => {
    await build(config);
    return deploy(config);
  };
  var getConfigFilepathsToWatch = (config) => {
    const configFilePathsToWatch = [config.configPath];
    if (config.chainConfig) {
      configFilePathsToWatch.push(config.chainConfig);
    }
    return configFilePathsToWatch;
  };
  var workspaceFileChanged = (state) => async (_event, path4) => {
    log(`
File changed: ${path4}`);
    await buildAndDeploy(state.config);
  };
  var configFileChanged = (state) => async (_event, path4) => {
    log(`
File changed: ${path4}`);
    closeAllFileHandlers(state.watchHandlers);
    state.fuelCore?.killChildProcess();
    try {
      await dev(await loadConfig(state.config.basePath));
    } catch (err) {
      await withConfigErrorHandler(err, state.config);
    }
  };
  var dev = async (config) => {
    const fuelCore = await autoStartFuelCore(config);
    const configFilePaths = getConfigFilepathsToWatch(config);
    const { contracts, scripts, predicates, basePath: cwd } = config;
    const workspaceFilePaths = [contracts, predicates, scripts].flat().flatMap((dir) => [
      dir,
      globSync(`${dir}/**/*.toml`, { cwd }),
      globSync(`${dir}/**/*.sw`, { cwd })
    ]).flat();
    try {
      await buildAndDeploy(config);
      const watchHandlers = [];
      const options = { persistent: true, ignoreInitial: true, ignored: "**/out/**" };
      const state = { config, watchHandlers, fuelCore };
      watchHandlers.push((0, import_chokidar.watch)(configFilePaths, options).on("all", configFileChanged(state)));
      watchHandlers.push((0, import_chokidar.watch)(workspaceFilePaths, options).on("all", workspaceFileChanged(state)));
    } catch (err) {
      error(err);
      throw err;
    }
  };

  // src/cli/commands/init/index.ts
  var import_fs16 = __require2("fs");
  var import_path25 = __require2("path");

  // src/cli/templates/fuels.config.ts
  var import_handlebars5 = __toESM(require_lib());

  // src/cli/templates/fuels.config.hbs
  var fuels_config_default = "import { createConfig } from 'fuels';\n\nexport default createConfig({\n  {{#if (isDefined workspace)}}\n  workspace: '{{workspace}}',\n  {{else}}\n    {{#if (isDefined contracts)}}\n  contracts: [\n      {{#each contracts}}\n        '{{this}}',\n      {{/each}}\n  ],\n    {{/if}}\n    {{#if (isDefined predicates)}}\n  predicates: [\n      {{#each predicates}}\n        '{{this}}',\n      {{/each}}\n  ],\n    {{/if}}\n    {{#if (isDefined scripts)}}\n  scripts: [\n      {{#each scripts}}\n        '{{this}}',\n      {{/each}}\n  ],\n    {{/if}}\n  {{/if}}\n  output: '{{output}}',\n  {{#if (isDefined useBuiltinForc)}}\n  useBuiltinForc: {{useBuiltinForc}},\n  {{/if}}\n  {{#if (isDefined useBuiltinFuelCore)}}\n  useBuiltinFuelCore: {{useBuiltinFuelCore}},\n  {{/if}}\n  {{#if (isDefined autoStartFuelCore)}}\n  autoStartFuelCore: {{autoStartFuelCore}},\n  {{/if}}\n});\n\n/**\n * Check the docs:\n * https://fuellabs.github.io/fuels-ts/guide/cli/config-file\n */\n";

  // src/cli/templates/fuels.config.ts
  import_handlebars5.default.registerHelper("isDefined", (v) => v !== void 0);
  function renderFuelsConfigTemplate(props) {
    const renderTemplate = (0, import_handlebars5.compile)(fuels_config_default, {
      strict: true,
      noEscape: true
    });
    return renderTemplate(props);
  }

  // src/cli/commands/init/index.ts
  function init(program2) {
    const options = program2.opts();
    const { path: path4, autoStartFuelCore: autoStartFuelCore2, useBuiltinForc, useBuiltinFuelCore } = options;
    let workspace;
    let absoluteWorkspace;
    if (options.workspace) {
      absoluteWorkspace = (0, import_path25.resolve)(path4, options.workspace);
      workspace = `./${(0, import_path25.relative)(path4, absoluteWorkspace)}`;
    }
    const absoluteOutput = (0, import_path25.resolve)(path4, options.output);
    const output3 = `./${(0, import_path25.relative)(path4, absoluteOutput)}`;
    const [contracts, scripts, predicates] = ["contracts", "scripts", "predicates"].map(
      (optionName) => {
        const pathOrGlob = options[optionName];
        if (!pathOrGlob) {
          return void 0;
        }
        const expanded = globSync(pathOrGlob, { cwd: path4 });
        const relatives = expanded.map((e) => (0, import_path25.relative)(path4, e));
        return relatives;
      }
    );
    const noneIsInformed = ![workspace, contracts, scripts, predicates].find((v) => v !== void 0);
    if (noneIsInformed) {
      process.stdout.write(`error: required option '-w, --workspace <path>' not specified\r`);
      process.exit(1);
    }
    const fuelsConfigPath = (0, import_path25.join)(path4, "fuels.config.ts");
    if ((0, import_fs16.existsSync)(fuelsConfigPath)) {
      throw new Error(`Config file exists, aborting.
  ${fuelsConfigPath}`);
    }
    const renderedConfig = renderFuelsConfigTemplate({
      workspace,
      contracts,
      scripts,
      predicates,
      output: output3,
      useBuiltinForc,
      useBuiltinFuelCore,
      autoStartFuelCore: autoStartFuelCore2
    });
    (0, import_fs16.writeFileSync)(fuelsConfigPath, renderedConfig);
    log(`Config file created at:

 ${fuelsConfigPath}
`);
  }

  // src/cli/commands/withProgram.ts
  function withProgram(program2, _command, fn) {
    return async () => {
      try {
        await fn(program2);
      } catch (err) {
        error(err);
      }
    };
  }

  // src/cli.ts
  var onPreAction = (command) => {
    const opts = command.opts();
    configureLogging({
      isDebugEnabled: opts.debug,
      isLoggingEnabled: !opts.silent
    });
  };
  var configureCli = () => {
    const program2 = new Command();
    program2.name("fuels");
    program2.option("-D, --debug", "Enables verbose logging", false);
    program2.option("-S, --silent", "Omit output messages", false);
    program2.version(versions.FUELS, "-v, --version", "Output the version number");
    program2.helpOption("-h, --help", "Display help");
    program2.addHelpCommand("help [command]", "Display help for command");
    program2.enablePositionalOptions(true);
    program2.hook("preAction", onPreAction);
    const pathOption = new Option("-p, --path <path>", "Path to project root").default(process.cwd());
    let command;
    const desc = `Relative path/globals to `;
    const arg = `<path|global>`;
    (command = program2.command("init" /* init */)).description("Create a sample `fuel.config.ts` file").addOption(pathOption).option("-w, --workspace <path>", "Relative dir path to Forc workspace").addOption(new Option(`-c, --contracts ${arg}`, `${desc} Contracts`).conflicts("workspace")).addOption(new Option(`-s, --scripts ${arg}`, `${desc} Scripts`).conflicts("workspace")).addOption(new Option(`-p, --predicates ${arg}`, `${desc} Predicates`).conflicts("workspace")).requiredOption("-o, --output <path>", "Relative dir path for Typescript generation output").option("--use-builtin-forc", "Use buit-in `forc` to build Sway programs").option("--use-builtin-fuel-core", "Use buit-in `fuel-core` when starting a Fuel node").option("--auto-start-fuel-core", "Auto-starts a `fuel-core` node during `dev` command").action(withProgram(command, "init" /* init */, init));
    (command = program2.command("dev" /* dev */)).description("Start a Fuel node and run build + deploy on every file change").addOption(pathOption).action(withConfig(command, "dev" /* dev */, dev));
    (command = program2.command("build" /* build */)).description("Build Sway programs and generate Typescript for them").addOption(pathOption).option(
      "-d, --deploy",
      "Deploy contracts after build (auto-starts a `fuel-core` node if needed)"
    ).action(withConfig(command, "build" /* build */, build));
    (command = program2.command("deploy" /* deploy */)).description("Deploy contracts to the Fuel network").addOption(pathOption).action(withConfig(command, "deploy" /* deploy */, deploy));
    configureCliOptions(
      program2.command("typegen").description(`Generate Typescript from Sway ABI JSON files`)
    );
    program2.command("versions").description("Check for version incompatibilities").action(runVersions);
    program2.command("core", "Wrapper around Fuel Core binary", {
      executableFile: findBinPath("fuels-core")
    });
    program2.command("forc", "Wrapper around Forc binary", {
      executableFile: findBinPath("fuels-forc")
    });
    return program2;
  };
  var run = async (argv) => {
    const program2 = configureCli();
    return program2.parseAsync(argv);
  };

  // src/bin.ts
  try {
    run(process.argv).catch(process.stderr.write);
  } catch (err) {
    error(err?.message || err);
    process.exit(1);
  }
})();
/*! Bundled license information:

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

normalize-path/index.js:
  (*!
   * normalize-path <https://github.com/jonschlinkert/normalize-path>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-extglob/index.js:
  (*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

is-glob/index.js:
  (*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

is-number/index.js:
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

to-regex-range/index.js:
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

fill-range/index.js:
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=bin.global.js.map